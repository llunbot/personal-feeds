{"title":"Vault Secrets Operator: A new method for Kubernetes integration","link":"https://www.hashicorp.com/blog/vault-secrets-operator-a-new-method-for-kubernetes-integration","date":1680123600000,"content":"<p>The beta version of the Vault Secrets Operator is now available as a final addition to the HashiCorp Vault 1.13 release. The Vault Secrets Operator is the newest method for Vault and Kubernetes integration, ​​implementing a first-class Kubernetes Operator along with a set of custom resource definitions (CRDs) responsible for synchronizing Vault secrets to Kubernetes Secrets natively. This post will take a dive deep into this Operator and its place in the Vault ecosystem.</p>\n\n<h2>Vault and Kubernetes: Better together</h2>\n\n<p>Kubernetes natively supports the management and distribution of secrets within a cluster. Applications running on Kubernetes can consume secrets natively from the <a href=\"https://kubernetes.io/docs/concepts/configuration/secret/\">Secrets API</a>. Kubernetes Secrets can be consumed directly from files in a volume mounted by a container, through container environment variables, or directly from the API by an application that supports that retrieval mechanism. </p>\n\n<p>In general, Kubernetes Secrets can be thought of as a static configuration object containing confidential information. Secrets are typically created during the deployment of an application and remain unchanged throughout the lifecycle of the application’s container. Kubernetes does not support dynamic secrets or rotation, leaving that responsibility to users.</p>\n\n<p>Vault fills the gaps left in Kubernetes by providing a complete solution for secrets management. It consolidates identity brokering, secrets management (including <a href=\"https://www.hashicorp.com/blog/why-we-need-dynamic-secrets\">dynamic secrets</a>), rotation, and security policy compliance in one platform. By coupling Vault’s secret management feature set with a Kubernetes Secrets cache, the developer only has to consume the secret natively from Kubernetes. </p>\n\n<h2>The Vault Secrets Operator</h2>\n\n<p>The current approaches to Vault/Kubernetes integration require some level of application modification if you want the ability to read from a file. Furthermore, applications need to be aware of when credentials have been modified so that they can be re-read from the file. In response to the user interest in a new, Operator-based method of Vault/Kubernetes integration, Vault 1.13 introduced the <a href=\"https://github.com/hashicorp/vault-secrets-operator/\">Vault Secrets Operator</a>, which will allow users to natively sync secrets from Vault to Kubernetes clusters.</p>\n\n<p><a href=\"https://kubernetes.io/docs/concepts/extend-kubernetes/operator/\">Kubernetes Operators</a> allow the customization of automatable tasks within a Kubernetes cluster. This operator pattern removes some service management burdens from human operators, such as managing secrets for the services orchestrated by Kubernetes. </p>\n\n<p>Today we’ve released the <a href=\"https://github.com/hashicorp/vault-secrets-operator/\">Vault Secrets Operator</a> (beta), which implements a first-class Kubernetes Operator along with a set of CRDs responsible for synchronizing Vault secrets to Kubernetes Secrets natively. The Operator synchronizes static, dynamic, and PKI-based secrets from one or more Vault server instances. The Operator is also responsible for secret rotation and provides controllers for handling the various secret-specific custom resources (CRs) s. The Operator can also perform post-rotation actions, like notifying an application directly by triggering a <a href=\"https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#rollout\">rolling update</a> of a <a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/\">deployment</a>.</p>\n\n<h3>How the Vault Secrets Operator works</h3>\n\n<p>The Vault Secrets Operator implements a controller that uses Kubernetes <a href=\"https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/\">custom resources</a> defined by the Vault Secrets Operator’s custom resource definitions to manage the secrets used by the services. The secrets are then managed by Vault, orchestrated in Kubernetes using custom resources, and consumed by the applications in a Kubernetes-native manner, cleanly separating concerns. Using standard Kubernetes declarative patterns, the Vault Secrets Operator reconciles the current state to the desired state specified in the CRs. </p>\n\n<p>To check out the code, visit the <a href=\"https://github.com/hashicorp/vault-secrets-operator/\">Kubernetes Vault Secrets Operator GitHub repo</a>. The project SDK is based on the <a href=\"https://sdk.operatorframework.io/\">Operator SDK</a> for Go and provides the tools necessary for building, testing, and deploying a Kubernetes Operator. </p>\n\n<h3>Authentication to Vault</h3>\n\n<p>During the beta period, we are supporting only the <a href=\"https://developer.hashicorp.com/vault/docs/auth/kubernetes\">Kubernetes authentication method</a>. This lets us focus on the core aspects around secret synchronization. Over time, we anticipate adding support for additional authentication methods.</p>\n\n<p>Vault authentication configuration can be applied from the VaultAuth CR. The Secret CR includes a reference to a VaultAuth. <a href=\"https://github.com/hashicorp/vault-secrets-operator/blob/main/config/samples/secrets_v1alpha1_vaultauth.yaml\">The VaultAuth resource provides the parameters</a> necessary to authenticate to Vault and perform the sync. </p>\n<pre><code>apiVersion: secrets.hashicorp.com/v1alpha1\nkind: VaultAuth\nmetadata:\n  labels:\n    app.kubernetes.io/name: vaultauth\n    app.kubernetes.io/instance: vaultauth-sample\n    app.kubernetes.io/part-of: vault-secrets-operator\n    app.kubernetes.io/managed-by: kustomize\n    app.kubernetes.io/created-by: vault-secrets-operator\n  name: vaultauth-sample\n  namespace: tenant-1\nspec:\n  vaultConnectionRef: vaultconnection-sample\n  method: kubernetes\n  mount: kubernetes\n  kubernetes:\n    role: demo\n    serviceAccount: default</code></pre><p>The necessary Vault login credentials come from a ServiceAccount configured in the CR’s namespace. The Vault Secrets Operator requires both read and create access to any ServiceAccount configured in the related VaultAuth CR. The create permission is required to create short-lived ServiceAccount tokens.</p>\n\n<p>By separating the authentication configuration from the Secret CR, we are able to provide future support for other authentication methods, and potentially other architectures or deployment strategies.</p>\n\n<h3>Authentication policy controls</h3>\n\n<p>In upcoming versions, we plan to give the Vault Secrets Operator the ability to limit the supported auth methods via the command line. The code will resemble this snippet:</p>\n\n<pre><code>allowed-auth-methods=aws,gcp,token\n</code></pre>\n\n<p>These options add an extra layer of security by preventing unsupported and unauthorized auth methods from being used. </p>\n\n<p>The Vault Secrets Operator will be able to constrain sync activities to specific Kubernetes namespaces. By default, all Kubernetes namespaces are allowed. The Vault Secrets Operator beta currently supports only the Kubernetes auth method, but more auth methods are planned for the GA release.</p>\n\n<h3>Required permissions</h3>\n\n<p>The Vault Secrets Operator requires various Kubernetes permissions to function correctly. These include:</p>\n\n<table>\n  <tr>\n   <td><strong>Object</strong>\n   </td>\n   <td><strong>Permission</strong>\n   </td>\n   <td><strong>Reason</strong>\n   </td>\n  </tr>\n  <tr>\n   <td>Secret\n   </td>\n   <td>create, read, update, delete, watch\n   </td>\n   <td>Sync operations, Vault auth\n   </td>\n  </tr>\n  <tr>\n   <td>ServiceAccount\n   </td>\n   <td>read, create\n   </td>\n   <td>Vault auth\n   </td>\n  </tr>\n  <tr>\n   <td>Deployment\n   </td>\n   <td>read, update, watch\n   </td>\n   <td>Post secret rotation actions\n   </td>\n  </tr>\n</table>\n\n<p>If granting these permissions for the entire cluster is problematic for your team from a security management or compliance standpoint, consider restricting the Vault Secrets Operator’s access to objects in specific namespaces.</p>\n\n<h3>Telemetry and operational reporting</h3>\n\n<p>The Vault Secrets Operator provides a <a href=\"https://prometheus.io/\">Prometheus</a> metrics endpoint, along with support for the <a href=\"https://github.com/prometheus-operator/prometheus-operator\">PrometheusOperator</a>. This allows users to be alerted to any potential issues with the system. The Prometheus output can be <a href=\"https://grafana.com/docs/grafana-cloud/kubernetes-monitoring/other-methods/prometheus/prometheus_operator/\">integrated with Grafana</a> during the beta period. However, we anticipate providing a Visual Studio Online-specific <a href=\"https://grafana.com/grafana/\">Grafana</a> dashboard for the GA release.</p>\n\n<p>The Vault Secrets Operator gives users meaningful signals for determining the overall health of its secrets management processes, as well as analytics to measure security policy adoption.</p>\n\n<p>Vault Secrets Operator metrics include:</p>\n\n<ul>\n<li>Number of managed secrets by namespace</li>\n<li>Vault request/response timings </li>\n<li>Number of secrets by Vault Secret type</li>\n<li>Number of Secret custom resources</li>\n<li>Number of Vault connections</li>\n<li>Number of VaultAuth custom resources</li>\n<li>Number of Vault authentication methods in use</li>\n<li>Kubernetes namespaces being serviced</li>\n<li>Sync operations</li>\n<li>Operator version and build information </li>\n<li>Sync failures</li>\n<li>Vault authentication failures</li>\n<li>Orphaned VaultAuth CRs from its VaultConnection</li>\n<li>Kubernetes API failures </li>\n<li>Orphaned Secret custom resources from its VaultAuth</li>\n<li>Duplicate Secret status</li>\n</ul>\n\n<h2>Related Vault and Kubernetes integration utilities</h2>\n\n<p>To learn more about other Vault/Kubernetes integration methods, read our blog post on <a href=\"https://www.hashicorp.com/blog/kubernetes-vault-integration-via-sidecar-agent-injector-vs-csi-provider\">Kubernetes Vault Integration via Sidecar Agent Injector vs. CSI Provider</a> and visit each method’s GitHub repository:</p>\n\n<ul>\n<li><a href=\"https://github.com/hashicorp/vault-k8s\">vault-k8s</a>: Provides access to Vault secrets by deploying a vault-agent sidecar into a Kubernetes Pod.</li>\n<li><a href=\"https://github.com/hashicorp/vault-csi-provider/\">vault-csi-provider</a>: Fetches secrets stored in Vault and uses the Secrets Store Container Storage Interface (CSI) driver interface to mount them into Kubernetes Pods.</li>\n</ul>\n\n<h2>Beta feedback</h2>\n\n<p>As you pursue your Kubernetes secrets management journey with Vault Secrets Operator, we’re interested in any feedback and recommendations you may have. To provide feedback on our beta, please log a <a href=\"https://github.com/hashicorp/vault-secrets-operator/issues\">GitHub Issue</a>. </p>\n\n<p>You can learn more about the Vault Secrets Operator by visiting the <a href=\"https://github.com/hashicorp/vault-secrets-operator\">vault-secrets-operator</a> GitHub repository. Further documentation on using Vault with Kubernetes can be found in our <a href=\"https://developer.hashicorp.com/vault/docs/platform/k8s/vso\">HashiCorp Developer guide to Kubernetes and Vault</a>. To learn more about HashiCorp Vault please visit the <a href=\"https://www.hashicorp.com/products/vault\">Vault product page</a>.</p>\n","author":"Rich Dubose","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"fc9690c309a1c2bb9eda1667d4b209eb81f5faab8ded67e5bb3bbe72b67ea849","category":"Tech"}