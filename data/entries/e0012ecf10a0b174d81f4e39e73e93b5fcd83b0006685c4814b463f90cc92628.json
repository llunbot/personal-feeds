{"title":"Integrations: From Simple Data Transfer To Modern Composable Architectures","link":"https://smashingmagazine.com/2025/02/integrations-from-simple-data-transfer-to-composable-architectures/","date":1738656000000,"content":"<p>This article is a sponsored by <a href=\"https://www.storyblok.com/?utm_source=smashing&amp;utm_medium=sponsor&amp;utm_campaign=DGM_DEV_SMA_TRA&amp;utm_content=smashing-OSS\">Storyblok</a></p>\n<p>When computers first started talking to each other, the methods were remarkably simple. In the early days of the Internet, systems exchanged files via FTP or communicated via raw TCP/IP sockets. This direct approach worked well for simple use cases but quickly showed its limitations as applications grew more complex.</p>\n<div>\n<pre><code># Basic socket server example\nimport socket\n\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 12345))\nserver_socket.listen(1)\n\nwhile True:\n    connection, address = server_socket.accept()\n    data = connection.recv(1024)\n    # Process data\n    connection.send(response)\n</code></pre>\n</div>\n\n<p>The real breakthrough in enabling complex communication between computers on a network came with the introduction of <strong>Remote Procedure Calls (RPC)</strong> in the 1980s. RPC allowed developers to call procedures on remote systems as if they were local functions, abstracting away the complexity of network communication. This pattern laid the foundation for many of the modern integration approaches we use today.</p>\n<blockquote>At its core, RPC implements a client-server model where the client prepares and serializes a procedure call with parameters, sends the message to a remote server, the server deserializes and executes the procedure, and then sends the response back to the client.</blockquote>\n\n<p>Here’s a simplified example using Python’s XML-RPC.</p>\n<pre><code># Server\nfrom xmlrpc.server import SimpleXMLRPCServer\n\ndef calculate_total(items):\n    return sum(items)\n\nserver = SimpleXMLRPCServer((\"localhost\", 8000))\nserver.register_function(calculate_total)\nserver.serve_forever()\n\n# Client\nimport xmlrpc.client\n\nproxy = xmlrpc.client.ServerProxy(\"http://localhost:8000/\")\ntry:\n    result = proxy.calculate_total([1, 2, 3, 4, 5])\nexcept ConnectionError:\n    print(\"Network error occurred\")\n</code></pre>\n\n<p>RPC can operate in both synchronous (blocking) and asynchronous modes.</p>\n<p>Modern implementations such as gRPC support streaming and bi-directional communication. In the example below, we define a gRPC service called <code>Calculator</code> with two RPC methods, <code>Calculate</code>, which takes a <code>Numbers</code> message and returns a <code>Result</code> message, and <code>CalculateStream</code>, which sends a stream of <code>Result</code> messages in response.</p>\n<pre><code>// protobuf\nservice Calculator {\n  rpc Calculate(Numbers) returns (Result);\n  rpc CalculateStream(Numbers) returns (stream Result);\n}\n</code></pre>\n\nModern Integrations: The Rise Of Web Services And SOA\n<p>The late 1990s and early 2000s saw the emergence of <strong>Web Services</strong> and <strong>Service-Oriented Architecture (SOA)</strong>. SOAP (Simple Object Access Protocol) became the standard for enterprise integration, introducing a more structured approach to system communication.</p>\n<div>\n<pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;soap:Envelope xmlns:soap=\"<a href=\"http://www.w3.org/2003/05/soap-envelope&quot;\">http://www.w3.org/2003/05/soap-envelope\"</a>&gt;\n  &lt;soap:Header&gt;\n  &lt;/soap:Header&gt;\n  &lt;soap:Body&gt;\n    &lt;m:GetStockPrice xmlns:m=\"<a href=\"http://www.example.org/stock&quot;\">http://www.example.org/stock\"</a>&gt;\n      &lt;m:StockName&gt;IBM&lt;/m:StockName&gt;\n    &lt;/m:GetStockPrice&gt;\n  &lt;/soap:Body&gt;\n&lt;/soap:Envelope&gt;\n</code></pre>\n</div>\n\n<p>While SOAP provided robust enterprise features, its complexity, and verbosity led to the development of simpler alternatives, especially the REST APIs that dominate Web services communication today.</p>\n<p>But REST is not alone. Let’s have a look at some modern integration patterns.</p>\n<h3>RESTful APIs</h3>\n<p><strong>REST (Representational State Transfer)</strong> has become the de facto standard for Web APIs, providing a simple, stateless approach to manipulating resources. Its simplicity and HTTP-based nature make it ideal for web applications.</p>\n<p>First defined by Roy Fielding in 2000 as an architectural style on top of the Web’s standard protocols, its constraints align perfectly with the goals of the modern Web, such as <strong>performance</strong>, <strong>scalability</strong>, <strong>reliability</strong>, and <strong>visibility</strong>: client and server separated by an interface and loosely coupled, stateless communication, cacheable responses.</p>\n<p>In modern applications, the most common implementations of the REST protocol are based on the JSON format, which is used to encode messages for requests and responses.</p>\n<div>\n<pre><code>// Request\nasync function fetchUserData() {\n  const response = await fetch('<a href=\"https://api.example.com/users/123')\">https://api.example.com/users/123')</a>;\n  const userData = await response.json();\n  return userData;\n}\n\n// Response\n{\n  \"id\": \"123\",\n  \"name\": \"John Doe\",\n  \"_links\": {\n    \"self\": { \"href\": \"/users/123\" },\n    \"orders\": { \"href\": \"/users/123/orders\" },\n    \"preferences\": { \"href\": \"/users/123/preferences\" }\n  }\n}\n</code></pre>\n</div>\n\n<h3>GraphQL</h3>\n<p>GraphQL emerged from Facebook’s internal development needs in 2012 before being open-sourced in 2015. Born out of the challenges of building complex mobile applications, it addressed limitations in traditional REST APIs, particularly the issues of over-fetching and under-fetching data.</p>\n<p>At its core, GraphQL is a query language and runtime that provides a type system and declarative data fetching, allowing the client to specify exactly what it wants to fetch from the server.</p>\n<pre><code>// graphql\ntype User {\n  id: ID!\n  name: String!\n  email: String!\n  posts: [Post!]!\n}\n\ntype Post {\n  id: ID!\n  title: String!\n  content: String!\n  author: User!\n  publishDate: String!\n}\n\nquery GetUserWithPosts {\n  user(id: \"123\") {\n    name\n    posts(last: 3) {\n      title\n      publishDate\n    }\n  }\n}\n</code></pre>\n\n<p>Often used to build complex UIs with nested data structures, mobile applications, or microservices architectures, it has proven effective at handling complex data requirements at scale and offers a growing ecosystem of tools.</p>\n<h3>Webhooks</h3>\n<p>Modern applications often require real-time updates. For example, e-commerce apps need to update inventory levels when a purchase is made, or content management apps need to refresh cached content when a document is edited. Traditional request-response models can struggle to meet these demands because they rely on clients’ polling servers for updates, which is inefficient and resource-intensive.</p>\n<p>Webhooks and event-driven architectures address these needs more effectively. Webhooks let servers send real-time notifications to clients or other systems when specific events happen. This reduces the need for continuous polling. Event-driven architectures go further by decoupling application components. Services can publish and subscribe to events asynchronously, and this makes the system more scalable, responsive, and simpler.</p>\n<pre><code>import fastify from 'fastify';\n\nconst server = fastify();\nserver.post('/webhook', async (request, reply) =&gt; {\n  const event = request.body;\n\n  if (event.type === 'content.published') {\n    await refreshCache();\n  }\n\n  return reply.code(200).send();\n});\n</code></pre>\n\n<p>This is a simple Node.js function that uses Fastify to set up a web server. It responds to the endpoint <code>/webhook</code>, checks the <code>type</code> field of the JSON request, and refreshes a cache if the event is of type <code>content.published</code>.</p>\n<p>With all this background information and technical knowledge, it’s easier to picture the current state of web application development, where <strong>a single, monolithic app is no longer the answer to business needs</strong>, but a new paradigm has emerged: Composable Architecture.</p>\nComposable Architecture And Headless CMSs\n<p>This evolution has led us to the concept of composable architecture, where applications are built by <strong>combining specialized services</strong>. This is where headless CMS solutions have a clear advantage, serving as the perfect example of how modern integration patterns come together. </p>\n<p>Headless CMS platforms separate content management from content presentation, allowing you to build specialized frontends relying on a fully-featured content backend. This decoupling facilitates <strong>content reuse</strong>, <strong>independent scaling</strong>, and the <strong>flexibility</strong> to use a dedicated technology or service for each part of the system.</p>\n<p>Take <a href=\"https://www.storyblok.com/?utm_source=smashing&amp;utm_medium=sponsor&amp;utm_campaign=DGM_DEV_SMA_TRA&amp;utm_content=smashing-OSS\">Storyblok</a> as an example. Storyblok is a headless CMS designed to help developers build flexible, scalable, and composable applications. Content is exposed via API, REST, or GraphQL; it offers a long list of events that can trigger a webhook. Editors are happy with a great Visual Editor, where they can see changes in real time, and many integrations are available out-of-the-box via a marketplace.</p>\n<p>Imagine this <code>ContentDeliveryService</code> in your app, where you can interact with Storyblok’s REST API using the <a href=\"https://github.com/storyblok/storyblok-js-client\">open source JS Client</a>:</p>\n<div>\n<pre><code>import StoryblokClient from \"storyblok-js-client\";\n\nclass ContentDeliveryService {\n  constructor(private storyblok: StoryblokClient) {}\n\n  async getPageContent(slug: string) {\n    const { data } = await this.storyblok.get(<code>cdn/stories/${slug}</code>, {\n      version: 'published',\n      resolve_relations: 'featured-products.products'\n    });\n\n    return data.story;\n  }\n\n  async getRelatedContent(tags: string[]) {\n    const { data } = await this.storyblok.get('cdn/stories', {\n      version: 'published',\n      with_tag: tags.join(',')\n    });\n\n    return data.stories;\n  }\n}\n</code></pre>\n</div>\n\n<p>The last piece of the puzzle is a real example of integration.</p>\n<p>Again, many are already available in the Storyblok marketplace, and you can easily control them from the dashboard. However, to fully leverage the Composable Architecture, we can use the most powerful tool in the developer’s hand: code.</p>\n<p>Let’s imagine a modern e-commerce platform that uses Storyblok as its content hub, Shopify for inventory and orders, Algolia for product search, and Stripe for payments.</p>\n<p>Once each account is set up and we have our access tokens, we could quickly build a front-end page for our store. This isn’t production-ready code, but just to get a quick idea, let’s use React to build the page for a single product that integrates our services.</p>\n<p>First, we should initialize our clients:</p>\n<pre><code>import StoryblokClient from \"storyblok-js-client\";\nimport { algoliasearch } from \"algoliasearch\";\nimport Client from \"shopify-buy\";\n\n\nconst storyblok = new StoryblokClient({\n  accessToken: \"your_storyblok_token\",\n});\nconst algoliaClient = algoliasearch(\n  \"your_algolia_app_id\",\n  \"your_algolia_api_key\",\n);\nconst shopifyClient = Client.buildClient({\n  domain: \"your-shopify-store.myshopify.com\",\n  storefrontAccessToken: \"your_storefront_access_token\",\n});\n</code></pre>\n\n<p>Given that we created a <code>blok</code> in Storyblok that holds product information such as the <code>product_id</code>, we could write a component that takes the <code>productSlug</code>, fetches the product content from Storyblok, the inventory data from Shopify, and some related products from the Algolia index:</p>\n<div>\n<pre><code>async function fetchProduct() {\n  // get product from Storyblok\n  const { data } = await storyblok.get(<code>cdn/stories/${productSlug}</code>);\n\n  // fetch inventory from Shopify\n  const shopifyInventory = await shopifyClient.product.fetch(\n    data.story.content.product_id\n  );\n\n  // fetch related products using Algolia\n  const { hits } = await algoliaIndex.search(\"products\", {\n    filters: <code>category:${data.story.content.category}</code>,\n  });\n}\n</code></pre>\n</div>\n\n<p>We could then set a simple component state:</p>\n<pre><code>const [productData, setProductData] = useState(null);\nconst [inventory, setInventory] = useState(null);\nconst [relatedProducts, setRelatedProducts] = useState([]);\n\nuseEffect(() =&gt;\n  // ...\n  // combine fetchProduct() with setState to update the state\n  // ...\n\n  fetchProduct();\n}, [productSlug]);\n</code></pre>\n\n<p>And return a template with all our data:</p>\n<pre><code>&lt;h1&gt;{productData.content.title}&lt;/h1&gt;\n&lt;p&gt;{productData.content.description}&lt;/p&gt;\n&lt;h2&gt;Price: ${inventory.variants[0].price}&lt;/h2&gt;\n&lt;h3&gt;Related Products&lt;/h3&gt;\n&lt;ul&gt;\n  {relatedProducts.map((product) =&gt; (\n    &lt;li key={product.objectID}&gt;{product.name}&lt;/li&gt;\n  ))}\n&lt;/ul&gt;\n</code></pre>\n\n<p>We could then use an event-driven approach and create a server that listens to our shop events and processes the checkout with Stripe (credits to Manuel Spigolon for <a href=\"https://backend.cafe/integrate-stripe-with-fastify\">this tutorial</a>):</p>\n<div>\n<pre><code>const stripe = require('stripe')\n\nmodule.exports = async function plugin (app, opts) {\n  const stripeClient = stripe(app.config.STRIPE_PRIVATE_KEY)\n\n  server.post('/create-checkout-session', async (request, reply) =&gt; {\n    const session = await stripeClient.checkout.sessions.create({\n      line_items: [...], // from request.body\n      mode: 'payment',\n      success_url: \"<a href=\"https://your-site.com/success&quot;\">https://your-site.com/success\"</a>,\n      cancel_url: \"<a href=\"https://your-site.com/cancel&quot;\">https://your-site.com/cancel\"</a>,\n    })\n\n    return reply.redirect(303, session.url)\n  })\n// ...\n</code></pre>\n</div>\n\n<p>And with this approach, each service is independent of the others, which helps us achieve our business goals (performance, scalability, flexibility) with a good developer experience and a smaller and simpler application that’s easier to maintain.</p>\nConclusion\n<p>The integration between headless CMSs and modern web services represents the current and future state of high-performance web applications. By using specialized, decoupled services, developers can focus on business logic and user experience. A composable ecosystem is not only modular but also resilient to the evolving needs of the modern enterprise.</p>\n<p>These integrations highlight the importance of mastering API-driven architectures and understanding how different tools can harmoniously fit into a larger tech stack.</p>\n<p>In today’s digital landscape, success lies in choosing tools that offer flexibility and efficiency, adapt to evolving demands, and create applications that are future-proof against the challenges of tomorrow.</p>\n<p>If you want to dive deeper into the integrations you can build with Storyblok and other services, check out <a href=\"https://www.storyblok.com/ecosystem/?utm_source=smashing&amp;utm_medium=sponsor&amp;utm_campaign=DGM_DEV_SMA_TRA&amp;utm_content=smashing-OSS\">Storyblok’s integrations page</a>. You can also take your projects further by creating your own plugins with <a href=\"https://www.storyblok.com/docs/plugins/field-plugins/introduction/?utm_source=smashing&amp;utm_medium=sponsor&amp;utm_campaign=DGM_DEV_SMA_TRA&amp;utm_content=smashing-OSS\">Storyblok’s plugin development</a> resources.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"e0012ecf10a0b174d81f4e39e73e93b5fcd83b0006685c4814b463f90cc92628","category":"Tech"}