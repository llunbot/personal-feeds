{"title":"Creating A Public/Private Multi-Monorepo For PHP Projects","link":"https://smashingmagazine.com/2021/08/public-private-multi-monorepo-php-projects/","date":1629875400000,"content":"<p>To make my development experience faster, I moved all of the PHP packages required by my projects to a monorepo. When each package is hosted in its own repository (the multirepo approach), I would need to develop and test it on its own and then publish it to Packagist before I can install it in other packages via Composer. With the monorepo, because all packages are hosted together, they can be developed, tested, versioned, and released at the same time.</p>\n<p>The monorepo that hosts my PHP packages is public, accessible to anyone on GitHub. Git repositories cannot grant different access to different assets; it’s all either public or private. Because I plan to release a pro WordPress plugin, I want its packages to be kept private, meaning they can’t be added to the public monorepo.</p>\n<p>The solution I found is to use a “multi-monorepo” approach, comprising two monorepos: one public and one private, with the private monorepo embedding the public one as a Git submodule, allowing it to access its files. The public monorepo can be considered the upstream one, and the private monorepo the downstream one.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a223ab2b-d926-4fec-a422-bed6e7b02178/01-architecture.png\" /></p>\n<p>As I kept iterating on my code, the repository set-up that I needed to use at each stage of my project also needed to be upgraded. Hence, I didn’t arrive at the multi-monorepo approach on day one; it was a <a href=\"https://css-tricks.com/from-a-single-repo-to-multi-repos-to-monorepo-to-multi-monorepo/\">process that spanned several years</a> and took a fair amount of effort, going from a single repository, to multiple repositories, to the monorepo, to, finally, the multi-monorepo.</p>\n<p>In this article, I will describe how I set up my multi-monorepo using <a href=\"https://github.com/symplify/monorepo-builder\">Monorepo Builder</a>, which works for PHP projects and is based on Composer.</p>\nReusing Code in the Multi-Monorepo\n<p>The public monorepo at <a href=\"https://github.com/leoloso/PoP\"><code>leoloso/PoP</code></a> is where I keep all of my PHP projects.</p>\n<p>This monorepo contains the workflow file <a href=\"https://github.com/leoloso/PoP/blob/3cd9eee/.github/workflows/generate_plugins.yml\"><code>generate_plugins.yml</code></a>, which generates multiple WordPress plugins for distribution when I <a href=\"https://github.com/leoloso/PoP/actions/runs/1058751996\">create a release on GitHub</a>:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b4c4e80d-e9d3-426d-af78-94151c91c0f4/02-generating-plugins.png\" /></p>\n<p>The workflow configuration is not hardcoded in the YAML file, but rather <a href=\"https://github.com/leoloso/PoP/blob/3cd9eee/.github/workflows/generate_plugins.yml#L55-L57\">injected via PHP code</a>:</p>\n<pre><code>  - id: output_data\n    run: |\n      echo \"::set-output name=plugin_config_entries::$(vendor/bin/monorepo-builder plugin-config-entries-json)\"</code></pre>\n\n<p>And the configuration is provided via a <a href=\"https://github.com/leoloso/PoP/blob/1965e044e371d62ed98f88f05559e48c26183fbd/src/Config/Symplify/MonorepoBuilder/DataSources/PluginDataSource.php#L16\">custom PHP class</a>:</p>\n<pre><code>class PluginDataSource\n{\n  public function getPluginConfigEntries(): array\n  {\n    return [\n      // GraphQL API for WordPress\n      [\n        'path' =&gt; 'layers/GraphQLAPIForWP/plugins/graphql-api-for-wp',\n        'zip_file' =&gt; 'graphql-api.zip',\n        'main_file' =&gt; 'graphql-api.php',\n        'dist_repo_organization' =&gt; 'GraphQLAPI',\n        'dist_repo_name' =&gt; 'graphql-api-for-wp-dist',\n      ],\n      // GraphQL API - Extension Demo\n      [\n        'path' =&gt; 'layers/GraphQLAPIForWP/plugins/extension-demo',\n        'zip_file' =&gt; 'graphql-api-extension-demo.zip',\n        'main_file' =&gt; 'graphql-api-extension-demo.php',\n        'dist_repo_organization' =&gt; 'GraphQLAPI',\n        'dist_repo_name' =&gt; 'extension-demo-dist',\n      ],\n    ];\n  }\n}</code></pre>\n\n<p>Generating multiple WordPress plugins all together, and configuring the workflow via PHP, has reduced the amount of time I need to manage the project. The workflow currently handles two plugins (the <a href=\"https://github.com/leoloso/PoP/blob/master/layers/GraphQLAPIForWP/plugins/graphql-api-for-wp\">GraphQL API</a> and its extension demo), but it could handle 200 without additional effort from me.</p>\n<p>It is this set-up that I want to reuse for my private monorepo at <code>leoloso/GraphQLAPI-PRO</code>, so that the pro plugins can also be generated without effort.</p>\n<p>The code to be reused will comprise:</p>\n<ul>\n<li>the GitHub Actions workflows to generate the WordPress plugins (including <a href=\"https://graphql-api.com/blog/graphql-api-for-wp-is-now-scoped-thanks-to-php-scoper/\">scoping</a>, <a href=\"https://graphql-api.com/blog/the-plugin-is-now-transpiled-from-php-80-to-71/\">downgrading from PHP 8.0 to 7.1</a>, and <a href=\"https://leoloso.com/posts/github-action-to-release-wp-plugin/\">uploading to the releases page</a>).</li>\n<li>the custom PHP services to configure the workflows.</li>\n</ul>\n<p>The private monorepo can then generate the pro WordPress plugins simply by triggering the workflows from the public monorepo and overriding their configuration in PHP.</p>\nLinking Monorepos Via Git Submodules\n<p>To embed the public repository in the private one, we use <a href=\"https://git-scm.com/book/en/v2/Git-Tools-Submodules\">Git submodules</a>:</p>\n<pre><code>git submodule add &lt;public repo URL&gt;</code></pre>\n\n<p>I embedded the public repository in the subfolder <code>submodules</code> of the private monorepo, allowing me to add more upstream monorepos in the future if needed. In GitHub, the folder <a href=\"https://github.blog/2016-02-01-working-with-submodules/\">displays the submodule’s specific commit</a>, and clicking on it will take me to that commit at <code>leoloso/PoP</code>:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6a567d4e-b656-4e05-9c96-291487f27a8e/03-embedding-public-monorepo.png\" /></p>\n<p>Because the private repository contains submodules, to clone it, we must provide the <code>--recursive</code> option:</p>\n<pre><code>git clone --recursive &lt;private repo URL&gt;</code></pre>\n\nReusing the GitHub Actions Workflows\n<p>GitHub Actions only loads workflows from under <code>.github/workflows</code>. Because the public workflows in the downstream monorepo are under <code>submodules/PoP/.github/workflows</code>, these must be duplicated in the expected location.</p>\n<p>In order to keep the upstream workflows as the single source of truth, we can limit ourselves to copying the files downstream under <code>.github/workflows</code>, but never editing them there. If any change is to be done, it must be done in the upstream monorepo and then copied over.</p>\n<p>As a side note, notice how this means that the multi-monorepo leaks: The upstream monorepo is not fully autonomous, and it will need to be adapted to suit the downstream monorepo.</p>\n<p>In my first iteration to copy the workflows, I created a simple <a href=\"https://getcomposer.org/doc/articles/scripts.md#defining-scripts\">Composer script</a>:</p>\n<pre><code>\n{\n  \"scripts\": {\n    \"copy-workflows\": [\n      \"php -r \\\"copy('submodules/PoP/.github/workflows/generate_plugins.yml', '.github/workflows/generate_plugins.yml');\\\"\",\n      \"php -r \\\"copy('submodules/PoP/.github/workflows/split_monorepo.yaml', '.github/workflows/split_monorepo.yaml');\\\"\"\n    ]\n  }\n}</code></pre>\n\n<p>Then, after editing the workflows in the upstream monorepo, I would copy them downstream by executing the following:</p>\n<pre><code>composer copy-workflows</code></pre>\n\n<p>But then I realized that just copying the workflows is not enough: They must also be modified in the process. This is because checking out the downstream monorepo requires the option <code>--recurse-submodules</code> in order to also check out the submodules.</p>\n<p>In GitHub Actions, the checkout downstream is done like this:</p>\n<pre><code>  - uses: actions/checkout@v2\n    with:\n        submodules: recursive</code></pre>\n\n<p>So, checking out the downstream repository needs the input <code>submodules: recursive</code>, but the upstream one does not, and they both use the same source file.</p>\n<p>The solution I found is to provide the value for the input <code>submodules</code> via the environment variable <code>CHECKOUT_SUBMODULES</code>, which by default is <a href=\"https://github.com/leoloso/PoP/blob/aec4615/.github/workflows/coding_standards.yml\">empty for the upstream repository</a>:</p>\n<pre><code>env:\n  CHECKOUT_SUBMODULES: \"\"\n\njobs:\n  provide_data:\n    steps:\n      - uses: actions/checkout@v2\n        with:\n          submodules: ${{ env.CHECKOUT_SUBMODULES }}</code></pre>\n\n<p>Then, when copying the workflows from upstream to downstream, the value of <code>CHECKOUT_SUBMODULES</code> is replaced with <code>recursive</code>:</p>\n<pre><code>env:\n  CHECKOUT_SUBMODULES: \"recursive\"</code></pre>\n\n<p>When modifying the workflow, it’s a good idea to use a regular expression (regex), so that it works for different formats in the source file (such as <code>CHECKOUT_SUBMODULES: \"\"</code> or <code>CHECKOUT_SUBMODULES:''</code> or <code>CHECKOUT_SUBMODULES:</code>). This will prevent bugs from being created for these kinds of ostensibly harmless changes.</p>\n<p>Thus, the <code>copy-workflows</code> Composer script shown above is not good enough to handle this complexity.</p>\n<p>In my next iteration, I created a PHP command, <code>CopyUpstreamMonorepoFilesCommand</code>, to be executed via Monorepo Builder:</p>\n<pre><code>vendor/bin/monorepo-builder copy-upstream-monorepo-files</code></pre>\n\n<p>This command uses a custom service, <code>FileCopierSystem</code>, to copy all files from a source folder to the specified destination, while optionally replacing their contents:</p>\n<pre><code>namespace PoP\\GraphQLAPIPRO\\Extensions\\Symplify\\MonorepoBuilder\\SmartFile;\n\nuse Nette\\Utils\\Strings;\nuse Symplify\\SmartFileSystem\\Finder\\SmartFinder;\nuse Symplify\\SmartFileSystem\\SmartFileSystem;\n\nfinal class FileCopierSystem\n{\n  public function __construct(\n    private SmartFileSystem $smartFileSystem,\n    private SmartFinder $smartFinder,\n  ) {\n  }\n\n  /**\n   * @param array $patternReplacements a regex pattern to search, and its replacement\n   */\n  public function copyFilesFromFolder(\n    string $fromFolder,\n    string $toFolder,\n    array $patternReplacements = []\n  ): void {\n    $smartFileInfos = $this-&gt;smartFinder-&gt;find([$fromFolder], '*');\n\n    foreach ($smartFileInfos as $smartFileInfo) {\n      $fromFile = $smartFileInfo-&gt;getRealPath();\n      $fileContent = $this-&gt;smartFileSystem-&gt;readFile($fromFile);\n\n      foreach ($patternReplacements as $pattern =&gt; $replacement) {\n        $fileContent = Strings::replace($fileContent, $pattern, $replacement);\n      }\n\n      $toFile = $toFolder . substr($fromFile, strlen($fromFolder));\n      $this-&gt;smartFileSystem-&gt;dumpFile($toFile, $fileContent);\n    }\n  }\n}</code></pre>\n\n<p>When invoking this method to copy all workflows downstream, I also replace the value of <code>CHECKOUT_SUBMODULES</code>:</p>\n<pre><code>/**\n * Copy all workflows to `.github/`, and convert:\n *   `CHECKOUT_SUBMODULES: \"\"`\n * into:\n *   `CHECKOUT_SUBMODULES: \"recursive\"`\n */\n$regexReplacements = [\n  '#CHECKOUT_SUBMODULES:(\\s+\".*\")?#' =&gt; 'CHECKOUT_SUBMODULES: \"recursive\"',\n];\n(new FileCopierSystem())-&gt;copyFilesFromFolder(\n  'submodules/PoP/.github/workflows',\n  '.github/workflows',\n  $regexReplacements\n);</code></pre>\n\n<p>The workflow in <code>generate_plugins.yml</code> needs an additional replacement. When the WordPress plugin is generated, its code is downgraded from PHP 8.0 to 7.1 <a href=\"https://github.com/leoloso/PoP/blob/3cd9eee96b603a124c18abd6f69f6e937a41477a/.github/workflows/generate_plugins.yml#L116\">by invoking</a> the script <a href=\"https://github.com/leoloso/PoP/blob/3cd9eee96b603a124c18abd6f69f6e937a41477a/.github/workflows/generate_plugins.yml#L116\"><code>ci/downgrade/downgrade_code.sh</code></a>:</p>\n<pre><code>  - name: Downgrade code for production (to PHP 7.1)\n    run: ci/downgrade/downgrade_code.sh \"${{ matrix.pluginConfig.rector_downgrade_config }}\" \"\" \"${{ matrix.pluginConfig.path }}\" \"${{ matrix.pluginConfig.additional_rector_configs }}\"</code></pre>\n\n<p>In the downstream monorepo, this file will be located under <code>submodules/PoP/ci/downgrade/downgrade_code.sh</code>. Then, we point the downstream workflow to the right path with this replacement:</p>\n<pre><code>$regexReplacements = [\n  // ...\n  '#(ci/downgrade/downgrade_code\\.sh)#' =&gt; 'submodules/PoP/$1',\n];</code></pre>\n\nConfiguring Packages in Monorepo Builder\n<p>The file <code>monorepo-builder.php</code> — placed at the root of the monorepo — holds the <a href=\"https://github.com/symplify/monorepo-builder#1-merge-local-composerjson-to-the-root-one\">configuration for Monorepo Builder</a>. In it, we must indicate where the packages (and plugins, clients, and anything else) are located:</p>\n<pre><code>use Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\ContainerConfigurator;\nuse Symplify\\MonorepoBuilder\\ValueObject\\Option;\n\nreturn static function (ContainerConfigurator $containerConfigurator): void {\n  $parameters = $containerConfigurator-&gt;parameters();\n  $parameters-&gt;set(Option::PACKAGE_DIRECTORIES, [\n    __DIR__ . '/packages',\n    __DIR__ . '/plugins',\n  ]);\n};</code></pre>\n\n<p>The private monorepo must have access to all code: its own packages, plus those from the public monorepo. Then, it must define all packages from both monorepos in the configuration file. The ones from the public monorepo are located under <code>/submodules/PoP</code>:</p>\n<pre><code>return static function (ContainerConfigurator $containerConfigurator): void {\n  $parameters = $containerConfigurator-&gt;parameters();\n  $parameters-&gt;set(Option::PACKAGE_DIRECTORIES, [\n    // public code\n    __DIR__ . '/submodules/PoP/packages',\n    __DIR__ . '/submodules/PoP/plugins',\n    // private code\n    __DIR__ . '/packages',\n    __DIR__ . '/plugins',\n    __DIR__ . '/clients',\n  ]);\n};</code></pre>\n\n<p>As they are, the configurations for upstream and downstream are pretty much the same, the differences being that the downstream one will:</p>\n<ul>\n<li>change the path to the public packages,</li>\n<li>add the private packages.</li>\n</ul>\n<p>So, it makes sense to rewrite the configuration using object-oriented programming (OOP). Let’s follow the DRY principle (“don’t repeat yourself”) by having a PHP class in the public repository be extended in the private repository.</p>\nRecreating the Configuration Via OOP\n<p>Let’s refactor the configuration. In the public repository, the file <code>monorepo-builder.php</code> will simply <a href=\"https://github.com/leoloso/PoP/blob/f958c8f/monorepo-builder.php\">reference a new class</a>, <a href=\"https://github.com/leoloso/PoP/blob/f958c8f/monorepo-builder.php\"><code>ContainerConfigurationService</code></a>, where all of the action will happen:</p>\n<pre><code>use PoP\\PoP\\Config\\Symplify\\MonorepoBuilder\\Configurators\\ContainerConfigurationService;\nuse Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\ContainerConfigurator;\n\nreturn static function (ContainerConfigurator $containerConfigurator): void {\n  $containerConfigurationService = new ContainerConfigurationService(\n    $containerConfigurator,\n    __DIR__\n  );\n  $containerConfigurationService-&gt;configureContainer();\n};</code></pre>\n\n<p>The <code>__DIR__</code> parameter points to the root of the monorepo. It will be needed to obtain the full path to the package directories.</p>\n<p>The class <code>ContainerConfigurationService</code> is now in charge of <a href=\"https://github.com/leoloso/PoP/blob/1965e04/src/Config/Symplify/MonorepoBuilder/Configurators/ContainerConfigurationService.php#L20\">producing the configuration</a>:</p>\n<pre><code>namespace PoP\\PoP\\Config\\Symplify\\MonorepoBuilder\\Configurators;\n\nuse PoP\\PoP\\Config\\Symplify\\MonorepoBuilder\\DataSources\\PackageOrganizationDataSource;\nuse Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\ContainerConfigurator;\nuse Symplify\\MonorepoBuilder\\ValueObject\\Option;\n\nclass ContainerConfigurationService\n{\n  public function __construct(\n    protected ContainerConfigurator $containerConfigurator,\n    protected string $rootDirectory,\n  ) {\n  }\n\n  public function configureContainer(): void\n  {\n    $parameters = $this-&gt;containerConfigurator-&gt;parameters();\n    if ($packageOrganizationConfig = $this-&gt;getPackageOrganizationDataSource($this-&gt;rootDirectory)) {\n      $parameters-&gt;set(\n        Option::PACKAGE_DIRECTORIES,\n        $packageOrganizationConfig-&gt;getPackageDirectories()\n      );\n    }\n  }\n\n  protected function getPackageOrganizationDataSource(): ?PackageOrganizationDataSource\n  {\n    return new PackageOrganizationDataSource($this-&gt;rootDirectory);\n  }\n}</code></pre>\n\n<p>The configuration can be split across several classes. In this case, <code>ContainerConfigurationService</code> retrieves the package configuration through the class <code>PackageOrganizationDataSource</code>, whose <a href=\"https://github.com/leoloso/PoP/blob/6260d11/src/Config/Symplify/MonorepoBuilder/DataSources/PackageOrganizationDataSource.php\">implementation you can see</a>:</p>\n<pre><code>namespace PoP\\PoP\\Config\\Symplify\\MonorepoBuilder\\DataSources;\n\nclass PackageOrganizationDataSource\n{\n  public function __construct(protected string $rootDir)\n  {\n  }\n\n  public function getPackageDirectories(): array\n  {\n    return array_map(\n      fn (string $packagePath) =&gt; $this-&gt;rootDir . '/' . $packagePath,\n      $this-&gt;getRelativePackagePaths()\n    );\n  }\n\n  public function getRelativePackagePaths(): array\n  {\n    return [\n      'packages',\n      'plugins',\n    ];\n  }\n}</code></pre>\n\nOverriding the Configuration in the Downstream Monorepo\n<p>Now that the configuration in the public monorepo has been set up using OOP, we can extend it to suit the needs of the private monorepo.</p>\n<p>In order to allow the private monorepo to autoload the PHP code from the public monorepo, we must first configure the downstream <code>composer.json</code> file to reference the source code from upstream, which is under the path <code>submodules/PoP/src</code>:</p>\n<pre><code>{\n  \"autoload\": {\n    \"psr-4\": {\n      \"PoP\\\\GraphQLAPIPRO\\\\\": \"src\",\n      \"PoP\\\\PoP\\\\\": \"submodules/PoP/src\"\n    }\n  }\n}</code></pre>\n\n<p>Below is the <code>monorepo-builder.php</code> file for the private monorepo. Notice that the referenced class <code>ContainerConfigurationService</code> in the upstream repository belonged to the <code>PoP\\PoP</code> namespace but now has been switched to the <code>PoP\\GraphQLAPIPRO</code> namespace. This class must receive the additional input of <code>$upstreamRelativeRootPath</code> (with a value of <code>submodules/PoP</code>) in order to recreate the full path to the public packages:</p>\n<pre><code>use PoP\\GraphQLAPIPRO\\Config\\Symplify\\MonorepoBuilder\\Configurators\\ContainerConfigurationService;\nuse Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\ContainerConfigurator;\n\nreturn static function (ContainerConfigurator $containerConfigurator): void {\n  $containerConfigurationService = new ContainerConfigurationService(\n    $containerConfigurator,\n    __DIR__,\n    'submodules/PoP'\n  );\n  $containerConfigurationService-&gt;configureContainer();\n};</code></pre>\n\n<p>The downstream class <code>ContainerConfigurationService</code> overrides which <code>PackageOrganizationDataSource</code> class is used in the configuration:</p>\n<pre><code>namespace PoP\\GraphQLAPIPRO\\Config\\Symplify\\MonorepoBuilder\\Configurators;\n\nuse PoP\\PoP\\Config\\Symplify\\MonorepoBuilder\\Configurators\\ContainerConfigurationService as UpstreamContainerConfigurationService;\nuse PoP\\GraphQLAPIPRO\\Config\\Symplify\\MonorepoBuilder\\DataSources\\PackageOrganizationDataSource;\nuse Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\ContainerConfigurator;\n\nclass ContainerConfigurationService extends UpstreamContainerConfigurationService\n{\n  public function __construct(\n    ContainerConfigurator $containerConfigurator,\n    string $rootDirectory,\n    protected string $upstreamRelativeRootPath\n  ) {\n    parent::__construct(\n      $containerConfigurator,\n      $rootDirectory\n    );\n  }\n\n  protected function getPackageOrganizationDataSource(): ?PackageOrganizationDataSource\n  {\n    return new PackageOrganizationDataSource(\n      $this-&gt;rootDirectory,\n      $this-&gt;upstreamRelativeRootPath\n    );\n  }\n}</code></pre>\n\n<p>Finally, the downstream class <code>PackageOrganizationDataSource</code> contains the full path to both public and private packages:</p>\n<pre><code>namespace PoP\\GraphQLAPIPRO\\Config\\Symplify\\MonorepoBuilder\\DataSources;\n\nuse PoP\\PoP\\Config\\Symplify\\MonorepoBuilder\\DataSources\\PackageOrganizationDataSource as UpstreamPackageOrganizationDataSource;\n\nclass PackageOrganizationDataSource extends UpstreamPackageOrganizationDataSource\n{\n  public function __construct(\n    string $rootDir,\n    protected string $upstreamRelativeRootPath\n  ) {\n    parent::__construct($rootDir);\n  }\n\n  public function getRelativePackagePaths(): array\n  {\n    return array_merge(\n      // Public packages - Prepend them with \"submodules/PoP/\"\n      array_map(\n        fn ($upstreamPackagePath) =&gt; $this-&gt;upstreamRelativeRootPath . '/' . $upstreamPackagePath,\n        parent::getRelativePackagePaths()\n      ),\n      // Private packages\n      [\n        'packages',\n        'plugins',\n        'clients',\n      ]\n    );\n  }\n}</code></pre>\n\nInjecting the Configuration From PHP Into GitHub Actions\n<p>Monorepo Builder offers the command <code>packages-json</code>, which we can use to inject the package paths into the GitHub Actions workflow:</p>\n<pre><code>jobs:\n  provide_data:\n    steps:\n      - id: output_data\n        name: Calculate matrix for packages\n        run: |\n          echo \"::set-output name=matrix::$(vendor/bin/monorepo-builder packages-json)\"\n\n    outputs:\n      matrix: ${{ steps.output_data.outputs.matrix }}</code></pre>\n\n<p>This command produces a stringified JSON. In the workflow, it must be converted to a JSON object via <code>fromJson</code>:</p>\n<pre><code>jobs:\n  split_monorepo:\n    needs: provide_data\n    strategy:\n      matrix:\n        package: ${{ fromJson(needs.provide_data.outputs.matrix) }}</code></pre>\n\n<p>Unfortunately, the command <code>packages-json</code> <a href=\"https://github.com/symplify/symplify/blob/3fddff4c47663d1519f7c97769bade425d6a4e5f/packages/monorepo-builder/src/Json/PackageJsonProvider.php#L23\">outputs the package names</a> but not their paths. This would work if all packages were under the same folder (such as <code>packages/</code>), but it doesn’t work in our case because the public and private packages are located in different folders.</p>\n<p>Fortunately, Monorepo Builder can be <a href=\"https://graphql-api.com/blog/extending-the-monorepo-builder/#heading-optimizing-the-monorepo\">extended with custom PHP services</a>. So, I created a custom command, <code>package-entries-json</code> (via the class <a href=\"https://github.com/leoloso/PoP/blob/57a7a21a378f718e1ecfd378fe34ea99fa62c168/src/Extensions/Symplify/MonorepoBuilder/Command/PackageEntriesJsonCommand.php\"><code>PackageEntriesJsonCommand</code></a>), that outputs the path to the package.</p>\n<p>The workflow was then <a href=\"https://github.com/leoloso/PoP/blob/514c27d03b6e438175e887c8dba550355b735b7d/.github/workflows/split_monorepo_tagged.yaml#L34-L37\">updated with the new command</a>:</p>\n<pre><code>    run: |\n      echo \"::set-output name=matrix::$(vendor/bin/monorepo-builder package-entries-json)\"</code></pre>\n\n<p>Executed on the public monorepo, this produces the following packages (among <a href=\"https://github.com/leoloso/PoP/actions/runs/1050692821\">many others</a>):</p>\n<pre><code>[\n  {\n    \"name\": \"graphql-api-for-wp\",\n    \"path\": \"layers/GraphQLAPIForWP/plugins/graphql-api-for-wp\"\n  },\n  {\n    \"name\": \"extension-demo\",\n    \"path\": \"layers/GraphQLAPIForWP/plugins/extension-demo\"\n  },\n  {\n    \"name\": \"access-control\",\n    \"path\": \"layers/Engine/packages/access-control\"\n  },\n  {\n    \"name\": \"api\",\n    \"path\": \"layers/API/packages/api\"\n  },\n  {\n    \"name\": \"api-clients\",\n    \"path\": \"layers/API/packages/api-clients\"\n  }\n]</code></pre>\n\n<p>Executed on the private monorepo, it produces the following entries (among many others):</p>\n<pre><code>[\n  {\n    \"name\": \"graphql-api-for-wp\",\n    \"path\": \"submodules/PoP/layers/GraphQLAPIForWP/plugins/graphql-api-for-wp\"\n  },\n  {\n    \"name\": \"extension-demo\",\n    \"path\": \"submodules/PoP/layers/GraphQLAPIForWP/plugins/extension-demo\"\n  },\n  {\n    \"name\": \"access-control\",\n    \"path\": \"submodules/PoP/layers/Engine/packages/access-control\"\n  },\n  {\n    \"name\": \"api\",\n    \"path\": \"submodules/PoP/layers/API/packages/api\"\n  },\n  {\n    \"name\": \"api-clients\",\n    \"path\": \"submodules/PoP/layers/API/packages/api-clients\"\n  },\n  {\n    \"name\": \"graphql-api-pro\",\n    \"path\": \"layers/GraphQLAPIForWP/plugins/graphql-api-pro\"\n  },\n  {\n    \"name\": \"convert-case-directives\",\n    \"path\": \"layers/Schema/packages/convert-case-directives\"\n  },\n  {\n    \"name\": \"export-directive\",\n    \"path\": \"layers/GraphQLByPoP/packages/export-directive\"\n  }\n]</code></pre>\n\n<p>It works quite well. The configuration for the downstream monorepo contains both public and private packages, and the paths to the public ones are prepended with <code>submodules/PoP</code>.</p>\nSkipping Public Packages in the Downstream Monorepo\n<p>So far, the downstream monorepo includes both public and private packages in its configuration. However, not every command needs to be executed on the public packages.</p>\n<p>Take static analysis, for instance. The public monorepo already executes <a href=\"https://phpstan.org/\">PHPStan</a> on all public packages via the workflow file <a href=\"https://github.com/leoloso/PoP/blob/aec4615/.github/workflows/phpstan.yml\"><code>phpstan.yml</code></a>, as shown in <a href=\"https://github.com/leoloso/PoP/runs/3176485273?check_suite_focus=true#step:6:1\">this run</a>. If the downstream monorepo ran PHPStan once again on the public packages, it would be a waste of computing time. The <code>phpstan.yml</code> workflow only needs to run on the private packages.</p>\n<p>This means that, depending on the command to be executed in the downstream repository, we might want to include either both public and private packages or only private ones.</p>\n<p>To determine whether to add public packages in the downstream configuration, we adapt the downstream class <code>PackageOrganizationDataSource</code> to check this condition via the input <code>$includeUpstreamPackages</code>:</p>\n<pre><code>namespace PoP\\GraphQLAPIPRO\\Config\\Symplify\\MonorepoBuilder\\DataSources;\n\nuse PoP\\PoP\\Config\\Symplify\\MonorepoBuilder\\DataSources\\PackageOrganizationDataSource as UpstreamPackageOrganizationDataSource;\n\nclass PackageOrganizationDataSource extends UpstreamPackageOrganizationDataSource\n{\n  public function __construct(\n    string $rootDir,\n    protected string $upstreamRelativeRootPath,\n    protected bool $includeUpstreamPackages\n  ) {\n    parent::__construct($rootDir);\n  }\n\n  public function getRelativePackagePaths(): array\n  {\n    return array_merge(\n      // Add the public packages?\n      $this-&gt;includeUpstreamPackages ?\n        // Public packages - Prepend them with \"submodules/PoP/\"\n        array_map(\n          fn ($upstreamPackagePath) =&gt; $this-&gt;upstreamRelativeRootPath . '/' . $upstreamPackagePath,\n          parent::getRelativePackagePaths()\n        ) : [],\n      // Private packages\n      [\n        'packages',\n        'plugins',\n        'clients',\n      ]\n    );\n  }\n}</code></pre>\n\n<p>Next, we need to provide the value <code>$includeUpstreamPackages</code> as either <code>true</code> or <code>false</code>, depending on the command to be executed.</p>\n<p>We can do this by replacing the configuration file <code>monorepo-builder.php</code> with two other configuration files: <code>monorepo-builder-with-upstream-packages.php</code> (which passes <code>$includeUpstreamPackages</code> =&gt; <code>true</code>) and <code>monorepo-builder-without-upstream-packages.php</code> (which passes <code>$includeUpstreamPackages</code> =&gt; <code>false</code>):</p>\n<pre><code>// File monorepo-builder-without-upstream-packages.php\nuse PoP\\GraphQLAPIPRO\\Config\\Symplify\\MonorepoBuilder\\Configurators\\ContainerConfigurationService;\nuse Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\ContainerConfigurator;\n\nreturn static function (ContainerConfigurator $containerConfigurator): void {\n  $containerConfigurationService = new ContainerConfigurationService(\n    $containerConfigurator,\n    __DIR__,\n    'submodules/PoP',\n    false, // This is $includeUpstreamPackages\n  );\n  $containerConfigurationService-&gt;configureContainer();\n};</code></pre>\n\n<p>We then update <code>ContainerConfigurationService</code> to receive the parameter <code>$includeUpstreamPackages</code> and pass it along to <code>PackageOrganizationDataSource</code>:</p>\n<pre><code>namespace PoP\\GraphQLAPIPRO\\Config\\Symplify\\MonorepoBuilder\\Configurators;\n\nuse PoP\\PoP\\Config\\Symplify\\MonorepoBuilder\\Configurators\\ContainerConfigurationService as UpstreamContainerConfigurationService;\nuse PoP\\GraphQLAPIPRO\\Config\\Symplify\\MonorepoBuilder\\DataSources\\PackageOrganizationDataSource;\nuse Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\ContainerConfigurator;\n\nclass ContainerConfigurationService extends UpstreamContainerConfigurationService\n{\n  public function __construct(\n    ContainerConfigurator $containerConfigurator,\n    string $rootDirectory,\n    protected string $upstreamRelativeRootPath,\n    protected bool $includeUpstreamPackages,\n  ) {\n    parent::__construct(\n      $containerConfigurator,\n      $rootDirectory,\n    );\n  }\n\n  protected function getPackageOrganizationDataSource(): ?PackageOrganizationDataSource\n  {\n    return new PackageOrganizationDataSource(\n      $this-&gt;rootDirectory,\n      $this-&gt;upstreamRelativeRootPath,\n      $this-&gt;includeUpstreamPackages,\n    );\n  }\n}</code></pre>\n\n<p>Next, we have to invoke the <code>monorepo-builder</code> with either configuration file, by providing the <code>--config</code> option:</p>\n<pre><code>jobs:\n  provide_data:\n    steps:\n      - id: output_data\n        name: Calculate matrix for packages\n        run: |\n          echo \"::set-output name=matrix::$(vendor/bin/monorepo-builder package-entries-json --config=monorepo-builder-without-upstream-packages.php)\"</code></pre>\n\n<p>However, as we saw earlier, we want to keep the GitHub Actions workflows in the upstream monorepo as the single source of truth, and they clearly do not need these changes.</p>\n<p>The solution I found to this issue is to always provide a <code>--config</code> option in the upstream repository, with each command getting its own configuration file, such as the <a href=\"https://github.com/leoloso/PoP/blob/aec4615e782494d6596d9106cc04a47d0234459b/.github/workflows/monorepo_validation.yml#L32\"><code>validate</code> command receiving the <code>validate.php</code> configuration file</a>:</p>\n<pre><code>  - name: Run validation\n    run: vendor/bin/monorepo-builder validate --config=config/monorepo-builder/validate.php</code></pre>\n\n<p>Now, there are no configuration files in the upstream monorepo, because it doesn’t need them. But it will not break, because Monorepo Builder <a href=\"https://github.com/symplify/symplify/blob/90714eec76fb7de8aa0088748d006a40ae75a21c/packages/monorepo-builder/bin/monorepo-builder.php#L45-L60\">checks whether the configuration file exists</a>, and, if it does not, it loads the default configuration file instead. So, either we will override the configuration or nothing will happen.</p>\n<p>The downstream repository provides the configuration files for each command, specifying whether to add the upstream packages:</p>\n\n<p>As a side note, this is another example of how the multi-monorepo leaks.</p>\n\n<pre><code>// File config/monorepo-builder/validate.php\nreturn require_once __DIR__ . '/monorepo-builder-with-upstream-packages.php';</code></pre>\n\nOverriding the Configuration\n<p>We are almost done. By now, the downstream monorepo can override the configuration from the upstream monorepo. So, all that’s left to do is to provide the new configuration.</p>\n<p>In the <code>PluginDataSource</code> class, I override the configuration of which WordPress plugins must be generated, providing the pro ones instead:</p>\n<pre><code>namespace PoP\\GraphQLAPIPRO\\Config\\Symplify\\MonorepoBuilder\\DataSources;\n\nuse PoP\\PoP\\Config\\Symplify\\MonorepoBuilder\\DataSources\\PluginDataSource as UpstreamPluginDataSource;\n\nclass PluginDataSource extends UpstreamPluginDataSource\n{\n  public function getPluginConfigEntries(): array\n  {\n    return [\n      // GraphQL API PRO\n      [\n        'path' =&gt; 'layers/GraphQLAPIForWP/plugins/graphql-api-pro',\n        'zip_file' =&gt; 'graphql-api-pro.zip',\n        'main_file' =&gt; 'graphql-api-pro.php',\n        'dist_repo_organization' =&gt; 'GraphQLAPI-PRO',\n        'dist_repo_name' =&gt; 'graphql-api-pro-dist',\n      ],\n      // GraphQL API Extensions\n      // Google Translate\n      [\n        'path' =&gt; 'layers/GraphQLAPIForWP/plugins/google-translate',\n        'zip_file' =&gt; 'graphql-api-google-translate.zip',\n        'main_file' =&gt; 'graphql-api-google-translate.php',\n        'dist_repo_organization' =&gt; 'GraphQLAPI-PRO',\n        'dist_repo_name' =&gt; 'graphql-api-google-translate-dist',\n      ],\n      // Events Manager\n      [\n        'path' =&gt; 'layers/GraphQLAPIForWP/plugins/events-manager',\n        'zip_file' =&gt; 'graphql-api-events-manager.zip',\n        'main_file' =&gt; 'graphql-api-events-manager.php',\n        'dist_repo_organization' =&gt; 'GraphQLAPI-PRO',\n        'dist_repo_name' =&gt; 'graphql-api-events-manager-dist',\n      ],\n    ];\n  }\n}</code></pre>\n\n<p>Creating a new release on GitHub will trigger the <code>generate_plugins.yml</code> workflow and will generate the pro plugins in my private monorepo:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/33ea9f4a-ed86-4208-9b8a-c7b561ac3491/04-generating-pro-plugins.png\" /></p>\n<p>Ta-da!</p>\nConclusion\n<p>As always, there is no “best” solution, only solutions that might work better depending on the context. The multi-monorepo approach is not suitable to every kind of project or team. I believe the biggest beneficiaries would be plugin creators who release public plugins that will be upgraded to their pro versions, as well as agencies that customizes plugins for their clients.</p>\n<p>In my case, I’m quite happy with this approach. Getting it right takes a bit of time and effort, but it’s a one-time investment. Once the set-up is over, I can focus on building my pro plugins, and the time saved with project management could be huge.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"30210a83bf05053bbbf7808d281ac7f3ad54453253f549211e2a84009583432f","category":"Tech"}