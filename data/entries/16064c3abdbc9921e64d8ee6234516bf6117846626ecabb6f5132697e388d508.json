{"title":"Smashing Podcast Episode 44 With Chris Ferdinandi: Is The Web Dead?","link":"https://smashingmagazine.com/2021/11/smashing-podcast-episode-44/","date":1638280800000,"content":"<p>In this episode, we’re asking if changes to best practises over the last year have negatively impacted the web. Is it all downhill from here? Drew McLellan talks to expert Chris Ferdinandi to find out.</p>\n\n\n<h3>Show Notes</h3>\n<ul>\n<li><a href=\"https://leanweb.dev\">The Lean Web book</a></li>\n<li><a href=\"https://gomakethings.com\">Chris Ferdinandi</a> on the web</li>\n<li><a href=\"https://twitter.com/chrisferdinandi\">Chris on Twitter</a></li>\n<li><a href=\"https://vanillajspodcast.com\">The Vanilla JavaScript Podcast</a></li>\n</ul>\n<h4>Weekly Update</h4>\n<ul>\n<li><a href=\"https://www.smashingmagazine.com/2021/11/nextjs-wildcard-subdomains/\">Next.js Wildcard Subdomains</a> written by Sam Poder</li>\n<li><a href=\"https://www.smashingmagazine.com/2021/11/improving-performance-wix-websites-case-study/\">Improving The Performance Of Wix Websites</a> written by Dan Shappir</li>\n<li><a href=\"https://www.smashingmagazine.com/2021/11/dyslexia-friendly-mode-website/\">Adding A Dyslexia-Friendly Mode To A Website</a> written by John C Barstow</li>\n<li><a href=\"https://www.smashingmagazine.com/2021/11/maintain-large-nextjs-application/\">How To Maintain A Large Next.js Application</a> written by Nirmalya Ghosh</li>\n<li><a href=\"https://www.smashingmagazine.com/2021/11/3d-css-flippy-snaps-react-greensock/\">3D CSS Flippy Snaps With React And GreenSock</a> written by Jhey Tompkins</li>\n</ul>\n<h3>Transcript</h3>\n<p><a href=\"https://twitter.com/chrisferdinandi\"><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/013d0d6a-f33c-41ea-bfe6-f99f95fdd75d/chris-ferdinandi-200x200-opt.jpg\" /></a>Drew McLellan: He’s the author of the Vanilla JavaScript Pocket Guide series, creator of the Vanilla JavaScript Academy Training Program and host of the Vanilla JavaScript Podcast. <a href=\"https://www.smashingmagazine.com/2020/07/smashing-podcast-episode-21/\">We last talked to him in July 2020</a>, where we asked if modern best practices about for the web. So we know he’s still an expert in Vanilla JS, but did you know he’s solely responsible for New Zealand being missing from 50% of world maps? My smashing friends, please welcome back, Chris Ferdinandi. Hi Chris, how are you?</p>\n\n<p>Chris Ferdinandi: Oh, I’m smashing. Thanks for having me Drew. Interesting thing. I actually make sure New Zealand is not on maps because it’s probably my favorite country in the whole world and I don’t want too many people to know about it.</p>\n<p>Drew: You want it to remain unspoiled.</p>\n<p>Chris: Indeed.</p>\n<p>Drew: So welcome back to the podcast. Last time we talked, we posed this question of if modern best practices, the use of reactive frameworks and these sorts of things were actually bad for the progress of the web. And I don’t know whether it was a controversial episode or it just struck a chord with a lot of listeners, but that conversation has been one of the most shared and listened to episodes that we’ve put out that smashing.</p>\n<p>Chris: Oh, that’s awesome.</p>\n<p>Drew: It’s actually been more than a year now, 15 months since we recorded that, which at the pace the web moves is like literally forever. So I wanted to ask, has anything changed? Is the web still in a terminal decline? Has the needle shifted at all?</p>\n<p>Chris: Yeah, quite a bit has changed quite a bit has not. So I think, it’s so weird. The web technology changes so fast, but the web itself tends to move a little bit slower just in terms of developer trends and habits. And so you see these slightly longer arcs where you’ll have a bunch of technology pile up around one approach and then it’ll slowly start to swing the other way and then change all at once. And so last time we talked, I think one of the big kind of... Well, I had two big points related to the modern web. The first was, we’re using a lot of tools that give developers convenience, but we’re using those tools at the expense of the user. So we’re throwing a ton of client-side JS at people, and that introduces a ton of agility and performance issues.</p>\n<p>Chris: The other big point that I was really hammering on was that these tools don’t necessarily improve the developer experience as much as I think people think they do. They do for some people. And I think for another segment of the front end professionals it actually can make things a little bit worse. But what I’m starting to see happen now, and one of the things I’d love to dig into a little bit more is I think we’re seeing a new, it’s almost like a second generation of tools that take a lot of the developer benefits that these client-side frameworks bring and strip away the punishing effects that we put on our users as a result. So it’s taking those same concepts and tools and packaging them a little bit differently in a way that’s actually better for the front end.</p>\n<p>Chris: So one of the things I’ve been talking about with people lately is this idea that modern development has broken the web, but it’s also starting to fix it. And so we can definitely dig into that in a bunch of different angles, depending on where you want to take this conversation.</p>\n<p>Drew: Sure. What sort of things have you seen in the last year that really stand out from that point of view?</p>\n<p>Chris: Yeah, so the two biggest trends I’ve noticed are the rise of microframeworks. So where we saw a lot of really big all encompassing libraries for a while React, Vue before that angular, which is just a massive beast at this point, we’ve started to see smaller libraries that do the same thing come into their own. So for example, I think the king of this hill is probably Preact, which is a three kilobyte alternative to React that uses the same API, ships way less code and actually runs orders of magnitude faster on safe updates than React does too. So you’ve got things like that.</p>\n<p>Chris: For a while you had... Well, it’s still out there, but Alpine JS, which was inspired by VJS and then actually inspired Evan You who built Vue to release Petite Vue, which is a 5.5 kilobyte subset of Vue that’s optimized around progressive enhancement. So these are still client-side libraries, but the intent behind them is that they ship less code, include fewer abstractions and ultimately work faster and put less of that cost on the front end user. So that’s been one angle.</p>\n<p>Chris: And then the second trend I’ve seen that I think is personally more compelling is a shift from libraries to compilers. And so the one that kicked this whole trend off was felt by Rich Harris, which takes the idea of state based reactivity. But instead of having this be a thing that runs in real time in the client, you author your code with the same general pattern that you might with React or Vue, and then you run a build tool that compiles all that into plain old HTML and vanilla JavaScript, and that’s what gets shipped to the browser. And so you’ve stripped out almost all of the abstractions in the client and you deliver something that’s way closer to what you might hand write with old school DOM manipulation, but with the developer convenience of state based EI. So that was really interesting.</p>\n<p>Chris: More recently there’s a new tool called ASTRO that builds on what Rich did with Svelt, and also allows you to pull in components from your favorite libraries so you can mix and match Vue, React, FELT, Vanilla, JavaScript, all in one package, compile it all out into Vanilla JavaScript and ship orders of magnitude, less code without the abstractions. And so it would run way faster in the browser as well. And those are, I think for me, really the two big things that are like standing on the shoulders of giants and producing a front end that will hopefully start to be a little bit faster. The compilers in particular are interesting because they take us away from rendering HTML in the browser as much as possible. You still render your HTML or you still author it with JavaScript if you want, but the outputted result is more static HTML and less JavaScript, which is always a good thing.</p>\n<p>Drew: Do you think this is the ecosystem’s response to this quiet developer dissatisfaction about the weight of modern frameworks? Is it just a natural heave and ho?</p>\n<p>Chris: Yeah, it is. Although to be honest, I’m not entirely sure how much of this was driven by... Well, there’s some definitely some performance minded developers out there who have been very vocal about how these tools are bad for the user. I don’t know that that’s necessarily representative of the general population though. I mean, certainly a subset of it given how the last time we talked that episode did, but I think one of the things that none of these tools for me get at is... Or the thing that I’m most bothered by by the modern web that I don’t think these tools address is that I personally feel like just the development process in general is over complicated.</p>\n<p>Chris: This is where I get into the whole like, I don’t think the developer experience is actually better with these tools, but I think for a lot of developers in maybe a team environment, it can be. For me as a largely solo developer, I find these tools more trouble than they’re worth, but I know a lot of folks disagree with me there, so I don’t want to dismiss that as invalid. If you find these tools useful great, but yeah, I think this is maybe a natural pendulum swing back in the other direction.</p>\n<p>Chris: The third thing that I didn’t talk about that your question actually makes me think about though is, there is almost a natural cycle in the web where you start to throw a lot of JavaScript at solving problems as the web and the capabilities of it grow. And eventually those JavaScript libraries get absorbed by the platform itself, but it’s a much slower process than creating a new JavaScript library is, because it’s standard processes and how important those are. So we saw the same thing happen with jQuery, right, where the amount of JavaScript being used on the web swelled with jQuery and jQuery plugins.</p>\n<p>Chris: And then eventually the web platform realized that these ways of doing things are really smart and we started to get native ways to do it. And then there was this really long, slow petering off of the shift away from jQuery. So I think these libraries, as much as they’ve done a lot of... That’ll be a little controversial here and say, they’ve done a lot of damage to the web. They’ve also served an important function in paving cow path for what native APIs could look like it could do. So I don’t want to completely dismiss them as terrible.</p>\n<p>Drew: It’s interesting that you mentioned ASTRO just a little bit earlier. I’ve actually recorded an interview with Matthew Phillips. I’m not sure if it goes out before or after this one. He’s one of the core developers on ASTRO. And it certainly is a very creative and an interesting approach to the problem. I do wonder as you saying how much this is. We’ve created a set of problems for ourselves and so now we’ve created a new solution, which patches over those problems and gives us something even better. But are we just stacking the bricks on top of each other and still ending up with a very wobbly tower because of it? Are we just going down the wrong path?</p>\n<p>Chris: It depends. So I, as the hair on my head has started to disappear and my beard has gotten whiter, I’ve started to talk in fewer absolutes than I did. And so five years ago, I would’ve said, \"Absolutely yes.\" I don’t want to diminish the value of these tools in a team environment. And the other thing, I honestly think a lot of libraries really have the potential to at least patch fix in the interim is accessibility problems with the web around complex UI components. So in short, if I were to give this just a one sentence, yes, I do think in many ways we’re creating a really delicate house of cards that collapses very easily. And I think one of the nicest things about using mostly or almost entirely platform native to build for the web, so just authoring an HTML, CSS and JavaScript is, you cannot touch that code for five years and come back to it and you don’t have any dependencies to update. You don’t have any build tools to run, to start working with it again. It just works. And that’s really great.</p>\n<p>Chris: But I think the thing I see with libraries is a lot of them come into creation to fill gaps in what the platform can do. And what I’ve noticed happens is after the platform catches up, the libraries stick around for a really long time. And so the thing I always try to do is be a little bit deliberate about what I add to the things I build, because it’s really easy to add stuff and really hard to take it away once it’s there. And just, I think to ground these heady abstract concepts, I’m talking about for a sec, every year, web aim, Web Accessibility consultancy firm does a survey of the top million sites on the web. And they run an audit, just automated audits. They’re not doing a detailed inspection of all these sites. So just stuff that, simple like robot tasks and pickup. And historically, one of the things they’ve always found is that sites that use UI rendering libraries have more accessibility issues than sites that don’t.</p>\n<p>Chris: This year they found the same trend with one exception. Sites that use React actually have fewer accessibility issues than sites that don’t. And that is a notable trend or noticeable departure, rather from the year before when React sites had more accessibility issues.</p>\n<p>Chris: I noticed a lot of focus on accessibility in the React community over the last year, building more accessible components, accessible routing, things of that nature. And for complex components, things like tabs and disclosure widgets, and sliders and things like that, it is really hard to do those accessibly with just HTML and Vanilla JavaScript. Trying to keep track of which ARIA attributes you need to add on, which elements and how to change them based on different behaviors and how to shift focus and announce different things is really complex. And I think these libraries as much as they can be a very delicate house of cards, I see a huge potential there to fill these gaps. Where I’d ultimately love to end up though, is in a place where the platform, the web, browsers offer native components that do those things so that you don’t need the libraries. And I think the details and summary elements provide a really nice model for what that could look like.</p>\n<p>Chris: So if you’re listening to this and you don’t know what those are, the details element is an HTML element that you wrap around some content, and then inside it you nest a summary element with like a little description of what’s in that content. And by default, this element will be a collapsed bit of content. And when you click on the stuff in the summary, it expands and then when you click it again, it collapses and it shows a little arrow when it’s open or closed to indicate what’s happening here. It’s accessible out of the box. If the browser doesn’t support it, it shows all the content by default. So it’s just automatically progressively enhanced. You don’t need to do anything special there.</p>\n<p>Chris: It can be styled with CSS. You can even change what the icons that display when it’s expanded and collapsed are, just with CSS. You don’t need to write any JS for it, but if you wanted to extend the behavior in some way you can, because it also exposes a JavaScript event that fires whenever it’s toggled open or closed. And I would love to see more stuff like that for tabs, for image sliders or carousels or photo galleries, which just... We have so many different interactive components now on the web that may or may not always be appropriate, but they’re in the designs and people are building them and having a way to do those things where you didn’t have to fumble through how to make them accessible or lean on a 30 kilobyte library would be awesome.</p>\n<p>Chris: And so for me, that’s, I think, the next evolution of the web. That’s where I really want to see things start to go. And I think that’s the big need that these libraries address today in addition to some other stuff like changing the UI based on state changes and interesting use cases like that.</p>\n<p>Drew: Yeah. Modern browsers are just so capable now and they automatically update themselves and they include many of the features natively that we’ve previously relied on, on big frameworks and build tools for. Is the requirement of a build process to deploy a project a red flag in 2021? Should HTML and CSS and JS just be deployable as it is?</p>\n<p>Chris: So technically they are. I don’t think for most build processes that’s real or for most apps or sites or companies that’s necessarily realistic today. I don’t know that I’d call it a red flag as much as a resigned I wish it wasn’t like this, but I understand why it is, for me. Even for myself, my site has several thousand pages on it now. I think I’m up to three or four thousand pages and there’s no way I am just hand coding all those. I use a static site generator and I think tools like that can be really great.</p>\n<p>Chris: I think there’s some challenge there in that they become things that have to be kept updated and maintained. And so I like to keep mine as lean as possible, but I think build tools that put more of the run time on you, the developer, and thus allow you to ship less to the browser are a good thing, especially as the things we build become more complex. So I don’t know that I would necessarily say it’s just by default a red flag. I think a lot of it depends on how you’re using it. If you need to run a build to ship a one or two page marketing site or brochure site, yeah, that’s a red flag. But if you’re building some complex applications and these allow you to author in a way that’s more sensical for you and then ship less stuff to the browser, that’s not a bad thing. And that’s why I find tools like ASTRO really, really interesting because there is still a build step there, but it’s a build step in the service of providing a better end user experience.</p>\n<p>Drew: Yes. It’s shifting all that computation onto the server to build time or pre deferred time and not on page request time.</p>\n<p>Chris: Yeah. And so for me, I almost break build steps into... Like for me, the gold standard is if I can ship it without any build step at all, that’s awesome. But even for myself, the vanilla jazz guy, that’s not how I do things a hundred percent today. And so I think the next step up is compilers that reduce your code to as much HTML and plain old JavaScript as possible, versus those that create even more JavaScript, like the ones that take a bunch of little files and make an even bigger file. So more of the former, less of the latter if possible is always a good thing, but not always possible.</p>\n<p>Drew: I think getting off the dependency treadmill, as it were, it’s got to be a big draw to a Vanilla JavaScript approach, not having a million dependencies to be updating all the time, but I guess one of the advantages to some of these bigger frameworks is that they sometimes dictate and sometimes facilitate a uniform way of working, which is really important with larger teams. Is there a danger of a project going a bit off the rails without those standards and procedures in place that a framework imposes?</p>\n<p>Chris: Yes. Yeah. I think that’s fair. I used to downplay, I think, the significance of this for a while. And I think that is valid. That is a fair benefit of these tools. I think that maybe the small counter argument here is if you Google, \"How to do X with React,\" you’re going to get half a dozen different approaches to doing that thing. So there are conventions, but there’s not necessarily hard and fast, like if you don’t do it this way, everything breaks kind of rules. One of the appeals of these tools is that they have a lot of flexibility. Certainly they do enforce more standard approaches though than just green fields, browser native things do. And so I think there’s maybe a bit of a balance, even if you don’t have a strong team lead who’s driving internal code standards.</p>\n<p>Chris: I have seen even framework based projects go off the rails with hodgepodge approaches before. So it’s not like these tools automatically give you that, but they definitely give you some guidelines, maybe some rails that nudge you in the right direction. And I know some people need that. If that is something you need, this is where I really like that we’re seeing more of these smaller libraries that use the same conventions, like Petite Vue or Preact and compilers that also... Like FELT has some very rigid rails around it, certainly more so than you would see with ASTRO and so if you really need that, I think you have some options that don’t punish users for that need as much as what we had been doing a few years ago.</p>\n<p>Drew: In the work that I do, we use Vue and the Vue single file components are a really compelling case for this in that we have engineers writing front-end code, who aren’t necessarily front-end specialists who say here’s a way to create a skeleton single file component. Your template goes here, your Java script goes here, your CSS goes here. And just naturally as a result of that, we end up with a very consistent code base, even though it’s been created by a very diverse set of people. And so the conventions like that can really have a big benefit to teams who aren’t necessarily all headed in the same direction because the engineering department’s so massive or whatever.</p>\n<p>Chris: Yeah, for sure. Where I think you sometimes get into trouble with that... And I agree. I absolutely like the ability to make a code base look consistent with a bunch of different people working on it is really, really important because the people writing the code today are not necessarily going to be the ones maintaining it later. And that can get messy fast. The flip side is, if you are someone who is not comfortable or really well versed in JavaScript, a lot of the modern tool set is really geared towards JavaScript. And there are a lot of people on teams who specialize primarily in HTML or CSS or accessibility. And for them, JavaScript is not a core competency nor do I think it’s fair to expect it to be. And just like you don’t expect all your JavaScript developers to be experts in CSS.</p>\n<p>Chris: And so it can make their job a lot harder. And this is for me, always that like that give and take with these tools is they can do some really awesome things, but they can also gate keep a lot of people out of the process. And I feel like that balance is different from team to team, but for me, one of the big arguments for leaning more on browser native stuff, or ditching as many of those dependencies as possible is that you open up your development process to a lot of people who are not as JavaScript heavy.</p>\n<p>Drew: There’s always this undercurrent within the industry that suggests there’s the current way of doing things, the latest and there’s the outdated way. And if you’re not up to date with whatever the latest is, you’re somehow not as good an engineer or whatever.</p>\n<p>Drew: In your estimation does taking a Vanilla JavaScript approach enable you to swim free of all that is Vanilla JS like an evergreen approach that stands apart from those techniques.</p>\n<p>Chris: Yeah. Yeah. There’s a few threads in what you just mentioned, Drew. So one of them is, if you understand the fundamentals of the web, I have found that it’s a lot easier to like a bee, just bounce from different technology to different technology and understand it enough to like... Even if you don’t use it, look at it and be like, \"Okay, I can see some benefits to this or not, and evaluate whether it’s the right choice.\" If you need to dive into a new technology based on client needs or shifting direction in the company, you can. I think it’s a lot harder to do that if you only know a library and you’ve only learned the web in the context of that library.</p>\n<p>Chris: Now the caveat here is, I learned JavaScript in the context of jQuery and then backed my way into Vanilla JavaScript, and then moved on to a bunch of other things too. The more I think about how that process went for me though, I think I was able to do that as easily as I did in large part because by the time I made that jump, ES5 had come out and had taken a bunch of its conventions from jQuery. And so there was a lot of these real one for one map. Mental map things I could do. I don’t know if we’re quite there yet with some of the state based UI libraries, but we’re definitely headed in that direction and I think that’s great. But the other thing here, there is this real pressure, as you mentioned in the industry to always keep up to date with all these new technologies, in large part because people who develop these technologies and people who work at the big companies are the ones who get invited to speak at conferences and talk about all the cool things they’ve built.</p>\n<p>Chris: But the reality is that a lot of our web, like I’d say a majority of our web, runs on boring old technology that hasn’t been updated in a while, or has been updated, but in just a patch fix process. A lot of really important applications run on Python or PHP, or as a backend with just some sprinkling of lightweight HTML, CSS, and JavaScript on top. jQuery is still used on a lot of important stuff to the exclusion of other libraries. And it doesn’t always feel like it because I feel like most job descriptions that you see talk about wanting experience in React or Vue or something these days. But my experience from working in bigger technology companies or older product companies, is that there are a lot of jobs to be found working on old stable technology. And a lot of times it’s not always the most exciting work, but a lot of times they’re jobs that pay well and have really great hours and a lot of work life balance in a way that you won’t get in a really exciting tech company working on the latest stuff.</p>\n<p>Chris: And so there’s these trade offs there. It’s not always a bad thing. Yeah, I think it’s one of those, like the new, new, new thing is potentially a very vocal minority of the web that’s not representative of as the web as a whole.</p>\n<p>Drew: And there seems to be along with this idea that you should be adopting everything new and immediately casting away everything that you’ve been using for the last 12 months. There’s also this idea that you should be engineering things that are enterprise grade of engineering, but you ought to be doing every small project the way that an enormous company with 400 engineers is building things. And those two ideas actually aren’t compatible at all. It’s the big companies with all these hundreds of engineers who are using the old crusty technology, because it’s reliable and they’ve got far too much momentum. They hate to be dropping it and picking up something new. So those two ideas are indirect conflict, I think.</p>\n<p>Chris: Yeah. It’s funny. You always see the whole like, \"Well, will it scale, will it scale,\" kind of thing all the time. And does it need to? Are you building things for a Facebook sized audience? I’m sure you’ll get there at... Well, you’ll get there, but it would be wonderful if you got there at some point, but like, if you’re not there today, maybe that’s not necessarily how you need to start out. Like those aren’t your needs today. You’re pre-engineering for a problem that you don’t have to the detriment of some problems that you do.</p>\n<p>Chris: I think the other thing here is there’s this presumption that because Facebook or Google or Twitter do things, it’s a good idea, or it’s a good idea for everybody. And that’s not necessarily the case. Those companies do a lot of things right. But they also do a lot of things poorly and they do them that way because of engineering trade offs they’ve had to make because of how their teams are structured or very specific internal problems they had at the time that they made this decision or because some executive somewhere felt really strongly about something and made the internal team do it, even though it wasn’t necessarily best at the time. And then these things stick around. And so, yeah, I think one of the biggest things I see happen in our industry to our own detriment is looking at those few really big visible technology companies and thinking, \"If they do it this way, I have to too,\" or \"That’s the right call for everybody.\"</p>\n<p>Chris: It’s that old, like no one got fired for hiring IBM kind of thing, but applied to if it’s good enough for Google or if it’s good enough for Twitter or whatever, so yeah. I agree. I think we do a lot of that and maybe that we shouldn’t.</p>\n<p>Drew: I asked on Twitter earlier on that what frustrated people about modern web development best practices and from the responses I got, there’s certainly a lot of dissatisfaction with the current state of things. One trend, which over the last few years is getting momentum is like the Jamstack approach to building sites. And it seems on the surface that this going back to just client-side apps and nothing complex on the server, it sounds like it’s going back to basics, but is it doing that? Is it or is it just masking the complexity of the stack in a different way?</p>\n<p>Chris: It depends. I’m a little biased here because I love the Jamstack personally, but I have also seen... Well, I shouldn’t say I have seen. I think what I’m trying to say here is the Jamstack is a term that can apply to a wide range of approaches up to and including a really large two megabyte of JavaScript single page app that has no server side rendering on one end. And then on the other end, flat HTML files that use absolutely no JavaScript at all, and instantly loading your browser and just happen to be shipped from a CDN or something like that. And technically speaking, both of those are Jamstack and are not the flat HTML thing. So Jamstack is not inherently better than server rendered, but in many cases it can be.</p>\n<p>Chris: So for those of you who don’t know, Jamstack used to be an acronym that stood for JavaScript, APIs and markup, and they’ve since changed the spelling and changed the definition a little bit there. And it really encompasses an approach to building the web that doesn’t rely on server side rendering. So anything you’re serving, you’ve already compiled and put together and that’s what ships in the browser. And if there’s any other processing or scripting that happens, that happens in the client. Doesn’t have to, but often does. And so what I think is awesome about Jamstack if done a certain way, is it can dramatically improve the performance of the things that you’re building.</p>\n<p>Chris: If you’re not just shipping like a metric ton of JavaScript to the client and having all the stuff that you used to do on the server happen in the browser instead, because the browser will always be less efficient at all that scripting than the server would be, but where this really comes to shine, and so I’ll use like WordPress as an example. I love WordPress. I built my career on WordPress. It’s the reason why I was able to become a developer, but every time someone visits a WordPress site out of the box, it has to make a call to a database, grabs some content, mash it into some templates, generate HTML and ship that back to the browser.</p>\n<p>Chris: And there are some plugins you can use to do some of that ahead of time, but it is a very slow process, especially on a shared inexpensive web host. A Jamstack approach would be to have that HTML file already built, and you cut... You don’t cut the server out, but you cut all of that server processing completely out. So the HTML file already exists and gets shipped. And in an ideal world, you would even push that out to a bunch of CDNs so it sits as close to the person accessing it as possible. And what that can do is take a load time from a couple of seconds on an inexpensive host to less than half a second, because of how little computing time it takes to actually just request a file, get the file back and load it, if it’s mostly HTML.</p>\n<p>Chris: And so, yeah, I really like rambling in long winded response to your question, Drew, but I think the answer is, if you’re using it with something like a static site generator, it can be amazingly more performant than some of the other things we’ve done in the past. And it allows you to get that same WordPress experience where I’m authoring content and I have some templates and I don’t have to hardcode HTML, but the performance is way better on one end.</p>\n<p>Chris: And then on the other end, you could theoretically define a React app as Jamstack as well and it can be really slow and buggy and terrible. And so it depends. The other thing I’m seeing happen that’s really, really funny and interesting is we just keep reinventing PHP over and over and over again as an industry in various ways. So-</p>\n<p>Drew: We still have PHP as well. It’s not gone.</p>\n<p>Chris: Right? And yet PHP still exists and still works great. And so we’ve got... Like I remember when Next.js came out. There was all these kind of, \"And here’s all the things you can do with it.\" And I was like, \"Oh, that’s like PHP,\" but a decade later. And then my friend Zach Leatherman who built Eleventy which is an amazing static site generator has been experimenting with some compiling in real time on the server stuff with Eleventy.</p>\n<p>Chris: So it’s like just in time Jamstack and he even jokes that he’s essentially recreated PHP in node and JavaScript, but it’s slightly different because there’s like a serverless build that happens that then instant deploys it to a CDN and it’s like a little weird. So it’s still a house of cards. You’re just shifting around where those cards live and who’s responsible for them, but yeah, yeah. Jamstack is cool. Jamstack is problematic. It’s also not. It’s awesome. It’s potentially overused both as a term and a technology. Yeah. It’s a whole lot of things and I love it in the same way that I love PHP. It’s great and it has problems and every technology and approach is a series of trade-offs.</p>\n<p>Drew: Do you think we’re going through some industrial revolution in web development? What used to be skilled painstaking work from individual arts and is now high volume, high production factory output. All the machines have been brought in and the frameworks and the build tools and have we lost that hand rolled touch?</p>\n<p>Chris: Well, I mean, yes, to an extent, but we don’t have to. I mean, that analogy is appropriate in many ways, because a lot of the ways we do things today produce... I like to call them front end pollution in the over-reliance on JavaScript, but also in the very literal sense. We have so many heavy build processes now that they generate more actual literal pollution as well. But I think the counter argument here is with a... I will use farming, right? You could go out and hand mill your wheat with a scyther. I forget what you call those. The crescent shaped tool that you use to chop your wheat, or you could use an oxen drawn machine that will pull that off, or you can use a big tractor.</p>\n<p>Chris: And I think there’s a clear argument that at some point, factory farming is this big industrial complex that has lost a little bit of that close to the Earth touch, but I don’t think I necessarily need my farmers to be hand chopping their wheat. That is wildly inefficient for very little benefit. And there’s probably a balance there. And I feel the same thing with what we’re doing here. Some of these tools allow us to do more artisan work faster and more efficiently. And sometimes they just turn it into generating a bunch of garbage and turn it out as fast as possible. And there’s not necessarily a clear cut delineation for where that crossover happens. I think it’s a little fuzzy and gray and like a you know it when you see it kind of thing. Sometimes not always. But yeah, I think it’s a little bit of both. The commercialization of the web is both a really terrible thing and also a really great thing that has allowed folks like myself to have a living working on the platform that I love full time.</p>\n<p>Chris: That’s awesome. But it’s also produced a lot of problems and I think that’s true for any technology. There’s good and bad that comes with all of it.</p>\n<p>Drew: And maybe sometimes we’re just producing really fat pigs.</p>\n<p>Chris: Yeah. I’ve gotten a lot more like, it depends as I’ve gotten older. This stuff used to really, really upset me from a purist standpoint. And I still really hate the fact that we’ve forced our users to endorse such a fragile and easily broken web. The web in general has gotten four to five times faster in the last decade. And the average website has only gotten a hundred milliseconds faster in terms of load time, because we just keep throwing more and more stuff at our users. And we could have a really fast resilient web right now if we wanted one, but we don’t. And part of that is a natural trade off for pushing the capabilities of the web further and further and that’s awesome, but I feel like sometimes we do things just because it’s shiny and new and not because it adds real benefit to folks. So I’d love to see a little bit more balance there.</p>\n<p>Drew: Is part of the problem that we’re expecting the web to do too much? I mean, for many years we didn’t really have any great alternatives. So we enhanced and maybe over-stretched the high tech document system to behave like a software application. And now we’ve all got really powerful phones in our pockets, running a range of network connected apps. Is that the appropriate outlook for this functionality that we’re trying to build into websites? Should we just all be building apps for that case and leaving the document based stuff to be on the web?</p>\n<p>Chris: I would argue the other direction. I think the bigger problem is... So maybe there are certain things for which I even personally I prefer like a native app over something in the web. But I think having the web do more frees you from app ecosystems and allows you as a team to build a thing and be able to reach more people with it, not have to download an app before you can access the thing you want. That’s a really cool thing. And I would argue that potentially the bigger problem is that browsers can’t keep up with the pace of the thing that we want the web to do. And that’s not a knock on the people behind the standards processes. I would not want to go back to every browser just does their own thing and the hell with it. That was awful to develop for.</p>\n<p>Drew: It was, yeah.</p>\n<p>Chris: We do have some of those similar problems though, just based on how the standards process works. So sometimes you’ll see Google get frustrated because they have so much in-house development power, get frustrated with other browsers that are part of that process not wanting to go along with something or not moving fast enough. And so they just... Leeroy Jenkins it and just run off and go do whatever they want to do. On the flip side you sometimes see Apple moving very, very slow because they don’t put as much investment into the web as they do other parts of their business, which is hopefully, maybe starting to change a little bit with some of the more recent hires they’ve made. But I think one of the things you run into is just the web tends to move a little slowly sometimes.</p>\n<p>Chris: Technology moves fast, but the browsers themselves and the technologies they implement don’t always keep up. And so I don’t believe we demand too much of our browsers. I just think you get this natural ebb and flow where we demand a lot. We build a bunch of libraries to polyfill the things that we want and then when the browser eventually catches up, there’s this really slow, petering off as library usage for that particular stuff drops off.</p>\n<p>Chris: Yeah. But I don’t know that I would say we demand too much of the web. Yeah, I don’t know. I actually, I love all the things the web can do. I think it’s really, for me, it’s what’s so exciting about the web. I think my frustration is more just with how slow some of these technologies are to come out, particularly on iOS devices. And I say this as someone who, I love my iPhone, but progressive web apps continue to be a second... They just don’t get as much priority as native apps do on that platform, which is disappointing.</p>\n<p>Drew: So looking to the future on that note, what should we, as a development community be working on to fix some of these issues? Where should we be placing our efforts?</p>\n<p>Chris: Yeah. So I think there are a few different things. And I think some of the tools we’ve talked about, I don’t think they’ll ever necessarily go away. They might change in form a little bit, but so I already see some cool things on the horizon. One of the things people love about single page apps that we’ve never been able to do with, I call them multistage apps, but they’re really just plain old webpages is like the nice transitions that happen between views where you might like fade in, fade out, or something like that.</p>\n<p>Chris: There’s a native API in the works that’s going to make that a lot easier. That’s awesome. There’s also a native API in the works for HTML sanitization. So one of the big things that libraries do for you is they, when you’re rendering HTML from third party data, they have some libraries baked in that will help reduce your risk of cross-site scripting attacks.</p>\n<p>Chris: There’s not really a good, just native way to do that, but there’s one in the works that will make that a lot easier. And even if you continue to use state based libraries, that should allow them to strip a bunch of code out and that would be an awesome thing.</p>\n<p>Chris: One thing that the native web can’t do yet that would be really cool, is a way to handle DOM dipping so that if you want to build some HTML based on a JavaScript object and then update it as the object changes, it would be really cool if you didn’t have to rely on a library for that. And that there was maybe a performant out of the box way to do that in the browser. I think that would solve a lot of problems. As well as more accessible interactive components. I absolutely love when HTML and CSS can replace something I used to need JavaScript for. Doesn’t need to be as rigorously tested, way more fault tolerant, less likely to break, more performant all around. It’s a net win. And so I’d love to see more of those come to the platform.</p>\n<p>Chris: So from a browser native thing there’s that. And then the other big thing I think we’re going to start to see more of is a shift away from client-side libraries and a shift to more pre-compiled stuff. Whether that’s static side generators, something like ASTRO that still uses JavaScript libraries, but pre renders them instead of making the browser do it. But those are the, I think, the big things I’m seeing start to happen and I think we’re going to see more and more of.</p>\n<p>Drew: So you saying maybe it’s not all doom and gloom and perhaps we can fix this? There’s a way out?</p>\n<p>Chris: No, yeah, I see us emerging from the dark ages slowly. And what I think is going to happen is we’re going to hit a point where much like where today people are like, \"Why does everybody still use React?\" I can imagine in 7 to 10 years time, we’re going to be like, \"Why does anybody...\" I’m sorry. Not React. jQuery. \"Why does everybody still use jQuery?\" We’re going to see the same thing with React and Vue. Like, \"Why does everybody still start a project with those?\" And there’s going to be some new libraries that are starting to emerge to solve a whole new set of problems that we haven’t even dreamed of today.</p>\n<p>Drew: One comment from Twitter that I really identified with was from Amy Pellegrini, who said, \"Every time I update something, everything gets broken.\" Yep. I just think we’ve all been there, haven’t we?</p>\n<p>Chris: Yeah. I unfortunately don’t think that will ever fully go away because even in the non-build tool era of jQuery, we used to just load it with a script element. You would run into situations where different versions would be incompatible with each other. And so you’d drop a plug in into your site and it would be like, \"Sorry, you’re running jQuery 1.83, and this requires 1.89 or higher because it added this new...\" And so there’s always been some version of that. I think it’s a lot more pronounced now because so much of it happens in the command line and spits out all these terrible errors that don’t make sense. But yeah, that unfortunately I don’t think will ever go away. I feel the pain though. That one, it’s a big part of the reason why I try and use as few dependencies as possible.</p>\n<p>Drew: Me too. Me too. So I’ve been learning all about the lean web or learning more about the lean web than our conversation. What have you been learning about lately, Chris?</p>\n<p>Chris: Yeah. Great question. So I have been going deep on service workers in part because I love their ability to both make the web faster, or even if you’re not building a progressive web app, they’re just really, really cool. One of the things I’ve absolutely loved them for though is they allow me to build a single page app like experience in terms of performance, without all the complexity of having to handle JavaScript routing and stuff. So I can have a multipage app, cache my API calls for a short period of time without having to cache them in memory. And so I’ve been able to do some really cool things with them. And then the other thing I’ve been learning a lot about lately is serverless, which allows me to get the benefits of having some server-side code without having to actually manage a server, which is great.</p>\n<p>Chris: And so I went really, really deep on those, put together a couple of courses on both of those topics as well, but they have benefited me immensely in my own work, in particular service workers, which has been amazing. I’m obsessed with them. Recommend them for everybody.</p>\n<p>Drew: That’s amazing. And where can people find those courses that you put together on?</p>\n<p>Chris: So if you go to vanillajsguides.com, you can dig into those and a whole bunch of other courses as well.</p>\n<p>Drew: Amazing. If you dear listener would like to hear more from Chris, you can find his book on the web at leanweb.dev and his developer tips newsletter, which I believe now gets over 12,000 subscribers-</p>\n<p>Chris: Yeah. Up a little bit from the last time we chatted.</p>\n<p>Drew: Yeah. That’s at gomakethings.com. Chris is on twitter @chrisferdinandi. And you can check out his podcast at podcast.com or wherever you usually get your podcasts from. Thanks for joining us today, Chris. Do you have any parting words?</p>\n<p>Chris: No, that was a really great summary, Drew. Thank you so much. You hit all the key links. So thanks so much for having me. This was great.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"16064c3abdbc9921e64d8ee6234516bf6117846626ecabb6f5132697e388d508","category":"Tech"}