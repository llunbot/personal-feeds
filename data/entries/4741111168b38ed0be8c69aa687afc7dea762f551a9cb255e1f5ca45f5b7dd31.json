{"title":"SVG Coding Examples: Useful Recipes For Writing Vectors By Hand","link":"https://smashingmagazine.com/2024/09/svg-coding-examples-recipes-writing-vectors-by-hand/","date":1726650000000,"content":"<p>Even though I am the kind of front-end engineer who manually cleans up SVG files when they are a mess, I never expected to become one of <em>those</em> people. You know, those crazy people that <em>draw with code.</em></p>\n<p>But here we are.</p>\n<p>I dove deep into SVG specs last winter when I created a project to <a href=\"https://code.halfapx.com/guideline-generator/\">draw Calligraphy Grids</a>, and even though I knew the basic structures and rules of SVG, it was only then that I fully tried to figure out and understand what all of those numbers meant and how they interacted with each other.</p>\n<p>And, once you get the hang of it, it is actually very interesting and quite fun to code SVG by hand.</p>\n<blockquote><strong>No &lt;path&gt; ahead</strong><br /><br />We won’t go into more complex SVG shapes like <a href=\"https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\">paths</a> in this article, this is more about practical information for simple SVGs. When it comes to drawing curves, I still recommend using a tool like Illustrator or Affinity. However, if you are super into compounding your lines, a path is useful. Maybe we’ll do that in Part 2.<br /><br />Also, this guide focuses mostly on practical examples that illustrate some of the math involved when drawing SVGs. There is a wonderful article here that goes a bit deeper into the specs, which I recommend reading if you’re more interested in that: “<a href=\"https://www.smashingmagazine.com/2019/05/svg-design-tools-practical-guide/#comments-svg-design-tools-practical-guide\">A Practical Guide To SVG And Design Tools</a>.”</blockquote>\n\nDrawing With Math. Remember Coordinate Systems?\n<p>Illustrator, Affinity, and all other vector programs are basically just helping you draw on a coordinate system, and then those paths and shapes are stored in SVG files.</p>\n<p>If you open up these files in an editor, you’ll see that they are just a bunch of paths that contain lots of numbers, which are coordinates in that coordinate system that make up the lines.</p>\n<p>But, there is a difference between the all-powerful <code>&lt;path&gt;</code> and the other, more semantic elements like <code>&lt;rect&gt;</code>, <code>&lt;circle&gt;</code>, <code>&lt;line&gt;</code>, <code>&lt;ellipse&gt;</code>, <code>&lt;polygon&gt;</code>, and <code>&lt;polyline&gt;</code>.</p>\n<p>These elements are not that hard to read and write by hand, and they open up a lot of possibilities to add animation and other fun stuff. So, while most people might only think of SVGs as never-pixelated, infinitely scaling images, they can also be quite comprehensive pieces of code.</p>\n<h3>How Does SVG Work? <code>unit != unit</code></h3>\n<p>Before we get started on how SVG elements are drawn, let’s talk about the ways units work in SVG because they might be a bit confusing when you first get started.</p>\n<p>The beauty of SVG is that it’s a vector format, which means that the units are somewhat detached from the browser and are instead just relative to the coordinate system you’re working in.</p>\n<p>That means you would <strong>not</strong> use a unit within SVG but rather just use numbers and then define the size of the document you’re working with.</p>\n<p>So, your <code>width</code> and <code>height</code> might be using CSS <code>rem</code> units, but in your <code>viewBox</code>, units become just a concept that helps you in establishing sizing relationships. </p>\n<h3>What Is The <code>viewBox</code>?</h3>\n<p>The <code>viewBox</code> works a little bit like the CSS <code>aspect-ratio</code> property. It helps you establish a relationship between the width and the height of your coordinate system and sets up the box you’re working in. I tend to think of the <code>viewBox</code> as my “document” size.</p>\n<p>Any element that is placed within the SVG with bigger dimensions than the <code>viewBox</code> will not be visible. So, the <code>viewBox</code> is the cutout of the coordinate system we’re looking through. The <code>width</code> and <code>height</code> attributes are unnecessary if there is a <code>viewBox</code> attribute.</p>\n<p>So, in short, having an SVG with a <code>viewBox</code> makes it behave a lot like a regular image. And just like with images, it’s usually easiest to just set either a <code>width</code> or a <code>height</code> and let the other dimension be automatically sized based on the intrinsic aspect ratio dimensions.</p>\n<p>So, if we were to create a function that draws an SVG, we might store three separate variables and fill them in like this: </p>\n<pre><code>`&lt;svg \n  width=\"${svgWidth}\" \n  viewBox=\"0 0 ${documentWidth} ${documentHeight}\" \n  xmlns=\"http://www.w3.org/2000/svg\"\n&gt;`;\n</code></pre>\n\n<h3>SVG Things Of Note</h3>\n<p>There is a lot to know about SVG: When you want to reuse an image a lot, you may want to turn it into a <code>symbol</code> that can then be referenced with a <code>use</code> tag, you can create sprites, and there are some best practices when using them for icons, and so on.</p>\n<p>Unfortunately, this is a bit out of the scope of this article. Here, we’re mainly focusing on designing SVG files and not on how we can optimize and use them.</p>\n<p>However, one thing of note that is easier to implement from the start is <strong>accessibility</strong>.</p>\n<p>SVGs can be used in an <code>&lt;img&gt;</code> tag, where <code>alt</code> tags are available, but then you lose the ability to interact with your SVG code, so inlining might be your preference.</p>\n<p>When inlining, it’s easiest to declare <code>role=\"img\"</code> and then add a <code>&lt;title&gt;</code> tag with your image title.</p>\n<p><strong>Note</strong>: <em>You can check out <a href=\"https://www.smashingmagazine.com/2021/05/accessible-svg-patterns-comparison/\">this article for SVG and Accessibility recommendations</a>.</em></p>\n<pre><code>&lt;svg\n  role=\"img\"\n  [...attr]\n&gt;\n  &lt;title&gt;An accessible title&lt;/title&gt;\n  &lt;!-- design code --&gt;\n&lt;/svg&gt;\n</code></pre>\n\n\n\nDrawing SVG With JavaScript\n<p>There is usually some mathematics involved when drawing SVGs. It’s usually fairly simple arithmetic (except, you know, in case you draw calligraphy grids and then have to dig out trigonometry…), but I think even for simple math, most people don’t write their SVGs in pure HTML and thus would like to use algebra.</p>\n<p>At least for me, I find it much easier to understand SVG Code when giving meaning to numbers, so I always stick to JavaScript, and by giving my coordinates names, I like them immeasurable times more.</p>\n<p>So, for the upcoming examples, we’ll look at the list of variables with the simple math and then JSX-style templates for interpolation, as that gives more legible syntax highlighting than string interpolations, and then each example will be available as a CodePen.</p>\n<p>To keep this Guide framework-agnostic, I wanted to quickly go over drawing SVG elements with just good old vanilla JavaScript.</p>\n<p>We’ll create a container element in HTML that we can put our SVG into and grab that element with JavaScript.</p>\n<pre><code>&lt;div data-svg-container&gt;&lt;/div&gt;\n&lt;script src=\"template.js\"&gt;&lt;/script&gt;\n</code></pre>\n\n<p>To make it simple, we’ll draw a rectangle <code>&lt;rect&gt;</code> that covers the entire <code>viewBox</code> and uses a fill.</p>\n<p><strong>Note</strong>: <em>You can add all valid CSS values as fills, so a fixed color, or something like <code>currentColor</code> to access the site’s text color or a CSS variable would work here if you’re inlining your SVG and want it to interact with the page it’s placed in.</em></p>\n<p>Let’s first start with our variable setup.</p>\n<div>\n<pre><code>// vars\nconst container = document.querySelector(\"[data-svg-container]\");\nconst svgWidth = \"30rem\"; // use any value with units here\nconst documentWidth = 100;\nconst documentHeight = 100;\nconst rectWidth = documentWidth;\nconst rectHeight = documentHeight;\nconst rectFill = \"currentColor\"; // use any color value here\nconst title = \"A simple square box\";\n</code></pre>\n</div>\n\n<h3>Method 1: Create Element and Set Attributes</h3>\n<p>This method is easier to keep type-safe (if using TypeScript) — uses proper SVG elements and attributes, and so on — but it is less performant and may take a long time if you have many elements.</p>\n<div>\n<pre><code>const svg = document.createElementNS(\"<a href=\"http://www.w3.org/2000/svg&quot;\">http://www.w3.org/2000/svg\"</a>, \"svg\");\nconst titleElement = document.createElementNS(\"<a href=\"http://www.w3.org/2000/svg&quot;\">http://www.w3.org/2000/svg\"</a>, \"title\");\nconst rect = document.createElementNS(\"<a href=\"http://www.w3.org/2000/svg&quot;\">http://www.w3.org/2000/svg\"</a>, \"rect\");\n\nsvg.setAttribute(\"width\", svgWidth);\nsvg.setAttribute(\"viewBox\", <code>0 0 ${documentWidth} ${documentHeight}</code>);\nsvg.setAttribute(\"xmlns\", \"<a href=\"http://www.w3.org/2000/svg&quot;)\">http://www.w3.org/2000/svg\")</a>;\nsvg.setAttribute(\"role\", \"img\");\n\ntitleElement.textContent = title;\n\nrect.setAttribute(\"width\", rectWidth);\nrect.setAttribute(\"height\", rectHeight);\nrect.setAttribute(\"fill\", rectFill);\n\nsvg.appendChild(titleElement);\nsvg.appendChild(rect);\n\ncontainer.appendChild(svg);\n</code></pre>\n</div>\n\n<p><img src=\"https://files.smashing.media/articles/svg-coding-examples-recipes-writing-vectors-by-hand/polygon-polyline-composite-fixed.png\" /></p>\n<p>Here, you can see that with the same coordinates, a polyline won’t draw the line between the blue and the red dot, while a polygon will. However, when applying a fill, they take the exact same information as if the shape was closed, which is the right side of the graphic, where the polyline makes it look like a piece of a circle is missing.</p>\n<p>This is the second time where we have dealt with quite a bit of repetition, and we can have a look at how we could leverage the power of JavaScript logic to render our template faster.</p>\n<p>But first, we need a basic implementation like we’ve done before. We’re creating objects for the circles, and then we’re chaining the <code>cx</code> and <code>cy</code> values together to create the <code>points</code> attribute. We’re also storing our transforms in variables.</p>\n<div>\n<pre><code>const polyDocWidth = 200;\nconst polyDocHeight = 200;\nconst circleOne = { cx: 25, cy: 80, r: 10, fill: \"red\" };\nconst circleTwo = { cx: 40, cy: 20, r: 5, fill: \"lime\" };\nconst circleThree = { cx: 70, cy: 60, r: 8, fill: \"cyan\" };\nconst points = <code>${circleOne.cx},${circleOne.cy} ${circleTwo.cx},${circleTwo.cy} ${circleThree.cx},${circleThree.cy}</code>;\nconst moveToTopRight = <code>translate(${polyDocWidth / 2}, 0)</code>;\nconst moveToBottomRight = <code>translate(${polyDocWidth / 2}, ${polyDocHeight / 2})</code>;\nconst moveToBottomLeft = <code>translate(0, ${polyDocHeight / 2})</code>;\n</code></pre>\n</div>\n\n<p>And then, we apply the variables to the template, using either a <code>polyline</code> or <code>polygon</code> element and a <code>fill</code> attribute that is either set to <code>none</code> or a color value.</p>\n<pre><code>\n&lt;svg\n  width={svgWidth}\n  viewBox={`0 0 ${polyDocWidth} ${polyDocHeight}`}\n  xmlns=\"http://www.w3.org/2000/svg\"\n  role=\"img\"\n&gt;\n  &lt;title&gt;Composite shape comparison&lt;/title&gt;\n  &lt;g&gt;\n    &lt;circle\n      cx={circleOne.cx}\n      cy={circleOne.cy}\n      r={circleOne.r}\n      fill={circleOne.fill}\n    /&gt;\n    &lt;circle\n      cx={circleTwo.cx}\n      cy={circleTwo.cy}\n      r={circleTwo.r}\n      fill={circleTwo.fill}\n    /&gt;\n    &lt;circle\n      cx={circleThree.cx}\n      cy={circleThree.cy}\n      r={circleThree.r}\n      fill={circleThree.fill}\n    /&gt;\n    &lt;polyline\n      points={points}\n      fill=\"none\"\n      stroke=\"black\"\n    /&gt;\n  &lt;/g&gt;\n  &lt;g transform={moveToTopRight}&gt;\n    &lt;circle\n      cx={circleOne.cx}\n      cy={circleOne.cy}\n      r={circleOne.r}\n      fill={circleOne.fill}\n    /&gt;\n    &lt;circle\n      cx={circleTwo.cx}\n      cy={circleTwo.cy}\n      r={circleTwo.r}\n      fill={circleTwo.fill}\n    /&gt;\n    &lt;circle\n      cx={circleThree.cx}\n      cy={circleThree.cy}\n      r={circleThree.r}\n      fill={circleThree.fill}\n    /&gt;\n    &lt;polyline\n      points={points}\n      fill=\"white\"\n      stroke=\"black\"\n    /&gt;\n  &lt;/g&gt;\n  &lt;g transform={moveToBottomLeft}&gt;\n    &lt;circle\n      cx={circleOne.cx}\n      cy={circleOne.cy}\n      r={circleOne.r}\n      fill={circleOne.fill}\n    /&gt;\n    &lt;circle\n      cx={circleTwo.cx}\n      cy={circleTwo.cy}\n      r={circleTwo.r}\n      fill={circleTwo.fill}\n    /&gt;\n    &lt;circle\n      cx={circleThree.cx}\n      cy={circleThree.cy}\n      r={circleThree.r}\n      fill={circleThree.fill}\n    /&gt;\n    &lt;polygon\n      points={points}\n      fill=\"none\"\n      stroke=\"black\"\n    /&gt;\n  &lt;/g&gt;\n  &lt;g transform={moveToBottomRight}&gt;\n    &lt;circle\n      cx={circleOne.cx}\n      cy={circleOne.cy}\n      r={circleOne.r}\n      fill={circleOne.fill}\n    /&gt;\n    &lt;circle\n      cx={circleTwo.cx}\n      cy={circleTwo.cy}\n      r={circleTwo.r}\n      fill={circleTwo.fill}\n    /&gt;\n    &lt;circle\n      cx={circleThree.cx}\n      cy={circleThree.cy}\n      r={circleThree.r}\n      fill={circleThree.fill}\n    /&gt;\n    &lt;polygon\n      points={points}\n      fill=\"white\"\n      stroke=\"black\"\n    /&gt;\n  &lt;/g&gt;\n&lt;/svg&gt;\n</code></pre>\n\n<p>And here’s a version of it to play with:</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/OJeeVoM\">SVG Polygon / Polyline (simple) [forked]</a> by <a href=\"https://codepen.io/mynimi\">Myriam</a>.</p>\nDealing With Repetition\n<p>When it comes to drawing SVGs, you may find that you’ll be repeating a lot of the same code over and over again. This is where JavaScript can come in handy, so let’s look at the composite example again and see how we could optimize it so that there is less repetition.</p>\n<p><strong>Observations:</strong></p>\n<ul>\n<li>We have three circle elements, all following the same pattern.</li>\n<li>We create one repetition to change the <code>fill</code> style for the element.</li>\n<li>We repeat those two elements one more time, with either a <code>polyline</code> or a <code>polygon</code>.</li>\n<li>We have four different <code>transforms</code> (technically, no transform is a transform in this case).</li>\n</ul>\n<p>This tells us that we can create nested loops.</p>\n<p>Let’s go back to just a vanilla implementation for this since the way loops are done is quite different across frameworks.</p>\n<p>You could make this more generic and write separate generator functions for each type of element, but this is just to give you an idea of what you could do in terms of logic. There are certainly still ways to optimize this.</p>\n<p>I’ve opted to have arrays for each type of variation that we have and wrote a helper function that goes through the data and builds out an array of objects with all the necessary information for each group. In such a short array, it would certainly be a viable option to just have the data stored in one element, where the values are repeated, but we’re taking the DRY thing seriously in this one.</p>\n<p>The group array can then be looped over to build our SVG HTML.</p>\n<div>\n<pre><code>const container = document.querySelector(\"[data-svg-container]\");\nconst svgWidth = 200;\nconst documentWidth = 200;\nconst documentHeight = 200;\nconst halfWidth = documentWidth / 2;\nconst halfHeight = documentHeight / 2;\nconst circles = [\n  { cx: 25, cy: 80, r: 10, fill: \"red\" },\n  { cx: 40, cy: 20, r: 5, fill: \"lime\" },\n  { cx: 70, cy: 60, r: 8, fill: \"cyan\" },\n];\nconst points = circles.map(({ cx, cy }) =&gt; <code>${cx},${cy}</code>).join(\" \");\nconst elements = [\"polyline\", \"polygon\"];\nconst fillOptions = [\"none\", \"white\"];\nconst transforms = [\n  undefined,\n  <code>translate(${halfWidth}, 0)</code>,\n  <code>translate(0, ${halfHeight})</code>,\n  <code>translate(${halfWidth}, ${halfHeight})</code>,\n];\nconst makeGroupsDataObject = () =&gt; {\n  let counter = 0;\n  const g = [];\n  elements.forEach((element) =&gt; {\n    fillOptions.forEach((fill) =&gt; {\n      const transform = transforms[counter++];\n      g.push({ element, fill, transform });\n    });\n  });\n  return g;\n};\nconst groups = makeGroupsDataObject();\n// result:\n// [\n//   {\n//     element: \"polyline\",\n//     fill: \"none\",\n//   },\n//   {\n//     element: \"polyline\",\n//     fill: \"white\",\n//     transform: \"translate(100, 0)\",\n//   },\n//   {\n//     element: \"polygon\",\n//     fill: \"none\",\n//     transform: \"translate(0, 100)\",\n//   },\n//   {\n//     element: \"polygon\",\n//     fill: \"white\",\n//     transform: \"translate(100, 100)\",\n//   }\n// ]\n\nconst svg = document.createElementNS(\"<a href=\"http://www.w3.org/2000/svg&quot;\">http://www.w3.org/2000/svg\"</a>, \"svg\");\nsvg.setAttribute(\"width\", svgWidth);\nsvg.setAttribute(\"viewBox\", <code>0 0 ${documentWidth} ${documentHeight}</code>);\nsvg.setAttribute(\"xmlns\", \"<a href=\"http://www.w3.org/2000/svg&quot;)\">http://www.w3.org/2000/svg\")</a>;\nsvg.setAttribute(\"role\", \"img\");\nsvg.innerHTML = \"&lt;title&gt;Composite shape comparison&lt;/title&gt;\";\ngroups.forEach((groupData) =&gt; {\n  const circlesHTML = circles\n    .map((circle) =&gt; {\n      return <code>&amp;lt;circle \n          cx=\"${circle.cx}\" \n          cy=\"${circle.cy}\" \n          r=\"${circle.r}\" \n          fill=\"${circle.fill}\"\n        /&amp;gt;</code>;\n    })\n    .join(\"\");\n  const polyElementHTML = <code>&amp;lt;${groupData.element} \n      points=\"${points}\" \n      fill=\"${groupData.fill}\" \n      stroke=\"black\" \n    /&amp;gt;</code>;\n  const group = <code>&amp;lt;g ${groupData.transform ?</code>transform=\"${groupData.transform}\"<code>: \"\"}&amp;gt;\n        ${circlesHTML}\n        ${polyElementHTML}\n      &amp;lt;/g&amp;gt;</code>;\n  svg.innerHTML += group;\n});\ncontainer.appendChild(svg);\n</code></pre>\n</div>\n\n<p>And here’s the Codepen of that:</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/XWLLbPq\">SVG Polygon / Polyline (JS loop version) [forked]</a> by <a href=\"https://codepen.io/mynimi\">Myriam</a>.</p>\nMore Fun Stuff\n<p>Now, that’s all the basics I wanted to cover, but there is so much more you can do with SVG. There is more you can do with <code>transform</code>; you can use a <code>mask</code>, you can use a <code>marker</code>, and so on.</p>\n<p>We don’t have time to dive into all of them today, but since this started for me when making Calligraphy Grids, I wanted to show you the two most satisfying ones, which I, unfortunately, can’t use in the generator since I wanted to be able to open my generated SVGs in Affinity and it doesn’t support <code>pattern</code>.</p>\n<p>Okay, so <code>pattern</code> is part of the <code>defs</code> section within the SVG, which is where you can define reusable elements that you can then reference in your SVG.</p>\n<h3>Graph Grid with <code>pattern</code></h3>\n<p>If you think about it, a graph is just a bunch of horizontal and vertical lines that repeat across the x- and y-axis.</p>\n<p>So, <code>pattern</code> can help us with that. We can create a <code>&lt;rect&gt;</code> and then reference a <code>pattern</code> in the <code>fill</code> attribute of the <code>rect</code>. The pattern then has its own <code>width</code>, <code>height</code>, and <code>viewBox</code>, which defines how the pattern is repeated.</p>\n<p>So, let’s say we want to perfectly center our graph grid in any given width or height, and we want to be able to define the size of our resulting squares (cells).</p>\n<p>Once again, let’s start with the JavaScipt variables:</p>\n<pre><code>const graphDocWidth = 226;\nconst graphDocHeight = 101;\nconst cellSize = 5;\nconst strokeWidth = 0.3;\nconst strokeColor = \"currentColor\";\nconst patternHeight = (cellSize / graphDocHeight) * 100;\nconst patternWidth = (cellSize / graphDocWidth) * 100;\nconst gridYStart = (graphDocHeight % cellSize) / 2;\nconst gridXStart = (graphDocWidth % cellSize) / 2;\n</code></pre>\n\n<p>Now, we can apply them to the SVG element:</p>\n<pre><code>&lt;svg\n  width={svgWidth}\n  viewBox={`0 0 ${graphDocWidth} ${graphDocHeight}`}\n  xmlns=\"http://www.w3.org/2000/svg\"\n  role=\"img\"\n&gt;\n  &lt;defs&gt;\n    &lt;pattern\n      id=\"horizontal\"\n      viewBox={`0 0 ${graphDocWidth} ${strokeWidth}`}\n      width=\"100%\"\n      height={`${patternHeight}%`}\n    &gt;\n      &lt;line\n        x1=\"0\"\n        x2={graphDocWidth}\n        y1={gridYStart}\n        y2={gridYStart}\n        stroke={strokeColor}\n        stroke-width={strokeWidth}\n      /&gt;\n    &lt;/pattern&gt;\n    &lt;pattern\n      id=\"vertical\"\n      viewBox={`0 0 ${strokeWidth} ${graphDocHeight}`}\n      width={`${patternWidth}%`}\n      height=\"100%\"\n    &gt;\n      &lt;line\n        y1={0}\n        y2={graphDocHeight}\n        x1={gridXStart}\n        x2={gridXStart}\n        stroke={strokeColor}\n        stroke-width={strokeWidth}\n      /&gt;\n    &lt;/pattern&gt;\n  &lt;/defs&gt;\n  &lt;title&gt;A graph grid&lt;/title&gt;\n  &lt;rect\n    width={graphDocWidth}\n    height={graphDocHeight}\n    fill=\"url(#horizontal)\"\n  /&gt;\n  &lt;rect\n    width={graphDocWidth}\n    height={graphDocHeight}\n    fill=\"url(#vertical)\"\n  /&gt;\n&lt;/svg&gt;\n</code></pre>\n\n<p>And this is what that then looks like:</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/XWLLbxq\">SVG Graph Grid [forked]</a> by <a href=\"https://codepen.io/mynimi\">Myriam</a>.</p>\n<h3>Dot Grid With <code>pattern</code></h3>\n<p>If we wanted to draw a dot grid instead, we could simply repeat a circle. Or, we could alternatively use a line with a <code>stroke-dasharray</code> and <code>stroke-dashoffset</code> to create a dashed line. And we’d only need one line in this case.</p>\n<p>Starting with our JavaScript variables:</p>\n<pre><code>const dotDocWidth = 219;\nconst dotDocHeight = 100;\nconst cellSize = 4;\nconst strokeColor = \"black\";\nconst gridYStart = (dotDocHeight % cellSize) / 2;\nconst gridXStart = (dotDocWidth % cellSize) / 2;\nconst dotSize = 0.5;\nconst patternHeight = (cellSize / dotDocHeight) * 100;\n</code></pre>\n\n<p>And then adding them to the SVG element:</p>\n<pre><code>&lt;svg\n  width={svgWidth}\n  viewBox={`0 0 ${dotDocWidth} ${dotDocHeight}`}\n  xmlns=\"http://www.w3.org/2000/svg\"\n  role=\"img\"\n&gt;\n  &lt;defs&gt;\n    &lt;pattern\n      id=\"horizontal-dotted-line\"\n      viewBox={`0 0 ${dotDocWidth} ${dotSize}`}\n      width=\"100%\"\n      height={`${patternHeight}%`}\n    &gt;\n      &lt;line\n        x1={gridXStart}\n        y1={gridYStart}\n        x2={dotDocWidth}\n        y2={gridYStart}\n        stroke={strokeColor}\n        stroke-width={dotSize}\n        stroke-dasharray={`0,${cellSize}`}\n        stroke-linecap=\"round\"\n      &gt;&lt;/line&gt;\n    &lt;/pattern&gt;\n  &lt;/defs&gt;\n  &lt;title&gt;A Dot Grid&lt;/title&gt;\n  &lt;rect\n    x=\"0\"\n    y=\"0\"\n    width={dotDocWidth}\n    height={dotDocHeight}\n    fill=\"url(#horizontal-dotted-line)\"\n  &gt;&lt;/rect&gt;\n&lt;/svg&gt;\n</code></pre>\n\n<p>And this is what that looks like:</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/eYwwNQM\">SVG Dot Grid [forked]</a> by <a href=\"https://codepen.io/mynimi\">Myriam</a>.</p>\nConclusion\n<p>This brings us to the end of our little introductory journey into SVG. As you can see, coding SVG by hand is not as scary as it seems. If you break it down into the basic elements, it becomes quite like any other coding task:</p>\n<ul>\n<li>We analyze the problem,</li>\n<li>Break it down into smaller parts,</li>\n<li>Examine each coordinate and its mathematical breakdown,</li>\n<li>And then put it all together.</li>\n</ul>\n<p>I hope that this article has given you a starting point into the wonderful world of coded images and that it gives you the motivation to delve deeper into the specs and try drawing some yourself.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"4741111168b38ed0be8c69aa687afc7dea762f551a9cb255e1f5ca45f5b7dd31","category":"Tech"}