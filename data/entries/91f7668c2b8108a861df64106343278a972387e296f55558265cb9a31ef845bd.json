{"title":"Tools And Practices To Speed Up The Vue.js Development Process","link":"https://smashingmagazine.com/2021/07/tools-practices-speed-up-vuejs-development-process/","date":1625742000000,"content":"<p>Throughout this tutorial, we will be looking at practices that should be adopted, things that should be avoided, and have a closer look at some helpful tools to make writing Vue.js easier. I’ll be focusing mostly on <a href=\"https://vuejs.org/v2/guide/\">Vue 2</a> as most folks and organizations still use the older version. No reason to worry though, as most things mentioned here still apply to <a href=\"https://v3.vuejs.org/guide/introduction.html\">Vue 3</a> since it’s just a supercharged and faster version. Still, if you already know Vue 2 and just want to learn about what’s new in Vue 3, then you can check out the <a href=\"https://v3.vuejs.org/guide/migration/introduction.html\">migration guide</a> to learn more.</p>\n<p><strong>Note:</strong> <em>This article is aimed at both beginners and seasoned developers who want to better their Vue.js skills. Basic knowledge of JavaScript and Vue.js will be of great benefit as you work your way throughout this tutorial.</em></p>\nModule-Based vs File-Based Project Structuring\n<p>Let’s start by looking at how to structure files by modules, how file-based structuring might not be a good idea when it comes to building projects of scale, and how to structure modules to fit in with business requirements.</p>\n<p>As we are newly creating a project with Vue.js CLI, we are getting the default file structure that has been mapped out by the Vue.js team. Using the proposed file structure is not a bad way of structuring your project per se, but as your project grows, you will need a better structure as your code becomes clustered and harder to navigate and access files.</p>\n<p>This is where the <strong>module-based method of structuring your project</strong> comes into play.</p>\n<p>A bad way of structuring your project will involve storing different data that is not related to the same folder, such as the notification component and the authentication component in the root component folder:</p>\n<pre><code>+-- src/\n|   +-- assets/\n|       +-- logo.png\n|       +-- userprofile.png\n|   +-- components\n|       +-- NotificationBar.vue\n|       +-- LoginForm.vue\n|       +-- DashboardInfo.vue\n|       +-- AuthenticationModal.vue\n|   +-- main.js</code></pre>\n\n<p>So what we want to do is decouple the project based on business logic and concerns so that we have something like authentication module, product module, service module, and so on. This way we can make sure that anything concerning that particular feature is put in the module, making our code neater and navigating not so hard.</p>\n<pre><code>+-- modules/\n|   +-- AuthModule/\n|       +-- assets/\n|           +-- userprofile.png\n|       +-- Components/\n|           +-- Authentication.vue\n|           +-- login.vue\n|   +-- NotificationModule\n|       +-- assets/\n|            +-- Alert.png\n|       +-- Components/\n|            +-- NotificationBar.vue\n|   +-- ProductModule/</code></pre>\n\n<h3>Organizing Modules</h3>\n<p>There are two ways you can organize your modules:</p>\n<ol>\n<li>Vue.js core modules,</li>\n<li>App feature modules.</li>\n</ol>\n<p>The Vue.js core modules are here to facilitate your Vue.js development. Modules like the service module containing all the network requests needed by the company are kept in this core module and all corresponding network requests are made from here.</p>\n<p>Modularizing your app according to features is a great way of making a better file structure in your app. This will allow separation of your concern and make sure that you are only working on the feature that you or your team is assigned to. Another advantage of modularizing according to feature is its maintainability and ability to avoid technical debt in the long term where there might need to be a rework on the app.</p>\n<p>Now whenever there is a need to add, remove or change the state of a particular feature, all we need to do is to navigate to that feature and make changes without breaking the app. This method of modularization allows for efficient program development and easy debugging and modification in our application.</p>\n<p>For example, a payout feature assigned to you and your team is a good time to implement a <code>payout</code> module that encapsulates all functionalities and data for the feature.</p>\n<pre><code>+-- modules/\n|   +-- payout/\n|       +-- index.js\n|       +-- assets/\n|       +-- Components/\n|            +-- PayOut.vue\n|            +-- UserInfo.vue\n|       +-- store/\n|            +-- index.js \n|            +-- actions.js\n|            +-- mutations.js          \n|       +-- Test/</code></pre>\n\n<p>Based on our payout feature above, we have an <code>index.js</code> file to import and use plugins associated only with the payout module. The asset folder houses all the assets (images and styles) for the module. Our component folder contains components related to the payout feature. The store folder contains our actions, mutations, and getters used to manage the state of this feature. There is also a test folder to carry out testing for this feature.</p>\nUsing Custom Directives\n<p>Directives in Vue.js are a way for us to tell Vue.js to do something or exhibit a certain behavior for us. Examples of directives are <code>v-if</code>, <code>v-model</code>, <code>v-for</code>, etc. In our Vue.js app, when we use something like v-model to tie data to an input in a form, we are giving the Vue.js code some certain instructions that are peculiar to Vue.js. But what if we want a particular action or behavior that our Vue.js provided directive doesn't allow us to do, what do we do then? We can create what we call custom directives.</p>\n<h3>Registering Custom Directives and Directives Hooks</h3>\n<p>We can go about registering directives in two ways:</p>\n<ol>\n<li><strong>Globally</strong><br />In our <code>main.js</code> file.</li>\n<li><strong>Locally</strong><br />In our component.</li>\n</ol>\n<p>Hooks in directives are like methods that fire when a certain action happens in our directives. Like the <strong>created</strong> and <strong>mounted</strong> hook life cycle hooks, we are provided with hooks to use in our directives.</p>\n<p>Let's say we are building an application and in one of our pages, we want the background color to always change each time we navigate to it. We are going to name this directive <code>colorChange</code>. We can achieve that with the help of a directive.</p>\n<p>Our template looks something like this:</p>\n<pre><code>&lt;template&gt;\n  &lt;div id=\"app\" v-color-change&gt;\n    &lt;HelloWorld msg=\"Hello Vue in CodeSandbox!\"/&gt;\n  &lt;/div&gt;\n&lt;/template&gt;</code></pre>\n\n<p>We can see the custom directive above, but to make it work, in our <code>main.js</code> file we add:</p>\n<div>\n<pre><code>\n// custom directive\nVue.directive(\"color-change\", {\n  bind: function (el) {\n    const random = Math.floor(Math.random() * 900000) + 100000;\n    el.style.backgroundColor = <code>#${random}</code>\n  }\n})</code></pre>\n</div>\n\n<p>The above Vue.js directive takes in the directive name as the first argument then an <code>Object</code> as the second argument that controls the behavior of the directives. <code>bind</code> is one of the hooks we talked about and will be called once the directive is bound to the element. It accepts the following arguments:</p>\n<ul>\n<li><code>el</code><br />This is the element node we have attached the directive to.</li>\n<li><code>binding</code><br />It contains helpful properties that change the behavior of the directive.</li>\n<li><code>vnode</code><br />This is the virtual node of Vue.js.</li>\n</ul>\n<p>We have created a random set of  6-digit numbers so that we can use it in changing the hex code of our background color style.</p>\n<h3>Best Practices When Writing Custom Directives</h3>\n<p>We have created a custom directive for the above, but we need to take note of a few things. Apart from <code>el</code>, never modify hook arguments and make sure the arguments are read-only because the hook arguments are objects with native methods that can cause side effects if modified. If necessary, use the Vue.js dataset to share information among hooks.</p>\n<p>If we are using the CLI build of Vue.js, custom directives should be in the <code>main.js</code> file so that all the <code>.vue</code> files can have access to it. Your directive name should be something that resonates with what that particular directive does, very descriptive about the directive functionality.</p>\n<p>You can see and play more with the code in <a href=\"https://codesandbox.io/s/boring-paper-ox1mg?file=/src/main.js:87-293\">this codesandbox</a> I have created. You can also <a href=\"https://vuejs.org/v2/guide/custom-directive.html\">read more about this in the Vue docs</a>.</p>\n\n\nControlling Updates\n<p>Vue.js reactivity system is powerful in a way that it detects things that need updating and updates them without you as the developer doing anything. For example, re-rendering a page each time we navigate to it. At times the case can be different as we might find ourselves writing code that requires us to force an update. </p>\n<p><strong>Note:</strong> <em>If you find yourself needing to force an update, which is a rare occasion, then you may need to really understand Vue's Reactivity and how to properly use props in communicating dynamic data.</em></p>\n<h3>Forcing An Update To Occur</h3>\n<p>In most cases, when the value in the vue data object changes, the view automatically re-renders, but it’s not always like this. a classic case of our view, not re-rendering is when we are using a <code>v-for</code> in our template to loop over some data in the data object, and we do not add a <code>:key</code> value in the <code>v-for</code> loop.</p>\n<pre><code>&lt;div v-for=\"item in itemsArray\" :key=\"item\"&gt;</code></pre>\n\n<p>This gives Vue.js a way to track each node's identity and re-render the view for any change.</p>\n<p>A rare situation that can cause us to force an update is if we intentionally or accidentally set an array item with the index.</p>\n<pre><code>var app = new Vue({\n  data: {\n    items: ['1', '2']\n  }\n})\napp.items[1] = '7' //vue does not notice any change</code></pre>\n\n<p>There are different ways to force an update or re-render. Some are very bad practices like the use of <code>v-if</code> to re-render the page when it's <code>true</code>, and when false, the component disappears and no longer exists. This is bad practice because the template is never destroyed but just hidden till it can be re-used.</p>\n<pre><code>&lt;template&gt;\n    &lt;div v-if=\"show\"&gt;\n       &lt;button @click=\"rerender\"&gt;re-render&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/template&gt;</code></pre>\n\n<pre><code>&lt;script&gt;\n  export default {\n    data() {\n      return {\n        show: true,\n      };\n    },\n    methods: {\n      rerender() {\n        this.show= false;\n        this.$nextTick(() =&gt; {\n            this.show = true;\n        });\n      }\n    }\n  };\n&lt;/script&gt;</code></pre>\n\n<p>In the code above, the state of <code>show</code> is initially set to true, meaning our component is initially rendered. Then, when we click on the button, the <code>rerender(</code>) function is called and the state of <code>show</code> is set to <code>false</code>, and the component is no longer rendered. On the next tick, which is a single DOM update cycle, <code>show</code> is set to <code>true</code> and our component is rendered again. This is a very hacky way of re-rendering.</p>\n<p>I would like to talk about two legit ways this can be  done:</p>\n<ol>\n<li>Vue’s <code>$forceUpdate</code>.</li>\n<li>Key changing pattern.</li>\n</ol>\n<p><strong>Vue’s <code>$forceUpdate</code>:</strong> In the use of <code>$forceUpdate</code>, the child components do not render, only the Vue.js instance, the instance, and child components with slots.</p>\n<p>Globally we can force the update:</p>\n<pre><code>import Vue from 'vue';\nVue.forceUpdate();</code></pre>\n\n<p>And locally too:</p>\n<pre><code>export default {\n  methods: {\n    methodThatForcesUpdate() {\n      this.$forceUpdate();\n    }\n  }\n}</code></pre>\n\n<p>Using the <strong>key changing pattern</strong> which is much better than the <code>$forceUpdate</code> method is another way to go about this. The reason behind the key changing pattern being better is that it allows Vue.js to know which component is tied to a specific data and when the key changes, it destroys the old component to create a new one, according to <a href=\"https://github.com/matthiasg\">matthiasg</a> on this <a href=\"https://github.com/vuejs/Discussion/issues/356#issuecomment-336060875\">Github issue</a> I ran into. You can use a <code>:key</code> attribute to let Vue.js know which component is attached to a specific piece of data. When the key changes, it causes Vue.js to destroy the old component and a new one is created.</p>\n<pre><code>&lt;template&gt;\n  &lt;Child\n    :key=\"key\"\n  /&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  export default {\n    data() {\n      return {\n        key: 0,\n      };\n    },\n    methods: {\n      forceRerender() {\n        this.key += 1;\n      }\n    }\n  }\n&lt;/script&gt;</code></pre>\n\n\n\nThird Party Libraries and Optimization\n<p>It is almost inevitable that we do not use third-party libraries in our apps. Third-party libraries can begin to be a problem if we turn a blind eye to it, increasing bundle size and slowing down our application.</p>\n<p>I recently used the Vuetify component library in a project and checked to see that the overall bundle size was a whooping 500kb minified. Things like this can become a bottleneck in our application. You can check the bundle size of your app by using <code>webpack-bundle-analyzer</code>. You can install it by running:</p>\n<pre><code>npm install --save-dev webpack-bundle-analyzer</code></pre>\n\n<p>and include it in your webpack config file:</p>\n<div>\n<pre><code>const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\nmodule.exports = {\n  plugins: [\n    new BundleAnalyzerPlugin()\n  ]\n}</code></pre>\n</div>\n\n<h3>Good Practices To Optimize Your Vue App</h3>\n<ul>\n<li>Our main bundle should only contain dependencies that are critical to our app, like <code>vue</code>, <code>vuex</code>. We should avoid putting libraries that are used in specific routes in our app in the main bundle.</li>\n<li>When using component libraries, you can import individual components from the libraries, instead of importing everything. For example, vuetify:</li>\n</ul>\n<pre><code>&lt;template&gt;\n  &lt;v-app&gt;\n    &lt;v-navigation-drawer app&gt;\n    &lt;!-- --&gt;\n  &lt;/v-navigation-drawer&gt;\n  &lt;v-app-bar app&gt;\n    &lt;!-- --&gt;\n  &lt;/v-app-bar&gt;\n &lt;/v-app&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport { VApp, VNavigationDrawer, VAppBar } from 'vuetify/lib'\n\nexport default {\n  components: {\n    VApp,\n    VNavigationDrawer,\n    VAppBar,\n  }\n}\n&lt;/script&gt;</code></pre>\n\n<p>By doing the above we have reduced the bundle size and redundant code, only using the components we want to use in that particular route.</p>\nMaking Early Decisions to Use Vuex\n<p>Often I have found myself wondering if I should start up a project with Vuex. Sometimes I just want to start a small side project and I start it up without Vuex to manage my state and communication using props begins to get messy.</p>\n<p>So when should we use Vuex? To answer this, we need to consider:</p>\n<ul>\n<li>Size of the project,</li>\n<li>The simplicity of the code,</li>\n<li>Routing,</li>\n<li>Dataset involved,</li>\n<li>Components nesting.</li>\n</ul>\n<p>If your app begins to grow, it's only appropriate to include Vuex to manage the state in your application. If you're ever in doubt if you should use a state manager when starting your project, then just use it. However, <a href=\"https://vuejsdevelopers.com/2020/10/05/composition-api-vuex/\">there is a talk</a> of the new Vue3 composition API being a replacement for vuex.</p>\n<h3>How Vuex Should Be Set Up for Large Applications</h3>\n<p>We have four components in the vuex store:</p>\n<ul>\n<li><strong>State</strong>: Store data in our store.</li>\n<li><strong>Getters</strong>: Retrieve state data.</li>\n<li><strong>Mutations</strong>: Used to mutate state data.</li>\n<li><strong>Action</strong>: Used to commit mutations.</li>\n</ul>\n<p>When we use the above in Vuex we should keep in mind that actions should always commit mutations no matter what. This allows our <a href=\"https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=en\">devtools</a> to be able to track changes and revert to a particular period in our state and asynchronous operations or business logic should be carried out in the actions.</p>\n<p>You can create a separate file for each of the Vuex components to look like this:</p>\n<pre><code>├── services\n├── main.js\n└── store\n    ├── index.js          \n    ├── actions.js\n    ├── mutations.js\n    └── Getters.js\n├── components</code></pre>\n\n<h3>Moduling According To Feature</h3>\n<p>If our project is a very large project with a team, we can modularize our store according to app features. This is done especially when there are complex and large projects with many files and folders and we just want an organized way of handling the structuring of our app. We have to be careful the way we go about this, if not we can do more harm than good. A simple store modularized according to the feature looks like this:</p>\n<pre><code>store/\n   ├── index.js \n   └── modules/\n       ├── cart\n           ├── index.js          \n           ├── actions.js\n           ├── mutations.js       \n       ├── product.js\n       ├── login.js</code></pre>\n\n<h3>Good Practice When Using Vuex Modules</h3>\n<p>As the modules we have created become more complicated, it becomes harder to manually import and organize. It is advised that your modules have an <code>index.js</code> file at the root of your module, bringing the files altogether.</p>\n<p>Make sure you have a standard naming pattern in your store as this will increase maintainability. You can use camelCase for naming the modules then a <code>.store.js</code> extension. Example: <code>CartData.store.js</code>.</p>\n<pre><code>modules/\n       ├── cart.js\n           ├── index.js   -&gt; auto export module       \n           ├── userProduct.store.js\n           ├── userData.store.js</code></pre>\n\n<p>Code related to business logic or async code should not run inside mutations because of its blocking behavior, instead, actions should be used. It is considered best practice not to directly access a state object. Instead, use the getter function because it can be mapped into any vue component using the <code>mapGetters</code> behaving like a computed property with the getters result cached based on its dependencies. Also, make sure each module is namespaced and not to access them using the global state scope.</p>\nUsing the Provide/Inject Method To Pass Data Around\n<p>Think of an app that has different components. We have the parent component and the parent component has many child components. From the image below, we see our Child component A, B, and D as top components, then we see Component E nested in component D and component F nested in component E. What if we have app data (like User Address), that we want to use in child Component A, C, and F, and this User address data is in our parent component.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2249dc06-8600-4526-a68d-668bf8953ffa/2-tools-practices-speed-up-vuejs-development-process.jpeg\" /></p>\n<p>To do this, we need to:</p>\n<ul>\n<li>Provide value in the parent component (Dependency provider).</li>\n<li>Inject the value in component F (dependency consumer).</li>\n</ul>\n<p>In our parent component we provide the data:</p>\n<pre><code>app.component('parent-component', {\n  data() {\n    return {\n      user: {name:\"Uma Victor\", address:\"No 33 Rumukwurushi\"}\n    }\n  },\n  provide() {\n    return {\n     userAddress: this.user.address\n    }\n  },\n  template: `\n    ...\n  `\n})</code></pre>\n\n<p>We use <code>provide</code> as a function by returning an object to access component instance properties.</p>\n<p>In our <code>child-f</code> component, we have the following:</p>\n<pre><code>app.component('child-f', {\n  inject: ['userAddress'],\n  template: `\n    &lt;h2&gt;Injected property: {{ this.userAddress }}&lt;/h2&gt;\n  `\n})</code></pre>\n\n<p>However, we noticed that if we change our <code>user.address</code> to another address, the change won't be reflected in our injected value, this is because the data provided to the provide/inject are not reactive initially. We can fix this by passing a <code>reactive</code> object to <code>provide</code>. We have to assign a computed property to our user object.</p>\n<pre><code>app.component('parent-component', {\n  data() {\n    return {\n      user: {name:\"Uma Victor\", address:\"No 33 Rumukwurushi\"}\n    }\n  },\n  provide() {\n    return {\n     userAddress: Vue.computed(() =&gt; this.user)\n\n    }\n  },\n  template: `\n    ...\n  `\n})</code></pre>\n\n<p>This pattern can be very useful and simpler than using Vuex.</p>\n<p><em>However, with</em> <em>Vue3, and the recent upgrade, we can now use context providers, enabling us to share data between multiple components just like vuex.</em></p>\nProper Use of Props for Form Components\n<p>Building forms on the web is one of those things not everyone loves doing. Vue.js makes building excellent forms easy. To achieve this we need to know how to properly use props in our form components. In a traditional app where we have signup, logins, or product page we want to have consistent behavior and design. For example, the sign-in page below.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f1223a43-84cd-400d-bab7-632bff185ea7/3-tools-practices-speed-up-vuejs-development-process.png\" /></p>\n<p>With the code:</p>\n<pre><code>&lt;template&gt;\n  &lt;div class=\"form-group\"&gt;\n  &lt;form&gt;\n    &lt;label for=\"email\"&gt;Your Name&lt;/label&gt;\n    &lt;input\n      type=\"text\"\n      id=\"name\"\n      class=\"form-control\"\n      placeholder=\"name\"\n      v-model=\"userData.name\"\n    /&gt;\n    &lt;label for=\"email\"&gt;Your Email Address&lt;/label&gt;\n    &lt;input\n      type=\"text\"\n      id=\"email\"\n      class=\"form-control\"\n      placeholder=\"Email\"\n      v-model=\"userData.email\"\n    /&gt;\n    &lt;label for=\"email\"&gt;Your Password&lt;/label&gt;\n    &lt;input\n      type=\"text\"\n      id=\"password\"\n      class=\"form-control\"\n      placeholder=\"password\"\n      v-model=\"userData.password\"\n    /&gt;\n  &lt;/form&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n    export default {\n        data() {\n            return {\n                userData: {\n                    name: '',\n                    email: '',\n                    password: ''\n                }\n            }\n        },\n    }\n&lt;/script&gt;</code></pre>\n\n<p>We will like to have a <code>BaseInput</code> component that we can use for the three form inputs above. Our <code>BaseInput</code> looks like this:</p>\n<div>\n<pre><code>&lt;template&gt;\n &lt;div&gt;\n   &lt;label v-if=\"label\"&gt;{{ label }}&lt;/label&gt;\n   &lt;input type=\"email\" @value=\"value\" @input=\"updateInput\" v-bind=\"$attrs\"&gt;\n &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n    export default {\n      props: {\n        label: {\n          type: String,\n          default: \"\"\n        },\n        value: [String, Number]\n      },\n      methods: {\n        updateInput(event) {\n          this.$emit('input', event.target.value)\n        }\n      }\n    }\n&lt;/script&gt;</code></pre>\n</div>\n\n<p>We want our <code>BaseInput</code> to accept a <code>label</code> prop which is always a string, and if the Input has a label, we show it in our template as we can see above.</p>\n<p>When we fill the form, the <code>updateInput</code> method is triggered. The <code>updateInput</code> method takes the input event as an argument and it emits an event with the name of Input, along with the payload <code>event.target.value</code> which is the name (John Doe) in the form:</p>\n<div>\n<pre><code>&lt;BaseInput label=\"Your Name\" v-model=\"userData.name\" placeholder=\"Name\"/&gt;</code></pre>\n</div>\n\n<p>The <code>v-model</code> will be listening for the input event and then when it gets it, it sets our <code>userData.name</code> to the payload it got.</p>\n<p>If we want to set a placeholder for an input, we might experience an error, this is because in vue2 attributes always attach themselves to the parent, so to fix this we set <code>inheritAttrs</code> to <code>false</code> and bind <code>attrs</code>.</p>\n<pre><code>&lt;script&gt;\n    export default {\n      inheritAttrs: false,\n      props: {\n        label: {\n          type: String,\n          default: \"\"\n        },\n        value: [String, Number]\n      },\n      methods: {\n        updateInput(event) {\n          this.$emit('input', event.target.value)\n        }\n      }\n    }\n&lt;/script&gt;</code></pre>\n\n<p>To where we want the placeholder attribute to be. Our form page code looks like this now:</p>\n<div>\n<pre><code>&lt;template&gt;\n  &lt;div class=\"form-group\"&gt;\n    &lt;form&gt;\n      &lt;BaseInput label=\"Your Name\" v-model=\"userData.name\" placeholder=\"Name\"/&gt;\n      &lt;BaseInput label=\"Your Email Address\" v-model=\"userData.email\" placeholder=\"Email\"/&gt;\n      &lt;BaseInput label=\"Your Password\" v-model=\"userData.password\" placeholder=\"Password\"/&gt;\n    &lt;/form&gt;\n  &lt;/div&gt;\n&lt;/template&gt;</code></pre>\n</div>\n\n<p>We finally have a standalone reusable form component. You can play with the code in the <a href=\"https://codesandbox.io/s/sharp-euclid-szjkw?file=/src/main.js\">codesandbox I made</a>.</p>\n<p><strong>Note:</strong> <em><code>$Attrs</code> in Vue3 now includes all of your listeners, style bindings, and classes.</em></p>\nGetting Familiar With Vue Devtools\n<p>Vue.js Devtools is a very powerful tool as it helps us effectively debug our application in real-time. It is most powerful when we use Vuex and we have to manage mutations and track changes in our app. Most Vue.js developers use devtools as an <a href=\"https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd\">extension</a>, but we can also install it as a standalone app.</p>\n<p><strong>Note:</strong> <em>The Vue.js devtools only work in the development mode of your build and won't work in production so other people can't use it to inspect your app.</em></p>\n<h3>Installing Devtools As a Standalone App</h3>\n<p>You might be wondering why we would want to install a standalone app for devtools when we can use the browser extension for it? It is because when you install it as a standalone app locally, you can use it from any browser. </p>\n<p>We install it:</p>\n<pre><code>// Globally\nnpm install -g @vue/devtools\n// or locally\nnpm install --save-dev @vue/devtools</code></pre>\n\n<p>Once it's done installing, run:</p>\n<pre><code>vue-devtools</code></pre>\n\n<p>Then in our <code>index.html</code> file, located in the public folder in the root of our Vue.js application we add:</p>\n<pre><code>&lt;script src=\"http://localhost:8098\"&gt;&lt;/script&gt;</code></pre>\n\n<p>Once your app is reloaded, it will automatically connect.</p>\n<h3>Some Operations We Can Do With Vue Devtools</h3>\n<p>Here are some helpful operations you can do on Vue.js DevTools.</p>\n<ul>\n<li><strong>Dark Theme</strong><br />In the new DevTools, there is now an option to set between light, dark, or contrast themes. You can do this by going to your global settings and selecting it.</li>\n</ul>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c110e351-1608-419e-93e7-7c402d58b084/1-tools-practices-speed-up-vuejs-development-process.png\" /></p>\n<ul>\n<li><strong>Timeline</strong><br />The new timeline in the devtools displays information about events that occur and it's arranged in chronological order. It is located next to the inspector and settings view.</li>\n</ul>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/504f4566-f345-44cc-8cd0-79cd323d0d7e/4-tools-practices-speed-up-vuejs-development-process.png\" /></p>\n<ul>\n<li><strong>Format component name</strong><br />You can choose to display your component name in either camelCase or kebab-case.</li>\n</ul>\n<p>There are many other operations that you can utilize in the vue devtools. You can check out their <a href=\"https://headwayapp.co/vue-js-devtools-changelog\">changelog</a>.</p>\nTools to Make Work In Vue Easier\n<p>When working with Vuejs, we might encounter some features we would love to implement, but it might take a lot of time to hard code or just a little bit difficult to implement. As professional developers, we add certain tools and helper libraries to make things easier and we would be looking at some of them.</p>\n<h3>Testing libraries</h3>\n<p>Testing can play a crucial role when building large-scale applications. It helps us to avoid unnecessary bugs during development when working with a team. Let's look at the three types of testing we can carry out in our Vue application and their frameworks.</p>\n<ul>\n<li><strong>Component Testing</strong><br /><a href=\"https://testing-library.com/docs/vue-testing-library/intro\">Vue Testing Library</a>, <a href=\"https://vue-test-utils.vuejs.org/\">Vue Test Utils</a>.</li>\n<li><strong>Unit testing</strong><br /><a href=\"https://jestjs.io/\">Jest</a>, <a href=\"https://mochajs.org/\">Mocha</a>.</li>\n<li><strong>End to End Tests</strong><br /><a href=\"https://nightwatchjs.org/\">Nightwatch.js</a>, <a href=\"https://www.cypress.io/\">Cypress</a>.</li>\n</ul>\n<h3>Component Libraries</h3>\n<p>A component library is a set of reusable components we can use in our application to make UI development much faster and more consistent in our application. Like React and Angular, Vue has its own set of component libraries. Some of them include:</p>\n<ul>\n<li><a href=\"https://www.codeinwp.com/go/creative-tim-vue-material-kit/\">Vue Material Kit</a><br />A \"Badass\" Vue.js UI kit built upon material design. It contains more than 60+ handcrafted components.</li>\n<li><a href=\"https://buefy.org/\">Buefy</a><br />A lightweight component library based on the Bulma CSS framework. If you are comfortable with SASS, you will have no problem using it.</li>\n<li><a href=\"https://vuetifyjs.com/en/\">Vuetify</a><br />This is also a material design component framework with the availability of already made scaffolding for code, with a large community and regular updates</li>\n<li><a href=\"https://quasar-framework.org/\">Quasar</a><br />My personal favorite, when it comes to the component framework. Quasar with its high performant frontend stack allows you to build cross-platform applications for Web, Mobile, and Desktop.  </li>\n</ul>\n<h3>Other Interesting Libraries</h3>\n<p>Other note worthy libraries are:</p>\n<ul>\n<li><a href=\"https://pqina.nl/filepond\">FilePond</a><br />This Vue.js library uploads any image you give it and optimizes those images with a silky-smooth experience.</li>\n<li><a href=\"https://monterail.github.io/vuelidate/\">Vuelidate</a><br />This library is very important when working with forms and you need a way to validate user inputs on the frontend. It is a simple and lightweight Model-based validation.</li>\n<li><a href=\"https://www.npmjs.com/package/vue-clickaway\">vue-Clickaway</a><br />Vue doesn't have a native event listener to know when a user has clicked outside an element, for example, a dropdown, that's why <code>vue-clickaway</code> exists to detect click events.</li>\n</ul>\n<p><em>There are many more libraries out there. You can check out a plethora of them on</em> <a href=\"https://madewithvuejs.com/\"><em>madewithvuejs.com</em></a> <em>and</em> <a href=\"https://vuejsexamples.com/\"><em>vuejsexamples.com</em></a>.</p>\n<h3>Helpful Extensions To Help You In Writing Vue</h3>\n<p>Extensions are really helpful tools, which can make a big difference in your daily productivity when writing vuejs. During the time I have spent writing Vuejs code, I have found the following extensions Very helpful:</p>\n<ul>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=octref.vetur\">Vetur</a><br />This is the number one extension on my list. Saving me hours when writing Vuejs. It provides specific highlighting, snippets, Intellisense, debugging, and much more for Vue.js.</li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=alefragnani.Bookmarks\">Bookmarks</a><br />This extension comes in very handy when working on a large project because you can mark and set a bookmark in places in your code and jump to that specific place when you want to.</li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint\">Eslint</a><br />Eslint helps us to easily find coding errors by throwing a warning if we do something wrong in the code. It is advisable to use it in a prettier format.</li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=mubaidr.vuejs-extension-pack\">Vue.js Extension Pack</a><br />This extension pack contains a collection of other extensions that will help in your Vue.js development like Prettier, Vetur, Night Owl, Etc.</li>\n</ul>\nConclusion\n<p>In this tutorial, we have looked at some tips and tools to help you become a better Vue developer. We started with some helpful insights on organizing our projects for scale and other great points to note and we rounded it up with Tools and extensions that make writing Vuejs so much easier.  </p>\n<p>Keep in mind that most of what is learned in this article is centered on Vue.js 2, to avoid misunderstandings.</p>\n<h3>Further Resources</h3>\n<p>Here are some useful links you can check out if you want to dive deeper into some of the things we discussed above.</p>\n<ul>\n<li>“<a href=\"https://vuejs.org/v2/guide/custom-directive.html\">Custom Directives</a>,” Official Docs</li>\n<li>“<a href=\"https://vuejs.org/v2/guide/reactivity.html\">Vue’s Reactivity</a>,” Official Docs</li>\n<li>“<a href=\"https://devtools.vuejs.org/\">Vue Devtools</a>,” website</li>\n<li><a href=\"https://vuejsdevelopers.com/2020/10/05/composition-api-vuex/\">Talk on Composition API vs Vuex</a></li>\n<li><a href=\"https://www.smashingmagazine.com/2020/10/useful-tools-vue-javascript-web-development/\">Useful tools vue javascript development</a> by Timi Omoyeni</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"91f7668c2b8108a861df64106343278a972387e296f55558265cb9a31ef845bd","category":"Tech"}