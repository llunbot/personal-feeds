{"title":"Wall of Text: Rx is Functional operator over time","link":"https://blog.whs.in.th/node/3749","date":1737463813000,"content":"<p>น้องถามว่าเรียนอะไรดีตอนนี้ที่จะพัฒนาฝีมือ ก็เลยแนะนำว่าให้เขียน Rust ดู หรือไม่ก็ไปเขียน Frontend อื่นบ้างที่ไม่ใช่ React เช่น Android ก็ดีจะได้เปิดมุมมองใหม่ๆ</p>\n<p>ตอนไปเขียน Android ก็พบว่าตอนนี้มันมี API ใหม่คือ Jetpack Compose ซึ่งมันลอก React มา แต่ว่า state ของมันที่ React ใช้ <code>useState</code> มันยังมี hook ให้อีก 3 ท่า คือ RxJava, Flow และ LiveData</p>\n<p>ซึ่ง Kotlin Flow นี่มันก็คือ Rx นี่แหละ พอไปเขียนแล้วรู้สึกว่ามันว้าวมากๆ เพราะใน JavaScript เราจะไม่นิยมใช้ RxJS เท่าไรนัก บางคนก็จะรู้สึกว่ามันเป็นของทฤษฎีที่ไม่มีคนใช้ แต่ใน Android แล้ว Flow กลายเป็นท่าพื้นฐานที่นำข้อมูลจากภายนอก view เข้าไปใน view เลย</p>\n<h2>Time</h2>\n<p>ข้อสังเกตหนึ่งที่เพิ่งนึกออกคือ <strong>จริงๆ แล้ว Flow หรือ Rx มันคือ functional operator แต่ทำงานบนแกนเวลา</strong> ซึ่งฟังดูเข้าใจยาก แต่จะลองเทียบกันให้ดู</p>\n<p>Rx ปกติแล้วจะใช้ในงาน event driven หรือ observable เช่นเมื่อคลิกที่ปุ่มให้ส่งข้อความ click เข้าไปใน Flow หรือ Rx Stream</p>\n<p>ถ้าหากเราบอกว่าให้นับคลิกสองครั้งเท่านั้น ก็อาจจะต้อง flow ประมาณนี้</p>\n<pre><code>var n = 0\nclickStream.filter { ++n % 2 == 0 }\n</code></pre>\n<p>อีกโจทย์หนึ่งถ้าเรามี array อยู่แล้วเราบอกว่าต้องการสมาชิกตัวเว้นตัว ก็เขียน loop ประมาณนี้ได้ถ้าใช้สไตล์ functional</p>\n<pre><code>[0, 1, 2, 3].filter((_, i) =&gt; i % 2 === 0)\n</code></pre>\n<p>จะสังเกตว่าจริงๆ แล้วทั้ง Rx และ array โค้ดมันเขียนเหมือนกันเลย และคำสั่ง filter ก็ทำงานเหมือนกัน แตกต่างกันแค่ว่าแบบ array เรามีข้อมูลทั้งหมดอยู่ในมือแล้ว แต่แบบ Rx เราไม่มีข้อมูลอะไรอยู่ในมือเลย เพราะเราไม่รู้ว่าเคยมีการคลิกกี่ครั้งในอดีตที่ผ่านมา และในอนาคตจะมีการคลิกกี่ครั้ง</p>\n<figure><img src=\"https://blog.whs.in.th/wp-content/uploads/2025/01/filter1-300x127.png\" alt=\"\" width=\"300\" height=\"127\" srcset=\"https://blog.whs.in.th/wp-content/uploads/2025/01/filter1-300x127.png 300w, https://blog.whs.in.th/wp-content/uploads/2025/01/filter1-1024x432.png 1024w, https://blog.whs.in.th/wp-content/uploads/2025/01/filter1-768x324.png 768w, https://blog.whs.in.th/wp-content/uploads/2025/01/filter1-1200x506.png 1200w, https://blog.whs.in.th/wp-content/uploads/2025/01/filter1.png 1280w\" /><figcaption>Rx Filter (from RxJS docs)</figcaption></figure>\n<h2>Spacetime</h2>\n<p>คำถามถัดมาคือถ้าเรามีการ chain operator ต่อกันจะเกิดอะไรขึ้น เช่น JavaScript code นี้</p>\n<pre><code>[0, 1, 2, 3].filter((v) =&gt; v &gt; 0).map((v) =&gt; v * 2)\n</code></pre>\n<p>ถ้าดูจาก return type ของ filter, map ก็คงพอเดาได้ว่ามันจะมี array 3 ตัว คือ</p>\n<ul>\n<li>Input: <code>[0, 1, 2, 3]</code></li>\n<li>ชั่วคราว: <code>[1, 2, 3]</code></li>\n<li>Output: <code>[2, 4, 6]</code></li>\n</ul>\n<p>ซึ่งทำให้มันมี overhead มากกว่า loop ธรรมดาพอสมควรเพราะมีการ copy value เกิดขึ้น</p>\n<p>ในภาษา Rust จะยึดหลัก zero cost abstraction ในภาษา Rust ทำแบบนี้ได้</p>\n<pre><code>vec![0, 1, 2, 3].iter().filter(|v| v &gt; 0).map(|v| v * 2).collect&lt;Vec&lt;i32&gt;&gt;()\n</code></pre>\n<p>มันดูเหมือนว่าโค้ดใช้ท่าเดียวกับ JavaScript ยกเว้นตรง collect <strong>แต่โค้ดนี้เวลา compile release build แล้วผลไม่ต่างกับเขียน loop เอง</strong> นั่นคือ มันไม่มี vector/array ชั่วคราวใดๆ จนกระทั่งถึงตรงที่เราสั่ง collect เท่านั้นที่จะสร้าง array</p>\n<pre><code>let mut out = Vec::default();\nfor mut v in [0, 1, 2, 3] {\n    if v &gt; 0 {\n        out.push(v * 2)\n    }\n}\n</code></pre>\n<p>ที่มันทำแบบนี้ได้ก็เพราะว่า Iterator ใน Rust เป็น Rx!</p>\n<p>เราจะมองว่าคำสั่ง <code>iter</code> คือตัว<strong>เปลี่ยนจาก space เป็น time</strong> ก็ได้ คือมันอ่านค่าจาก vector ออกมาทีละ 1 ค่า แล้วส่งเข้าไปใน Rx stream ที่มีการยำข้อมูลกันภายใน</p>\n<p>และสุดท้ายคำสั่ง <code>collect</code> คือตัว<strong>เปลี่ยนกลับจาก time เป็น space</strong> คือมันสร้าง array เปล่าขึ้นมาในพื้นที่หน่วยความจำ จากนั้นพอได้รับค่าจาก Rx stream ก็เอาไปใส่ใน array จนกระทั่ง stream ปิด</p>\n<p>จะสังเกตว่าการใช้ Rx นั้นลำดับการทำงานมันจะทำ filter, map, collect, filter, map, collect สลับกันไปเพราะไม่มีการพักข้อมูล</p>\n<p>ข้อเสียของวิธีนี้ก็คือในกรณีของ JavaScript เราจะพอเดาได้ว่าคำสั่ง filter นั้น output จะมีขนาดเท่าไร (ถ้า array มี 10 ตัว output จะมี 0-10 ตัว) หรือคำสั่ง map (ถ้า array มี 10 ตัว output จะมี 10 ตัวเสมอ) ทำให้จองหน่วยความจำไว้ล่วงหน้าได้ แต่ Rx เราจะไม่รู้ว่าต้องจองหน่วยความจำเท่าไรทำให้ช้า ซึ่งใน Rust ก็จะมีเมธอด size_hint() เพื่อเป็น side channel ในการส่งข้อมูลนี้ แต่ถ้าเป็นเคสอื่นๆ ที่ไม่ทั่วไปอาจจะต้องใช้ท่าอื่นๆ เช่น ผสม Rx stream เข้าด้วยกัน (zip)</p>\n<p>อีกปัญหาหนึ่งคือเราไม่สามารถตัด stream กลางคันได้ เช่น process 1, 2, 3 แล้วเอาผลลัพท์ของ 3 ไปต่อเป็น 3.1 3.2 3.3 ทำพร้อมๆ กัน เพราะว่าความเร็วของ 3.1 3.2 3.3 อาจไม่เท่ากัน หรือ data type นั้นอาจจะ clone ไปหลายที่ไม่ได้ ถ้าจะทำแบบนี้ก็จะต้องมี operator พิเศษเข้ามาที่อาจจะต้องมี buffer space พักข้อมูลไว้ด้วย หรือบางทีก็ใช้ <code>collect</code> ธรรมดาไปเลยนี่แหละ</p>\n<h2>Rx operator is hard</h2>\n<p>ผมคิดว่าปัญหาจริงๆ ของการเรียน Rx คือมันไม่มี escape hatch ที่ง่ายสักเท่าไรนัก ถ้าเทียบกับว่าถ้าคุณไม่เข้าใจ functional programming คุณก็ใช้ loop ธรรมดาแทนได้ แต่ loop over time หรือที่เรียกว่า generator/coroutine นั้นไม่ค่อยเป็นที่นิยมหรือเรียนกันเท่าไร ภาษาโปรแกรมมิ่งมักจะเอาไปซ่อน ดังนั้นหลายคนก็เลยจะเลี่ยงไม่เอาของเข้ามาเป็น Rx</p>\n<p>ในขณะเดียวกัน คนที่เขียนโค้ดหลายๆ ทีก็อาจจะไม่ได้ใช้ functional programming ขั้นสูง เช่น คำสั่ง partition, zip, chunk, concat แล้วบางทีก็ไปใช้วิธี loop เอาแทน แต่พอเป็น Rx มันไม่มีทางหนีแบบนี้ กลายเป็นว่าคนก็จะกลัวว่า Rx เป็นวิทยาการขั้นสูง ใช้ลำบาก</p>\n<p>แต่พอมาใช้งานจริงๆ แล้วก็รู้สึกว่า Rx มันมีประโยชน์มากเลยนะ เพราะการไป implement operator เหล่านั้นเองก็ยุ่งยากเหมือนกันและทำให้โค้ดอ่านยากไม่เข้าใจว่ามันต้องการทำอะไร</p>\n<h2>Real world use case with Rx</h2>\n<p>จากที่เคยทำงานมา Rx ที่ได้เอาไปใช้งานจริงจะมีอยู่ก็คือ</p>\n<ol>\n<li>Frontend state management อย่างที่เล่าไปว่า Jetpack Compose ใน Android จะใช้ Kotlin flow เป็นหลัก</li>\n<li>Parallel code คือโค้ดที่ประมวลผลข้อมูลหลาย core และบางส่วนเป็น I/O bound บางส่วนเป็น CPU bound เราก็ตัดให้มันเป็น map() ในแต่ละ step ไปและพอทำเสร็จแล้วให้เขียนออกมาที่ Rx กลาง ผลสุดท้ายคือโค้ดบนสุดมันจะกลายเป็น chain แล้วเข้าใจการทำงานง่าย เช่น <code>readFileNameStream().map(readFile).map(parseFile).map(printOutput)</code> (แต่ต้องทำให้มันเป็น unordered ด้วย)</li>\n<li>Iterator ปกติใน Rust ถ้าเขียนเป็นก็คือใช้ Rx อยู่แล้ว</li>\n</ol>\n<p>นอกจากนี้ API ใน Node ที่เป็น Stream (เช่น Gulp build) ก็ใช้มุมมองคล้ายๆ Rx เพียงแต่ว่าไม่ได้ใช้คำศัพท์หรือ operator แบบ Rx เท่านั้นเอง และไม่ได้การันตีลำดับของข้อมูล</p>","author":"whs","siteTitle":"Quietly Verbose","siteHash":"5f972a6fe70a917eb1b1aa165b3cb2be8a9465af33ab38bf05f34c55c0e40587","entryHash":"6d438ece8dcb1270a684d00136e17cfc1e79689b1fed1a926099d5a7f2b9fce1","category":"Thai"}