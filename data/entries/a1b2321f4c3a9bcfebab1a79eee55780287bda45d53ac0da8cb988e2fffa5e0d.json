{"title":"Automate AWS deployments with HCP Terraform and GitHub Actions","link":"https://www.hashicorp.com/blog/automate-aws-deployments-with-hcp-terraform-and-github-actions","date":1725879600000,"content":"<p><em>Saravanan Gnanaguru is a <a href=\"https://www.hashicorp.com/ambassador\">HashiCorp Ambassador</a></em></p>\n\n<p>Using GitHub Actions with HashiCorp Terraform to automate infrastructure as code workflows directly from version control is a popular early path for many developer teams. However, this setup can make it difficult to stop configuration drift as your infrastructure codebase grows. </p>\n\n<p>Rather than running Terraform on the GitHub Actions instance runner, it’s much easier and safer to run configurations remotely via HCP Terraform. This ensures that the creation, modification, and deletion of Terraform resources is handled on a managed cloud platform rather than on the GitHub Actions runner. HCP Terraform has many more systems and safeguards for team Terraform management and <a href=\"https://www.hashicorp.com/resources/how-can-i-prevent-configuration-drift\">drift prevention</a>.</p>\n\n<p>This post shows how to use HCP Terraform to define AWS infrastructure and GitHub Actions to automate infrastructure changes. You’ll learn how to set up a GitHub Actions workflow that interacts with HCP Terraform to automate the deployment of AWS infrastructure, such as Amazon EC2 instances.</p>\n\n<h2>Workflow overview</h2>\n\n<p>For this tutorial you can use your own Terraform configuration in a GitHub repository, or use this <a href=\"https://github.com/chefgs/terraform_repo/tree/main/tfcloud_samples\">example repository</a>. The example repository’s GitHub Actions include a workflow that creates the AWS resources defined in the repository. Whenever the repository trigger event happens on the main branch, it runs the workflow defined in the <code>.github/workflows</code> directory. It then performs the infrastructure creation or management in AWS. The figure below outlines the interaction between the GitHub repository, Actions, HCP Terraform, and AWS.</p>\n<img src=\"https://www.datocms-assets.com/2885/1725634943-hcptf-gh-actions.png\" alt=\"HCP\" /><p>Here’s how to implement this workflow.</p>\n\n<h2>Prerequisites</h2>\n\n<p>Ensure you have the following:</p>\n\n<ul>\n<li>An AWS account with necessary permissions to create resources.</li>\n<li>A HCP Terraform account, with a workspace set up for this tutorial.</li>\n<li>A GitHub account, with a repository for Terraform configuration files.</li>\n<li>The Terraform CLI installed on your local machine for testing purposes.</li>\n</ul>\n\n<p>Follow the following steps below to add AWS credentials in the HCP Terraform workspace and the <code>TF_API_TOKEN</code> in GitHub Actions secrets.</p>\n\n<h2>Securely access AWS from HCP Terraform</h2>\n\n<p>HCP Terraform’s <a href=\"https://developer.hashicorp.com/terraform/cloud-docs/workspaces/dynamic-provider-credentials\">dynamic provider credentials</a> allow Terraform runs to <a href=\"https://docs.aws.amazon.com/sdkref/latest/guide/access-assume-role.html#credOrSourceAssumeRole\">assume</a> an IAM role through native OpenID Connect (OIDC) integration and obtain temporary security credentials for each run. These AWS credentials allow you to call AWS APIs that the IAM role has access to at runtime. These credentials are usable for only one hour by default, so their usefulness to an attacker is limited.</p>\n\n<p>For more on how to securely access AWS from HCP Terraform with OIDC federation, check out the <a href=\"https://www.hashicorp.com/blog/access-aws-from-hcp-terraform-with-oidc-federation\">Access AWS from HCP Terraform with OIDC federation</a> blog.</p>\n\n<h2>Add HCP Terraform token to GitHub Actions</h2>\n\n<p>Fetch the <code>TF_API_TOKEN</code> by following <a href=\"https://developer.hashicorp.com/terraform/cloud-docs/users-teams-organizations/api-tokens\">instructions available in the HCP Terraform documentation</a>. This example creates a user API token for the GitHub Action workflow.</p>\n\n<p>Open the GitHub repository with the Terraform configuration.</p>\n\n<p>Click on \"Settings\" in the repository menu. From the left sidebar, select \"Secrets\" and then choose \"Actions\".</p>\n\n<p>To add a new repository secret, click on \"New repository secret\". Name the secret <code>TF_API_TOKEN</code> and add the HCP Terraform API token to the “Value” field. Click \"Add secret\" to save the new secret.</p>\n<img src=\"https://www.datocms-assets.com/2885/1725634973-tf_api_token-secret.png\" alt=\"Naming\" /><p>By following these steps, you will securely provide your AWS credentials to HCP Terraform and also provide the HCP Terraform API token to GitHub Actions, enabling automated infrastructure deployment through a GitHub Actions workflow.</p>\n\n<h2>Create the GitHub Actions workflow</h2>\n\n<p>After setting up the credentials, add a GitHub Actions workflow to your repository. The example repository uses a <a href=\"https://github.com/chefgs/terraform_repo/blob/main/.github/workflows/tf_cloud_aws.yml\">workflow</a> YAML file defining one job with four steps to initialize, plan, apply, and destroy Terraform. This workflow uses the <a href=\"https://github.com/hashicorp/setup-terraform\">HashiCorp official marketplace actions</a> for performing the Terraform command operations.</p>\n<pre><code># This workflow will create AWS resource using HCP Terraform\n# It is reusable workflow that can be called in other workflows\n\nname: AWS Infra Creation Using in HCP Terraform\n\non:\n workflow_call:\n   secrets:\n       TF_API_TOKEN:\n           required: true\n push:\n   branches: [ \"main\" ]\n pull_request:\n   branches: [ \"main\" ]\n workflow_dispatch:\n\nenv:\n tfcode_path: tfcloud_samples/amazon_ec2\n tfc_organisation: demo-tf-org # Replace it with your TFC Org\n tfc_hostname: app.terraform.io\n tfc_workspace: demo-tf-workspace # Replace it with your TFC Workspace\n\njobs:\n aws_tfc_job:\n   name: Create AWS Infra Using TFC\n\n   runs-on: ubuntu-latest\n\n   steps:\n   - name: Checkout tf code in runner environment\n     uses: actions/checkout@v3.5.2\n\n   # Configure HCP Terraform API token, since we are using remote backend option of HCP Terraform in AWS code\n   - name: Setup Terraform CLI\n     uses: hashicorp/setup-terraform@v2.0.2\n     with:\n       cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}\n\n   # Add the AWS Creds as ENV variable in HCP Terraform workspace, since the tf run happens in HCP Terraform environment\n\n   # Invoke the Terraform commands\n   - name: Terraform init and validate\n     run: |\n       echo `pwd`\n       echo \"** Running Terraform Init**\"\n       terraform init\n        \n       echo \"** Running Terraform Validate**\"\n       terraform validate\n     working-directory: ${{ env.tfcode_path }}\n\n   - name: Terraform Plan\n     uses: hashicorp/tfc-workflows-github/actions/create-run@v1.3.0\n     id: run\n     with:\n       workspace: ${{ env.tfc_workspace }}\n       plan_only: true\n       message: \"Plan Run from GitHub Actions\"\n       ## Can specify hostname,token,organization as direct inputs\n       hostname: ${{ env.tfc_hostname }}\n       token: ${{ secrets.TF_API_TOKEN }}\n       organization: ${{ env.tfc_organisation }}\n\n   - name: Terraform Plan Output\n     uses: hashicorp/tfc-workflows-github/actions/plan-output@v1.3.0\n     id: plan-output\n     with:\n       hostname: ${{ env.tfc_hostname }}\n       token: ${{ secrets.TF_API_TOKEN }}\n       organization: ${{ env.tfc_organisation }}\n       plan: ${{ steps.run.outputs.plan_id }}\n  \n   - name: Reference Plan Output\n     run: |\n       echo \"Plan status: ${{ steps.plan-output.outputs.plan_status }}\"\n       echo \"Resources to Add: ${{ steps.plan-output.outputs.add }}\"\n       echo \"Resources to Change: ${{ steps.plan-output.outputs.change }}\"\n       echo \"Resources to Destroy: ${{ steps.plan-output.outputs.destroy }}\"\n\n # Once the user verifies the Terraform Plan, the user can run the Terraform Apply and Destroy commands\n apply_terraform_plan:\n     needs: aws_tfc_job\n     if: github.event_name == 'workflow_dispatch'\n     runs-on: ubuntu-latest\n     steps:\n     - name: Checkout\n       uses: actions/checkout@v3.5.2\n     - name: Setup Terraform CLI\n       uses: hashicorp/setup-terraform@v2.0.2\n       with:\n         cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}\n\n     # Invoke the Terraform commands\n     - name: Terraform init and validate\n       run: |\n         echo `pwd`\n         echo \"** Running Terraform Init**\"\n         terraform init\n      \n         echo \"** Running Terraform Validate**\"\n         terraform validate\n       working-directory: ${{ env.tfcode_path }}\n    \n     - name: Terraform Apply\n       run: echo \"** Running Terraform Apply**\"; terraform apply -auto-approve\n       working-directory: ${{ env.tfcode_path }}\n      - name: Terraform Destroy\n       run: echo \"** Running Terraform Destroy**\"; terraform destroy -auto-approve\n       working-directory: ${{ env.tfcode_path }}</code></pre><p>Let’s review each section of the workflow.</p>\n\n<h3>Define the triggers</h3>\n\n<p>When you push commits or open a pull request on the <code>main</code> branch, the workflow initializes, plans, and applies Terraform. This workflow can be triggered by a:</p>\n\n<ul>\n<li><code>workflow_call</code>: This allows the workflow to be reused in other workflows. It requires the <code>TF_API_TOKEN</code> secret.</li>\n<li><code>push</code>: Triggers the workflow when there is a push to the <code>main</code> branch.</li>\n<li><code>pull_request</code>: Triggers the workflow when a pull request is made to the <code>main</code> branch.</li>\n<li><code>workflow_dispatch</code>: Allows the GitHub Actions interface to manually trigger the workflow.</li>\n</ul>\n<pre><code># This workflow will create AWS resource using HCP Terraform\n# It is reusable workflow that can be called in other workflows\n\nname: AWS Infra Creation Using in HCP Terraform\n\non:\n workflow_call:\n   secrets:\n       TF_API_TOKEN:\n           required: true\n push:\n   branches: [ \"main\" ]\n pull_request:\n   branches: [ \"main\" ]\n workflow_dispatch:</code></pre><h3>Configure environment variables</h3>\n\n<p>Set the <code>tfcode_path</code> environment variable to specify the location of your Terraform configuration files within the repository. Include the HCP Terraform organization, workspace, and hostname for future jobs.</p>\n<pre><code>env:\n tfcode_path: tfcloud_samples/amazon_ec2 # Directory in which the tf files are stored\n tfc_organisation: demo-tf-org # Replace it with your HCP Terraform Org\n tfc_hostname: app.terraform.io\n tfc_workspace: demo-tf-workspace # Replace it with your HCP Terraform Workspace</code></pre><h3>Define jobs</h3>\n\n<p>In the GitHub Actions workflow, define each automation step inside the <code>jobs</code> block. The job consists of job name and workflow runner instance definition in the <code>runs-on</code> block. This workflow uses the <code>ubuntu-latest</code> instance runner.</p>\n\n<p>The first step in the <code>apply_terraform_plan</code> is the <code>actions/checkout</code> entry, which clones the repository into the GitHub Actions runner. This makes the Terraform configuration files available for subsequent steps.</p>\n<pre><code>jobs:\n aws_tfc_job:\n   name: Create AWS Infra Using HCPTF\n\n   runs-on: ubuntu-latest\n\n   steps:\n   - name: Checkout tf code in runner environment\n     uses: actions/checkout@v3.5.2</code></pre><p>In the second step, use the <code>hashicorp/setup-terraform</code> pre-built action to configure the Terraform CLI in the runner environment. It sets up the HCP Terraform API token (<code>TF_API_TOKEN</code>) for authentication. This token allows the Terraform CLI to communicate with HCP Terraform, enabling it to manage state, perform operations, and apply configurations in the context of the HCP Terraform workspace.</p>\n<pre><code>    - name: Setup Terraform CLI\n      uses: hashicorp/setup-terraform@v2.0.2\n      with:\n        cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}</code></pre><p>Next, initialize and validate Terraform. <code>terraform init</code> initializes the Terraform working directory by downloading necessary providers and initializing backends. If you’re using HCP Terraform as the backend, this command configures the workspace and prepares it for operations. </p>\n\n<p><code>terraform validate</code> checks the syntax and validity of the Terraform files, ensuring they are correctly formatted and logically sound. These commands run inside the working directory defined by <code>env.tfcode_path</code>, which contains the Terraform configuration.</p>\n<pre><code>    - name: Terraform init and validate\n      run: |\n        echo `pwd`\n        echo \"** Running Terraform Init**\"\n        terraform init\n          \n        echo \"** Running Terraform Validate**\"\n        terraform validate\n      working-directory: ${{ env.tfcode_path }}</code></pre><p>In general, you will want to review the<code>terraform plan</code> before applying to verify the changes Terraform will make. Use the <code>hashicorp/tfc-workflows-github/actions/create-run</code> action to run a plan in HCP Terraform and export the plan using the <code>plan_only</code> attribute. Then, use the <code>hashicorp/tfc-workflows-github/actions/plan-output</code> action to get the output of the Terraform plan using the <code>plan_id</code> from the previous step's output. Finally, print the plan status and resource changes in the workflow’s output.</p>\n<pre><code>   - name: Terraform Plan\n     uses: hashicorp/tfc-workflows-github/actions/create-run@v1.3.0\n     id: run\n     with:\n       workspace: ${{ env.tfc_workspace }}\n       plan_only: true\n       message: \"Plan Run from GitHub Actions\"\n       hostname: ${{ env.tfc_hostname }}\n       token: ${{ secrets.TF_API_TOKEN }}\n       organization: ${{ env.tfc_organisation }}\n\n   - name: Terraform Plan Output\n     uses: hashicorp/tfc-workflows-github/actions/plan-output@v1.3.0\n     id: plan-output\n     with:\n       hostname: ${{ env.tfc_hostname }}\n       token: ${{ secrets.TF_API_TOKEN }}\n       organization: ${{ env.tfc_organisation }}\n       plan: ${{ steps.run.outputs.plan_id }}\n  \n   - name: Reference Plan Output\n     run: |\n       echo \"Plan status: ${{ steps.plan-output.outputs.plan_status }}\"\n       echo \"Resources to Add: ${{ steps.plan-output.outputs.add }}\"\n       echo \"Resources to Change: ${{ steps.plan-output.outputs.change }}\"\n       echo \"Resources to Destroy: ${{ steps.plan-output.outputs.destroy }}\"</code></pre><p>The workflow outputs the plan status and any resources to add, change, or destroy in its log.</p>\n<img src=\"https://www.datocms-assets.com/2885/1725635607-tf-plan-reference-review.png\" alt=\"Workflow\" /><p>If the plan does not reflect the correct changes, fix the Terraform configuration to achieve the expected output. After verifying the plan in the previous job, manually trigger the workflow to run <code>terraform apply</code>. This command starts a run in the HCP Terraform workspace, where the actual infrastructure changes are made.</p>\n<pre><code> apply_terraform_plan:\n     needs: aws_tfc_job\n     if: github.event_name == 'workflow_dispatch'\n     runs-on: ubuntu-latest\n     steps:\n     - name: Checkout\n       uses: actions/checkout@v3.5.2\n     - name: Setup Terraform CLI\n       uses: hashicorp/setup-terraform@v2.0.2\n       with:\n         cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}\n\n     # Invoke the Terraform commands\n     - name: Terraform init and validate\n       run: |\n         echo `pwd`\n         echo \"** Running Terraform Init**\"\n         terraform init\n      \n         echo \"** Running Terraform Validate**\"\n         terraform validate\n       working-directory: ${{ env.tfcode_path }}\n    \n     - name: Terraform Apply\n       run: echo \"** Running Terraform Apply**\"; terraform apply -auto-approve\n       working-directory: ${{ env.tfcode_path }}</code></pre><img src=\"https://www.datocms-assets.com/2885/1725635689-apply-terraform-after-review.png\" alt=\"Apply\" /><p>Optionally, you can add a <code>terraform destroy</code> step to clean up resources and avoid unnecessary costs. You can add this step in non-production or testing environments.</p>\n<pre><code>    - name: Terraform Destroy\n      run: |\n        echo \"** Running Terraform Destroy**\"\n        terraform destroy -auto-approve\n      working-directory: ${{ env.tfcode_path }}</code></pre><h2>Setup review and further learning</h2>\n\n<p>This setup leverages the strengths of both platforms: GitHub Actions for CI/CD automation and HCP Terraform for secure, collaborative infrastructure management. Integrating HCP Terraform with GitHub Actions provides a powerful, automated pipeline for deploying and managing AWS infrastructure. By leveraging these tools, teams can achieve more reliable and efficient infrastructure management, reduce manual errors, and ensure consistency across environments. </p>\n\n<p>HCP Terraform facilitates collaboration among team members ensuring that infrastructure changes are managed safely and efficiently. Platform teams can audit the runs in HCP Terraform while development teams can review runs in GitHub Actions.</p>\n\n<p>From a security perspective, HCP Terraform workspaces can be configured with environment variables, such as AWS credentials, or <a href=\"https://developer.hashicorp.com/terraform/tutorials/cloud/dynamic-credentials\">dynamic credentials</a>. The GitHub Actions workflow does not directly handle the credentials, which minimizes the blast radius of compromised credentials through the workflow. HCP Terraform provides additional features like access controls, private module registry, and policy enforcement to ensure that infrastructure changes are secure and compliant with organizational policies. </p>\n\n<p>This guide has walked you through setting up a basic workflow, but the flexibility of both platforms allows for customization to fit your specific needs.</p>\n\n<p>For further questions on best practices, please refer to the GitHub Actions and HCP Terraform FAQs <a href=\"https://github.com/chefgs/terraform_repo/blob/main/tfcloud_samples/TFC_Workflow_BestPracticesFAQs.md\">available in this repository</a>. As mentioned before, this repository includes the full code example used in this post. For more information on GitHub Actions, review GitHub’s <a href=\"https://docs.github.com/en/actions\">documentation</a>. To learn more about automating Terraform with GitHub Actions, review the <a href=\"https://developer.hashicorp.com/terraform/tutorials/automation/github-actions\">official tutorial</a> on the HashiCorp Developer portal and the <a href=\"https://github.com/hashicorp/tfc-workflows-github/tree/main/actions\">starter workflow templates</a> to use HCP Terraform with GitHub Actions.</p>\n\n<p>For alternatives to this workflow, you can also use HCP Vault Secrets to sync the <code>TF_API_TOKEN</code> <a href=\"https://developer.hashicorp.com/hcp/docs/vault-secrets/integrations/github-actions\">to the GitHub Actions secrets</a>. With this method, you only need to update the token in one place, rather than every GitHub repo. HashiCorp also has <a href=\"https://www.hashicorp.com/blog/hashicorp-releases-new-ci-cd-pipeline-integration-tool-templates-for-terraform\">integration templates for HCP Terraform and GitHub Actions</a> that you should check out.</p>\n","author":"Saravanan Gnanaguru","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"a1b2321f4c3a9bcfebab1a79eee55780287bda45d53ac0da8cb988e2fffa5e0d","category":"Tech"}