{"title":"New for AWS Distro for OpenTelemetry – Tracing Support is Now Generally Available","link":"https://aws.amazon.com/blogs/aws/new-for-aws-distro-for-opentelemetry-tracing-support-is-now-generally-available/","date":1632411341000,"content":"<p>Last year before <a href=\"https://reinvent.awsevents.com/\">re:Invent</a>, we <a href=\"https://aws.amazon.com/blogs/aws/public-preview-aws-distro-open-telemetry/\">introduced the public preview</a> of <a href=\"https://aws.amazon.com/otel/\">AWS Distro for OpenTelemetry</a>, a secure distribution of the <a href=\"https://opentelemetry.io/\">OpenTelemetry project</a> supported by AWS. OpenTelemetry provides tools, APIs, and SDKs to instrument, generate, collect, and export telemetry data to better understand the behavior and the performance of your applications. Yesterday, upstream OpenTelemetry <a href=\"https://medium.com/opentelemetry/opentelemetry-collector-achieves-tracing-stability-milestone-80e34cadbbf5\">announced tracing stability milestone for its components</a>. Today, I am happy to share that <strong>support for traces is now generally available in AWS Distro for OpenTelemetry</strong>.</p> \n<p>Using OpenTelemetry, you can <strong>instrument your applications just once</strong> and then send traces to multiple monitoring solutions.</p> \n<p>You can use AWS Distro for OpenTelemetry to instrument your applications running on <a href=\"https://aws.amazon.com/ec2/\">Amazon Elastic Compute Cloud (Amazon EC2)</a>, <a href=\"https://aws.amazon.com/ecs/\">Amazon Elastic Container Service (Amazon ECS)</a>, <a href=\"https://aws.amazon.com/eks/\">Amazon Elastic Kubernetes Service (EKS)</a>, and <a href=\"https://aws.amazon.com/lambda/\">AWS Lambda</a>, as well as on premises. Containers running on <a href=\"https://aws.amazon.com/fargate/\">AWS Fargate</a> and orchestrated via either ECS or EKS are also supported.</p> \n<p>You can send tracing data collected by AWS Distro for OpenTelemetry to <a href=\"https://aws.amazon.com/x-ray/\">AWS X-Ray</a>, as well as <a href=\"https://aws.amazon.com/otel/partners/\">partner destinations</a> such as:</p> \n<ul> \n <li><a href=\"https://www.appdynamics.com/\">AppDynamics</a>, <a href=\"https://www.dynatrace.com/\">Dynatrace</a>, <a href=\"https://grafana.com/\">Grafana</a>, <a href=\"https://www.honeycomb.io/\">Honeycomb</a>, <a href=\"https://lightstep.com/\">Lightstep</a>, <a href=\"https://newrelic.com/\">NewRelic</a>, and <a href=\"https://www.sumologic.com/\">SumoLogic</a> – which support OpenTelemetry Protocol (OTLP) exporters natively.</li> \n <li><a href=\"https://www.datadoghq.com/\">Datadog</a>, <a href=\"https://logz.io/\">Logz.io</a>, <a href=\"https://www.splunk.com/\">Splunk</a> – which have their own exporters.</li> \n</ul> \n<p>You can use <strong>auto-instrumentation</strong> agents to collect traces without changing your code. Auto-instrumentation is available today for Java and Python applications. Auto-instrumentation support for Python currently only covers the AWS SDK. You can instrument your applications using other programming languages (such as Go, Node.js, and .NET) with the OpenTelemetry SDKs.</p> \n<p>Let’s see how this works in practice for a Java application.</p> \n<p><span><strong>Visualizing Traces for a Java Application Using Auto-Instrumentation</strong></span><br /> I create a simple Java application that shows the list of my <a href=\"https://aws.amazon.com/s3/\">Amazon Simple Storage Service (Amazon S3)</a> buckets and my <a href=\"https://aws.amazon.com/dynamodb/\">Amazon DynamoDB</a> tables:</p> \n<pre><code>package com.example.myapp;\n\nimport software.amazon.awssdk.regions.Region;\nimport software.amazon.awssdk.services.s3.S3Client;\nimport software.amazon.awssdk.services.s3.model.*;\nimport software.amazon.awssdk.services.dynamodb.model.DynamoDbException;\nimport software.amazon.awssdk.services.dynamodb.model.ListTablesResponse;\nimport software.amazon.awssdk.services.dynamodb.model.ListTablesRequest;\nimport software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n\nimport java.util.List;\n\n/**\n * Hello world!\n *\n */\npublic class App {\n\n    public static void listAllTables(DynamoDbClient ddb) {\n\n        System.out.println(\"DynamoDB Tables:\");\n\n        boolean moreTables = true;\n        String lastName = null;\n\n        while (moreTables) {\n            try {\n                ListTablesResponse response = null;\n                if (lastName == null) {\n                    ListTablesRequest request = ListTablesRequest.builder().build();\n                    response = ddb.listTables(request);\n                } else {\n                    ListTablesRequest request = ListTablesRequest.builder().exclusiveStartTableName(lastName).build();\n                    response = ddb.listTables(request);\n                }\n\n                List&lt;String&gt; tableNames = response.tableNames();\n\n                if (tableNames.size() &gt; 0) {\n                    for (String curName : tableNames) {\n                        System.out.format(\"* %s\\n\", curName);\n                    }\n                } else {\n                    System.out.println(\"No tables found!\");\n                    System.exit(0);\n                }\n\n                lastName = response.lastEvaluatedTableName();\n                if (lastName == null) {\n                    moreTables = false;\n                }\n            } catch (DynamoDbException e) {\n                System.err.println(e.getMessage());\n                System.exit(1);\n            }\n        }\n\n        System.out.println(\"Done!\\n\");\n    }\n\n    public static void listAllBuckets(S3Client s3) {\n\n        System.out.println(\"S3 Buckets:\");\n\n        ListBucketsRequest listBucketsRequest = ListBucketsRequest.builder().build();\n        ListBucketsResponse listBucketsResponse = s3.listBuckets(listBucketsRequest);\n        listBucketsResponse.buckets().stream().forEach(x -&gt; System.out.format(\"* %s\\n\", x.name()));\n\n        System.out.println(\"Done!\\n\");\n    }\n\n    public static void listAllBucketsAndTables(S3Client s3, DynamoDbClient ddb) {\n        listAllBuckets(s3);\n        listAllTables(ddb);\n    }\n\n    public static void main(String[] args) {\n\n        Region region = Region.EU_WEST_1;\n\n        S3Client s3 = S3Client.builder().region(region).build();\n        DynamoDbClient ddb = DynamoDbClient.builder().region(region).build();\n\n        listAllBucketsAndTables(s3, ddb);\n\n        s3.close();\n        ddb.close();\n    }\n}</code></pre> \n<p>I package the application using <a href=\"https://maven.apache.org/\">Apache Maven</a>. Here’s the <a href=\"https://maven.apache.org/pom.html#what-is-the-pom\">Project Object Model (POM)</a> file managing dependencies such as the <a href=\"https://aws.amazon.com/sdk-for-java/\">AWS SDK for Java</a> 2.x that I use to interact with S3 and DynamoDB:</p> \n<pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt;\n  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n  &lt;properties&gt;\n    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n  &lt;/properties&gt;\n  &lt;groupId&gt;com.example.myapp&lt;/groupId&gt;\n  &lt;artifactId&gt;myapp&lt;/artifactId&gt;\n  &lt;packaging&gt;jar&lt;/packaging&gt;\n  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n  &lt;name&gt;myapp&lt;/name&gt;\n  &lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n      &lt;dependency&gt;\n        &lt;groupId&gt;software.amazon.awssdk&lt;/groupId&gt;\n        &lt;artifactId&gt;bom&lt;/artifactId&gt;\n        &lt;version&gt;2.17.38&lt;/version&gt;\n        &lt;type&gt;pom&lt;/type&gt;\n        &lt;scope&gt;import&lt;/scope&gt;\n      &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n  &lt;/dependencyManagement&gt;\n  &lt;dependencies&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;junit&lt;/groupId&gt;\n      &lt;artifactId&gt;junit&lt;/artifactId&gt;\n      &lt;version&gt;3.8.1&lt;/version&gt;\n      &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;software.amazon.awssdk&lt;/groupId&gt;\n      &lt;artifactId&gt;s3&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;software.amazon.awssdk&lt;/groupId&gt;\n      &lt;artifactId&gt;dynamodb&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n  &lt;/dependencies&gt;\n  &lt;build&gt;\n    &lt;plugins&gt;\n      &lt;plugin&gt;\n        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n        &lt;version&gt;3.8.1&lt;/version&gt;\n        &lt;configuration&gt;\n          &lt;source&gt;8&lt;/source&gt;\n          &lt;target&gt;8&lt;/target&gt;\n        &lt;/configuration&gt;\n      &lt;/plugin&gt;\n      &lt;plugin&gt;\n        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;\n        &lt;configuration&gt;\n          &lt;archive&gt;\n            &lt;manifest&gt;\n              &lt;mainClass&gt;com.example.myapp.App&lt;/mainClass&gt;\n            &lt;/manifest&gt;\n          &lt;/archive&gt;\n          &lt;descriptorRefs&gt;\n            &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;\n          &lt;/descriptorRefs&gt;\n        &lt;/configuration&gt;\n      &lt;/plugin&gt;\n    &lt;/plugins&gt;\n  &lt;/build&gt;\n&lt;/project&gt;</code></pre> \n<p>I use Maven to create an executable <a href=\"https://en.wikipedia.org/wiki/JAR_(file_format)\">Java Archive (JAR)</a> file that includes all dependencies:</p> \n<div> \n <pre><code>$ mvn clean compile assembly:single</code></pre> \n</div> \n<p>To run the application and get tracing data, I need two components:</p> \n<ul> \n <li>The <a href=\"https://github.com/aws-observability/aws-otel-java-instrumentation\">AWS Distro for OpenTelemetry Auto-Instrumentation Agent for Java</a>, a Java agent that can be attached to any Java 8+ application to capture telemetry from a number of popular libraries and frameworks, including the AWS SDK.</li> \n <li>The <a href=\"https://github.com/aws-observability/aws-otel-collector\">AWS Distro for OpenTelemetry Collector</a>, an executable that can receive, process, and export telemetry data to monitoring destinations.</li> \n</ul> \n<p>In one terminal, I run the AWS Distro for OpenTelemetry Collector using <a href=\"https://www.docker.com/\">Docker</a>:</p> \n<div> \n <pre><code>$ docker run --rm -p 4317:4317 -p 55680:55680 -p 8889:8888 \\\n         -e AWS_REGION=eu-west-1 \\\n         -e AWS_PROFILE=default \\\n         -v ~/.aws:/root/.aws \\\n         --name awscollector public.ecr.aws/aws-observability/aws-otel-collector:latest</code></pre> \n</div> \n<p>The collector is now ready to receive traces and forward them to a monitoring platform. By default, the AWS Distro for OpenTelemetry Collector sends traces to AWS X-Ray. I can change the exporter or add more exporters by editing the collector configuration. For example, I can follow the documentation to <a href=\"https://aws-otel.github.io/docs/components/otlp-exporter\">configure OLTP exporters</a> to send telemetry data using the OLTP protocol. In the documentation, I also find how to configure other partner destinations.</p> \n<p>I <a href=\"https://github.com/aws-observability/aws-otel-java-instrumentation/releases/\">download the latest version</a> of the AWS Distro for OpenTelemetry Auto-Instrumentation Java Agent. Now, I run my application and use the agent to capture telemetry data without having to add any specific instrumentation the code. In the <code>OTEL_RESOURCE_ATTRIBUTES</code> environment variable I set a name and a namespace for the service:</p> \n<div> \n <pre><code>$ OTEL_RESOURCE_ATTRIBUTES=service.name=MyApp,service.namespace=MyTeam \\\n  java -javaagent:otel/aws-opentelemetry-agent.jar \\\n       -jar myapp/target/myapp-1.0-SNAPSHOT-jar-with-dependencies.jar</code></pre> \n</div> \n<p>As expected, I get the list of my S3 buckets globally and of the DynamoDB tables in the Region.</p> \n<p>To generate more tracing data, I run the previous command a few times. Each time I run the application, telemetry data is collected by the agent and sent to the collector. The collector buffers the data and then sends it to the configured exporters. By default, it is sending traces to X-Ray.</p> \n<p>Now, I look at the service map in the <a href=\"https://console.aws.amazon.com/xray/home\">AWS X-Ray console</a> to see my application’s interactions with other services:</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/09/13/aws-otel-service-map.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/09/13/aws-otel-service-map-1024x587.png\" /></a></p> \n<p>And there they are! Without any change in the code, I see my application’s calls to the S3 and DynamoDB APIs. There were no errors, and all the circles are green. Inside the circles, I find the average latency of the invocations and the number of transactions per minute.</p> \n<p><span><strong>Adding Spans to a Java Application</strong></span><br /> The information automatically collected can be improved by providing more information with the traces. For example, I might have interactions with the same service in different parts of my application, and it would be useful to separate those interactions in the service map. In this way, if there is an error or high latency, I would know which part of my application is affected.</p> \n<p>One way to do so is to use spans or segments. A span represents a group of logically related activities. For example, the <code>listAllBucketsAndTables</code> method is performing two operations, one with S3 and one with DynamoDB. I’d like to group them together in a span. The quickest way with OpenTelemetry is to add the <code>@WithSpan</code> annotation to the method. Because the result of a method usually depends on its arguments, I also use the <code>@SpanAttribute</code> annotation to describe which arguments in the method invocation should be automatically added as attributes to the span.</p> \n<pre><code>@WithSpan\n    public static void listAllBucketsAndTables(@SpanAttribute(\"title\") String title, S3Client s3, DynamoDbClient ddb) {\n\n        System.out.println(title);\n\n        listAllBuckets(s3);\n        listAllTables(ddb);\n    }</code></pre> \n<p>To be able to use the <code>@WithSpan</code> and <code>@SpanAttribute</code> annotations, I need to import them into the code and add the necessary OpenTelemetry dependencies to the POM. All these changes are based on the OpenTelemetry specifications and don’t depend on the actual implementation that I am using, or on the tool that I will use to visualize or analyze the telemetry data. I have only to make these changes once to instrument my application. Isn’t that great?</p> \n<p>To better see how spans work, I create another method that is running the same operations in reverse order, first listing the DynamoDB tables, then the S3 buckets:</p> \n<pre><code>    @WithSpan\n    public static void listTablesFirstAndThenBuckets(@SpanAttribute(\"title\") String title, S3Client s3, DynamoDbClient ddb) {\n\n        System.out.println(title);\n\n        listAllTables(ddb);\n        listAllBuckets(s3);\n    }\n</code></pre> \n<p>The application is now running the two methods (<code>listAllBucketsAndTables</code> and <code>listTablesFirstAndThenBuckets</code>) one after the other. For simplicity, here’s the full code of the instrumented application:</p> \n<pre><code>package com.example.myapp;\n\nimport software.amazon.awssdk.regions.Region;\nimport software.amazon.awssdk.services.s3.S3Client;\nimport software.amazon.awssdk.services.s3.model.*;\nimport software.amazon.awssdk.services.dynamodb.model.DynamoDbException;\nimport software.amazon.awssdk.services.dynamodb.model.ListTablesResponse;\nimport software.amazon.awssdk.services.dynamodb.model.ListTablesRequest;\nimport software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n\nimport java.util.List;\n\nimport io.opentelemetry.extension.annotations.SpanAttribute;\nimport io.opentelemetry.extension.annotations.WithSpan;\n\n/**\n * Hello world!\n *\n */\npublic class App {\n\n    public static void listAllTables(DynamoDbClient ddb) {\n\n        System.out.println(\"DynamoDB Tables:\");\n\n        boolean moreTables = true;\n        String lastName = null;\n\n        while (moreTables) {\n            try {\n                ListTablesResponse response = null;\n                if (lastName == null) {\n                    ListTablesRequest request = ListTablesRequest.builder().build();\n                    response = ddb.listTables(request);\n                } else {\n                    ListTablesRequest request = ListTablesRequest.builder().exclusiveStartTableName(lastName).build();\n                    response = ddb.listTables(request);\n                }\n\n                List&lt;String&gt; tableNames = response.tableNames();\n\n                if (tableNames.size() &gt; 0) {\n                    for (String curName : tableNames) {\n                        System.out.format(\"* %s\\n\", curName);\n                    }\n                } else {\n                    System.out.println(\"No tables found!\");\n                    System.exit(0);\n                }\n\n                lastName = response.lastEvaluatedTableName();\n                if (lastName == null) {\n                    moreTables = false;\n                }\n            } catch (DynamoDbException e) {\n                System.err.println(e.getMessage());\n                System.exit(1);\n            }\n        }\n\n        System.out.println(\"Done!\\n\");\n    }\n\n    public static void listAllBuckets(S3Client s3) {\n\n        System.out.println(\"S3 Buckets:\");\n\n        ListBucketsRequest listBucketsRequest = ListBucketsRequest.builder().build();\n        ListBucketsResponse listBucketsResponse = s3.listBuckets(listBucketsRequest);\n        listBucketsResponse.buckets().stream().forEach(x -&gt; System.out.format(\"* %s\\n\", x.name()));\n\n        System.out.println(\"Done!\\n\");\n    }\n\n    @WithSpan\n    public static void listAllBucketsAndTables(@SpanAttribute(\"title\") String title, S3Client s3, DynamoDbClient ddb) {\n\n        System.out.println(title);\n\n        listAllBuckets(s3);\n        listAllTables(ddb);\n\n    }\n\n    @WithSpan\n    public static void listTablesFirstAndThenBuckets(@SpanAttribute(\"title\") String title, S3Client s3, DynamoDbClient ddb) {\n\n        System.out.println(title);\n\n        listAllTables(ddb);\n        listAllBuckets(s3);\n\n    }\n\n    public static void main(String[] args) {\n\n        Region region = Region.EU_WEST_1;\n\n        S3Client s3 = S3Client.builder().region(region).build();\n        DynamoDbClient ddb = DynamoDbClient.builder().region(region).build();\n\n        listAllBucketsAndTables(\"My S3 buckets and DynamoDB tables\", s3, ddb);\n        listTablesFirstAndThenBuckets(\"My DynamoDB tables first and then S3 bucket\", s3, ddb);\n\n        s3.close();\n        ddb.close();\n    }\n}</code></pre> \n<p>And here’s the updated POM that includes the additional OpenTelemetry dependencies:</p> \n<pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt;\n  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n  &lt;properties&gt;\n    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n  &lt;/properties&gt;\n  &lt;groupId&gt;com.example.myapp&lt;/groupId&gt;\n  &lt;artifactId&gt;myapp&lt;/artifactId&gt;\n  &lt;packaging&gt;jar&lt;/packaging&gt;\n  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n  &lt;name&gt;myapp&lt;/name&gt;\n  &lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n      &lt;dependency&gt;\n        &lt;groupId&gt;software.amazon.awssdk&lt;/groupId&gt;\n        &lt;artifactId&gt;bom&lt;/artifactId&gt;\n        &lt;version&gt;2.16.60&lt;/version&gt;\n        &lt;type&gt;pom&lt;/type&gt;\n        &lt;scope&gt;import&lt;/scope&gt;\n      &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n  &lt;/dependencyManagement&gt;\n  &lt;dependencies&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;junit&lt;/groupId&gt;\n      &lt;artifactId&gt;junit&lt;/artifactId&gt;\n      &lt;version&gt;3.8.1&lt;/version&gt;\n      &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;software.amazon.awssdk&lt;/groupId&gt;\n      &lt;artifactId&gt;s3&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;software.amazon.awssdk&lt;/groupId&gt;\n      &lt;artifactId&gt;dynamodb&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;io.opentelemetry&lt;/groupId&gt;\n      &lt;artifactId&gt;opentelemetry-extension-annotations&lt;/artifactId&gt;\n      &lt;version&gt;1.5.0&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;io.opentelemetry&lt;/groupId&gt;\n      &lt;artifactId&gt;opentelemetry-api&lt;/artifactId&gt;\n      &lt;version&gt;1.5.0&lt;/version&gt;\n    &lt;/dependency&gt;\n  &lt;/dependencies&gt;\n  &lt;build&gt;\n    &lt;plugins&gt;\n      &lt;plugin&gt;\n        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n        &lt;version&gt;3.8.1&lt;/version&gt;\n        &lt;configuration&gt;\n          &lt;source&gt;8&lt;/source&gt;\n          &lt;target&gt;8&lt;/target&gt;\n        &lt;/configuration&gt;\n      &lt;/plugin&gt;\n      &lt;plugin&gt;\n        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;\n        &lt;configuration&gt;\n          &lt;archive&gt;\n            &lt;manifest&gt;\n              &lt;mainClass&gt;com.example.myapp.App&lt;/mainClass&gt;\n            &lt;/manifest&gt;\n          &lt;/archive&gt;\n          &lt;descriptorRefs&gt;\n            &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;\n          &lt;/descriptorRefs&gt;\n        &lt;/configuration&gt;\n      &lt;/plugin&gt;\n    &lt;/plugins&gt;\n  &lt;/build&gt;\n&lt;/project&gt;</code></pre> \n<p>I compile my application with these changes and run it again a few times:</p> \n<div> \n <pre><code>$ mvn clean compile assembly:single\n\n$ OTEL_RESOURCE_ATTRIBUTES=service.name=MyApp,service.namespace=MyTeam \\\n  java -javaagent:otel/aws-opentelemetry-agent.jar \\\n       -jar myapp/target/myapp-1.0-SNAPSHOT-jar-with-dependencies.jar</code></pre> \n</div> \n<p>Now, let’s look at the X-Ray service map, computed using the additional information provided by those annotations.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/09/13/aws-otel-annotations.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/09/13/aws-otel-annotations-1024x586.png\" /></a></p> \n<p>Now I see the two methods and the other services they invoke. If there are errors or high latency, I can easily understand how the two methods are affected.</p> \n<p>In the <strong>Traces</strong> section of the X-Ray console, I look at the <strong>Raw data</strong> for some of the traces. Because the <code>title</code> argument was annotated with <code>@SpanAttribute</code>, each trace has the value of that argument in the <code>metadata</code> section.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/09/13/aws-otel-metadata.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/09/13/aws-otel-metadata-1024x409.png\" /></a></p> \n<p><b><u>Collecting Traces from Lambda Functions<br /> </u></b>The previous steps work on premises, on EC2, and with applications running in containers. To collect traces and use auto-instrumentation with Lambda functions, you can use the <a href=\"https://github.com/aws-observability/aws-otel-lambda\">AWS managed OpenTelemetry Lambda Layers</a> (a few examples are included in the repository).</p> \n<p>After you add the Lambda layer to your function, you can use the environment variable <code>OPENTELEMETRY_COLLECTOR_CONFIG_FILE</code> to pass your own configuration to the collector. More information on using <a href=\"https://aws-otel.github.io/docs/getting-started/lambda\">AWS Distro for OpenTelemetry with AWS Lambda is available in the documentation</a>.</p> \n<p><span><strong>Availability and Pricing<br /> </strong></span>You can use <a href=\"https://aws.amazon.com/otel/\">AWS Distro for OpenTelemetry</a> to get telemetry data from your application running on premises and on AWS. There are no additional costs for using AWS Distro for OpenTelemetry. Depending on your configuration, you might pay for the AWS services that are destinations for OpenTelemetry data, such as <a href=\"https://aws.amazon.com/x-ray/\">AWS X-Ray</a>, <a href=\"https://aws.amazon.com/cloudwatch/\">Amazon CloudWatch</a>, and <a href=\"https://aws.amazon.com/prometheus/\">Amazon Managed Service for Prometheus (AMP)</a>.</p> \n<p><strong><a href=\"https://amazon.webex.com/amazon/j.php?RGID=rda84947dd12531393dfa8425695d3525\">To learn more, you are invited to this webinar on Thursday, October 7 at 10:00 am PT / 1:00 pm EDT / 7:00 pm CEST.</a></strong></p> \n<p><a href=\"https://aws.amazon.com/otel/\"><strong>Simplify the instrumentation of your applications and improve their observability using AWS Distro for OpenTelemetry today.</strong></a></p> \n<p>— <a href=\"https://twitter.com/danilop\">Danilo</a></p>","author":"Danilo Poccia","siteTitle":"AWS News Blog","siteHash":"6093e072e4117ec22616e844cb857d03ca62c57a411a8affc77cb5e8b6b15bf6","entryHash":"e4cb8e27558c2c535a49056504e18a39355ccd8c8119689c5e3d0b72ffe8052d","category":"Tech"}