{"title":"Setting And Persisting Color Scheme Preferences With CSS And A “Touch” Of JavaScript","link":"https://smashingmagazine.com/2024/03/setting-persisting-color-scheme-preferences-css-javascript/","date":1711368000000,"content":"<p>Many modern websites give users the power to set a site-specific color scheme preference. A basic implementation is straightforward with JavaScript: listen for when a user changes a checkbox or clicks a button, toggle a class (or attribute) on the <code>&lt;body&gt;</code> element in response, and write the styles for that class to override design with a different color scheme.</p>\n<p>CSS’s new <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/:has\"><code>:has()</code> pseudo-class</a>, supported by major browsers since December 2023, opens many doors for front-end developers. I’m especially excited about leveraging it to modify UI in response to user interaction <em>without JavaScript</em>. Where previously we have used JavaScript to toggle classes or attributes (or to set styles directly), we can now pair <code>:has()</code> selectors with HTML’s native interactive elements.</p>\n<p>Supporting a color scheme preference, like “Dark Mode,” is a great use case. We can use a <code>&lt;select&gt;</code> element anywhere that toggles color schemes based on the selected <code>&lt;option&gt;</code> — no JavaScript needed, save for a sprinkle to save the user’s choice, which we’ll get to further in.</p>\nRespecting System Preferences\n<p>First, we’ll support a user’s system-wide color scheme preferences by adopting a “Light Mode”-first approach. In other words, we start with a light color scheme by default and swap it out for a dark color scheme for users who prefer it.</p>\n<p>The <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme\"><code>prefers-color-scheme</code></a> media feature detects the user’s system preference. Wrap “dark” styles in a <code>prefers-color-scheme: dark</code> media query.</p>\n<pre><code>selector {\n  /* light styles */\n\n  @media (prefers-color-scheme: dark) {\n    /* dark styles */\n  }\n}\n</code></pre>\n\n<p>Next, set the <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/color-scheme\"><code>color-scheme</code></a> property to match the preferred color scheme. Setting <code>color-scheme: dark</code> switches the browser into its built-in dark mode, which includes a black default background, white default text, “dark” styles for scrollbars, and other elements that are difficult to target with CSS, and more. I’m using CSS variables to hint that the value is dynamic — and because I like the browser developer tools experience — but plain <code>color-scheme: light</code> and <code>color-scheme: dark</code> would work fine.</p>\n<pre><code>:root {\n  /* light styles here */\n  color-scheme: var(--color-scheme, light);\n\n  /* system preference is \"dark\" */\n  @media (prefers-color-scheme: dark) {\n    --color-scheme: dark;\n    /* any additional dark styles here */\n  }\n}\n</code></pre>\n\nGiving Users Control\n<p>Now, to support <em>overriding</em> the system preference, let users choose between light (default) and dark color schemes at the page level.</p>\n<p>HTML has native elements for handling user interactions. Using one of those controls, rather than, say, a <code>&lt;div&gt;</code> nest, improves the chances that assistive tech users will have a good experience. I’ll use a <code>&lt;select&gt;</code> menu with options for “system,” “light,” and “dark.” A group of <code>&lt;input type=\"radio\"&gt;</code> would work, too, if you wanted the options right on the surface instead of a dropdown menu.</p>\n<pre><code>&lt;select id=\"color-scheme\"&gt;\n  &lt;option value=\"system\" selected&gt;System&lt;/option&gt;\n  &lt;option value=\"light\"&gt;Light&lt;/option&gt;\n  &lt;option value=\"dark\"&gt;Dark&lt;/option&gt;\n&lt;/select&gt;\n</code></pre>\n\n<p>Before CSS gained <code>:has()</code>, responding to the user’s selected <code>&lt;option&gt;</code> required JavaScript, for example, setting an event listener on the <code>&lt;select&gt;</code> to toggle a class or attribute on <code>&lt;html&gt;</code> or <code>&lt;body&gt;</code>.</p>\n<p>But now that we have <code>:has()</code>, we can now do this with CSS alone! You’ll save spending any of your performance budget on a dark mode script, plus the control will work even for users who have disabled JavaScript. And any “no-JS” folks on the project will be satisfied.</p>\n<p>What we need is a selector that applies to the page when it <code>:has()</code> a <code>select</code> menu with a particular <code>[value]:checked</code>. Let’s translate that into CSS:</p>\n<pre><code>:root:has(select option[value=\"dark\"]:checked)</code></pre>\n\n<p>We’re defaulting to a light color scheme, so it’s enough to account for two possible dark color scheme scenarios:</p>\n<ol>\n<li>The page-level color preference is “system,” and the system-level preference is “dark.”</li>\n<li>The page-level color preference is “dark”.</li>\n</ol>\n<p>The first one is a page-preference-aware iteration of our <code>prefers-color-scheme: dark</code> case. A “dark” system-level preference is no longer enough to warrant dark styles; we need a “dark” system-level preference and a “follow the system-level preference” at the page-level preference. We’ll wrap the <code>prefers-color-scheme</code> media query dark scheme styles with the <code>:has()</code> selector we just wrote:</p>\n<div>\n<pre><code>:root {\n  /* light styles here */\n  color-scheme: var(--color-scheme, light);\n\n  /* page preference is \"system\", and system preference is \"dark\" */\n  @media (prefers-color-scheme: dark) {\n    &amp;:has(#color-scheme option[value=\"system\"]:checked) {\n      --color-scheme: dark;\n      /* any additional dark styles, again */\n    }\n  }\n}\n</code></pre>\n</div>\n\n<p>Notice that I’m using <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Nesting_selector\">CSS Nesting</a> in that last snippet. <a href=\"https://github.com/web-platform-dx/web-features/blob/main/docs/baseline.md\">Baseline 2023</a> has it pegged as “Newly available across major browsers” which means support is good, but at the time of writing, support on Android browsers not included in <a href=\"https://github.com/web-platform-dx/web-features/blob/main/docs/baseline.md#core-browser-set\">Baseline’s core browser set</a> is <a href=\"https://caniuse.com/css-nesting\">limited</a>. You can get the same result without nesting.</p>\n<div>\n<pre><code>:root {\n  /* light styles */\n  color-scheme: var(--color-scheme, light);\n\n  /* page preference is \"dark\" */\n  &amp;:has(#color-scheme option[value=\"dark\"]:checked) {\n    --color-scheme: dark;\n    /* any additional dark styles */\n  }\n}\n</code></pre>\n</div>\n\n<p>For the second dark mode scenario, we’ll use nearly the exact same <code>:has()</code> selector as we did for the first scenario, this time checking whether the “dark” option — rather than the “system” option — is selected:</p>\n<div>\n<pre><code>:root {\n  /* light styles */\n  color-scheme: var(--color-scheme, light);\n\n  /* page preference is \"dark\" */\n  &amp;:has(#color-scheme option[value=\"dark\"]:checked) {\n    --color-scheme: dark;\n    /* any additional dark styles */\n  }\n\n  /* page preference is \"system\", and system preference is \"dark\" */\n  @media (prefers-color-scheme: dark) {\n    &amp;:has(#color-scheme option[value=\"system\"]:checked) {\n      --color-scheme: dark;\n      /* any additional dark styles, again */\n    }\n  }\n}\n</code></pre>\n</div>\n\n<p>Now the page’s styles respond to both changes in users’ system settings <em>and</em> user interaction with the page’s color preference UI — all with CSS!</p>\n<p>But the colors change <em>instantly</em>. Let’s smooth the transition.</p>\nRespecting Motion Preferences\n<p>Instantaneous style changes can feel inelegant in some cases, and this is one of them. So, let’s apply a CSS transition on the <code>:root</code> to “ease” the switch between color schemes. (Transition styles at the <code>:root</code> will cascade down to the rest of the page, which may necessitate adding <code>transition: none</code> or other transition overrides.)</p>\n<p>Note that the CSS <code>color-scheme</code> property does not support transitions.</p>\n<div>\n<pre><code>:root {\n  transition-duration: 200ms;\n  transition-property: /* properties changed by your light/dark styles */;\n}\n</code></pre>\n</div>\n\n<p>Not all users will consider the addition of a transition a welcome improvement. Querying the <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-motion\"><code>prefers-reduced-motion</code></a> media feature allows us to account for a user’s motion preferences. If the value is set to <code>reduce</code>, then we remove the <code>transition-duration</code> to eliminate unwanted motion.</p>\n<div>\n<pre><code>:root {\n  transition-duration: 200ms;\n  transition-property: /* properties changed by your light/dark styles */;\n\n  @media screen and (prefers-reduced-motion: reduce) {\n    transition-duration: none;\n  }\n}\n</code></pre>\n</div>\n\n<p>Transitions can also produce poor user experiences on devices that render changes slowly, for example, ones with e-ink screens. We can extend our “no motion condition” media query to account for that with the <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/@media/update\"><code>update</code></a> media feature. If its value is <code>slow</code>, then we remove the <code>transition-duration</code>.</p>\n<div>\n<pre><code>:root {\n  transition-duration: 200ms;\n  transition-property: /* properties changed by your light/dark styles */;\n\n  @media screen and (prefers-reduced-motion: reduce), (update: slow) {\n    transition-duration: 0s;\n  }\n}\n</code></pre>\n</div>\n\n<p>Let’s try out what we have so far in the following demo. Notice that, to work around <code>color-scheme</code>’s lack of transition support, I’ve explicitly styled the properties that should transition during theme changes.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/YzMVQja\">CSS-only theme switcher (requires :has()) [forked]</a> by <a href=\"https://codepen.io/henry\">Henry</a>.</p>\n<p>Not bad! But what happens if the user refreshes the pages or navigates to another page? The reload effectively wipes out the user’s form selection, forcing the user to re-make the selection. That may be acceptable in some contexts, but it’s likely to go against user expectations. Let’s bring in JavaScript for a touch of progressive enhancement in the form of…</p>\nPersistence\n<p>Here’s a vanilla JavaScript implementation. It’s a naive starting point — the functions and variables aren’t encapsulated but are instead properties on <code>window</code>. You’ll want to adapt this in a way that fits your site’s conventions, framework, library, and so on.</p>\n<p>When the user changes the color scheme from the <code>&lt;select&gt;</code> menu, we’ll store the selected <code>&lt;option&gt;</code> value in a new <code>localStorage</code> item called <code>\"preferredColorScheme\"</code>. On subsequent page loads, we’ll check <code>localStorage</code> for the <code>\"preferredColorScheme\"</code> item. If it exists, and if its value corresponds to one of the form control options, we restore the user’s preference by programmatically updating the menu selection.</p>\n<div>\n<pre><code>/*\n * If a color scheme preference was previously stored,\n * select the corresponding option in the color scheme preference UI\n * unless it is already selected.\n */\nfunction restoreColorSchemePreference() {\n  const colorScheme = localStorage.getItem(colorSchemeStorageItemName);\n\n  if (!colorScheme) {\n    // There is no stored preference to restore\n    return;\n  }\n\n  const option = colorSchemeSelectorEl.querySelector(<code>[value=${colorScheme}]</code>);<br />\n  if (!option) {\n    // The stored preference has no corresponding option in the UI.\n    localStorage.removeItem(colorSchemeStorageItemName);\n    return;\n  }\n\n  if (option.selected) {<br />    // The stored preference's corresponding menu option is already selected\n    return;\n  }\n\n  option.selected = true;\n}\n\n/*\n * Store an event target's value in localStorage under colorSchemeStorageItemName\n */\nfunction storeColorSchemePreference({ target }) {\n  const colorScheme = target.querySelector(\":checked\").value;\n  localStorage.setItem(colorSchemeStorageItemName, colorScheme);\n}\n\n// The name under which the user's color scheme preference will be stored.\nconst colorSchemeStorageItemName = \"preferredColorScheme\";\n\n// The color scheme preference front-end UI.\nconst colorSchemeSelectorEl = document.querySelector(\"#color-scheme\");\n\nif (colorSchemeSelectorEl) {\n  restoreColorSchemePreference();\n\n  // When the user changes their color scheme preference via the UI,\n  // store the new preference.\n  colorSchemeSelectorEl.addEventListener(\"input\", storeColorSchemePreference);\n}\n</code></pre>\n</div>\n\n<p>Let’s try that out. Open this demo (perhaps in a new window), use the menu to change the color scheme, and then refresh the page to see your preference persist:</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/GRLmEXX\">CSS-only theme switcher (requires :has()) with JS persistence [forked]</a> by <a href=\"https://codepen.io/henry\">Henry</a>.</p>\n<p>If your system color scheme preference is “light” and you set the demo’s color scheme to “dark,” you may get the light mode styles for a moment immediately after reloading the page before the dark mode styles kick in. That’s because CodePen loads its own JavaScript before the demo’s scripts. That is out of my control, but you can take care to improve this persistence on your projects.</p>\nPersistence Performance Considerations\n<p>Where things can get tricky is restoring the user’s preference <em>immediately</em> after the page loads. If the color scheme preference in <code>localStorage</code> is different from the user’s system-level color scheme preference, it’s possible the user will see the system preference color scheme before the page-level preference is restored. (Users who have selected the “System” option will never get that flash; neither will those whose system settings match their selected option in the form control.)</p>\n<p>If your implementation is showing a <a href=\"https://css-tricks.com/flash-of-inaccurate-color-theme-fart/\">“flash of inaccurate color theme”</a>, where is the problem happening? Generally speaking, the earlier the scripts appear on the page, the lower the risk. The “best option” for you will depend on your specific stack, of course.</p>\nWhat About Browsers That Don’t Support <code>:has()</code>?\n<p><a href=\"https://caniuse.com/css-has\">All major browsers support <code>:has()</code> today</a> Lean into modern platforms if you can. But if you do need to consider legacy browsers, like Internet Explorer, there are two directions you can go: either hide or remove the color scheme picker for those browsers or make heavier use of JavaScript.</p>\n<p>If you consider color scheme support itself a progressive enhancement, you can entirely hide the selection UI in browsers that don’t support <code>:has()</code>:</p>\n<pre><code>@supports not selector(:has(body)) {\n  @media (prefers-color-scheme: dark) {\n    :root {\n      /* dark styles here */\n    }\n  }\n\n  #color-scheme {\n    display: none;\n  }\n}\n</code></pre>\n\n<p>Otherwise, you’ll need to rely on a JavaScript solution not only for persistence but for the core functionality. Go back to that traditional event listener toggling a class or attribute.</p>\n<p>The CSS-Tricks “<a href=\"https://css-tricks.com/a-complete-guide-to-dark-mode-on-the-web/\">Complete Guide to Dark Mode</a>” details several alternative approaches that you might consider as well when working on the legacy side of things.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"705d1f346b6025db5398abddc0fb945d5fe48fa6b0f327c96cc7793bb7425e73","category":"Tech"}