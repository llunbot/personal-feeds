{"title":"How OWASP Helps You Secure Your Full-Stack Web Applications","link":"https://smashingmagazine.com/2025/02/how-owasp-helps-secure-full-stack-web-applications/","date":1739865600000,"content":"<p>Security can be an intimidating topic for web developers. The vocabulary is rich and full of acronyms. Trends evolve quickly as hackers and analysts play a perpetual cat-and-mouse game. Vulnerabilities stem from little details we cannot afford to spend too much time on during our day-to-day operations.</p>\n<p>JavaScript developers already have a lot to take with the emergence of a new wave of innovative architectures, such as React Server Components, Next.js App Router, or Astro islands.</p>\n<p>So, let’s have a focused approach. What we need is to be able to <strong>detect</strong> and <strong>palliate the most common security issues</strong>. A top ten of the most common vulnerabilities would be ideal.</p>\nMeet The OWASP Top 10\n<p>Guess what: there happens to be such a top ten of the most common vulnerabilities, curated by experts in the field! </p>\n<p>It is provided by the <strong>OWASP Foundation</strong>, and it’s an extremely valuable resource for getting started with security. </p>\n<p>OWASP stands for “Open Worldwide Application Security Project.” It’s a nonprofit foundation whose goal is to make software more secure globally. It supports many open-source projects and produces high-quality education resources, including the OWASP top 10 vulnerabilities list.</p>\n<p>We will dive through each item of the OWASP top 10 to understand <em>how</em> to recognize these vulnerabilities in a full-stack application.</p>\n<p><strong>Note</strong>: <em>I will use Next.js as an example, but this knowledge applies to any similar full-stack architecture, even outside of the JavaScript ecosystem.</em></p>\n<p>Let’s start our countdown towards a safer web!</p>\nNumber 10: Server-Side Request Forgery (SSRF)\n<p>You may have heard about Server-Side Rendering, aka SSR. Well, you can consider SSRF to be its evil twin acronym.</p>\n<p>Server-Side Request Forgery can be summed up as <strong>letting an attacker fire requests using your backend server</strong>. Besides hosting costs that may rise up, the main problem is that the attacker will benefit from your server’s level of accreditation. In a complex architecture, this means being able to target your internal private services using your own corrupted server.</p>\n<p><img src=\"https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/ssr-good-ssrf-bad.jpg\" /></p>\n<p>Here is an example. Our app lets a user input a URL and summarizes the content of the target page server-side using an AI SDK. A mischievous user passes <code>localhost:3000</code> as the URL instead of a website they’d like to summarize. Your server will fire a request against itself or any other service running on port 3000 in your backend infrastructure. This is a severe SSRF vulnerability!</p>\n<p>You’ll want to be careful when firing requests based on user inputs, especially server-side.</p>\nNumber 9: Security Logging And Monitoring Failures\n<p>I wish we could establish a telepathic connection with our beloved Node.js server running in the backend. Instead, the best thing we have to see what happens in the cloud is a dreadful stream of unstructured pieces of text we name “logs.”</p>\n<p>Yet we will have to deal with that, not only for debugging or performance optimization but also because <strong>logs are often the only information you’ll get to discover and remediate a security issue</strong>.</p>\n<p>As a starter, you might want to focus on logging the most important transactions of your application exactly like you would prioritize writing end-to-end tests. In most applications, this means login, signup, payouts, mail sending, and so on. In a bigger company, a more complete telemetry solution is a must-have, such as Open Telemetry, Sentry, or Datadog.</p>\n<p>If you are using React Server Components, you may need to set up a proper logging strategy anyway since it’s not possible to debug them directly from the browser as we used to do for Client components.</p>\nNumber 8: Software And Data Integrity Failures\n<p>The OWASP top 10 vulnerabilities tend to have various levels of granularity, and this one is really a big family. I’d like to focus on <strong>supply chain attacks</strong>, as they have gained a lot of popularity over the years.</p>\n<p>You may have heard about the <strong>Log4J vulnerability</strong>. It was very publicized, very critical, and very exploited by hackers. It’s a massive supply chain attack.</p>\n<p>In the JavaScript ecosystem, you most probably install your dependencies using NPM. Before picking dependencies, you might want to craft yourself a small list of health indicators. </p>\n<ul>\n<li>Is the library maintained and tested with proper code?</li>\n<li>Does it play a critical role in my application?</li>\n<li>Who is the main contributor?</li>\n<li>Did I spell it right when installing?</li>\n</ul>\n<p>For more serious business, you might want to consider setting up a <strong>Supply Chain Analysis (SCA)</strong> solution; GitHub’s Dependabot is a free one, and Snyk and Datadog are other famous actors.</p>\nNumber 7: Identification And Authentication Failures\n<p>Here is a stereotypical vulnerability belonging to this category: your admin password is leaked. A hacker finds it. Boom, game over. </p>\n<p>Password management procedures are beyond the scope of this article, but in the context of full-stack web development, let’s dive deep into how we can prevent brute force attacks using Next.js edge middlewares.</p>\n<p><strong>Middlewares</strong> are tiny proxies written in JavaScript. They process requests in a way that is supposed to be very, very fast, faster than a normal Node.js endpoint, for example. They are a good fit for handling <strong>low-level processing</strong>, like blocking malicious IPs or redirecting users towards the correct translation of a page.</p>\n<p>One interesting use case is <strong>rate limiting</strong>. You can quickly improve the security of your applications by limiting people’s ability to spam your POST endpoints, especially login and signup.</p>\n<p>You may go even further by setting up a <strong>Web Applications Firewall (WAF)</strong>. A WAF lets developers implement elaborate security rules. This is not something you would set up directly in your application but rather at the host level. For instance, Vercel has released its own WAF in 2024.</p>\nNumber 6: Vulnerable And Outdated Components\n<p>We have discussed supply chain attacks earlier. Outdated components are a variation of this vulnerability, where you actually are the person to blame. Sorry about that.</p>\n<p>Security vulnerabilities are often discovered ahead of time by diligent security analysts before a mean attacker can even start thinking about exploiting them. Thanks, analysts friends! When this happens, they fill out a <strong>Common Vulnerabilities and Exposure</strong> and store that in a public database.</p>\n<p>The remedy is the same as for supply chain attacks: set up an SCA solution like Dependabot that will regularly check for the use of vulnerable packages in your application.</p>\n<p><img src=\"https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/vulnerable-components.jpg\" /></p>\nHalfway break\n<p>I just want to mention at this point how much progress we have made since the beginning of this article. To sum it up:</p>\n<ul>\n<li>We know how to recognize an SSRF. This is a nasty vulnerability, and it is easy to accidentally introduce while crafting a super cool feature.</li>\n<li>We have identified monitoring and dependency analysis solutions as important pieces of “support” software for securing applications.</li>\n<li>We have figured out a good use case for Next.js edge middlewares: rate limiting our authentication endpoints to prevent brute force attacks.</li>\n</ul>\n<p>It’s a good time to go grab a tea or coffee. But after that, come back with us because we are going to discover the five most common vulnerabilities affecting web applications!</p>\nNumber 5: Security Misconfiguration\n<p>There are so many configurations that we can mismanage. But let’s focus on the most insightful ones for a web developer learning about security: <strong>HTTP headers</strong>.</p>\n<p>You can use HTTP response headers to pass on a lot of information to the user’s browser about what’s possible or not on your website.</p>\n<p>For example, by narrowing down the “Permissions-Policy” headers, you can claim that your website will never require access to the user’s camera. This is an extremely powerful protection mechanism in case of a <strong>script injection attack (XSS)</strong>. Even if the hacker manages to run a malicious script in the victim’s browser, the latter will not allow the script to access the camera.</p>\n<p>I invite you to observe the security configuration of any template or boilerplate that you use to craft your own websites. <em>Do you understand them properly?</em> <em>Can you improve them?</em> Answering these questions will inevitably lead you to vastly increase the safety of your websites!</p>\nNumber 4: Insecure Design\n<p>I find this one funny, although a bit insulting for us developers.</p>\n<p>Bad code is literally the fourth most common cause of vulnerabilities in web applications! You can’t just blame your infrastructure team anymore.</p>\n<p>Design is actually not just about code but about <strong>the way we use our programming tools</strong> to produce software artifacts. </p>\n<p><img src=\"https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/bad-design.jpg\" /></p>\n<p>In the context of full-stack JavaScript frameworks, I would recommend learning how to use them <strong>idiomatically</strong>, the same way you’d want to learn a foreign language. It’s not just about translating what you already know word-by-word. You need to get a grasp of how a native speaker would phrase their thoughts.</p>\n<p>Learning idiomatic Next.js is really, really hard. Trust me, I teach this framework to web developers. Next is all about client and server logic hybridization, and some patterns may not even transfer to competing frameworks with a different architecture like Astro.js or Remix.</p>\n<p>Hopefully, the Next.js core team has produced many free learning resources, including articles and documentation specifically focusing on security.</p>\n<p>I recommend reading Sebastian Markbåge’s famous article “<a href=\"https://nextjs.org/blog/security-nextjs-server-components-actions\">How to Think About Security in Next.js</a>” as a starting point. If you use Next.js in a professional setting, consider organizing proper training sessions before you start working on high-stakes projects.</p>\nNumber 3: Injection\n<p>Injections are the epitome of vulnerabilities, the quintessence of breaches, and the paragon of security issues. SQL injections are typically very famous, but JavaScript injections are also quite common. Despite being well-known vulnerabilities, injections are still in the top 3 in the OWASP ranking!</p>\n<p>Injections are the reason why forcing a React component to render HTML is done through an unwelcoming <code>dangerouslySetInnerHTML</code> function.</p>\n<p>React doesn’t want you to include user input that could contain a malicious script.</p>\n<p>The screenshot below is a demonstration of an injection using images. It could target a message board, for instance. The attacker misused the image posting system. They passed a URL that points towards an API GET endpoint instead of an actual image. Whenever your website’s users see this post in their browser, an authenticated request is fired against your backend, triggering a payment!</p>\n<p>As a bonus, having a GET endpoint that triggers side-effects such as payment also constitutes a risk of <strong>Cross-Site Request Forgery</strong> (CSRF, which happens to be SSRF client-side cousin).</p>\n<p><img src=\"https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/csrf-hacked.png\" /></p>\n<p>Even experienced developers can be caught off-guard. Are you aware that dynamic route parameters are user inputs? For instance, <code>[language]/page.jsx</code> in a Next.js or Astro app. I often see clumsy attack attempts when logging them, like “language” being replaced by a path traversal like <code>../../../../passwords.txt</code>.</p>\n<p><strong>Zod</strong> is a very popular library for running server-side data validation of user inputs. You can add a transform step to sanitize inputs included in database queries, or that could land in places where they end up being executed as code.</p>\nNumber 2: Cryptographic Failures\n<p>A typical discussion between two developers that are in deep, deep trouble:</p>\n<blockquote>— We have leaked our database and encryption key. What algorithm was used to encrypt the password again? AES-128 or SHA-512?<br />— I don’t know, aren’t they the same thing? They transform passwords into gibberish, right?<br />— Alright. We are in deep, deep trouble.</blockquote>\n\n<p>This vulnerability mostly concerns backend developers who have to deal with <strong>sensitive personal identifiers (PII)</strong> or <strong>passwords</strong>. </p>\n<p>To be honest, I don’t know much about these algorithms; I studied computer science way too long ago.</p>\n<p>The only thing I remember is that you need <strong>non-reversible algorithms to encrypt passwords</strong>, aka hashing algorithms. The point is that if the encrypted passwords are leaked, and the encryption key is also leaked, it will still be super hard to hack an account (you can’t just reverse the encryption).</p>\n<p>In the State of JavaScript survey, we use passwordless authentication with an email magic link and one-way hash emails, so even as admins, we cannot guess a user’s email in our database.</p>\n<p><img src=\"https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/encrypted-email.png\" /></p>\nAnd number 1  is...\n<p>Such suspense! We are about to discover that the top 1 vulnerability in the world of web development is...</p>\n<p><strong>Broken Access Control!</strong> Tada.</p>\n<p>Yeah, the name is not super insightful, so let me rephrase it. It’s about people being able to access other people’s accounts or people being able to access resources they are not allowed to. That’s more impressive when put this way.</p>\n<p>A while ago, I wrote an article about the fact that <a href=\"https://www.ericburel.tech/blog/static-paid-content-app-router\"><strong>checking authorization within a layout may leave page content unprotected in Next.js</strong></a>. It’s not a flaw in the framework’s design but a consequence of how React Server Components have a different model than their client counterparts, which then affects how the layout works in Next.</p>\n<p>Here is a demo of how you can implement a paywall in Next.js that doesn’t protect anything.</p>\n<pre><code>// app/layout.jsx\n// Using cookie-based authentication as usual\nasync function checkPaid() {\n  const token = cookies.get(\"auth_token\");\n  return await db.hasPayments(token);\n}\n// Running the payment check in a layout to apply it to all pages\n// Sadly, this is not how Next.js works!\nexport default async function Layout() {\n  // ❌ this won't work as expected!!\n  const hasPaid = await checkPaid();\n  if (!hasPaid) redirect(\"/subscribe\");\n  // then render the underlying page\n  return &lt;div&gt;{children}&lt;/div&gt;;\n}\n// ❌ this can be accessed directly\n// by adding “RSC=1” to the request that fetches it!\nexport default function Page() {\n  return &lt;div&gt;PAID CONTENT&lt;/div&gt;\n}\n</code></pre>\n\nWhat We Have Learned From The Top 5 Vulnerabilities\n<p>Most common vulnerabilities are tightly related to application design issues: </p>\n<ul>\n<li>Copy-pasting configuration without really understanding it.</li>\n<li>Having an improper understanding of the framework we use in inner working. Next.js is a complex beast and doesn’t make our life easier on this point!</li>\n<li>Picking an algorithm that is not suited for a given task.</li>\n</ul>\n<p>These vulnerabilities are tough ones because they confront us to our own limits as web developers. Nobody is perfect, and the most experienced developers will inevitably write vulnerable code at some point in their lives without even noticing. </p>\n<p>How to prevent that? By not staying alone! When in doubt, ask around fellow developers; there are great chances that someone has faced the same issues and can lead you to the right solutions.</p>\nWhere To Head Now?\n<p>First, I must insist that you have already done a great job of improving the security of your applications by reading this article. Congratulations!</p>\n<p>Most hackers rely on a volume strategy and are not particularly skilled, so they are really in pain when confronted with educated developers who can spot and fix the most common vulnerabilities.</p>\n<p><img src=\"https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/owasp.jpg\" /></p>\n<p>From there, I can suggest a few directions to get even better at securing your web applications:</p>\n<ul>\n<li><strong>Try to apply the OWASP top 10 to an application you know well</strong>, either a personal project, your company’s codebase, or an open-source solution.</li>\n<li><strong>Give a shot at some third-party security tools.</strong> They tend to overflow developers with too much information but keep in mind that most actors in the field of security are aware of this issue and work actively to provide more focused vulnerability alerts.</li>\n<li>I’ve added my favorite <strong>security-related resources</strong> at the end of the article, so you’ll have plenty to read!</li>\n</ul>\n<p>Thanks for reading, and stay secure!</p>\n<h3>Resources For Further Learning</h3>\n<ul>\n<li><a href=\"https://nextpatterns.dev/p/security/ssrf-server-action\">An interactive demo of an SSRF in a Next.js app and how to fix it</a></li>\n<li><a href=\"https://owasp.org/www-project-top-ten/\">OWASP Top 10</a></li>\n<li><a href=\"https://www.assetnote.io/resources/research/digging-for-ssrf-in-nextjs-apps\">An SSRF vulnerability that affected Next.js image optimization system</a></li>\n<li><a href=\"https://www.dash0.com/blog/how-to-inspect-react-server-component-activity-with-next-js\">Observe React Server Components using Open Telemetry</a></li>\n<li><a href=\"https://opentelemetry.io/\">OpenTelemetry and open source Telemtry standard</a> </li>\n<li><a href=\"https://www.ibm.com/think/topics/log4j\">Log4J vulnerability</a></li>\n<li><a href=\"https://upstash.com/blog/edge-rate-limiting\">Setting up rate limiting in a middleware using a Redis service</a></li>\n<li><a href=\"https://vercel.com/blog/introducing-the-vercel-waf\">Vercel WAF annoucement</a></li>\n<li><a href=\"https://cve.mitre.org/\">Mitre CVE database</a></li>\n<li><a href=\"https://nextpatterns.dev/p/security/csrf-image\">An interactive demo of a CSRF vulnerability in a Next.js app and how to fix it</a></li>\n<li><a href=\"https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/\">A super complete guide on authentication specifically targeting web apps</a></li>\n<li><a href=\"https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations#server-side-form-validation\">Server form validation with zod in Next.js</a> (Astro has it built-in)</li>\n<li><a href=\"https://github.com/colinhacks/zod/discussions/1358\">Sanitization with zod</a></li>\n<li><a href=\"https://www.ericburel.tech/blog/static-paid-content-app-router\">Secure statically rendered paid content in Next.js and how layouts are a bad place to run authentication checks</a></li>\n<li><a href=\"https://www.smashingmagazine.com/search/?q=security\">Smashing Magazine articles related to security</a> (almost 50 matches at the time of writing!)</li>\n</ul>\n<p><em>This article is inspired by my talk at React Advanced London 2024, “<a href=\"https://gitnation.com/contents/securing-server-rendered-applications-nextjs-case\">Securing Server-Rendered Applications: Next.js case</a>,” which is available to watch as a replay online.</em></p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"83ff89ce0a5dd5246426c635502721e67f0eead1ebc347c9e399e3ae3e9759f3","category":"Tech"}