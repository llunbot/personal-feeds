{"title":"Reduce costs and latency with Amazon Bedrock Intelligent Prompt Routing and prompt caching (preview)","link":"https://aws.amazon.com/blogs/aws/reduce-costs-and-latency-with-amazon-bedrock-intelligent-prompt-routing-and-prompt-caching-preview/","date":1733332947000,"content":"<p>Today, <a href=\"https://aws.amazon.com/bedrock/\">Amazon Bedrock</a> has introduced in preview two capabilities that help reduce costs and latency for <a href=\"https://aws.amazon.com/ai/generative-ai\">generative AI</a> applications:</p> \n<p><strong>Amazon Bedrock Intelligent Prompt Routing</strong> – When invoking a model, you can now use a combination of <a href=\"https://aws.amazon.com/what-is/foundation-models/\">foundation models (FMs)</a> from the same model family to help optimize for quality and cost. For example, with the <a href=\"https://aws.amazon.com/bedrock/claude/\">Anthropic’s Claude</a> model family, Amazon Bedrock can intelligently route requests between Claude 3.5 Sonnet and Claude 3 Haiku depending on the complexity of the prompt. Similarly, Amazon Bedrock can route requests between <a href=\"https://aws.amazon.com/bedrock/llama/\">Meta Llama</a> 3.1 70B and 8B. The prompt router predicts which model will provide the best performance for each request while optimizing the quality of response and cost. This is particularly useful for applications such as customer service assistants, where uncomplicated queries can be handled by smaller, faster, and more cost-effective models, and complex queries are routed to more capable models. Intelligent Prompt Routing can reduce costs by up to 30 percent without compromising on accuracy.</p> \n<p><strong>Amazon Bedrock now supports prompt caching</strong> – You can now cache frequently used context in prompts across multiple model invocations. This is especially valuable for applications that repeatedly use the same context, such as document Q&amp;A systems where users ask multiple questions about the same document or coding assistants that need to maintain context about code files. The cached context remains available for up to 5 minutes after each access. Prompt caching in Amazon Bedrock can reduce costs by up to 90% and latency by up to 85% for supported models.</p> \n<p>These features make it easier to reduce latency and balance performance with cost efficiency. Let’s look at how you can use them in your applications.</p> \n<p><span><strong>Using Amazon Bedrock Intelligent Prompt Routing in the console<br /> </strong></span>Amazon Bedrock Intelligent Prompt Routing uses advanced prompt matching and model understanding techniques to predict the performance of each model for every request, optimizing for quality of responses and cost. During the preview, you can use the default prompt routers for <a href=\"https://aws.amazon.com/bedrock/claude/\">Anthropic’s Claude</a> and <a href=\"https://aws.amazon.com/bedrock/llama/\">Meta Llama</a> model families.</p> \n<p>Intelligent prompt routing can be accessed through the <a href=\"https://console.aws.amazon.com\">AWS Management Console</a>, the <a href=\"https://aws.amazon.com/cli/\">AWS Command Line Interface (AWS CLI)</a>, and the <a href=\"https://aws.amazon.com/tools/\">AWS SDKs</a>. In the <a href=\"https://console.aws.amazon.com/bedrock\">Amazon Bedrock console</a>, I choose <strong>Prompt routers</strong> in the <strong>Foundation models</strong> section of the navigation pane.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/12/02/bedrock-prompt-routers.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/12/02/bedrock-prompt-routers.png\" alt=\"Console screenshot.\" width=\"1465\" height=\"676\" /></a></p> \n<p>I choose the <strong>Anthropic Prompt Router</strong> default router to get more information.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/11/26/bedrock-prompt-routers-anthropic-1.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/11/26/bedrock-prompt-routers-anthropic-1.png\" alt=\"Console screenshot.\" width=\"1481\" height=\"496\" /></a></p> \n<p>From the configuration of the prompt router, I see that it’s routing requests between Claude 3.5 Sonnet and Claude 3 Haiku using <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html\">cross-Region inference profiles</a>. The routing criteria defines the quality difference between the response of the largest model and the smallest model for each prompt as predicted by the router internal model at runtime. The fallback model, used when none of the chosen models meet the desired performance criteria, is Anthropic’s Claude 3.5 Sonnet.</p> \n<p>I choose <strong>Open in Playground</strong> to chat using the prompt router and enter this prompt:</p> \n<p><code>Alice has N brothers and she also has M sisters. How many sisters does Alice’s brothers have?</code></p> \n<p>The result is quickly provided. I choose the new <strong>Router metrics</strong> icon on the right to see which model was selected by the prompt router. In this case, because the question is rather complex, Anthropic’s Claude 3.5 Sonnet was used.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/11/15/bedrock-prompt-routers-anthropic-chat.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/11/15/bedrock-prompt-routers-anthropic-chat.png\" alt=\"Console screenshot.\" width=\"1476\" height=\"447\" /></a></p> \n<p>Now I ask a straightforward question to the same prompt router:</p> \n<p><code>Describe the purpose of a 'hello world' program in one line.</code></p> \n<p>This time, Anthropic’s Claude 3 Haiku has been selected by the prompt router.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/11/26/bedrock-prompt-routers-anthropic-chat-simple.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/11/26/bedrock-prompt-routers-anthropic-chat-simple.png\" alt=\"Console screenshot.\" width=\"1615\" height=\"365\" /></a></p> \n<p>I select the <strong>Meta Prompt Router</strong> to check its configuration. It’s using the cross-Region inference profiles for Llama 3.1 70B and 8B with the 70B model as fallback.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/11/26/bedrock-prompt-routers-meta-1.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/11/26/bedrock-prompt-routers-meta-1.png\" alt=\"Console screenshot.\" width=\"1481\" height=\"491\" /></a></p> \n<p>Prompt routers are integrated with other Amazon Bedrock capabilities, such as <a href=\"https://aws.amazon.com/bedrock/knowledge-bases/\">Amazon Bedrock Knowledge Bases</a> and <a href=\"https://aws.amazon.com/bedrock/agents/\">Amazon Bedrock Agents</a>, or when <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/evaluation.html\">performing evaluations</a>. For example, here I create a model evaluation to help me compare, for my use case, a prompt router to another model or prompt router.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/11/26/bedrock-prompt-routers-evaluation.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/11/26/bedrock-prompt-routers-evaluation.png\" alt=\"Console screenshot.\" width=\"1304\" height=\"777\" /></a></p> \n<p>To use a prompt router in an application, I need to set the prompt router <a href=\"https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html\">Amazon Resource Name (ARN)</a> as model ID in the Amazon Bedrock API. Let’s see how this works with the AWS CLI and an AWS SDK.</p> \n<p><span><strong>Using Amazon Bedrock Intelligent Prompt Routing with the AWS CLI<br /> </strong></span>The Amazon Bedrock API has been extended to handle prompt routers. For example, I can list the existing prompt routes in an AWS Region using <strong>ListPromptRouters</strong>:</p> \n<div> \n <pre><code>aws bedrock list-prompt-routers</code></pre> \n</div> \n<p>In output, I receive a summary of the existing prompt routers, similar to what I saw in the console.</p> \n<p>Here’s the full output of the previous command:</p> \n<pre><code>{\n    \"promptRouterSummaries\": [\n        {\n            \"promptRouterName\": \"Anthropic Prompt Router\",\n            \"routingCriteria\": {\n                \"responseQualityDifference\": 0.26\n            },\n            \"description\": \"Routes requests among models in the Claude family\",\n            \"createdAt\": \"2024-11-20T00:00:00+00:00\",\n            \"updatedAt\": \"2024-11-20T00:00:00+00:00\",\n            \"promptRouterArn\": \"arn:aws:bedrock:us-east-1:123412341234:default-prompt-router/anthropic.claude:1\",\n            \"models\": [\n                {\n                    \"modelArn\": \"arn:aws:bedrock:us-east-1:123412341234:inference-profile/us.anthropic.claude-3-haiku-20240307-v1:0\"\n                },\n                {\n                    \"modelArn\": \"arn:aws:bedrock:us-east-1:123412341234:inference-profile/us.anthropic.claude-3-5-sonnet-20240620-v1:0\"\n                }\n            ],\n            \"fallbackModel\": {\n                \"modelArn\": \"arn:aws:bedrock:us-east-1:123412341234:inference-profile/us.anthropic.claude-3-5-sonnet-20240620-v1:0\"\n            },\n            \"status\": \"AVAILABLE\",\n            \"type\": \"default\"\n        },\n        {\n            \"promptRouterName\": \"Meta Prompt Router\",\n            \"routingCriteria\": {\n                \"responseQualityDifference\": 0.0\n            },\n            \"description\": \"Routes requests among models in the LLaMA family\",\n            \"createdAt\": \"2024-11-20T00:00:00+00:00\",\n            \"updatedAt\": \"2024-11-20T00:00:00+00:00\",\n            \"promptRouterArn\": \"arn:aws:bedrock:us-east-1:123412341234:default-prompt-router/meta.llama:1\",\n            \"models\": [\n                {\n                    \"modelArn\": \"arn:aws:bedrock:us-east-1:123412341234:inference-profile/us.meta.llama3-1-8b-instruct-v1:0\"\n                },\n                {\n                    \"modelArn\": \"arn:aws:bedrock:us-east-1:123412341234:inference-profile/us.meta.llama3-1-70b-instruct-v1:0\"\n                }\n            ],\n            \"fallbackModel\": {\n                \"modelArn\": \"arn:aws:bedrock:us-east-1:123412341234:inference-profile/us.meta.llama3-1-70b-instruct-v1:0\"\n            },\n            \"status\": \"AVAILABLE\",\n            \"type\": \"default\"\n        }\n    ]\n}</code></pre> \n<p>I can get information about a specific prompt router using <strong>GetPromptRouter</strong> with a prompt router ARN. For example, for the Meta Llama model family:</p> \n<div> \n <pre><code>aws bedrock get-prompt-router --prompt-router-arn arn:aws:bedrock:us-east-1:123412341234:default-prompt-router/meta.llama:1</code></pre> \n</div> \n<pre><code>{\n    \"promptRouterName\": \"Meta Prompt Router\",\n    \"routingCriteria\": {\n        \"responseQualityDifference\": 0.0\n    },\n    \"description\": \"Routes requests among models in the LLaMA family\",\n    \"createdAt\": \"2024-11-20T00:00:00+00:00\",\n    \"updatedAt\": \"2024-11-20T00:00:00+00:00\",\n    \"promptRouterArn\": \"arn:aws:bedrock:us-east-1:123412341234:default-prompt-router/meta.llama:1\",\n    \"models\": [\n        {\n            \"modelArn\": \"arn:aws:bedrock:us-east-1:123412341234:inference-profile/us.meta.llama3-1-8b-instruct-v1:0\"\n        },\n        {\n            \"modelArn\": \"arn:aws:bedrock:us-east-1:123412341234:inference-profile/us.meta.llama3-1-70b-instruct-v1:0\"\n        }\n    ],\n    \"fallbackModel\": {\n        \"modelArn\": \"arn:aws:bedrock:us-east-1:123412341234:inference-profile/us.meta.llama3-1-70b-instruct-v1:0\"\n    },\n    \"status\": \"AVAILABLE\",\n    \"type\": \"default\"\n}\n</code></pre> \n<p>To use a prompt router with Amazon Bedrock, I set the prompt router ARN as model ID when making API calls. For example, here I use the Anthropic Prompt Router with the AWS CLI and the Amazon Bedrock Converse API:</p> \n<div> \n <pre><code>aws bedrock-runtime converse \\\n    --model-id arn:aws:bedrock:us-east-1:123412341234:default-prompt-router/anthropic.claude:1 \\\n    --messages '[{ \"role\": \"user\", \"content\": [ { \"text\": \"Alice has N brothers and she also has M sisters. How many sisters does Alice’s brothers have?\" } ] }]' \\</code></pre> \n</div> \n<p>In output, invocations using a prompt router include a new <code>trace</code> section that tells which model was actually used. In this case, it’s Anthropic’s Claude 3.5 Sonnet:</p> \n<pre><code>{\n    \"output\": {\n        \"message\": {\n            \"role\": \"assistant\",\n            \"content\": [\n                {\n                    \"text\": \"To solve this problem, let's think it through step-by-step:\\n\\n1) First, we need to understand the relationships:\\n   - Alice has N brothers\\n   - Alice has M sisters\\n\\n2) Now, we need to consider who Alice's brothers' sisters are:\\n   - Alice herself is a sister to all her brothers\\n   - All of Alice's sisters are also sisters to Alice's brothers\\n\\n3) So, the total number of sisters that Alice's brothers have is:\\n   - The number of Alice's sisters (M)\\n   - Plus Alice herself (+1)\\n\\n4) Therefore, the answer can be expressed as: M + 1\\n\\nThus, Alice's brothers have M + 1 sisters.\"\n                }\n            ]\n        }\n    },\n    . . .\n    \"trace\": {\n        \"promptRouter\": {\n            \"invokedModelId\": \"arn:aws:bedrock:us-east-1:123412341234:inference-profile/us.anthropic.claude-3-5-sonnet-20240620-v1:0\"\n        }\n    }\n}</code></pre> \n<p><span><strong>Using Amazon Bedrock Intelligent Prompt Routing with an AWS SDK<br /> </strong></span>Using an AWS SDK with a prompt router is similar to the previous command line experience. When invoking a model, I set the model ID to the prompt model ARN. For example, in this Python code I’m using the Meta Llama router with the <strong>ConverseStream</strong> API:</p> \n<pre><code>import json\nimport boto3\n\nbedrock_runtime = boto3.client(\n    \"bedrock-runtime\",\n    region_name=\"us-east-1\",\n)\n\nMODEL_ID = \"arn:aws:bedrock:us-east-1:123412341234:default-prompt-router/meta.llama:1\"\n\nuser_message = \"Describe the purpose of a 'hello world' program in one line.\"\nmessages = [\n    {\n        \"role\": \"user\",\n        \"content\": [{\"text\": user_message}],\n    }\n]\n\nstreaming_response = bedrock_runtime.converse_stream(\n    modelId=MODEL_ID,\n    messages=messages,\n)\n\nfor chunk in streaming_response[\"stream\"]:\n    if \"contentBlockDelta\" in chunk:\n        text = chunk[\"contentBlockDelta\"][\"delta\"][\"text\"]\n        print(text, end=\"\")\n    if \"messageStop\" in chunk:\n        print()\n    if \"metadata\" in chunk:\n        if \"trace\" in chunk[\"metadata\"]:\n            print(json.dumps(chunk['metadata']['trace'], indent=2))\n</code></pre> \n<p>This script prints the response text and the content of the trace in response metadata. For this uncomplicated request, the faster and more affordable model has been selected by the prompt router:</p> \n<div> \n <pre><code>A \"Hello World\" program is a simple, introductory program that serves as a basic example to demonstrate the fundamental syntax and functionality of a programming language, typically used to verify that a development environment is set up correctly.\n{\n  \"promptRouter\": {\n    \"invokedModelId\": \"arn:aws:bedrock:us-east-1:123412341234:inference-profile/us.meta.llama3-1-8b-instruct-v1:0\"\n  }\n}</code></pre> \n</div> \n<p><span><strong>Using prompt caching with an AWS SDK<br /> </strong></span>You can use prompt caching with the <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/conversation-inference.html\">Amazon Bedrock Converse API</a>. When you tag content for caching and send it to the model for the first time, the model processes the input and saves the intermediate results in a cache. For subsequent requests containing the same content, the model loads the preprocessed results from the cache, significantly reducing both costs and latency.</p> \n<p>You can implement prompt caching in your applications with a few steps:</p> \n<ol> \n <li>Identify the portions of your prompts that are frequently reused.</li> \n <li>Tag these sections for caching in the list of messages using the new <code>cachePoint</code> block.</li> \n <li>Monitor cache usage and latency improvements in the response metadata <code>usage</code> section.</li> \n</ol> \n<p>Here’s an example of implementing prompt caching when working with documents.</p> \n<p>First, I download <a href=\"https://aws.amazon.com/getting-started/decision-guides/\">three decision guides in PDF format from the AWS website</a>. These guides help choose the AWS services that fit your use case.</p> \n<p>Then, I use a Python script to ask three questions about the documents. In the code, I create a <code>converse()</code> function to handle the conversation with the model. The first time I call the function, I include a list of documents and a flag to add a <code>cachePoint</code> block.</p> \n<pre><code>import json\n\nimport boto3\n\nMODEL_ID = \"us.anthropic.claude-3-5-sonnet-20241022-v2:0\"\nAWS_REGION = \"us-west-2\"\n\nbedrock_runtime = boto3.client(\n    \"bedrock-runtime\",\n    region_name=AWS_REGION,\n)\n\nDOCS = [\n    \"bedrock-or-sagemaker.pdf\",\n    \"generative-ai-on-aws-how-to-choose.pdf\",\n    \"machine-learning-on-aws-how-to-choose.pdf\",\n]\n\nmessages = []\n\n\ndef converse(new_message, docs=[], cache=False):\n\n    if len(messages) == 0 or messages[-1][\"role\"] != \"user\":\n        messages.append({\"role\": \"user\", \"content\": []})\n\n    for doc in docs:\n        print(f\"Adding document: {doc}\")\n        name, format = doc.rsplit('.', maxsplit=1)\n        with open(doc, \"rb\") as f:\n            bytes = f.read()\n        messages[-1][\"content\"].append({\n            \"document\": {\n                \"name\": name,\n                \"format\": format,\n                \"source\": {\"bytes\": bytes},\n            }\n        })\n\n    messages[-1][\"content\"].append({\"text\": new_message})\n\n    if cache:\n        messages[-1][\"content\"].append({\"cachePoint\": {\"type\": \"default\"}})\n\n    response = bedrock_runtime.converse(\n        modelId=MODEL_ID,\n        messages=messages,\n    )\n\n    output_message = response[\"output\"][\"message\"]\n    response_text = output_message[\"content\"][0][\"text\"]\n\n    print(\"Response text:\")\n    print(response_text)\n\n    print(\"Usage:\")\n    print(json.dumps(response[\"usage\"], indent=2))\n\n    messages.append(output_message)\n\n\nconverse(\"Compare AWS Trainium and AWS Inferentia in 20 words or less.\", docs=DOCS, cache=True)\nconverse(\"Compare Amazon Textract and Amazon Transcribe in 20 words or less.\")\nconverse(\"Compare Amazon Q Business and Amazon Q Developer in 20 words or less.\")</code></pre> \n<p>For each invocation, the script prints the response and the <code>usage</code> counters.</p> \n<div> \n <pre><code>Adding document: bedrock-or-sagemaker.pdf\nAdding document: generative-ai-on-aws-how-to-choose.pdf\nAdding document: machine-learning-on-aws-how-to-choose.pdf\nResponse text:\nAWS Trainium is optimized for machine learning training, while AWS Inferentia is designed for low-cost, high-performance machine learning inference.\nUsage:\n{\n  \"inputTokens\": 4,\n  \"outputTokens\": 34,\n  \"totalTokens\": 29879,\n  \"cacheReadInputTokenCount\": 0,\n  \"cacheWriteInputTokenCount\": 29841\n}\nResponse text:\nAmazon Textract extracts text and data from documents, while Amazon Transcribe converts speech to text from audio or video files.\nUsage:\n{\n  \"inputTokens\": 59,\n  \"outputTokens\": 30,\n  \"totalTokens\": 29930,\n  \"cacheReadInputTokenCount\": 29841,\n  \"cacheWriteInputTokenCount\": 0\n}\nResponse text:\nAmazon Q Business answers questions using enterprise data, while Amazon Q Developer assists with building and operating AWS applications and services.\nUsage:\n{\n  \"inputTokens\": 108,\n  \"outputTokens\": 26,\n  \"totalTokens\": 29975,\n  \"cacheReadInputTokenCount\": 29841,\n  \"cacheWriteInputTokenCount\": 0\n}</code></pre> \n</div> \n<p>The <code>usage</code> section of the response contains two new counters: <code>cacheReadInputTokenCount</code> and <code>cacheWriteInputTokenCount</code>. The total number of tokens for an invocation is the sum of the input and output tokens plus the tokens read and written into the cache.</p> \n<p>Each invocation processes a list of messages. The messages in the first invocation contain the documents, the first question, and the cache point. Because the messages preceding the cache point aren’t currently in the cache, they’re written to cache. According to the <code>usage</code> counters, 29,841 tokens have been written into the cache.</p> \n<div> \n <pre><code>\"cacheWriteInputTokenCount\": 29841</code></pre> \n</div> \n<p>For the next invocations, the previous response and the new question are appended to the list of messages. The messages before the <code>cachePoint</code> are not changed and found in the cache.</p> \n<p>As expected, we can tell from the <code>usage</code> counters that the same number of tokens previously written is now read from the cache.</p> \n<div> \n <pre><code>\"cacheReadInputTokenCount\": 29841</code></pre> \n</div> \n<p>In my tests, the next invocations take 55 percent less time to complete compared to the first one. Depending on your use case (for example, with more cached content), prompt caching can improve latency up to 85 percent.</p> \n<p>Depending on the model, you can set more than one cache point in a list of messages. To find the right cache points for your use case, try different configurations and look at the effect on the reported usage.</p> \n<p><span><strong>Things to know<br /> </strong></span>Amazon Bedrock Intelligent Prompt Routing is available in preview today in US East (N. Virginia) and US West (Oregon) <a href=\"https://aws.amazon.com/about-aws/global-infrastructure/regions_az/\">AWS Regions</a>. During the preview, you can use the default prompt routers, and there is no additional cost for using a prompt router. You pay the cost of the selected model. You can use prompt routers with other Amazon Bedrock capabilities such as <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/evaluation.html\">performing evaluations</a>, <a href=\"https://aws.amazon.com/bedrock/knowledge-bases/\">using knowledge bases</a>, and <a href=\"https://aws.amazon.com/bedrock/agents/\">configuring agents</a>.</p> \n<p>Because the internal model used by the prompt routers needs to understand the complexity of a prompt, intelligent prompt routing currently only supports English language prompts.</p> \n<p>Amazon Bedrock support for prompt caching is available in preview in US West (Oregon) for Anthropic’s Claude 3.5 Sonnet V2 and Claude 3.5 Haiku. Prompt caching is also available in US East (N. Virginia) for Amazon Nova Micro, Amazon Nova Lite, and Amazon Nova Pro.</p> \n<p>With prompt caching, cache reads receive a 90 percent discount compared to noncached input tokens. There are no additional infrastructure charges for cache storage. When using Anthropic models, you pay an additional cost for tokens written in the cache. There are no additional costs for cache writes with Amazon Nova models. For more information, see <a href=\"https://aws.amazon.com/bedrock/pricing/\">Amazon Bedrock pricing</a>.</p> \n<p>When using prompt caching, content is cached for up to 5 minutes, with each cache hit resetting this countdown. Prompt caching has been implemented to transparently support <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html\">cross-Region inference</a>. In this way, your applications can get the cost optimization and latency benefit of prompt caching with the flexibility of cross-Region inference.</p> \n<p>These new capabilities make it easier to build cost-effective and high-performing generative AI applications. By intelligently routing requests and caching frequently used content, you can significantly reduce your costs while maintaining and even improving application performance.</p> \n<p>To learn more and start using these new capabilities today, visit the <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html\">Amazon Bedrock documentation</a> and send feedback to <a href=\"https://repost.aws/tags/TAQeKlaPaNRQ2tWB6P7KrMag/amazon-bedrock\">AWS re:Post for Amazon Bedrock</a>. You can find deep-dive technical content and discover how our Builder communities are using Amazon Bedrock at <a href=\"https://community.aws/\">community.aws</a>.</p> \n<p>— <a href=\"https://twitter.com/danilop\">Danilo</a></p>","author":"Danilo Poccia","siteTitle":"AWS News Blog","siteHash":"6093e072e4117ec22616e844cb857d03ca62c57a411a8affc77cb5e8b6b15bf6","entryHash":"ac6b87b2590530b23d803ce3539a4560b8a7a5339a0feca59710d45b1e3c7e7a","category":"Tech"}