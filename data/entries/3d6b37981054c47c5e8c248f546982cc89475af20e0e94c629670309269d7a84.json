{"title":"Terraform 1.7 adds test mocking and config-driven remove","link":"https://www.hashicorp.com/blog/terraform-1-7-adds-test-mocking-and-config-driven-remove","date":1705521600000,"content":"<p>We’re excited to announce that HashiCorp Terraform 1.7 is now generally available, <a href=\"https://developer.hashicorp.com/terraform/downloads\">ready for download</a>, and available for use in <a href=\"https://www.hashicorp.com/products/terraform\">Terraform Cloud</a>. Terraform 1.7 features a new mocking capability for the Terraform test framework, a new method for removing resources from state, and an enhancement for config-driven import. These additions help Terraform developers more thoroughly test their modules and gives operators safer and more efficient options for state manipulation.</p>\n\n<h2>Terraform test mocking</h2>\n\n<p>In Terraform 1.6 we introduced the Terraform testing framework, a native option to perform unit and integration testing of your Terraform code using the HashiCorp Configuration Language (HCL). Terraform 1.7 brings several improvements to the testing framework, highlighted by the new <em>mocking</em> feature.</p>\n\n<p>Previously, all tests were executed by making actual provider calls using either a <em>plan</em> or <em>apply</em> operation. This is a great way to observe the real behavior of a module. But it can also be useful to mock provider calls to model more advanced situations and to test without having to create actual infrastructure or requiring credentials. This can be especially useful with cloud resources that take a long time to provision, such as databases and higher-level platform services. Mocking can significantly reduce the time required to run a test suite with many different permutations, giving module authors the ability to thoroughly test their code without slowing down the development process.</p>\n\n<p>Test mocking adds powerful flexibility to module testing through two primary functions: <em>mock providers</em> and <em>overrides</em>.</p>\n\n<h3>Mock providers</h3>\n\n<p>A mocked provider or resource in a Terraform test will generate fake data for all computed attributes that would normally be provided by the underlying provider APIs. By employing aliases, mocked and real providers can be used together to create a flexible Terraform test suite for your modules. </p>\n\n<p>The new <code>mock_provider</code> block defines a mock provider, and within this block you can specify values for computed attributes of resources and data sources. This example mocks the <a href=\"https://registry.terraform.io/providers/hashicorp/aws/latest/docs\">AWS provider</a> and sets a specific value for the Amazon S3 bucket resource. Test runs using the mocked version of this provider will return the specified <code>arn</code> value for all S3 bucket resources instead of randomly generated fake data:</p>\n<pre><code>mock_provider \"aws\" {\n  mock_resource \"aws_s3_bucket\" {\n    defaults = {\n      arn = \"arn:aws:s3:::test-bucket-name\"\n    }\n  }\n}\n\nrun \"sets_bucket_name\" {\n  variables {\n    bucket_name = \"test-bucket-name\"\n  }\n\n  # Validates a known attribute set in the resource configuration\n  assert {\n    condition     = output.bucket == \"test-bucket-name\"\n    error_message = \"Wrong ARN value\"\n  }\n\n  # Validates a computed attribute using the mocked resource\n  assert {\n    condition     = output.arn == \"arn:aws:s3:::test-bucket-name\"\n    error_message = \"Wrong ARN value\"\n  }\n}</code></pre><h3>Overrides</h3>\n\n<p>In addition to mocking whole providers, you can also override specific instances of resources, data sources, and modules. Override blocks can be placed at the root of a Terraform test file to apply to all test runs, or within an individual <code>run</code> block, and can be used with both real and mocked providers. Common use cases for overrides include cutting down test execution time for resources that take a long time to provision, child modules where you’re concerned only with simulating the outputs, or to diversify the attributes of a data source for various test scenarios. This example overrides a module and mocks the output values:</p>\n<pre><code>mock_provider \"aws\" {}\n\noverride_module {\n  target = module.big_database\n  outputs = {\n    endpoint = \"big_database.012345678901.us-east-1.rds.amazonaws.com:3306\"\n    db_name  = \"test_db\"\n    username = \"fakeuser\"\n    password = \"fakepassword\"\n  }\n}\n\nrun \"test\" {\n  assert {\n    condition     = module.big_database.username == \"fakeuser\"\n    error_message = \"Incorrect username\"\n  }\n}</code></pre><h3>Learn more about test mocking</h3>\n\n<p>There’s much more you can do with the new mocking capabilities of the Terraform test framework to help enhance your testing and produce higher-quality modules. To learn more, check out the <a href=\"https://developer.hashicorp.com/terraform/language/tests/mocking\">Mocks documentation</a>, and try it out by following the updated <a href=\"https://developer.hashicorp.com/terraform/tutorials/configuration-language/test\">Write Terraform tests tutorial</a>.</p>\n\n<p>Along with test mocking, Terraform 1.7 includes several other enhancements to the test framework. You can now:</p>\n\n<ul>\n<li>Reference variables and run outputs in test provider blocks</li>\n<li>Use HCL functions in variable and provider blocks</li>\n<li>Load variable values for tests from <code>*.tfvars</code> files.</li>\n</ul>\n\n<p>For a deep dive on all things testing, check out the recently updated <a href=\"https://www.hashicorp.com/blog/testing-hashicorp-terraform\">Testing HashiCorp Terraform blog post</a>.</p>\n\n<h2>Config-driven remove</h2>\n\n<p>During the infrastructure lifecycle, it’s sometimes necessary to modify the state of a resource. The Terraform CLI has multiple commands related to state manipulation, but these all face similar challenges: they operate on only one resource at a time, must be performed locally with direct access to state and credentials, and they immediately modify the state. This is risky because it leaves the configuration and state out of sync, which can lead to accidental resource changes. That’s why in Terraform 1.1 we introduced the concept of <a href=\"https://www.hashicorp.com/blog/terraform-1-1-improves-refactoring-and-the-cloud-cli-experience#easier-and-safer-refactoring-with-moved-statements\">config-driven refactoring with the <code>moved</code> block</a>, and continued this with <a href=\"https://www.hashicorp.com/blog/terraform-1-5-brings-config-driven-import-and-checks#config-driven-import\">config-driven import in Terraform 1.5</a>. Today with Terraform 1.7, this concept has again been extended with <em>config-driven remove</em>.</p>\n\n<p>There are several reasons why you might need to remove a resource from state without actually destroying it:</p>\n\n<ul>\n<li>Moving resources between workspaces</li>\n<li>Cleaning up state after apply-time failures</li>\n<li>Refresh failures due to manual resource changes</li>\n<li>Provider deprecations and upgrades</li>\n</ul>\n\n<p>As an alternative to the <code>terraform state rm</code> command, the <code>removed</code> block addresses all of these challenges. Just like the <code>moved</code> and <code>import</code> blocks, state removal can now be performed in bulk and is plannable, so you can be confident that the operation will have the intended effect before modifying state. Removed blocks have a simple syntax:</p>\n<pre><code>removed {\n  # The resource address to remove from state\n  from = aws_instance.example\n\n  # The lifecycle block instructs Terraform not to destroy the underlying resource\n  lifecycle {\n    destroy = false\n  }\n}</code></pre><p>Config-driven remove is also compatible with all Terraform Cloud workflows including VCS-driven workspaces. And soon, structured run output in Terraform Cloud will be able to visually render removal actions alongside other plan activity. Read more about <a href=\"https://developer.hashicorp.com/terraform/language/resources/syntax#removing-resources\">using <code>removed</code> blocks with resources</a> and <a href=\"https://developer.hashicorp.com/terraform/language/modules/syntax#removing-modules\">using <code>removed</code> blocks with modules</a> in the Terraform documentation, and try it out with the updated <a href=\"https://developer.hashicorp.com/terraform/tutorials/state/state-cli\">Manage resources in Terraform state tutorial</a>.</p>\n\n<h2>Import block for_each</h2>\n\n<p>Terraform 1.7 also includes an enhancement for config-driven import: the ability to expand <code>import</code> blocks using <code>for_each</code> loops. Previously you could target a particular instance of a resource in the <code>to</code> attribute of an import block, but you had to write a separate import block for each instance. Now you can accomplish this with a single import block:</p>\n<pre><code>locals {\n  buckets = {\n    \"staging\" = \"bucket-demoapp-staging\"\n    \"uat\"     = \"bucket-demoapp-uat\"\n    \"prod\"    = \"bucket-demoapp-prod\"\n  }\n}\n\nimport {\n  for_each = local.buckets\n  to       = aws_s3_bucket.example[each.key]\n  id       = each.value\n}\n\nresource \"aws_s3_bucket\" \"example\" {\n  for_each = local.buckets\n  bucket   = each.value\n}</code></pre><p>This technique can also be used to expand imports across multiple module instances. Learn more and see an example in the <a href=\"https://developer.hashicorp.com/terraform/language/v1.7.x/import#import-multiple-instances-with-for_each\">Import documentation</a>.</p>\n\n<h2>Get started with Terraform 1.7</h2>\n\n<p>For more details and to learn about all of the enhancements in Terraform 1.7, please review the full <a href=\"https://github.com/hashicorp/terraform/releases/tag/v1.7.0\">HashiCorp Terraform 1.7 changelog</a>. Additional resource links include:</p>\n\n<ul>\n<li><a href=\"https://developer.hashicorp.com/terraform/downloads\">Download Terraform 1.7</a></li>\n<li><a href=\"https://app.terraform.io/public/signup/account\">Sign up for a free Terraform Cloud account</a></li>\n<li>Read the <a href=\"https://developer.hashicorp.com/terraform/language/v1.7.x/upgrade-guides\">Terraform 1.7 upgrade guide</a></li>\n<li>Get hands-on with tutorials at <a href=\"https://developer.hashicorp.com/terraform/tutorials\">HashiCorp Developer</a></li>\n</ul>\n\n<p>As always, this release wouldn't have been possible without all of the great community feedback we've received via GitHub issues and from our customers. Thank you!</p>\n","author":"Dan Barr","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"3d6b37981054c47c5e8c248f546982cc89475af20e0e94c629670309269d7a84","category":"Tech"}