{"title":"Creating A Multi-Author Blog With Next.js","link":"https://smashingmagazine.com/2021/06/creating-multi-author-blog-nextjs/","date":1624620600000,"content":"<p>In this article, we are going to build a blog with Next.js that supports two or more authors. We will attribute each post to an author and show their name and picture with their posts. Each author also gets a profile page, which lists all posts they contributed. It will look something like this:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/28f01cad-c083-43df-bb1e-509c8e5b5d21/001-creating-multi-author-blog-nextjs.png\" /></p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/3a27dd24-d92a-4f34-ad30-05078f96fdb2/3-multi-author-blog-nextjs.png\" /></p>\n<p>We are going to keep all information in files on the local filesystem. The two types of content, posts and authors, will use different types of files. The text-heavy posts will use Markdown, allowing for an easier editing process. Because the information on authors is lighter, we will keep that in JSON files. Helper functions will make reading different file types and combining their content easier.</p>\n<p>Next.js lets us read data from different sources and of different types effortlessly. Thanks to its dynamic routing and <code>next/link</code>, we can quickly build and navigate to our site’s various pages. We also get image optimization for free with the <code>next/image</code> package.</p>\n<p>By picking the “batteries included” Next.js, we can focus on our application itself. We don’t have to spend any time on the repetitive groundwork new projects often come with. Instead of building everything by hand, we can rely on the tested and proven framework. The large and active community behind Next.js makes it easy to get help if we run into issues along the way.</p>\n<p>After reading this article, you will be able to add many kinds of content to a single Next.js project. You will also be able to create relationships between them. That allows you to link things like authors and posts, courses and lessons, or actors and movies.</p>\n<p>This article assumes basic familiarity with Next.js. If you have not used it before, you might want to read up on <a href=\"https://nextjs.org/docs/basic-features/pages\">how it handles pages and fetches data for them</a> first.</p>\n<p>We won’t cover styling in this article and focus on making it all work instead. You can get the result <a href=\"https://github.com/domhabersack/nextjs-multiauthor-blog-starter\">on GitHub</a>. There is also <a href=\"https://github.com/domhabersack/nextjs-multiauthor-blog-starter/blob/main/styles/globals.css\">a stylesheet</a> you can drop into your project if you want to follow along with this article. To get the same frame, including the navigation, replace your <code>pages/_app.js</code> with <a href=\"https://github.com/domhabersack/nextjs-multiauthor-blog-starter/blob/main/pages/_app.js\">this file</a>.</p>\nSetup\n<p>We begin by setting up a new project using <a href=\"https://create-next-app.js.org\"><code>create-next-app</code></a> and changing to its directory:</p>\n<pre><code>$ npx create-next-app multiauthor-blog\n$ cd multiauthor-blog\n</code></pre>\n\n<p>We will need to read Markdown files later. To make this easier, we also add a few more dependencies before getting started.</p>\n<pre><code>multiauthor-blog$ yarn add gray-matter remark remark-html\n</code></pre>\n\n<p>Once the installation is complete, we can run the <code>dev</code> script to start our project:</p>\n<pre><code>multiauthor-blog$ yarn dev\n</code></pre>\n\n<p>We can now explore our site. In your browser, open <a href=\"http://localhost:3000\">http://localhost:3000</a>. You should see the default page added by create-next-app.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/1c903d1c-7555-4a96-9001-be31f5d1c884/4-multi-author-blog-nextjs.png\" /></p>\n<p>In a bit, we’ll need a navigation to reach our pages. We can add them in <code>pages/_app.js</code> even before the pages exist.</p>\n<pre><code>import Link from 'next/link'\n\nimport '../styles/globals.css'\n\nexport default function App({ Component, pageProps }) {\n  return (\n    &lt;&gt;\n      &lt;header&gt;\n        &lt;nav&gt;\n          &lt;ul&gt;\n            &lt;li&gt;\n              &lt;Link href=\"/\"&gt;\n                &lt;a&gt;Home&lt;/a&gt;\n              &lt;/Link&gt;\n            &lt;/li&gt;\n\n            &lt;li&gt;\n              &lt;Link href=\"/posts\"&gt;\n                &lt;a&gt;Posts&lt;/a&gt;\n              &lt;/Link&gt;\n            &lt;/li&gt;\n\n            &lt;li&gt;\n              &lt;Link href=\"/authors\"&gt;\n                &lt;a&gt;Authors&lt;/a&gt;\n              &lt;/Link&gt;\n            &lt;/li&gt;\n          &lt;/ul&gt;\n        &lt;/nav&gt;\n      &lt;/header&gt;\n\n      &lt;main&gt;\n        &lt;Component {...pageProps} /&gt;\n      &lt;/main&gt;\n    &lt;/&gt;\n  )\n}\n</code></pre>\n\n<p>Throughout this article, we’ll add these missing pages the navigation points to. Let’s first add some posts so we have something to work with on a blog overview page.</p>\nCreating Posts\n<p>To keep our content separate from the code, we’ll put our posts in a directory called <code>_posts/</code>. To make writing and editing easier, we’ll create each post as a Markdown file. Each post’s filename will serve as the slug in our routes later. The file <code>_posts/hello-world.md</code> will be accessible under <code>/posts/hello-world</code>, for example.</p>\n<p>Some information, like the full title and a short excerpt, goes in the frontmatter at the beginning of the file.</p>\n<pre><code>---\ntitle: \"Hello World!\"\nexcerpt: \"This is my first blog post.\"\ncreatedAt: \"2021-05-03\"\n---\nHey, how are you doing? Welcome to my blog. In this post, …\n</code></pre>\n\n<p>Add a few more files like this so the blog doesn’t start out empty:</p>\n<pre><code>multi-author-blog/\n├─ _posts/\n│  ├─ hello-world.md\n│  ├─ multi-author-blog-in-nextjs.md\n│  ├─ styling-react-with-tailwind.md\n│  └─ ten-hidden-gems-in-javascript.md\n└─ pages/\n   └─ …\n </code></pre>\n\n<p>You can add your own or grab <a href=\"https://github.com/domhabersack/nextjs-multiauthor-blog-starter/tree/main/_posts\">these sample posts</a> from the GitHub repository.</p>\nListing All Posts\n<p>Now that we have a few posts, we need a way to get them onto our blog. Let’s start by adding a page that lists them all, serving as the index of our blog.</p>\n<p>In Next.js, a file created under <code>pages/posts/index.js</code> will be accessible as <code>/posts</code> on our site. The file must export a function that will serve as that page’s body. Its first version looks something like this:</p>\n<pre><code>export default function Posts() {\n  return (\n    &lt;div className=\"posts\"&gt;\n      &lt;h1&gt;Posts&lt;/h1&gt;\n\n      {/* TODO: render posts */}\n    &lt;/div&gt;\n  )\n}\n</code></pre>\n\n<p>We don’t get very far because we don’t have a way to read the Markdown files yet. We can already navigate to <a href=\"http://localhost:3000/posts\">http://localhost:3000/posts</a>, but we only see the heading.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ffca4ffa-7df3-487d-a304-d0a43d9ba19b/5-multi-author-blog-nextjs.png\" /></p>\n<p>We now need a way to get our posts on there. Next.js uses a function called <code>getStaticProps()</code> to pass data to a page component. The function passes the <code>props</code> in the returned object to the component as props.</p>\n<p>From <code>getStaticProps()</code>, we are going to pass the posts to the component as a prop called <code>posts</code>. We’ll hardcode two placeholder posts in this first step. By starting this way, we define what format we later want to receive the real posts in. If a helper function returns them in this format, we can switch over to it without changing the component.</p>\n<p>The post overview won’t show the full text of the posts. For this page, the title, excerpt, permalink, and date of each post are enough.</p>\n<pre><code> export default function Posts() { … }\n\n+export function getStaticProps() {\n+  return {\n+    props: {\n+      posts: [\n+        {\n+          title: \"My first post\",\n+          createdAt: \"2021-05-01\",\n+          excerpt: \"A short excerpt summarizing the post.\",\n+          permalink: \"/posts/my-first-post\",\n+          slug: \"my-first-post\",\n+        }, {\n+          title: \"My second post\",\n+          createdAt: \"2021-05-04\",\n+          excerpt: \"Another summary that is short.\",\n+          permalink: \"/posts/my-second-post\",\n+          slug: \"my-second-post\",\n+        }\n+      ]\n+    }\n+  }\n+}\n</code></pre>\n\n<p>To check the connection, we can grab the posts from the props and show them in the <code>Posts</code> component. We’ll include the title, date of creation, excerpt, and a link to the post. For now, that link won’t lead anywhere yet.</p>\n<div>\n<pre><code>+import Link from 'next/link'\n\n-export default function Posts() {\n+export default function Posts({ posts }) {\n   return (\n     &lt;div className=\"posts\"&gt;\n       &lt;h1&gt;Posts&lt;/h1&gt;\n\n-      {/<em> TODO: render posts </em>/}\n+      {posts.map(post =&gt; {\n+        const prettyDate = new Date(post.createdAt).toLocaleString('en-US', {\n+          month: 'short',\n+          day: '2-digit',\n+          year: 'numeric',\n+        })\n+\n+        return (\n+          &lt;article key={post.slug}&gt;\n+            &lt;h2&gt;\n+              &lt;Link href={post.permalink}&gt;\n+                &lt;a&gt;{post.title}&lt;/a&gt;\n+              &lt;/Link&gt;\n+            &lt;/h2&gt;\n+\n+            &lt;time dateTime={post.createdAt}&gt;{prettyDate}&lt;/time&gt;\n+\n+            &lt;p&gt;{post.excerpt}&lt;/p&gt;\n+\n+            &lt;Link href={post.permalink}&gt;\n+              &lt;a&gt;Read more →&lt;/a&gt;\n+            &lt;/Link&gt;\n+          &lt;/article&gt;\n+        )\n+      })}\n     &lt;/div&gt;\n   )\n }\n\n export function getStaticProps() { … }\n</code></pre>\n</div>\n\n<p>After reloading the page in the browser, it now shows these two posts:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/9bb9bbc3-d2aa-4320-8b17-01893b5217d1/6-multi-author-blog-nextjs.png\" /></p>\n<p>We don’t want to hardcode all our blog posts in <code>getStaticProps()</code> forever. After all, that is why we created all these files in the <code>_posts/</code> directory earlier. We now need a way to read those files and pass their content to the page component.</p>\n<p>There are a few ways we could do that. We could read the files right in <code>getStaticProps()</code>. Because this function runs on the server and not the client, we have access to native Node.js modules like <code>fs</code> in it. We could read, transform, and even manipulate local files in the same file we keep the page component.</p>\n<p>To keep the file short and focused on one task, we’re going to move that functionality to a separate file instead. That way, the <code>Posts</code> component only needs to display the data, without also having to read that data itself. This adds some separation and organization to our project.</p>\n<p>By convention, we are going to put functions reading data in a file called <code>lib/api.js</code>. That file will hold all functions that grab our content for the components that display it.</p>\n<p>For the posts overview page, we want a function that reads, processes, and returns all posts. We’ll call it <code>getAllPosts()</code>. In it, we first use <code>path.join()</code> to build the path to the <code>_posts/</code> directory. We then use <code>fs.readdirSync()</code> to read that directory, which gives us the names of all files in it. Mapping over these names, we then read each file in turn.</p>\n<div>\n<pre><code>import fs from 'fs'\nimport path from 'path'\n\nexport function getAllPosts() {\n  const postsDirectory = path.join(process.cwd(), '_posts')\n  const filenames = fs.readdirSync(postsDirectory)\n\n  return filenames.map(filename =&gt; {\n    const file = fs.readFileSync(path.join(process.cwd(), '_posts', filename), 'utf8')\n\n    // TODO: transform and return file\n  })\n}\n</code></pre>\n</div>\n\n<p>After reading the file, we get its contents as a long string. To separate the frontmatter from the text of the post, we run that string through <code>gray-matter</code>. We’re also going to grab each post’s slug by removing the <code>.md</code> from the end of its filename. We need that slug to build the URL from which the post will be accessible later. Since we don’t need the Markdown body of the posts for this function, we can ignore the remaining content.</p>\n<div>\n<pre><code>import fs from 'fs'\n import path from 'path'\n+import matter from 'gray-matter'\n\n export function getAllPosts() {\n   const postsDirectory = path.join(process.cwd(), '_posts')\n   const filenames = fs.readdirSync(postsDirectory)\n\n   return filenames.map(filename =&gt; {\n     const file = fs.readFileSync(path.join(process.cwd(), '_posts', filename), 'utf8')\n\n-    // TODO: transform and return file\n+    // get frontmatter\n+    const { data } = matter(file)\n+\n+    // get slug from filename\n+    const slug = filename.replace(/.md$/, '')\n+\n+    // return combined frontmatter and slug; build permalink\n+    return {\n+      ...data,\n+      slug,\n+      permalink: <code>/posts/${slug}</code>,\n+    }\n   })\n }\n</code></pre>\n</div>\n\n<p>Note how we spread <code>...data</code> into the returned object here. That lets us access values from its frontmatter as <code>{post.title}</code> instead of <code>{post.data.title}</code> later.</p>\n<p>Back in our posts overview page, we can now replace the placeholder posts with this new function.</p>\n<pre><code>+import { getAllPosts } from '../../lib/api'\n\n export default function Posts({ posts }) { … }\n\n export function getStaticProps() {\n   return {\n     props: {\n-      posts: [\n-        {\n-          title: \"My first post\",\n-          createdAt: \"2021-05-01\",\n-          excerpt: \"A short excerpt summarizing the post.\",\n-          permalink: \"/posts/my-first-post\",\n-          slug: \"my-first-post\",\n-        }, {\n-          title: \"My second post\",\n-          createdAt: \"2021-05-04\",\n-          excerpt: \"Another summary that is short.\",\n-          permalink: \"/posts/my-second-post\",\n-          slug: \"my-second-post\",\n-        }\n-      ]\n+      posts: getAllPosts(),\n     }\n   }\n }\n</code></pre>\n\n<p>After reloading the browser, we now see our real posts instead of the placeholders we had before.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b7b61bea-28b6-4ddd-b24a-20e984c4bff8/7-multi-author-blog-nextjs.png\" /></p>\nAdding Individual Post Pages\n<p>The links we added to each post don’t lead anywhere yet. There is no page that responds to URLs like <code>/posts/hello-world</code> yet. With <a href=\"https://nextjs.org/docs/routing/dynamic-routes\">dynamic routing</a>, we can add a page that matches all paths like this.</p>\n<p>A file created as <code>pages/posts/[slug].js</code> will match all URLs that look like <code>/posts/abc</code>. The value that appears instead of <code>[slug]</code> in the URL will be available to the page as a query parameter. We can use that in the corresponding page’s <code>getStaticProps()</code> as <code>params.slug</code> to call a helper function.</p>\n<p>As a counterpart to <code>getAllPosts()</code>, we’ll call that helper function <code>getPostBySlug(slug)</code>. Instead of all posts, it will return a single post that matches the slug we pass it. On a post’s page, we also need to show the underlying file’s Markdown content.</p>\n<p>The page for individual posts looks like the one for the post overview. Instead of passing <code>posts</code> to the page in <code>getStaticProps()</code>, we only pass a single <code>post</code>. Let’s do the general setup first before we look at how to transform the post’s Markdown body to usable HTML. We’re going to skip the placeholder post here, using the helper function we’ll add in the next step immediately.</p>\n<div>\n<pre><code>import { getPostBySlug } from '../../lib/api'\n\nexport default function Post({ post }) {\n  const prettyDate = new Date(post.createdAt).toLocaleString('en-US', {\n    month: 'short',\n    day: '2-digit',\n    year: 'numeric',\n  })\n\n  return (\n    &lt;div className=\"post\"&gt;\n      &lt;h1&gt;{post.title}&lt;/h1&gt;\n\n      &lt;time dateTime={post.createdAt}&gt;{prettyDate}&lt;/time&gt;\n\n      {/<em> TODO: render body </em>/}\n    &lt;/div&gt;\n  )\n}\n\nexport function getStaticProps({ params }) {\n  return {\n    props: {\n      post: getPostBySlug(params.slug),\n    },\n  }\n}\n</code></pre>\n</div>\n\n<p>We now have to add the function <code>getPostBySlug(slug)</code> to our helper file <code>lib/api.js</code>. It is like <code>getAllPosts()</code>, with a few notable differences. Because we can get the post’s filename from the slug, we don’t need to read the entire directory first. If the slug is <code>'hello-world'</code>, we are going to read a file called <code>_posts/hello-world.md</code>. If that file doesn’t exist, Next.js will show a 404 error page.</p>\n<p>Another difference to <code>getAllPosts()</code> is that this time, we also need to read the post’s Markdown content. We can return it as render-ready HTML instead of raw Markdown by processing it with <code>remark</code> first.</p>\n<div>\n<pre><code> import fs from 'fs'\n import path from 'path'\n import matter from 'gray-matter'\n+import remark from 'remark'\n+import html from 'remark-html'\n\n export function getAllPosts() { … }\n\n+export function getPostBySlug(slug) {\n+  const file = fs.readFileSync(path.join(process.cwd(), '_posts', <code>${slug}.md</code>), 'utf8')\n+\n+  const {\n+    content,\n+    data,\n+  } = matter(file)\n+\n+  const body = remark().use(html).processSync(content).toString()\n+\n+  return {\n+    ...data,\n+    body,\n+  }\n+}\n</code></pre>\n</div>\n\n<p>In theory, we could use the function <code>getAllPosts()</code> inside <code>getPostBySlug(slug)</code>. We’d first get all posts with it, which we could then search for one that matches the given slug. That would mean we would always need to read all posts before we could get a single one, which is unnecessary work. <code>getAllPosts()</code> also doesn’t return the posts’ Markdown content. We could update it to do that, in which case it would do more work than it currently needs to.</p>\n<p>Because the two helper functions do different things, we are going to keep them separate. That way, we can focus the functions on exactly and only the job we need each of them to do.</p>\n<p>Pages that use dynamic routing can provide a <code>getStaticPaths()</code> next to their <code>getStaticProps()</code>. This function tells Next.js what values of the dynamic path segments to build pages for. We can provide those by using <code>getAllPosts()</code> and returning a list of objects that define each post’s <code>slug</code>.</p>\n<pre><code>-import { getPostBySlug } from '../../lib/api'\n+import { getAllPosts, getPostBySlug } from '../../lib/api'\n\n export default function Post({ post }) { … }\n\n export function getStaticProps({ params }) { … }\n\n+export function getStaticPaths() {\n+  return {\n+    fallback: false,\n+    paths: getAllPosts().map(post =&gt; ({\n+      params: {\n+        slug: post.slug,\n+      },\n+    })),\n+  }\n+}\n</code></pre>\n\n<p>Since we parse the Markdown content in <code>getPostBySlug(slug)</code>, we can render it on the page now. We need to use <code>dangerouslySetInnerHTML</code> for this step so Next.js can render the HTML behind <code>post.body</code>. Despite its name, it is safe to use the property in this scenario. Because we have full control over our posts, it is unlikely they are going to inject unsafe scripts.</p>\n<div>\n<pre><code> import { getAllPosts, getPostBySlug } from '../../lib/api'\n\n export default function Post({ post }) {\n  const prettyDate = new Date(post.createdAt).toLocaleString('en-US', {\n    month: 'short',\n    day: '2-digit',\n    year: 'numeric',\n  })\n\n   return (\n     &lt;div className=\"post\"&gt;\n       &lt;h1&gt;{post.title}&lt;/h1&gt;\n\n       &lt;time dateTime={post.createdAt}&gt;{prettyDate}&lt;/time&gt;\n\n-      {/<em> TODO: render body </em>/}\n+      &lt;div dangerouslySetInnerHTML={{ __html: post.body }} /&gt;\n     &lt;/div&gt;\n   )\n }\n\n export function getStaticProps({ params }) { … }\n\n export function getStaticPaths() { … }\n</code></pre>\n</div>\n\n<p>If we follow one of the links from the post overview, we now get to that post’s own page.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/38f5e54e-2fe7-4b85-a813-d4c4629b787c/8-multi-author-blog-nextjs.png\" /></p>\nAdding Authors\n<p>Now that we have posts wired up, we need to repeat the same steps for our authors. This time, we’ll use JSON instead of Markdown to describe them. We can mix different types of files in the same project like this whenever it makes sense. The helper functions we use to read the files take care of any differences for us. Pages can use these functions without knowing what format we store our content in.</p>\n<p>First, create a directory called <code>_authors/</code> and add a few author files to it. As we did with posts, name the files by each author’s slug. We’ll use that to look up authors later. In each file, we specify an author’s full name in a JSON object.</p>\n<pre><code>{\n  \"name\": \"Adrian Webber\"\n}\n</code></pre>\n\n<p>For now, having two authors in our project is enough.</p>\n<p>To give them some more personality, let’s also add a profile picture for each author. We’ll put those static files in the <code>public/</code> directory. By naming the files by the same slug, we can connect them using the implied convention alone. We could add the path of the picture to each author’s JSON file to link the two. By naming all files by the slugs, we can manage this connection without having to write it out. The JSON objects only need to hold information we can’t build with code.</p>\n<p>When you’re done, your project directory should look something like this.</p>\n<pre><code>multi-author-blog/\n├─ _authors/\n│  ├─ adrian-webber.json\n│  └─ megan-carter.json\n├─ _posts/\n│  └─ …\n├─ pages/\n│  └─ …\n└─ public/\n   ├─ adrian-webber.jpg\n   └─ megan-carter.jpg\n </code></pre>\n\n<p>Same as with the posts, we now need helper functions to read all authors and get individual authors. The new functions <code>getAllAuthors()</code> and <code>getAuthorBySlug(slug)</code> also go in <code>lib/api.js</code>. They do almost exactly the same as their post counterparts. Because we use JSON to describe authors, we don’t need to parse any Markdown with <code>remark</code> here. We also don’t need <code>gray-matter</code> to parse frontmatter. Instead, we can use JavaScript’s built-in <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse\"><code>JSON.parse()</code></a> to read the text contents of our files into objects.</p>\n<pre><code>const contents = fs.readFileSync(somePath, 'utf8')\n// ⇒ looks like an object, but is a string\n//   e.g. '{ \"name\": \"John Doe\" }'\n\nconst json = JSON.parse(contents)\n// ⇒ a real JavaScript object we can do things with\n//   e.g. { name: \"John Doe\" }\n</code></pre>\n\n<p>With that knowledge, our helper functions look like this:</p>\n<div>\n<pre><code> export function getAllPosts() { … }\n\n export function getPostBySlug(slug) { … }\n\n+export function getAllAuthors() {\n+  const authorsDirectory = path.join(process.cwd(), '_authors')\n+  const filenames = fs.readdirSync(authorsDirectory)\n+\n+  return filenames.map(filename =&gt; {\n+    const file = fs.readFileSync(path.join(process.cwd(), '_authors', filename), 'utf8')\n+\n+    // get data\n+    const data = JSON.parse(file)\n+\n+    // get slug from filename\n+    const slug = filename.replace(/.json/, '')\n+\n+    // return combined frontmatter and slug; build permalink\n+    return {\n+      ...data,\n+      slug,\n+      permalink: <code>/authors/${slug}</code>,\n+      profilePictureUrl: <code>${slug}.jpg</code>,\n+    }\n+  })\n+}\n+\n+export function getAuthorBySlug(slug) {\n+  const file = fs.readFileSync(path.join(process.cwd(), '_authors', <code>${slug}.json</code>), 'utf8')\n+\n+  const data = JSON.parse(file)\n+\n+  return {\n+    ...data,\n+    permalink: <code>/authors/${slug}</code>,\n+    profilePictureUrl: <code>/${slug}.jpg</code>,\n+    slug,\n+  }\n+}\n</code></pre>\n</div>\n\n<p>With a way to read authors into our application, we can now add a page that lists them all. Creating a new page under <code>pages/authors/index.js</code> gives us an <code>/authors</code> page on our site.</p>\n<p>The helper functions take care of reading the files for us. This page component does not need to know authors are JSON files in the filesystem. It can use <code>getAllAuthors()</code> without knowing where or how it gets its data. The format does not matter as long as our helper functions return their data in a format we can work with. Abstractions like this let us mix different types of content across our application.</p>\n<p>The index page for authors looks a lot like the one for posts. We get all authors in <code>getStaticProps()</code>, which passes them to the <code>Authors</code> component. That component maps over each author and lists some information about them. We don’t need to build any other links or URLs from the slug. The helper function already returns the authors in a usable format.</p>\n<div>\n<pre><code>import Image from 'next/image'\nimport Link from 'next/link'\n\nimport { getAllAuthors } from '../../lib/api/authors'\n\nexport default function Authors({ authors }) {\n  return (\n    &lt;div className=\"authors\"&gt;\n      &lt;h1&gt;Authors&lt;/h1&gt;\n\n      {authors.map(author =&gt; (\n        &lt;div key={author.slug}&gt;\n          &lt;h2&gt;\n            &lt;Link href={author.permalink}&gt;\n              &lt;a&gt;{author.name}&lt;/a&gt;\n            &lt;/Link&gt;\n          &lt;/h2&gt;\n\n          &lt;Image alt={author.name} src={author.profilePictureUrl} height=\"40\" width=\"40\" /&gt;\n\n          &lt;Link href={author.permalink}&gt;\n            &lt;a&gt;Go to profile →&lt;/a&gt;\n          &lt;/Link&gt;\n        &lt;/div&gt;\n      ))}\n    &lt;/div&gt;\n  )\n}\n\nexport function getStaticProps() {\n  return {\n    props: {\n      authors: getAllAuthors(),\n    },\n  }\n}\n</code></pre>\n</div>\n\n<p>If we visit <code>/authors</code> on our site, we see a list of all authors with their names and pictures.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7ff7a205-3c5a-4b51-ae05-91042aa1225f/9-multi-author-blog-nextjs.png\" /></p>\n<p>The links to the authors’ profiles don’t lead anywhere yet. To add the profile pages, we create a file under <code>pages/authors/[slug].js</code>. Because authors don’t have any text content, all we can add for now are their names and profile pictures. We also need another <code>getStaticPaths()</code> to tell Next.js what slugs to build pages for.</p>\n<div>\n<pre><code>import Image from 'next/image'\n\nimport { getAllAuthors, getAuthorBySlug } from '../../lib/api'\n\nexport default function Author({ author }) {\n  return (\n    &lt;div className=\"author\"&gt;\n      &lt;h1&gt;{author.name}&lt;/h1&gt;\n\n      &lt;Image alt={author.name} src={author.profilePictureUrl} height=\"80\" width=\"80\" /&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport function getStaticProps({ params }) {\n  return {\n    props: {\n      author: getAuthorBySlug(params.slug),\n    },\n  }\n}\n\nexport function getStaticPaths() {\n  return {\n    fallback: false,\n    paths: getAllAuthors().map(author =&gt; ({\n      params: {\n        slug: author.slug,\n      },\n    })),\n  }\n}\n</code></pre>\n</div>\n\n<p>With this, we now have a basic author profile page that is very light on information.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/e31fe8ec-42a5-4931-bb8e-311878e12475/10-multi-author-blog-nextjs.png\" /></p>\n<p>At this point, authors and posts are not connected yet. We’ll build that bridge next so we can add a list of each authors’ posts to their profile pages.</p>\nConnecting Posts And Authors\n<p>To connect two pieces of content, we need to reference one in the other. Since we already identify posts and authors by their slugs, we’ll reference them with that. We could add authors to posts and posts to authors, but one direction is enough to link them. Since we want to attribute posts to authors, we are going to add the author’s slug to each post’s frontmatter.</p>\n<pre><code> ---\n title: \"Hello World!\"\n excerpt: \"This is my first blog post.\"\n createdAt: \"2021-05-03\"\n+author: adrian-webber\n ---\n Hey, how are you doing? Welcome to my blog. In this post, …\n</code></pre>\n\n<p>If we keep it at that, running the post through <code>gray-matter</code> adds the author field to the post as a string:</p>\n<pre><code>const post = getPostBySlug(\"hello-world\")\nconst author = post.author\n\nconsole.log(author)\n// \"adrian-webber\"\n</code></pre>\n\n<p>To get the object representing the author, we can use that slug and call <code>getAuthorBySlug(slug)</code> with it.</p>\n<pre><code> const post = getPostBySlug(\"hello-world\")\n-const author = post.author\n+const author = getAuthorBySlug(post.author)\n\n console.log(author)\n // {\n //   name: \"Adrian Webber\",\n //   slug: \"adrian-webber\",\n //   profilePictureUrl: \"/adrian-webber.jpg\",\n //   permalink: \"/authors/adrian-webber\"\n // }\n</code></pre>\n\n<p>To add the author to a single post’s page, we need to call <code>getAuthorBySlug(slug)</code> once in <code>getStaticProps()</code>.</p>\n<div>\n<pre><code>+import Image from 'next/image'\n+import Link from 'next/link'\n\n-import { getPostBySlug } from '../../lib/api'\n+import { getAuthorBySlug, getPostBySlug } from '../../lib/api'\n\n export default function Post({ post }) {\n   const prettyDate = new Date(post.createdAt).toLocaleString('en-US', {\n     month: 'short',\n     day: '2-digit',\n     year: 'numeric',\n   })\n\n   return (\n     &lt;div className=\"post\"&gt;\n       &lt;h1&gt;{post.title}&lt;/h1&gt;\n\n       &lt;time dateTime={post.createdAt}&gt;{prettyDate}&lt;/time&gt;\n\n+      &lt;div&gt;\n+        &lt;Image alt={post.author.name} src={post.author.profilePictureUrl} height=\"40\" width=\"40\" /&gt;\n+\n+        &lt;Link href={post.author.permalink}&gt;\n+          &lt;a&gt;\n+            {post.author.name}\n+          &lt;/a&gt;\n+        &lt;/Link&gt;\n+      &lt;/div&gt;\n\n       &lt;div dangerouslySetInnerHTML={{ __html: post.body }}&gt;\n     &lt;/div&gt;\n   )\n }\n\n export function getStaticProps({ params }) {\n+  const post = getPostBySlug(params.slug)\n\n   return {\n     props: {\n-      post: getPostBySlug(params.slug),\n+      post: {\n+        ...post,\n+        author: getAuthorBySlug(post.author),\n+      },\n     },\n   }\n }\n</code></pre>\n</div>\n\n<p>Note how we spread <code>...post</code> into an object also called <code>post</code> in <code>getStaticProps()</code>. By placing <code>author</code> after that line, we end up replacing the string version of the author with its full object. That lets us access an author’s properties through <code>post.author.name</code> in the <code>Post</code> component.</p>\n<p>With that change, we now get a link to the author’s profile page, complete with their name and picture, on a post’s page.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/5c7ecc97-76d5-4784-a0e3-f8b29dfe0d16/11-multi-author-blog-nextjs.png\" /></p>\n<p>Adding authors to the post overview page requires a similar change. Instead of calling <code>getAuthorBySlug(slug)</code> once, we need to map over all posts and call it for each one of them.</p>\n<div>\n<pre><code>+import Image from 'next/image'\n+import Link from 'next/link'\n\n-import { getAllPosts } from '../../lib/api'\n+import { getAllPosts, getAuthorBySlug } from '../../lib/api'\n\n export default function Posts({ posts }) {\n   return (\n     &lt;div className=\"posts\"&gt;\n       &lt;h1&gt;Posts&lt;/h1&gt;\n\n       {posts.map(post =&gt; {\n         const prettyDate = new Date(post.createdAt).toLocaleString('en-US', {\n           month: 'short',\n           day: '2-digit',\n           year: 'numeric',\n         })\n\n         return (\n           &lt;article key={post.slug}&gt;\n             &lt;h2&gt;\n               &lt;Link href={post.permalink}&gt;\n                 &lt;a&gt;{post.title}&lt;/a&gt;\n               &lt;/Link&gt;\n             &lt;/h2&gt;\n\n             &lt;time dateTime={post.createdAt}&gt;{prettyDate}&lt;/time&gt;\n\n+            &lt;div&gt;\n+              &lt;Image alt={post.author.name} src={post.author.profilePictureUrl} height=\"40\" width=\"40\" /&gt;\n+\n+              &lt;span&gt;{post.author.name}&lt;/span&gt;\n+            &lt;/div&gt;\n\n             &lt;p&gt;{post.excerpt}&lt;/p&gt;\n\n             &lt;Link href={post.permalink}&gt;\n               &lt;a&gt;Read more →&lt;/a&gt;\n             &lt;/Link&gt;\n           &lt;/article&gt;\n         )\n       })}\n     &lt;/div&gt;\n   )\n }\n\n export function getStaticProps() {\n   return {\n     props: {\n-      posts: getAllPosts(),\n+      posts: getAllPosts().map(post =&gt; ({\n+        ...post,\n+        author: getAuthorBySlug(post.author),\n+      })),\n    }\n  }\n}\n</code></pre>\n</div>\n\n<p>That adds the authors to each post in the post overview:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/cdc81aa3-6c7b-4040-a8c6-b6669c5ec838/12-multi-author-blog-nextjs.png\" /></p>\n<p>We don’t need to add a list of an author’s posts to their JSON file. On their profile pages, we first get all posts with <code>getAllPosts()</code>. We can then filter the full list for the ones attributed to this author.</p>\n<div>\n<pre><code>import Image from 'next/image'\n+import Link from 'next/link'\n\n-import { getAllAuthors, getAuthorBySlug } from '../../lib/api'\n+import { getAllAuthors, getAllPosts, getAuthorBySlug } from '../../lib/api'\n\n export default function Author({ author }) {\n   return (\n     &lt;div className=\"author\"&gt;\n       &lt;h1&gt;{author.name}&lt;/h1&gt;\n\n       &lt;Image alt={author.name} src={author.profilePictureUrl} height=\"40\" width=\"40\" /&gt;\n\n+      &lt;h2&gt;Posts&lt;/h2&gt;\n+\n+      &lt;ul&gt;\n+        {author.posts.map(post =&gt; (\n+          &lt;li&gt;\n+            &lt;Link href={post.permalink}&gt;\n+              &lt;a&gt;\n+                {post.title}\n+              &lt;/a&gt;\n+            &lt;/Link&gt;\n+          &lt;/li&gt;\n+        ))}\n+      &lt;/ul&gt;\n     &lt;/div&gt;\n   )\n }\n\n export function getStaticProps({ params }) {\n   const author = getAuthorBySlug(params.slug)\n\n   return {\n     props: {\n-      author: getAuthorBySlug(params.slug),\n+      author: {\n+        ...author,\n+        posts: getAllPosts().filter(post =&gt; post.author === author.slug),\n+      },\n     },\n   }\n }\n\n export function getStaticPaths() { … }\n</code></pre>\n</div>\n\n<p>This gives us a list of articles on every author’s profile page.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/4b8baa6e-8d8e-43d1-8033-802ded0d74d8/13-multi-author-blog-nextjs.png\" /></p>\n<p>On the author overview page, we’ll only add how many posts they have written to not clutter the interface.</p>\n<div>\n<pre><code>import Image from 'next/image'\nimport Link from 'next/link'\n\n-import { getAllAuthors } from '../../lib/api'\n+import { getAllAuthors, getAllPosts } from '../../lib/api'\n\n export default function Authors({ authors }) {\n   return (\n     &lt;div className=\"authors\"&gt;\n       &lt;h1&gt;Authors&lt;/h1&gt;\n\n       {authors.map(author =&gt; (\n         &lt;div key={author.slug}&gt;\n           &lt;h2&gt;\n             &lt;Link href={author.permalink}&gt;\n               &lt;a&gt;\n                 {author.name}\n               &lt;/a&gt;\n             &lt;/Link&gt;\n           &lt;/h2&gt;\n\n           &lt;Image alt={author.name} src={author.profilePictureUrl} height=\"40\" width=\"40\" /&gt;\n\n+         &lt;p&gt;{author.posts.length} post(s)&lt;/p&gt;\n\n           &lt;Link href={author.permalink}&gt;\n             &lt;a&gt;Go to profile →&lt;/a&gt;\n           &lt;/Link&gt;\n         &lt;/div&gt;\n       ))}\n     &lt;/div&gt;\n   )\n }\n\n export function getStaticProps() {\n   return {\n     props: {\n-      authors: getAllAuthors(),\n+      authors: getAllAuthors().map(author =&gt; ({\n+        ...author,\n+        posts: getAllPosts().filter(post =&gt; post.author === author.slug),\n+      })),\n     }\n   }\n }\n</code></pre>\n</div>\n\n<p>With that, the Authors overview page shows how many posts each author has contributed.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/eaf63b06-a805-4961-84a0-4a95b5e46792/14-multi-author-blog-nextjs.png\" /></p>\n<p>And that’s it! Posts and authors are completely linked up now. We can get from a post to an author’s profile page, and from there to their other posts.</p>\nSummary And Outlook\n<p>In this article, we connected two related types of content through their unique slugs. Defining the relationship from post to author enabled a variety of scenarios. We can now show the author on each post and list their posts on their profile pages.</p>\n<p>With this technique, we can add many other kinds of relationships. Each post might have a reviewer on top of an author. We can set that up by adding a <code>reviewer</code> field to a post’s frontmatter.</p>\n<pre><code> ---\n title: \"Hello World!\"\n excerpt: \"This is my first blog post.\"\n createdAt: \"2021-05-03\"\n author: adrian-webber\n+reviewer: megan-carter\n ---\n Hey, how are you doing? Welcome to my blog. In this post, …\n</code></pre>\n\n<p>On the filesystem, the reviewer is another author from the <code>_authors/</code> directory. We can use <code>getAuthorBySlug(slug)</code> to get their information as well.</p>\n<pre><code> export function getStaticProps({ params }) {\n   const post = getPostBySlug(params.slug)\n\n   return {\n     props: {\n       post: {\n         ...post,\n         author: getAuthorBySlug(post.author),\n+        reviewer: getAuthorBySlug(post.reviewer),\n       },\n     },\n   }\n }\n</code></pre>\n\n<p>We could even support co-authors by naming two or more authors on a post instead of only a single person.</p>\n<pre><code> ---\n title: \"Hello World!\"\n excerpt: \"This is my first blog post.\"\n createdAt: \"2021-05-03\"\n-author: adrian-webber\n+authors:\n+  - adrian-webber\n+  - megan-carter\n ---\n Hey, how are you doing? Welcome to my blog. In this post, …\n</code></pre>\n\n<p>In this scenario, we could no longer look up a single author in a post’s <code>getStaticProps()</code>. Instead, we would map over this array of authors to get them all.</p>\n<pre><code> export function getStaticProps({ params }) {\n   const post = getPostBySlug(params.slug)\n\n   return {\n     props: {\n       post: {\n         ...post,\n-        author: getAuthorBySlug(post.author),\n+        authors: post.authors.map(getAuthorBySlug),\n       },\n     },\n   }\n }\n</code></pre>\n\n<p>We can also produce other kinds of scenarios with this technique. It enables any kind of one-to-one, one-to-many, or even many-to-many relationship. If your project also features newsletters and case studies, you can add authors to each of them as well.</p>\n<p>On a site all about the Marvel universe, we could connect characters and the movies they appear in. In sports, we could connect players and the teams they currently play for.</p>\n<p>Because helper functions hide the data source, content could come from different systems. We could read articles from the filesystem, comments from an API, and merge them into our code. If some piece of content relates to another type of content, we can connect them with this pattern.</p>\n<h3>Further Resources</h3>\n<p>Next.js offers more background on the functions we used in their page on <a href=\"https://nextjs.org/docs/basic-features/data-fetching\">Data Fetching</a>. It includes links to sample projects that fetch data from different types of sources.</p>\n<p>If you want to take this starter project further, check out these articles:</p>\n<ul>\n<li><a href=\"https://strapi.io/blog/building-a-css-tricks-website-clone-with-strapi-next-js\">Building a CSS Tricks Website Clone with Strapi and Next.js</a><br />Replace the files on the local filesystem with a Strapi-powered backend.</li>\n<li><a href=\"https://www.smashingmagazine.com/2020/09/comparison-styling-methods-next-js/\">Comparing Styling Methods in Next.js</a><br />Explore different ways of writing custom CSS to change this starter’s styling.</li>\n<li><a href=\"https://nextjs.org/blog/markdown\">Markdown/MDX with Next.js</a><br />Add MDX to your project so you can use JSX and React components in your Markdown.</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"00aa7d94821eab5bdb47357b54be4c4173c59f05f8309725a888192ddababd9d","category":"Tech"}