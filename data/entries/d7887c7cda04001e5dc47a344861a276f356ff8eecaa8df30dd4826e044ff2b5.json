{"title":"A Few Ways CSS Is Easier To Write In 2023","link":"https://smashingmagazine.com/2023/11/few-ways-css-easier-write-2023/","date":1700812800000,"content":"<p>A little while back, I poked at a number of <a href=\"https://geoffgraham.me/what-exactly-is-modern-css/\">“modern” CSS</a> features and <a href=\"https://www.smashingmagazine.com/2023/07/writing-css-2023/\">openly evaluated</a> whether or not they have really influenced the way I write styles.</p>\n<p><strong>Spoiler alert:</strong> The answer is not <em>much</em>. Some, but not to the extent that the styles I write today would look foreign when held side-by-side with a stylesheet from two or three years ago.</p>\n<p>That was a fun thought process but more academic than practicum. As I continue thinking about how I approach CSS today, I’m realizing that the differences are a lot more subtle than I may have expected — or have even noticed.</p>\n<p>CSS has gotten easier to write than it is different to write.</p>\n<p>And that’s not because of one hot screaming new feature that changes everything — say, Cascade Layers or new color spaces — but how many of the new features <em>work together</em> to make my styles more succinct, resilient, and even slightly defensive.</p>\n<p>Let me explain.</p>\nEfficient Style Groups\n<p>Here’s a quick hit. Rather than chaining <code>:hover</code> and <code>:focus</code> states together with comma separation, using the newer <code>:is()</code> pseudo-class makes it a more readable one-liner:</p>\n<pre><code>/* Tradition */\na:hover,\na:focus {\n  /* Styles */\n}\n\n/* More readable */\na:is(:hover, :focus) {\n  /* Styles */\n}\n</code></pre>\n\n<p>I say “more readable” because it’s not exactly more efficient. I simply like how it reads as normal conversation: <em>An anchor that is in hover or in focus is styled like this...</em></p>\n<p>Of course, <code>:is()</code> can most definitely make for a more efficient selector. Rather than make up some crazy example, <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/:is#simplifying_list_selectors\">you can check out MDN’s example</a> to see the efficiency powers of <code>:is()</code> and rejoice.</p>\nCentering\n<p>This is a classic example, right? The “traditional” approach for aligning an element in the center of its parent container was usually a no-brainer, so to speak. We reached for some variety of <code>margin: auto</code> to push an element from all sides inward until it sits plumb in the middle.</p>\n<p>That’s still an extremely effective solution for centering, as the <code>margin</code> shorthand looks at every direction. But say we only need to work in the <em>inline</em> direction, as in left and right, when working in a default horizontal left-to-write writing mode. That’s where the “traditional” approach falls apart a bit.</p>\n<pre><code>/* Traditional */\nmargin-left: auto;\nmargin-right: auto;\n</code></pre>\n\n<p>Maybe “falls apart” is heavy-handed. It’s more that it requires dropping the versatile <code>margin</code> shorthand and reaching specifically for two of its constituent properties, adding up to one more line of overhead. But, thanks to the concept of <strong>logical properties</strong>, we get two more shorthands of the <code>margin</code> variety: one for the <em>block</em> direction and one for the <em>inline</em> direction. So, going back to a situation where centering only needs to happen in the inline direction, we now have this to keep things efficient:</p>\n<pre><code>/* Easier! */\nmargin-inline: auto;\n</code></pre>\n\n<p>And you know what else? The simple fact that this example makes the subtle transition from physical properties to logical ones means that this little snippet is both as equally efficient as throwing <code>margin: auto</code> out there and resilient to changes in the writing mode. If the page suddenly finds itself in a vertical right-to-left mode, it still holds up by automatically centering the element in the inline direction when the inline direction flows up and down rather than left and right.</p>\nAdjusting For Writing Modes, In General\n<p>I’ve already extolled the virtues of logical properties. They actually may influence how I write CSS today more than any other CSS feature since Flexbox and CSS Grid.</p>\n<p>I certainly believe logical properties don’t get the credit they deserve, likely because document flow is a lot less exciting than, say, things like custom properties and container queries.</p>\n<p>Traditionally, we might write one set of styles for whatever is the “normal” writing direction, then target the writing mode on the HTML level using <code>[dir=\"rtl\"]</code> or whatever. Today, though, forget all that and use logical properties instead. That way, the layout follows the writing mode!</p>\n<p>So, where we may normally need to reset a physical margin when changing writing modes like this:</p>\n<pre><code>/* Traditional */\nbody {\n  margin-left: 1rem;\n}\n\nbody[dir=\"rtl\"] {\n  margin-left: 0; /* reset left margin */\n  margin-right: 1rem; /* apply to the right */\n  text-align: right; /* push text to the other side */\n}\n</code></pre>\n\n<p>... there’s no longer a need to rest things as long as we’re working with logical properties:</p>\n<pre><code>/* Much easier! */\nbody {\n  margin-inline-start: 1rem;\n}\n</code></pre>\n\nTrimming Superfluous Spacing\n<p>Here’s another common pattern. I’m sure you’ve used an unordered list of links inside of a <code>&lt;nav&gt;</code> for the main or global navigation of a project.</p>\n<pre><code>&lt;nav&gt;\n  &lt;ul&gt;\n    &lt;li&gt;&lt;a href=\"/products\"&gt;Products&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"/products\"&gt;Services&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"/products\"&gt;Docs&lt;/a&gt;&lt;/li&gt;\n    &lt;!-- etc. --&gt;\n  &lt;ul&gt;\n&lt;/nav&gt;\n</code></pre>\n\n<p>And in those cases, I’m sure you’ve been asked to display those links side-by-side rather than allowing them to stack vertically as an unordered list is naturally wont to do. Some of us who have been writing styles for some years may have muscle memory for changing the <code>display</code> of those list items from default block-level elements into inline elements while preserving the box model properties of block elements:</p>\n<pre><code>/* Traditional */\nli {\n  display: inline-block;\n}\n</code></pre>\n\n<p>You’re going to need space between those list items. After all, they no longer take up the full available width of their parent since <code>inline-block</code> elements are only as wide as the content they contain, plus whatever borders, padding, margin, and offsets we add. Traditionally, that meant reaching for <code>margin</code> as we do for centering, but only the constituent <code>margin</code> property that applies the margin in the inline direction we want, whether that is <code>margin-left</code>/<code>margin-inline-start</code> or <code>margin-right</code>/<code>margin-inline-end</code>.</p>\n<p>Let’s assume we’re working with logical properties and want a margin at the end of the list of items in the inline direction:</p>\n<pre><code>/* Traditional */\nli {\n  display: inline-block;\n  margin-inline-end: 1rem;\n}\n</code></pre>\n\n<p>But wait! Now we have margin on <em>all</em> of the list items. There’s really no need for a margin on the last list item because, well, there are no other items after it.</p>\n<p><img src=\"https://files.smashing.media/articles/few-ways-css-easier-write-2023/1-margin-trim.png\" /></p>\n<p>That may be cool in the vast majority of situations, but it leaves the layout susceptible. What if, later, we decide to display another element next to the <code>&lt;nav&gt;</code>? Suddenly, we’re dealing with superfluous spacing that might affect how we decide to style that new element. It’s a form of <a href=\"https://css-tricks.com/defining-and-dealing-with-technical-debt/\">technical debt</a>.</p>\n<p>It would be better to clean that up and tackle spacing for reals without that worry. We could reach for a more modern feature like the <code>:not()</code> pseudo-class. That way, we can <em>exclude</em> the last list item from participating in the margin party.</p>\n<pre><code>/* A little more modern */\nli {\n  display: inline-block;\n}\nli:not(:last-of-type) {\n  margin-inline-end: 1rem;\n}\n</code></pre>\n\n<p>Even easier? Even <em>more</em> modern? We could reach for the <code>margin-trim</code> property, which, when applied to the parent element, chops off superfluous spacing like a good haircut, effectively collapsing margins that prevent the child elements from sitting flush with the parent’s edges.</p>\n<pre><code>/* Easier, more modern */\nul {\n  margin-trim: inline-end;\n}\n\nli {\n  display: inline-block;\n  margin-inline-end: 1rem;\n}\n</code></pre>\n\n<p>Before any pitchforks are raised, let’s note that <code>margin-trim</code> is experimental and <a href=\"https://caniuse.com/mdn-css_properties_margin-trim\">only supported by Safari</a> at the time I’m writing this. So, yes, this is <em>bleeding-edge</em> modern stuff and not exactly the sort of thing you want to ship straight to production. Just because something is “modern” doesn’t mean it’s the right tool for the job!</p>\n<p>In fact, there’s probably an even better solution without all the caveats, and it’s been sitting right under our noses: <strong>Flexbox</strong>. Turning the unordered list into a flexible container overrides the default block-level flow of the list items without changing their display, giving us the side-by-side layout we want. Plus, we gain access to the <code>gap</code> property, which you might think of as <code>margin</code> with <code>margin-trim</code> built right in because it only applies space <em>between</em> the children rather than all sides of them.</p>\n<pre><code>/* Less modern, but even easier! */\nul {\n  display: flex;\n  gap: 1rem;\n}\n</code></pre>\n\n<p>This is what I love about CSS. It’s poetic in the sense that <a href=\"https://css-tricks.com/hearts-in-html-and-css/\">there are many ways to say the same thing</a> — some are more elegant than others — but <strong>the “best” approach is the one that fits your thinking model</strong>. Don’t let anyone tell you you’re wrong if the output is what you’re expecting.</p>\n<p>Just because we’re on the topic of styling lists that don’t look like lists, it’s worth noting that the common task of removing list styles on both ordered and unordered lists (<code>list-style-type: none</code>) <a href=\"https://web.dev/articles/creative-list-styling#styling_lists_that_dont_look_like_lists\">has a side effect in Safari that strips the list items of its default accessible role</a>. One way to “fix” it (if you consider it a breaking change) is to add the role back in HTML a là <code>&lt;ul role=\"list&gt;</code>. Manuel Matuzović has another approach that allows us to stay in CSS by <a href=\"https://matuzo.at/blog/2023/removing-list-styles-without-affecting-semantics\">removing the list style type with a value of empty quotes</a>:</p>\n<pre><code>ul {\n  list-style-type: \"\";\n}\n</code></pre>\n\n<p>I appreciate that Manuel not only shared the idea but has provided the results of light testing as well while noting that more testing might be needed to ensure it doesn’t introduce other latent consequences.</p>\nMaintaining Proportions\n<p>There’s no need to dwell on this one. We used to have very few options for maintaining an element’s physical proportions. For example, if you want a perfect square, you could rely on fixed pixel units explicitly declared on the element’s <code>width</code> and <code>height</code>:</p>\n<pre><code>/* Traditional */\nheight: 500px;\nwidth: 500px;\n</code></pre>\n\n<p>Or, perhaps you need the element’s size to flex a bit, so you prefer relative units. In that case, something like percentages is difficult because a value like <code>50%</code> is relative to the size of the element’s parent container rather than the element itself. The parent element then needs fixed dimensions or something else that’s completely predictable. It’s almost an infinite loop of trying to maintain the 1:1 proportion of one element by setting the proportion of another containing element.</p>\n<p>The so-called “Padding Hack” sure was a clever workaround and not really much of a “hack” as much as a display of masterclass-level command of the CSS Box Model. Its origins <a href=\"https://alistapart.com/article/creating-intrinsic-ratios-for-video/\">date back to 2009</a>, but <a href=\"https://css-tricks.com/aspect-ratio-boxes/\">Chris Coyier explained it nicely in 2017</a>:</p>\n<blockquote>“If we force the height of the element to zero (<code>height: 0;</code>) and don’t have any borders, then the padding will be the only part of the box model affecting the height, and we’ll have our square.”<br /><br />— Chris Coyier</blockquote>\n\n<p>Anyway, it took a lot of ingenious CSS to pull it off. Let’s hear it for the CSS Working Group, which came up with a much more elegant solution: an <code>aspect-ratio</code> property.</p>\n<pre><code>/* Easier! */\naspect-ratio: 1;\nwidth: 50%;\n</code></pre>\n\n<p>Now, we have a perfect square no matter how the element’s width responds to its surroundings, providing us with an <strong>easier and more efficient ruleset that’s more resilient to change</strong>. I often find myself using <code>aspect-ratio</code> in place of an explicit <code>height</code> or <code>width</code> in my styles these days.</p>\nCard Hover Effects\n<p>Not really CSS-specific, but styling a hover effect on a card has traditionally been a convoluted process where we wrap the element in an <code>&lt;a&gt;</code> and hook into it to style the card accordingly on hover. But with <code>:has()</code> — now supported in <a href=\"https://caniuse.com/css-has\">all major browsers as of Firefox 121</a>! — we can put the link in the card as a child how it should be and style the card as a parent element when it *has* hover.</p>\n<pre><code>.card:has(:hover, :focus) {\n  /* Style away! */\n}\n</code></pre>\n\n<p>That’s way super cool, awesome, and easier to read than, say:</p>\n<pre><code>a.card-link:hover &gt; .card {\n  /* Style what?! */\n}\n</code></pre>\n\nCreating And Maintaining Color Palettes\n<p>A long, long time ago, I shared <a href=\"https://geoffgraham.me/naming-sass-color-variables/\">how I name color variables</a> in my Sass files. The point is that I defined variables with hexadecimal values, sort of like this in a more modern context using CSS variables instead of Sass:</p>\n<pre><code>/* Traditional */\n:root {\n  --black: #000;\n  --gray-dark: #333;\n  --gray-medium: #777;\n  --gray-light: #ccc;\n  --gray-lighter: #eaeaea;\n  --white: #fff;\n}\n</code></pre>\n\n<p>There’s nothing inherently wrong with this. Define colors how you want! But notice that what I was doing up there was manually setting a range of grayscale colors and doing so with inflexible color values. As you might have guessed by this point, there is a more efficient way to set this up so that it is much more maintainable and even easier to read.</p>\n<div>\n<pre><code>/* Easier to maintain! */\n:root {\n  --primary-color: #000;\n  --gray-dark: color-mix(in srgb, var(--primary-color), #fff 25%);\n  --gray-medium: color-mix(in srgb, var(--primary-color), #fff 40%);\n  --gray-light: color-mix(in srgb, var(--primary-color), #fff 60%);\n  --gray-lighter: color-mix(in srgb, var(--primary-color), #fff 75%);\n}\n</code></pre>\n</div>\n\n<p>Those aren’t exactly 1:1 conversions. I’m too lazy to do it for real, but you get the idea, right? <em>Right?!</em> The “easier” way may *look* more complicated, but if you want to change the main color, update the <code>--primary-color</code> variable and call it a day.</p>\n<p>Perhaps a better approach would be to change the name <code>--primary-color</code> to <code>--grayscale-palette-base</code>. This way, we can use the same sort of approach across many other color scales for a robust color system.</p>\n<div>\n<pre><code>/* Easier to maintain! */\n:root {\n  /* Baseline Palette */\n  --black: hsl(0 0% 0%);\n  --white: hsl(0 0% 100%);\n  --red: hsl(11 100% 55%);\n  --orange: hsl(27 100% 49%);\n  /* etc. */\n\n  /* Grayscale Palette */\n  --grayscale-base: var(--black);\n  --grayscale-mix: var(--white);\n\n  --gray-100: color-mix(in srgb, var(--grayscale-base), var(--grayscale-mix) 75%);\n  --gray-200: color-mix(in srgb, var(--grayscale-base), var(--grayscale-mix) 60%);\n  --gray-300: color-mix(in srgb, var(--grayscale-base), var(--grayscale-mix) 40%);\n  --gray-400: color-mix(in srgb, var(--grayscale-base), var(--grayscale-mix) 25%);\n\n  /* Red Palette */\n  --red-base: var(--red);\n  --red-mix: var(--white);\n\n  --red-100: color-mix(in srgb, var(--red-base), var(--red-mix) 75%);\n  /* etc. */\n\n  /* Repeat as needed */\n}\n</code></pre>\n</div>\n\n<p>Managing color systems is a science unto itself, so please don’t take any of this as a prescription for how it’s done. The point is that we have <em>easier</em> ways to approach them these days, whereas we were forced to reach for non-CSS tooling to even get access to variables.</p>\nManaging Line Lengths\n<p>Two things that are pretty new to CSS that I’m absolutely loving:</p>\n<ul>\n<li>Character length units (<code>ch</code>);</li>\n<li><code>text-wrap: balance</code>.</li>\n</ul>\n<p>As far as the former goes, I love it for establishing the maximum width of containers, particularly those meant to hold long-form content. Conventional wisdom tells us that an ideal length for a line of text is <a href=\"https://baymard.com/blog/line-length-readability\">somewhere between 50-75 characters per line</a>, depending on your source. In a world where font sizing can <a href=\"https://www.smashingmagazine.com/2023/11/addressing-accessibility-concerns-fluid-type/\">adapt to the container size or the viewport size</a>, predicting how many characters will wind up on a line is a guessing game with a moving target. But if we set the container to a maximum width that never exceeds 75 characters via the <code>ch</code> unit and a minimum width that fills most, if not all, of the containing width in smaller contexts, that’s no longer an issue, and we can ensure a comfortable reading space at any breakpoint — without media, to boot.</p>\n<pre><code>article {\n  width: min(100%, 75ch);\n}\n</code></pre>\n\n<p>Same sort of thing with headings. We don’t always have the information we need — font size, container size, writing mode, and so on — to produce a well-balanced heading. But you know who does? The browser! Using the new <a href=\"https://developer.chrome.com/blog/css-text-wrap-balance/\"><code>text-wrap: balance</code></a> value lets the browser decide when to wrap text in a way that prevents orphaned words or grossly unbalanced line lengths in a multi-line heading. This is another one of those cases where we’re waiting on complete browser support (<a href=\"https://caniuse.com/css-text-wrap-balance\">Safari, in this instance</a>). Still, it’s also one of those things I’m comfortable dropping into production now as a progressive enhancement since there’s no negative consequence with or without it.</p>\n<p>A word of caution, however, for those of you who may be tempted to apply this in a heavy-handed way across the board for <em>all</em> text:</p>\n<pre><code>/* 👎 */\n* {\n  text-wrap: balance;\n}\n</code></pre>\n\n<p>Not only is that an un-performant decision, but the <code>balance</code> value is specced in a way that <a href=\"https://caniuse.com/css-text-wrap-balance\">ignores any text that is longer than ten lines</a>. The exact algorithm, according to the spec, is up to the user agent and could be treated as the <code>auto</code> value if the maximum number of lines is exceeded.</p>\n<pre><code>/* 👍 */\narticle:is(h1, h2, h3, h4, h5, h6) {\n  text-wrap: balance;\n}\n</code></pre>\n\n<p><code>text-wrap: pretty</code> is another one in experimentation at the moment. It sounds like it’s similar to <code>balance</code> but in a way that allows the browser to sacrifice some performance gains for layout considerations. However, I have not played with it, and support for it is even more limited than <code>balance</code>.</p>\nHow About You?\n<p>These are merely the things that CSS offers here in late 2023 that I feel are having the most influence on how I write styles today versus how I may have approached similar situations back in the day when, during writing, I had to walk uphill both ways to produce a stylesheet.</p>\n<p>I can think of other features that I’ve used but haven’t fully adopted in my toolset. Those would include things like the following:</p>\n<ul>\n<li><a href=\"https://www.smashingmagazine.com/2022/01/introduction-css-cascade-layers/\">Cascade Layers</a> used mostly in CodePen demos.</li>\n<li><a href=\"https://www.smashingmagazine.com/2021/05/complete-guide-css-container-queries/\">Container Queries</a> in isolated cases as I continue to wrap my head around them.</li>\n<li><a href=\"https://www.smashingmagazine.com/2023/06/advanced-form-control-styling-selectmenu-anchoring-api/\"><code>&lt;selectmenu&gt;</code></a> which, OK, is HTML; but HTML that extends CSS powers.</li>\n<li><a href=\"https://developer.chrome.com/articles/css-nesting/\">CSS Nesting</a>, but I’m sure that’s bound to make its way into my work.</li>\n</ul>\n<p>What say you? I know there was a period of time when some of us were openly questioning whether there’s <a href=\"https://css-tricks.com/is-there-too-much-css-now/\">“too much” CSS these days</a> and opining that the learning curve for getting into CSS is becoming a difficult barrier to entry for new front-enders. What new features are you finding yourself using, and are they helping you write CSS in new and different ways that make your code easier to read and maintain or perhaps “re-learning” how you think about styles?</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"d7887c7cda04001e5dc47a344861a276f356ff8eecaa8df30dd4826e044ff2b5","category":"Tech"}