{"title":"Secret remediation best practices","link":"https://www.hashicorp.com/blog/secret-remediation-best-practices","date":1724774400000,"content":"<p>Everyone has secrets, whether they know it or not. It’s all too common these days for organizations to discover they have secrets or sensitive data living in insecure locations. Secrets might be exposed in code repositories, collaboration platforms, or even messages. Because of this reality, removing hard-coded secrets from application code and other insecure locations should be at the top of your list of rules and policies.</p>\n\n<p>This blog post provides a standard framework and best practices to help quickly and securely remediate issues with insecure secrets and sensitive data. It also includes a detailed example of remediating an insecure secret with <a href=\"https://developer.hashicorp.com/hcp/docs/vault-radar\">HCP Vault Radar</a> using these best practices. </p>\n\n<h2>Common challenges and solutions in secrets management</h2>\n\n<p>The common challenges in secrets management stem from the fact that SecOps teams often have little control when it comes to secret usage. Developers are the ones using secrets in code to connect across systems, and it is often <a href=\"https://www.hashicorp.com/resources/what-is-a-platform-team-and-why-do-we-need-them\">platform teams</a> that manage the systems that generate those secrets. But developers are typically judged on how quickly they can code new features, and managing secrets securely may not be fast or easy. For the sake of expediency, secrets and sensitive data aren’t always managed according to established rules and policies. </p>\n\n<p>Modern cloud security practices encourage organizations to closely audit code and require developers to manage high-value secrets using secret management vaults, rather than simply embedding them in code. That lets applications access secrets in separate files that can be isolated from the application code. They are then accessed only when needed during runtime and left out of code builds.</p>\n\n<p>Finally, to avoid inadvertent leaks during builds, development teams should establish policies and processes that require developers to inform those who write and maintain configuration files about the location of any secrets. That way, when appropriate, they can add those files to a list that will exclude them from build packages.</p>\n\n<h2>Secret discovery and remediation</h2>\n\n<p>In larger organizations, SecOps teams are responsible for establishing and enforcing these policies. The challenge is enabling and encouraging the affected developer teams to successfully follow these policies and processes. In order for developer teams to successfully meet security requirements, they need the right tools and guidelines. </p>\n\n<h3>Discovery and notification</h3>\n\n<p>Before they choose the right tool, teams need a framework for their desired approach to secret discovery and remediation. A standard, best-practice approach starts with a discovery and notification workflow. The process can start with a manual or automated environment scan at regular intervals:</p>\n\n<ul>\n<li><strong>Scan (Reactive discovery)</strong>: The SecOps team <a href=\"https://developer.hashicorp.com/hcp/tutorials/get-started-hcp-vault-radar/vault-radar-secret-scanning\">scans an organization’s environments</a> for unsecured secrets and sensitive data. They find a critical or high-severity event in the scan results. \n\n<ul>\n<li><strong>Investigate</strong>: When triaging this event, the SecOps team member sees information such as the person who committed the secret, where it is located, and the <a href=\"https://developer.hashicorp.com/hcp/docs/vault-radar/concepts/severity\">severity</a> of the issue. This contextual information will include steps required to appropriately remediate the risk.</li>\n<li><strong>Assign</strong>: Using this information, the event can be assigned to the appropriate owner, such as the developer or repository owner, for review and remediation.</li>\n</ul></li>\n</ul>\n\n<p>Alternatively or additionally, teams can set up targeted scans to happen during certain events in various areas of activity:</p>\n\n<ul>\n<li><strong>Monitor (Proactive discovery)</strong>: Automated proactive scanning for secret introduction into version control repositories is implemented. The developer team receives notifications from these scanning tools so they can prevent secrets and secure data from being introduced into unprotected locations. For example:\n\n<ul>\n<li><strong>Prevent</strong>: Guardrail systems can stop version control merges or provisioning before an unsecured secret is introduced.</li>\n<li><strong>Alert</strong>: A high-severity event triggers a <a href=\"https://developer.hashicorp.com/hcp/docs/vault-radar/get-started/set-up-alerting/pagerduty/setup\">PagerDuty notification</a> to immediately alert the team if a secret is introduced into an unprotected location.</li>\n<li><strong>Track</strong>: A <a href=\"https://developer.hashicorp.com/hcp/docs/vault-radar/get-started/set-up-ticketing/jira\">Jira issue is automatically created</a> to track, prioritize, and triage the event. </li>\n</ul></li>\n</ul>\n\n<h3>Remediation workflows</h3>\n\n<p>The main goals of a remediation workflow are rapid response and containment. Consistently applying best practices to remediation can reduce mean time to detection, mean time to remediate, and the number of incidents per month. When working to properly contain secrets and sensitive data, keep these five key tasks in mind:</p>\n\n<ol>\n<li><strong>Assess:</strong> Assess the impact of changing the secret (see step 4).</li>\n<li><strong>Revoke:</strong> Exposed secrets should be immediately revoked. The secret must be deactivated as quickly as possible, then systems need to be in place to monitor the status of the revoked secret.</li>\n<li><strong>Rotate:</strong> A new secret must be quickly created and implemented. This task is best enabled by an automated process in your workflow for quick turnaround, low rate of implementation errors, and least-privilege access. </li>\n<li><strong>Delete:</strong> Revoked or rotated secrets must be immediately removed from the exposed system, application code, logs, or other unprotected locations. Be aware that secrets in code could have a commit history, so avoid breaking links to other commits with history rewrites. Also, you need a process for removing secrets in logs while maintaining log integrity.</li>\n<li><strong>Track:</strong> Incident response teams need access to information about the lifecycle of a secret to aid in containment and remediation via log files, including who had access, when they used it, and the last rotation or update.</li>\n</ol>\n\n<p>There are two main categories of remediation: proactive and reactive. </p>\n\n<h4>Proactive remediation</h4>\n\n<p>Proactive remediation workflows typically involve automated scans that detect unsecured secrets or sensitive data before they get pushed into environments. An example of this would be implementing automated scanning for tip-of-branch and pull-request merge operations to stop secrets from being pushed into builds. In this case, contextual information would be provided in GitHub if that’s where the scan is running. </p>\n\n<h4>Reactive remediation</h4>\n\n<p>Reactive remediation workflows, on the other hand, are required upon discovery of secrets that have already been released into insecure environments. An example would be to either manually, or with a product workflow, revoke the secret from all locations.</p>\n\n<h4>Example workflow</h4>\n\n<p>Appropriate remediation is dependent on many factors, such as the type of secret, where it was found, the intended user, the criticality of the secret, and having context-specific guidance from your tools. A clear system of ownership for secrets remediation is key to a smooth workflow.</p>\n\n<p>This is a good, general example of a secret remediation process for a developer team:</p>\n\n<ul>\n<li>There’s a clear system of ownership and coordination. The owning developer receives timely notification of a secret discovered in their repo or environment, either automatically by tool integration or via a hand-over from SecOps after triage.</li>\n<li>The notification contains contextual information about the secret, such as severity, location, time of exposure, and other details. This information can include the exact location of that secret, who introduced it, whether it’s still active, and the length of time from when it was exposed and when it was discovered.</li>\n<li>Based on the details of the event, the developer receives customized steps for appropriately remediating the issue. In many cases, the remediation solution is to immediately remove the exposed secret and then rotate and store the secret in an approved secure secrets management system, such as <a href=\"https://www.hashicorp.com/products/vault?utm_source=google&amp;utm_channel_bucket=paid&amp;utm_medium=sem&amp;utm_campaign=&amp;utm_content=hashicorp%20vault-161229712449-689727110045&amp;utm_offer=&amp;gad_source=1&amp;gclid=Cj0KCQjwiOy1BhDCARIsADGvQnDE2BbHYbGJn8UoqHDml20kMvfkOuoWmrP83kmOxEnf_2mhnKcae8EaAm4mEALw_wcB\">HashiCorp Vault</a>. </li>\n</ul>\n\n<p>It’s important to note that remediation is not “one size fits all”, so having all the details prior to remediation is critical. For example, revoking secrets without the appropriate visibility can lead to broken systems and disruption of service. The team that uses a secret may not be the one that has access to the system that generates it, so coordination is required for successful remediation of unmanaged secrets.</p>\n\n<h3>Choosing the right tool</h3>\n\n<p>HCP Vault Radar is one of the few products that has the right mix of features to support the full best-practices workflow for secret discovery and remediation outlined above. Its native integration with HashiCorp Vault, one of the <a href=\"https://radar.cncf.io/2021-02-secrets-management\">most popular secrets managers</a>, makes it ideal for delivering secret remediation and moving those secrets into a proven solution for secrets management. The example below uses HCP Vault Radar to enact a reactive secret remediation workflow.</p>\n\n<h3>Example reactive remediation workflow with HCP Vault Radar</h3>\n\n<p>Remediation steps and workflows are dependent on many variables, including your organization's security policies as well as audit and reporting requirements. In order to determine the appropriate remediation workflow, you’ll need to gather information about an unsecured secret when it’s discovered. When HCP Vault Radar finds a secret in plaintext, it gathers the following information about the secret:</p>\n\n<ul>\n<li>Type of secret (Stripe API key, AWS credential.)</li>\n<li>Time of commit, if secret was committed</li>\n<li>Location of the secret (public or private repo, line of code, main branch or historic)</li>\n<li>Author of the commit</li>\n<li>Activeness status</li>\n</ul>\n\n<p>To put this information in context, here is an example of detailed remediation guidance and steps following remediation best practices.</p>\n\n<h4>An AWS secret is discovered in a code server</h4>\n\n<p>In this example, HCP Vault Radar provides step-by-step remediation recommendations following the most secure workflows available in Vault. Because of this, best practices for remediation with Vault are already built in. In this case, the workflow is following best practices for remediating a <a href=\"https://developer.hashicorp.com/vault/tutorials/getting-started/getting-started-dynamic-secrets\">dynamic secret</a> using Vault.</p>\n\n<h4>1) Create an incident</h4>\n\n<p>An incident event is automatically generated by HCP Vault Radar upon discovering an unsecured secret in your code server. Since a secret is leaked in code and event details indicate it is still active, this can lead to unauthorized access of your services. To prevent malicious activity, the following actions are recommended:</p>\n\n<ul>\n<li>Rotate and store the secret in a secrets manager.</li>\n<li>Follow your organization’s guidelines for emergency rotation of a secret</li>\n<li>Contact your AWS account owner </li>\n</ul>\n\n<h4>2) Store secret in Vault’s AWS secrets engine</h4>\n\n<p>To keep secrets secure, store them in a secret manager such as Vault. </p>\n\n<p><strong>Note:</strong> This example uses Vault’s <a href=\"https://developer.hashicorp.com/vault/docs/secrets/aws\">AWS secrets engine</a> and IAM auth method. If your application is already configured to access secrets in Vault, use your existing secrets engines and auth methods.</p>\n\n<p>1. Enable the AWS secrets engine in Vault:</p>\n<pre><code>$ vault auth enable aws</code></pre><p>2. Create a client:</p>\n<pre><code>$ vault write auth/aws/config/client access_key={AWS_ACCESS_KEY} secret_key={AWS_SECRET_KEY}</code></pre><p><strong>Note:</strong> Secrets created by Vault using the AWS secrets engine have a default lease of 60 minutes. For more information on how to change the lease, visit our <a href=\"https://developer.hashicorp.com/vault/api-docs/secret/aws#configure-lease\">AWS secrets engine documentation</a>.</p>\n\n<p>3. Create a policy:</p>\n<pre><code>$ vault policy write my-policy - &lt;&lt; EOF\npath \"my-secret\" {\n \t\tcapabilities = [ \"read\" ]\n}\nEOF</code></pre><p>4. Create an IAM role with the policy. This IAM role needs to match the permissions required on AWS:</p>\n<pre><code>$ vault write aws/roles/my-role \\\n    credential_type=iam_user \\\n    policy_document=-my_policy</code></pre><p><strong>Note:</strong> Find more information about the AWS secrets engine <a href=\"https://developer.hashicorp.com/vault/docs/secrets/aws#usage\">here</a>.</p>\n\n<h4>3) Remove the secret from code</h4>\n\n<p>You can now reference the secret from Vault in your code. </p>\n\n<p><strong>Note:</strong> This example uses an environment variable to store the secret in Vault.</p>\n\n<p>1. Populate the environment variable <code>MY_SECRET</code> with a Vault token:</p>\n<pre><code>$ export MY_SECRET=$(curl \\\n    --header \"X-Vault-Token: ...\" \\\n    http://127.0.0.1:8200/v1/aws/static-creds/{my-role})</code></pre><p>2. Remove the secret from source and add a reference to the secret stored at the environment variable <code>MY_SECRET</code>:</p>\n<pre><code>mySecret = getenv(“MY_SECRET”)</code></pre><p>3. Start your local server and test. </p>\n\n<p><strong>Note:</strong> Dynamic secrets need to be refreshed. If you are using an environment variable to read the secret, your application needs a way to refresh the secret value when it expires. Here are some ways to keep the dynamic secret value updated within your running application:</p>\n\n<ul>\n<li>Create secrets with the <a href=\"https://developer.hashicorp.com/vault/tutorials/kubernetes/vault-secrets-operator\">Vault secrets operator</a> for Kubernetes.</li>\n<li>Use Vault Enterprise <a href=\"https://developer.hashicorp.com/vault/tutorials/enterprise/secrets-sync\">secret sync</a> for services like Vercel or Heroku.</li>\n<li>Read and reload secrets in <a href=\"https://developer.hashicorp.com/vault/tutorials/app-integration/spring-reload-secrets\">Spring</a>.</li>\n<li>If you do not use environment variables, refer to the <a href=\"https://developer.hashicorp.com/vault/api-docs/secret/aws#generate-credentials\">Vault API documentation</a>.</li>\n</ul>\n\n<h4>4) Revoke the secret</h4>\n\n<p>Revoke the unsecured secret to complete the remediation process.</p>\n\n<ul>\n<li>Test that the code changes work. \n\n<ul>\n<li>Validate the environment variable is populated from Vault.</li>\n<li>Deploy and test the application.</li>\n</ul></li>\n<li>Work with the AWS service owner to revoke the previous secret value.</li>\n</ul>\n\n<h2>Learn more about HCP Vault Radar</h2>\n\n<p>For more information about unsecured secret discovery and remediation, visit the <a href=\"https://developer.hashicorp.com/hcp/tutorials/get-started-hcp-vault-radar\">HCP Vault Radar tutorials page</a>. Additional resource links include:</p>\n\n<ul>\n<li><a href=\"https://developer.hashicorp.com/hcp/docs/vault-radar\">What is Vault Radar?</a></li>\n<li><a href=\"https://developer.hashicorp.com/hcp/docs/vault-radar/remediate-secrets\">Secret remediation with HCP Vault Radar</a></li>\n<li>HCP Vault Radar <a href=\"https://developer.hashicorp.com/hcp/tutorials/get-started-hcp-vault-radar/vault-radar-introduction#integrations\">alerting and ticketing tool integration</a></li>\n<li>HCP Vault Radar <a href=\"https://developer.hashicorp.com/hcp/docs/vault-radar/cli\">command line interface tool</a></li>\n</ul>\n","author":"David Mills","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"956d5aa1323a90cc2dbb8d6415470c164d50c62612f2d57e455adc84114e360e","category":"Tech"}