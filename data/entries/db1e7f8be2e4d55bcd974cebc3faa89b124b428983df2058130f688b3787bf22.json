{"title":"Kubernetes Vault integration via Sidecar Agent Injector vs. Vault Secrets Operator vs. CSI provider","link":"https://www.hashicorp.com/blog/kubernetes-vault-integration-via-sidecar-agent-injector-vs-csi-provider","date":1681228800000,"content":"<p>In this post, I will explore three different methods for integrating HashiCorp Vault with Kubernetes:</p>\n\n<ol>\n<li>The Vault Sidecar Agent Injector</li>\n<li>The Vault Container Storage Interface (CSI) provider</li>\n<li>The Vault Secrets Operator</li>\n</ol>\n\n<p>I’ll provide practical guidance for each method to help you understand and choose the best method for your use case.</p>\n\n<p>This post is not intended to be a product documentation or step-by-step implementation guide. It is for DevOps practitioners familiar with HashiCorp Vault and Kubernetes who also have a basic understanding of secrets-management concepts.</p>\n\n<h2>Vault Sidecar Agent Injector</h2>\n\n<p>The <a href=\"https://www.vaultproject.io/docs/platform/k8s/injector\">Vault Sidecar Agent Injector</a> leverages the <a href=\"https://docs.microsoft.com/en-us/azure/architecture/patterns/sidecar\">sidecar pattern</a> to alter pod specifications to include a Vault Agent container that renders Vault secrets to a shared memory volume. By rendering secrets to a shared volume, containers within the pod can consume Vault secrets without being Vault-aware. The injector is a Kubernetes mutating webhook controller. The controller intercepts pod events and applies mutations to the pod if annotations exist within the request. This functionality is provided by the <a href=\"https://github.com/hashicorp/vault-k8s\">vault-k8s</a> project and can be automatically installed and configured using the Vault Helm chart.</p>\n<img src=\"https://www.datocms-assets.com/2885/1643214443-sidecar-workflow-v1.png\" alt=\"Sidecar\" /><h2>Vault CSI provider</h2>\n\n<p>The <a href=\"https://www.vaultproject.io/docs/platform/k8s/csi\">Vault CSI provider</a> allows pods to consume Vault secrets by using ephemeral <a href=\"https://github.com/kubernetes-sigs/secrets-store-csi-driver\">CSI Secrets Store</a> volumes. At a high level, the CSI Secrets Store driver allows users to create <code>SecretProviderClass</code> objects. These objects define which secret provider to use and what secrets to retrieve. When pods requesting CSI volumes are created, the CSI Secrets Store driver sends the request to the Vault CSI provider if the provider is <code>vault</code>. The Vault CSI provider then uses the specified <code>SecretProviderClass</code> and the pod’s service account to retrieve the secrets from Vault and mount them into the pod’s CSI volume. Note that the secret is retrieved from Vault and populated to the CSI secrets store volume during the <code>ContainerCreation</code> phase. This means that pods will be blocked from starting until the secrets have been read from Vault and written to the volume.</p>\n<img src=\"https://www.datocms-assets.com/2885/1643214470-csi-workflow-v1.png\" alt=\"CSI\" /><h2>Vault Secrets Operator</h2>\n\n<p>The <a href=\"https://github.com/hashicorp/vault-secrets-operator/\">Vault Secrets Operator</a> is a new integration method that implements a Kubernetes Secrets Operator with a set of CRDs responsible for synchronizing Vault secrets to Kubernetes Secrets natively. The Operator supports synchronizing the full lifecycle of secrets management including static, dynamic, and PKI-based secrets from one or more Vault server instances. The Operator is also capable of managing secret rotation and performing post rotation actions including notifying an application directly via a <a href=\"https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#rollout\">rolling update</a> of a <a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/\">Deployment</a> or by triggering a rolling update.</p>\n\n<h2>Common design considerations</h2>\n\n<p>There are some similarities and differences between the two solutions that you should consider when designing and implementing your secrets management strategy in Kubernetes environments.</p>\n\n<ol>\n<li><strong>Secret projections:</strong> Every application requires secrets to be presented to it in a specific way. Typically, applications expect secrets to be either exported as environment variables or written to a file that the application can read on startup. Keep that in mind as you’re deciding on the right method to use. </li>\n<li><strong>Secret scope:</strong> Some applications are deployed across multiple Kubernetes environments (e.g. <em>dev, qa, prod</em>) across your datacenters, the edge, or public clouds. Some services run outside of Kubernetes on VMs, serverless, or other cloud-managed services. You may face scenarios where these applications need to share sets of secrets across these heterogeneous environments. Scoping the secrets correctly to be either local to the Kubernetes environment or global across different environments helps ensure that each application can easily and securely access its own set of secrets within the environment it is deployed in.</li>\n<li><strong>Secret types:</strong> Secrets can be text files, binary files, tokens, or certs. They can be statically or dynamically generated. They can be valid permanently or time-scoped. They also vary in size. You need to consider the secret types your application requires and how they’re projected into the application.</li>\n<li><strong>Secret definition:</strong> You also need to consider how each secret is defined, created, updated, and removed, as well as the tooling associated with that process.</li>\n<li><strong>Encryption:</strong> Encrypting secrets both at rest and in transit is a critical requirement for many enterprise organizations.</li>\n<li><strong>Governance:</strong> Applications and secrets can have a many-to-many relationship that requires careful considerations when it comes to granting access for applications to retrieve their respective secrets. As the number of applications and secrets scale, so does the challenge of managing their access policies.</li>\n<li><strong>Secrets updates and rotation:</strong> Secrets can be leased, time-scoped, or automatically rotated, and each scenario needs be a programmatic process to ensure the new secret is properly propagated to the application pods.</li>\n<li><strong>Secret caching:</strong> In certain Kubernetes environments (e.g. edge or retail) there is a potential need for secret caching in the case of communication or network failures between the environment and the secret storage.</li>\n<li><strong>Auditability:</strong> Keeping a secret access audit log detailing all secret access information is critical to ensure traceability of secret-access events.</li>\n</ol>\n\n<p>Keeping these design considerations in mind, let’s go over some of the similarities and differences between the two integration solutions.</p>\n\n<h2>Similarities</h2>\n\n<p>Vault Operator, CSI, and sidecar solutions:</p>\n\n<ul>\n<li><p>Simplify retrieving different types of secrets stored in Vault and expose them to the target pod running on Kubernetes without it being aware of the not-so-trivial Vault processes. It’s important to note that there is no need to make any changes in the application logic or code in order for it to use these solutions, making it easier to migrate brownfield applications into Kubernetes. Developers working on greenfield applications can leverage the <a href=\"https://www.vaultproject.io/api/libraries\">Vault SDKs</a> to directly integrate with Vault.</p></li>\n<li><p>Support all types of Vault <a href=\"https://www.vaultproject.io/docs/secrets\">secrets engines</a>. This means that you can leverage an extensive set of secret types, ranging from static key-value secrets to dynamically generated database credentials and TLS certs with customized TTL.</p></li>\n<li><p>Leverage the application’s Kubernetes pod service account token as <a href=\"https://www.hashicorp.com/resources/secret-zero-mitigating-the-risk-of-secret-introduction-with-vault\">“Secret Zero”</a> to authenticate with Vault via the Kubernetes auth method. This means that there is no need to manage yet another separate identity to identify the application pods when authenticating to Vault. </p></li>\n</ul>\n<img src=\"https://www.datocms-assets.com/2885/1643214683-vault-k8s-auth-blog.png\" alt=\"Vault\" /><p><em>Vault’s Kubernetes auth workflow</em></p>\n\n<ul>\n<li>Require the desired secrets to exist within Vault before deploying the application</li>\n<li>Require the pod’s service account to be bound to a Vault role with a policy enabling access to desired secrets (that is,  Kubernetes RBAC isn’t used to authorize access to secrets)</li>\n<li>Deployable via Helm</li>\n<li>Require successfully retrieving secrets from Vault before the pods are started</li>\n<li>Rely on user-defined pod annotations to retrieve the required secrets from Vault</li>\n<li>Both the <a href=\"https://www.vaultproject.io/docs/agent/template#renewals-and-updating-secrets\">Sidecar Injector Service</a> and <a href=\"https://secrets-store-csi-driver.sigs.k8s.io/topics/secret-auto-rotation.html\">CSI Driver</a> can automatically renew, rotate, and fetch secrets/tokens.</li>\n</ul>\n\n<h2>Differences</h2>\n\n<p>Here’s how the three solutions are different:</p>\n\n<ul>\n<li>The Sidecar Agent Injector solution is composed of two elements: \n\n<ul>\n<li>The Sidecar Service Injector, which is deployed as a cluster service and is responsible for intercepting Kubernetes apiserver pod events and mutating pod specs to add required sidecar containers</li>\n<li>The Vault Sidecar Container, which is deployed alongside each application pod and is responsible for authenticating into Vault, retrieving secrets from Vault, and rendering secrets for the application to consume </li>\n</ul></li>\n<li>In contrast, the Vault CSI Driver is deployed as a daemonset on every node in the Kubernetes cluster and uses the Secret Provider Class specified and the pod’s service account to retrieve the secrets from Vault, and mount them into the pod’s CSI volume.</li>\n<li>The Vault Operator is also capable of managing secret rotation and performing post rotation actions including notifying an application directly via (or by triggering) a rolling update of a Deployment.</li>\n<li>The Sidecar Agent Injector supports <a href=\"https://www.vaultproject.io/docs/platform/k8s/injector/annotations#vault-hashicorp-com-auth-path\">all</a> Vault<a href=\"https://www.vaultproject.io/docs/agent/autoauth/methods\"> auto-auth</a> methods. The Sidecar CSI driver<a href=\"https://www.vaultproject.io/docs/platform/k8s/csi/configurations#vaultkubernetesmountpath\"> supports only Vault’s Kubernetes auth method</a> and Vault Operator only supports the Kubernetes auth method at this time.</li>\n<li>The sidecar container that is launched with every application pod uses<a href=\"https://www.vaultproject.io/docs/agent\"> Vault Agent</a>, which provides a powerful set of capabilities such as auto-auth, templating, and caching. The CSI driver does not use the Vault Agent and therefore lacks these functionalities.</li>\n<li>The Vault Operator includes support for the Promethus Operator for governance reporting. </li>\n<li>The Vault CSI driver supports rendering Vault secrets into both Kubernetes secrets and environment variables. Sidecar Injector Service does not support rendering secrets into Kubernetes secrets — however there are<a href=\"https://www.vaultproject.io/docs/platform/k8s/injector/examples#environment-variable-example\"> ways to use agent templating</a> to render secrets into environment variables.</li>\n<li>The CSI driver uses <code>hostPath</code> to mount ephemeral volumes into the pods, which some container platforms (e.g. OpenShift) disable by default. On the other hand, Sidecar Agent Service uses in-memory <em>tmpfs</em> volumes.</li>\n<li>Sidecar Injector Service<a href=\"https://www.vaultproject.io/docs/agent/template#renewals-and-updating-secrets\"> automatically</a> renews, rotates, and fetches secrets/tokens. The CSI Driver does not support that.</li>\n</ul>\n\n<h2>Comparison Chart</h2>\n\n<p>The table below provides a high-level comparison of the two solutions:</p>\n<img src=\"https://www.datocms-assets.com/2885/1680644640-csi-vs-sidecar-vs-operator-chart.png\" alt=\"Sidecar\" /><p>*achieved through <a href=\"https://www.vaultproject.io/docs/platform/k8s/injector/examples#environment-variable-example\">Agent templating</a></p>\n\n<h2>Going Beyond the Native Kubernetes Secrets</h2>\n\n<p>On the surface, Kubernetes native secrets might seem similar to the two approaches presented above, but there are major differences between them: </p>\n\n<ul>\n<li><p>Kubernetes is <em>not</em> a secrets management solution. It does have native support for secrets, but that is quite different from an enterprise secrets management solution. Kubernetes secrets are scoped to the cluster only and many applications will have some services running outside Kubernetes or in different Kubernetes clusters. Therefore, considering the secret scope as part of the design process is critical. Having these applications use Kubernetes secrets from outside a Kubernetes environment will be cumbersome and introduce authentication and authorization challenges. </p></li>\n<li><p>Kubernetes secrets are static in nature. You can define secrets by using kubectl or the Kubernetes API but once they are defined they are stored in etcd and presented to pods only during pod creation. This can create scenarios where secrets get stale, outdated, or expired, requiring additional workflows to update and rotate the secrets and then re-deploying the application to use the new version of the secrets. This can add complexity and waste time. So make sure you consider any requirement for secret freshness, updates, and rotation as part of your design process.</p></li>\n<li><p>The security model of secret access management is tied to the Kubernetes RBAC model. This can be challenging to adopt for users who are not familiar with Kubernetes. Adopting a platform-agnostic security governance model can enable you to adopt workflows for applications regardless of how and where they are running.</p></li>\n</ul>\n\n<h2>Summary</h2>\n\n<p>Designing for secrets management in Kubernetes is no easy task. There are multiple approaches each with its own set of pros and cons. I highly recommend exploring the options presented in this blog post to understand their internals and decide on the best option for your use case.</p>\n\n<h2>Additional Resources</h2>\n\n<ul>\n<li><a href=\"https://medium.com/hashicorp-engineering/hashicorp-vault-delivering-secrets-with-kubernetes-1b358c03b2a3\">HashiCorp Vault: Delivering Secrets with Kubernetes</a></li>\n<li><a href=\"https://www.hashicorp.com/blog/vault-secrets-operator-a-new-method-for-kubernetes-integration\">Kubernetes Secrets Vault Operator</a></li>\n<li><a href=\"https://github.com/hashicorp/vault-secrets-operator/\">Kubernetes Vault Operator Repo</a></li>\n<li><a href=\"https://www.hashicorp.com/blog/retrieve-hashicorp-vault-secrets-with-kubernetes-csi\">Retrieve HashiCorp Vault Secrets with Kubernetes CSI</a></li>\n<li><a href=\"https://learn.hashicorp.com/tutorials/vault/kubernetes-secret-store-driver?in=vault/kubernetes\">Mount Vault Secrets Through Container Storage Interface (CSI) Volume</a></li>\n<li><a href=\"https://learn.hashicorp.com/tutorials/vault/kubernetes-sidecar\">Injecting Secrets into Kubernetes Pods via Vault Agent Containers</a></li>\n<li><a href=\"https://www.vaultproject.io/docs/platform/k8s/injector/annotations\">Vault Sidecar Injector Configurations and Examples</a></li>\n<li><a href=\"https://www.vaultproject.io/docs/platform/k8s/csi/configurations\">Vault CSI Driver Configurations and Examples</a></li>\n</ul>\n","author":"Nico Kabar","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"db1e7f8be2e4d55bcd974cebc3faa89b124b428983df2058130f688b3787bf22","category":"Tech"}