{"title":"CDK for Terraform 0.16 improves automatic HCL conversion","link":"https://www.hashicorp.com/blog/cdk-for-terraform-0-16-improves-automatic-hcl-conversion","date":1681833600000,"content":"<p><a href=\"https://developer.hashicorp.com/terraform/cdktf\">CDK for Terraform</a> (CDKTF) lets you write HashiCorp Terraform configurations in your choice of TypeScript, Python, C#, Java, or Go, and still benefit from the full ecosystem of Terraform <a href=\"https://registry.terraform.io/\">providers and modules</a>. CDKTF <a href=\"https://www.hashicorp.com/blog/cdk-for-terraform-now-generally-available\">reached its GA</a> in August, 2022.</p>\n\n<p>Today, we’re releasing CDKTF 0.16, which improves the ability of the Cloud Development Kit (CDK) to convert HCL to TypeScript, Python, C#, Java, or Go. These improvements, primarily in the CDKTF CLI’s <code>convert</code> command, include:</p>\n\n<ul>\n<li><strong>Type coercion based on Terraform provider schema:</strong> When converting from HCL to a supported language, the CDKTF <code>convert</code> command now matches the type of the value being assigned to an attribute and converts it to the correct type.</li>\n<li><strong>Enhanced iterators support:</strong> Iterators are used by CDKTF to replace attributes like <code>for_each</code> and dynamic blocks within Terraform. The conversion from HCL in the 0.16 release now also uses iterators when possible, reducing the need for escape hatches. </li>\n<li><strong>Better functions support</strong>: The generated code now uses CDKTF library functions to replace Terraform HCL functions, instead of relying solely on string templating. This improves the readability of the code.</li>\n</ul>\n\n<p>Apart from improvements in the <code>convert</code> command, 0.16 upgrades the underlying <a href=\"https://developer.hashicorp.com/terraform/cdktf/concepts/cdktf-architecture\">JSII compiler</a> to use TypeScript 5. This change will improve the performance of  CDKTF <code>synth</code> and <code>get</code>. We’ve also updated the minimum version of Node.js to 16 as Node.js 14 will be hitting <a href=\"https://azure.microsoft.com/en-us/updates/community-support-for-node-14-lts-is-ending-on-30-april-2023/\">end of life</a> on April 30, 2023.</p>\n\n<h2>The <code>convert</code> command</h2>\n\n<p>The CDKTF CLI released the <code>convert</code> command in <a href=\"https://github.com/hashicorp/terraform-cdk/releases/tag/v0.5.0\">version 0.5</a>, which allowed users to automatically convert their existing Terraform HCL code to a CDKTF-compatible language automatically. This is really useful for teams with either an HCL background or a HCL code base who would like to use CDKTF.</p>\n\n<p>While we have been releasing minor bug fixes and improvements to <code>convert</code>, the 0.16 release focuses on improving the conversion process. More information about usage and parameters to the <code>convert</code> command can be found <a href=\"https://developer.hashicorp.com/terraform/cdktf/cli-reference/commands#convert\">in our documentation</a>.</p>\n\n<p>To give an example of the conversion process, consider the following Terraform HCL:</p>\n<pre><code>provider \"aws\" {\n  region  = \"us-west-2\"\n}\n\nresource \"aws_instance\" \"app_server\" {\n  ami           = \"ami-830c94e3\"\n  instance_type = \"t2.micro\"\n\n  tags = {\n    Name = \"ExampleAppServerInstance\"\n  }\n}</code></pre><p>When converted into TypeScript through the <code>convert</code> command, it becomes a construct that can be used directly within a CDKTF application:</p>\n<pre><code>import * as constructs from \"constructs\";\n/*Provider bindings are generated by running cdktf get.\nSee https://cdk.tf/provider-generation for more details.*/\nimport * as aws from \"./.gen/providers/aws\";\n\nclass MyConvertedCode extends constructs.Construct {\n  constructor(scope: constructs.Construct, name: string) {\n    super(scope, name);\n    new aws.provider.AwsProvider(this, \"aws\", {\n      region: \"us-west-2\",\n    });\n    new aws.instance.Instance(this, \"app_server\", {\n      ami: \"ami-830c94e3\",\n      instanceType: \"t2.micro\",\n      tags: {\n        Name: \"ExampleAppServerInstance\",\n      },\n    });\n  }\n}</code></pre><h2>Type coercion based on Terraform provider schema</h2>\n\n<p>Since CDKTF uses Terraform to perform any infrastructure changes, problems like type mismatches are hard to detect until the <code>terraform plan</code> stage. Prior to the 0.16 release, the <code>convert</code> command could generate invalid code because it would try to convert by only looking at the HCL source code. </p>\n\n<p>With 0.16, <code>convert</code> also compares the type being generated from HCL and matches it with the provider schema. In case of a type mismatch, it wraps the incoming value to the type expected by the attribute. This makes the conversion process a lot more accurate and results in fewer conversion errors.</p>\n\n<p>Take a look at a simple contrived example:</p>\n<pre><code>resource \"aws_route53_record\" \"my_record\" {\n  name    = \"example.com\"\n  type    = \"TXT\"\n  ttl     = \"300\"\n  records = [\"test\"]\n}</code></pre><p>The schema for <code>aws_route53_record</code> marks <code>ttl</code> as a number here, so it seems like an error. However, Terraform <a href=\"https://developer.hashicorp.com/terraform/language/expressions/type-constraints#conversion-of-primitive-types\">automatically converts primitive types</a> to match the schema, therefore the above code will not trigger an error within Terraform.</p>\n\n<p>Contrary to that, CDKTF code wouldn’t allow that, since strongly typed languages will not allow a string to be assigned to a number type. To handle these scenarios, we built type coercion into <code>convert</code>. The code above will now generate the following:</p>\n<pre><code>new aws.route53Record.Route53Record(\n  this,\n  \"my_record\",\n  {\n    name: \"example.com\",\n    records: [\"test\"],\n    ttl: cdktf.Token.asNumber(\"300\"),\n    type: \"TXT\",\n  }\n);</code></pre><p>Here, <code>convert</code> wraps the string value to a number before passing it to <code>ttl</code>. <code>convert</code> not only does this for primitive types, but also for more complex types like Maps, and Lists. </p>\n\n<h2>Enhanced iterators support</h2>\n\n<p>Terraform HCL has meta-arguments that help users create multiple resources, like <a href=\"https://developer.hashicorp.com/terraform/language/meta-arguments/count\"><code>count</code></a>, and <a href=\"https://developer.hashicorp.com/terraform/language/meta-arguments/for_each\"><code>for_each</code></a>. There’s also the concept of <a href=\"https://developer.hashicorp.com/terraform/language/expressions/dynamic-blocks\">dynamic blocks</a>, which deals with complex resources that have repeated configurations within. The equivalent concept within CDKTF is called <a href=\"https://developer.hashicorp.com/terraform/cdktf/concepts/iterators\">iterators</a>. </p>\n\n<p>In the 0.16 release, the <code>count</code> meta-attribute can also be represented as iterators through an <a href=\"https://developer.hashicorp.com/terraform/cdktf/concepts/resources#escape-hatch\">escape hatch</a>. For more details about usage and code examples, please refer to <a href=\"https://developer.hashicorp.com/terraform/cdktf/concepts/iterators\">our documentation</a>.</p>\n\n<p><code>convert</code> is now also able to use iterators to replace <code>for_each</code>, <code>count</code>, and even dynamic blocks. Previously <code>convert</code> reverted to using escape hatches for iterators.</p>\n\n<h2>Using CDKTF functions when converting from built-in Terraform functions</h2>\n\n<p>HCL to CDKTF conversion is now able to convert Terraform functions to their corresponding CDKTF functions. This is nicer for readability as well as being able to get autocomplete and documentation support from the IDE for CDKTF projects. <code>convert</code> also uses functions representing unary, binary, or ternary expressions.</p>\n\n<p>If we take the contrived example of an HCL expression containing functions and operators below:</p>\n<pre><code>replace(\"hello-${22+22}\", \"44\", \"world\")</code></pre><p>This now gets converted into:</p>\n<pre><code>cdktf.Fn.replace(\"hello-\" + cdktf.Token.asString(cdktf.Op.add(22, 22)), \"44\", \"world\")</code></pre><h2>What's next for CDKTF?</h2>\n\n<p>The upcoming CDKTF 0.17 release will focus on building on top of the 0.16 improvements, especially with regard to converting HCL to languages like Java, C#, and Go.</p>\n\n<h2>Try CDK for Terraform</h2>\n\n<p>If you’re new to the project, these <a href=\"https://developer.hashicorp.com/terraform/tutorials/cdktf\">tutorials for CDK for Terraform</a> are the best way to get started. You can dive deeper into our documentation with this <a href=\"https://developer.hashicorp.com/terraform/cdktf\">overview of CDKTF</a>.</p>\n\n<p>Whether you’re still experimenting or actively using CDK for Terraform, we’d love to hear from you. Please <a href=\"https://github.com/hashicorp/terraform-cdk/issues/new?assignees=&amp;labels=bug%2C+new&amp;template=bug-report.md&amp;title=\">file any bugs you encounter</a>, let us know about your <a href=\"https://github.com/hashicorp/terraform-cdk/issues/new?assignees=&amp;labels=enhancement%2C+new&amp;template=feature-request.md&amp;title=\">feature requests</a>, and share your questions, thoughts, and experiences in the <a href=\"https://discuss.hashicorp.com/c/terraform-core/cdk-for-terraform/47\">CDK for Terraform discussion forum</a>.</p>\n","author":"Rohan Kumar Tripathy","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"0a59fad2277196ef70db861dd0f1d28f11f99846c4284ba26e3ef8639202ce7e","category":"Tech"}