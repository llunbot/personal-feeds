{"title":"The Hype Around Signals","link":"https://smashingmagazine.com/2024/11/the-hype-around-signals/","date":1732701600000,"content":"<p>The groundwork for what we call today “signals” dates as early as the 1970s. Based on this work, they became popular with different fields of computer science, defining them more specifically around the 90s and the early 2000s.</p>\n<p>In Web Development, they first made a run for it with <a href=\"https://knockoutjs.com\">KnockoutJS</a>, and shortly after, signals took a backseat in (most of) our brains. Some years ago, multiple similar implementations came to be.</p>\n<ul>\n<li><a href=\"https://mobx.js.org/observable-state.html\">MobX observable states</a></li>\n<li><a href=\"https://vuejs.org/api/reactivity-advanced.html\">Vue.js refs and shallow refs</a></li>\n<li><a href=\"https://docs.solidjs.com/concepts/intro-to-reactivity\">SolidJS signals</a> </li>\n</ul>\n<p>With different names and implementation details, those approaches are similar enough to be wrapped in a category we know today as <strong>Fine-Grained Reactivity</strong>, even if they have different levels of “fine” x “coarse” updates — we’ll get more into what this means soon enough.</p>\n<p><strong>To summarize the history</strong>: Even being an older technology, signals started a revolution in how we thought about interactivity and data in our UIs at the time. And since then, every UI library (SolidJS, Marko, Vue.js, Qwik, Angular, Svelte, Wiz, Preact, etc) has adopted some kind of implementation of them (except for React).</p>\n<p>Typically, a <strong>signal</strong> is composed of an accessor (getter) and a setter. The setter establishes an update to the value held by the signal and triggers all dependent effects. While an accessor pulls the value from the source and is run by effects every time a change happens upstream.</p>\n<pre><code>const [signal, setSignal] = createSignal(\"initial value\");\n\nsetSignal(\"new value\");\n\nconsole.log(signal()); // \"new value\"\n</code></pre>\n\n<p>In order to understand the reason for that, we need to dig a little deeper into what <strong>API Architectures</strong> and <strong>Fine-Grained Reactivity</strong> actually mean.</p>\nAPI Architectures\n<p>There are two basic ways of defining systems based on how they handle their data. Each of these approaches has its pros and cons. </p>\n<ul>\n<li><strong>Pull</strong>: The consumer pings the source for updates.</li>\n<li><strong>Push</strong>: The source sends the updates as soon as they are available.</li>\n</ul>\n<p><strong>Pull</strong> systems need to handle polling or some other way of maintaining their data up-to-date. They also need to guarantee that all consumers of the data get torn down and recreated once new data arrives to avoid <strong>state tearing</strong>.</p>\n<blockquote><strong>State Tearing</strong> occurs when different parts of the same UI are at different stages of the state. For example, when your header shows 8 posts available, but the list has 10.</blockquote>\n\n<p><strong>Push</strong> systems don’t need to worry about maintaining their data up-to-date. Nevertheless, the source is unaware of whether the consumer is ready to receive the updates. This can cause <strong>backpressure</strong>. A data source may send too many updates in a shorter amount of time than the consumer is capable of handling. If the update flux is too intense for the receiver, it can cause loss of data packages (leading to <strong>state tearing</strong> once again) and, in more serious cases, even crash the client.</p>\n<p>In <strong>pull</strong> systems, the accepted tradeoff is that data is unaware of where it’s being used; this causes the receiving end to create precautions around maintaining all their components up-to-date. That’s how systems like <a href=\"https://react.dev\">React</a> work with their teardown/re-render mechanism around updates and reconciliation.</p>\n<p>In <strong>push</strong> systems, the accepted tradeoff is that the receiving end needs to be able to deal with the update stream in a way that won’t cause it to crash while maintaining all consuming nodes in a synchronized state. In web development, <a href=\"https://rxjs.dev\">RxJS</a> is the most popular example of a push system.</p>\n<p>The attentive reader may have noticed the tradeoffs on each system are at the opposite ends of the spectrum: while pull systems are good at scheduling the updates efficiently, in push architectures, the data knows where it’s being used — allows for more granular control. That’s what makes a great opportunity for a <strong>hybrid</strong> model.</p>\nPush-Pull Architectures\n<p>In Push-Pull systems, the state has a list of subscribers, which can then trigger for re-fetching data once there is an update. The way it differs from traditional push is that the update itself isn’t sent to the subscribers — just a notification that they’re now stale.</p>\n<p>Once the subscriber is aware its current state has become stale, it will then fetch the new data at a proper time, avoiding any kind of backpressure and behaving similarly to the pull mechanism. The difference is that this only happens when the subscriber is certain there is new data to be fetched.</p>\n<p>We call these data <strong>signals</strong>, and the way those subscribers are triggered to update are called <strong>effects</strong>. Not to confuse with <code>useEffect</code>, which is a similar name for a completely different thing.</p>\nFine-Grained Reactivity\n<p>Once we establish the two-way interaction between the data source and data consumer, we will have a reactive system.</p>\n<blockquote>A <strong>reactive system</strong> only exists when data can notify the consumer it has changed, and the consumer can apply those changes.</blockquote>\n\n<p>Now, to make it <strong>fine-grained</strong> there are two fundamental requirements that need to be met:</p>\n<ol>\n<li><strong>Efficiency</strong>: The system only executes the minimum amount of computations necessary.</li>\n<li><strong>Glitch-Free</strong>: No intermediary states are shown in the process of updating a state.</li>\n</ol>\n<h3>Efficiency In UIs</h3>\n<p>To really understand how signals can achieve high levels of efficiency, one needs to understand what it means to have an <strong>accessor</strong>. In broad strokes, they behave as getter functions. Having an accessor means the value does not exist within the boundaries of our component — what our templates receive is a getter for that value, and every time their effects run, they will bring an up-to-date new value. This is why signals are functions and not simple variables. For example, in Solid:</p>\n<pre><code>import { createSignal } from 'solid-js'\n\nfunction ReactiveComponent() {\n  const [signal, setSignal] = createSignal()\n\n  return (\n    &lt;h1&gt;Hello, {signal()}&lt;/h1&gt;\n  )\n}\n</code></pre>\n\n<p>The part that is relevant to performance (and efficiency) in the snippet above is that considering <code>signal()</code> is a getter, it does not need to re-run the whole <code>ReactiveComponent()</code> function to update the rendered artifact; only the signal is re-run, guaranteeing no extra computation will run.</p>\nGlitch-Free UIs\n<p>Non-reactive systems avoid intermediary states by having a teardown/re-render mechanism. They toss away the artifacts with possibly stale data and recreate everything from scratch. That works well and consistently but at the expense of efficiency.</p>\n<p>In order to understand how reactive systems handle this problem, we need to talk about the <strong>Diamond Challenge</strong>. This is a quick problem to describe but a tough one to solve. Take a look at the diagram below:</p>\n<p><img src=\"https://files.smashing.media/articles/the-hype-around-signals/1-diamond-diagram.jpg\" /></p>\n<p>Pay attention to the <code>E</code> node. It depends on <code>D</code> and <code>B</code>, but only <code>D</code> depends on <code>C</code>. </p>\n<p>If your reactive system is too eager to update, it can receive the update from <code>B</code> while <code>D</code> is still stale. That will cause <code>E</code> to show an intermediary state that should not exist.</p>\n<p>It’s easy and intuitive to have <code>A</code> trigger its children for updates as soon as new data arrives and let it cascade down. But if this happens, <code>E</code> receives the data from <code>B</code> while <code>D</code> is stale. If <code>B</code> is able to trigger an update from <code>E</code>, <code>E</code> will show an intermediate state.</p>\n<p>Each implementation adopts different update strategies to solve this challenge. They can be grouped into two categories:</p>\n<ol>\n<li><strong>Lazy Signals</strong><br />Where a scheduler defines the order within which the updates will occur. (<code>A</code>, then <code>B</code> and <code>C</code>, then <code>D</code>, and finally <code>E</code>).</li>\n<li><strong>Eager Signals</strong><br />When signals are aware if their parents are <strong>stale</strong>, <strong>checking</strong>, or <strong>clean</strong>. In this approach, when <code>E</code> receives the update from <code>B</code>, it will trigger a check/update on <code>D</code>, which will climb up until it can ensure to be back in a <strong>clean</strong> state, allowing <code>E</code> to finally update.</li>\n</ol>\nBack To Our UIs\n<p>After this dive into what <strong>fine-grained reactivity</strong> means, it’s time to take a step back and look at our websites and apps. Let’s analyze what it means to our daily work.</p>\nDX And UX\n<p>When the code we wrote is easier to reason about, we can then focus on the things that really matter: the features we deliver to our users. Naturally, tools that require less work to operate will deliver less maintenance and overhead for the craftsperson.</p>\n<p>A system that is glitch-free and efficient by default will get out of the developer’s way when it’s time to build with it. It will also enforce a higher connection to the platform via a thinner abstraction layer.</p>\n<p>When it comes to Developer Experience, there is also something to be said about known territory. People are more productive within the mental models and paradigms they are used to. Naturally, solutions that have been around for longer and have solved a larger quantity of challenges are easier to work with, but that is <strong>at odds with innovation</strong>. It was a cognitive exercise when JSX came around and replaced imperative DOM updates with jQuery. In the same way, a new paradigm to handle rendering will cause a similar discomfort until it becomes common.</p>\nGoing Deeper\n<p>We will talk further about this in the next article, where we’re looking more closely into different implementations of signals (lazy, eager, hybrid), scheduled updates, interacting with the DOM, and debugging your own code!</p>\n<p>Meanwhile, you can find me in the comments section below, on <a href=\"https://atila.io/x\">𝕏 (Twitter)</a>, <a href=\"https://atila.io/linkedin\">LinkedIn</a>, <a href=\"https://atila.io/bsky\">BlueSky</a>, or even <a href=\"https://atila.io/youtube\">youtube</a>. I’m always happy to chat, and if you tell me what you want to know, I’ll make sure to include it in the next article! See ya!</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"80887a0139f0248ec241f2ccb885b5b790b2ad34e2ce5bb40c3ebad3b4dcabda","category":"Tech"}