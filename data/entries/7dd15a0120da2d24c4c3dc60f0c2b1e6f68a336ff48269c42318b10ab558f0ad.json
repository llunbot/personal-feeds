{"title":"Integrating Localization Into Design Systems","link":"https://smashingmagazine.com/2025/05/integrating-localization-into-design-systems/","date":1747044000000,"content":"<p>Mark and I work as product designers for SAS, a leader in analytics and artificial intelligence recognized globally for turning data into valuable insights. Our primary role is to support the token packages and component libraries for the SAS Filament Design System. SAS’ customer base is global, meaning people from diverse countries, cultures, and languages interact with products built with the Filament Design System.</p>\n<p>SAS designers use Figma libraries developed by the Filament Design System team to create UX specifications. These high-fidelity designs are typically crafted in English, unknowingly overlooking multilingual principles, which can result in layout issues, text overflow, and challenges with right-to-left (RTL) languages. These issues cascade into the application, ultimately creating <strong>usability issues</strong> for SAS customers. This highlights the need to prioritize <strong>localization</strong> from the start of the design process.</p>\n<p>With the introduction of Figma Variables, alongside the advancements in design tokens, we saw an opportunity for designers. We imagined a system where a Figma design could dynamically switch between themes, densities, and even languages.</p>\n<p>This would allow us to design and test multilingual capabilities more effectively, ensuring our design system was both <strong>flexible</strong> and <strong>adaptable</strong>.</p>\n<p>While researching localization integration for design systems, we realized a significant gap in existing documentation on supporting localization and internationalization in design tokens and Figma Variables. Many of the challenges we faced, such as managing typography across locales or adapting layouts dynamically, were undocumented or only partially addressed in available resources.</p>\n<p>Our story demonstrates how combining foundational principles of multilingual design with design tokens can help tackle the complexities of language switching in design systems. We are not arguing that our approach is the best, but given the lack of documentation available on the subject, we hope it will get the conversation started.</p>\n<p>But before we start, it’s essential to understand the distinction between Localization (L10n) and Internationalization (I18n).</p>\n<p><strong>Localization (L10n)</strong> refers to the process of adapting designs for specific languages, regions, or cultures and involves the following:</p>\n<ul>\n<li>Translating text;</li>\n<li>Adjusting layouts to accommodate language-specific requirements, such as longer or shorter text strings or right-to-left (RTL) text for languages like Arabic;</li>\n<li>Ensuring visual elements are culturally appropriate and resonate with the target audience.</li>\n</ul>\n<p><strong>Internationalization (I18n)</strong> is the preparation phase, ensuring designs are flexible and adaptable to different languages and regions. Key considerations in Figma include:</p>\n<ul>\n<li>Using placeholder text to represent dynamic content;</li>\n<li>Setting up constraints for dynamic resizing to handle text expansion or contraction;</li>\n<li>Supporting bi-directional text for languages that require RTL layouts.</li>\n</ul>\n<p>These concepts are not only foundational to multilingual design but also integral to delivering inclusive and accessible experiences to global users.</p>\nPre-Figma Setup: Building A Framework\n<h3>Understanding Our Design Token System</h3>\n<p>Before diving deeper, it’s crucial to understand that our design tokens are stored in JSON files. These JSON files are managed in an application we call “Token Depot,” hosted on our corporate GitHub.</p>\n<p>We utilize the Tokens Studio plugin (pro plan) to transform these JSON files into Figma libraries. For us, design tokens are synonymous with variables — we don’t create additional variables that only exist in Figma. However, we do create styles in Figma that serve as “recipe cards” for specific HTML elements. For instance, an H2 might include a combination of font-family, font-size, and font-weight.</p>\n<p><strong>It’s important to note</strong> that our design token values are directly tied to CSS-based values.</p>\n<h3>Initial Setup: Theme Switching And Localization</h3>\n<p>In 2022, we took on the massive task of refactoring all our token names to be more <strong>semantic</strong>. At that time, we were only concerned with theme switching in our products.</p>\n<p>Our tokens were re-categorized into the following groups:</p>\n<ul>\n<li>Color<ul>\n<li>Brand colors (SAS brand colors)</li>\n<li>Base colors (references to Brand colors)</li>\n</ul>\n</li>\n<li>Typography (e.g., fonts, spacing, styles)</li>\n<li>Space (e.g., padding, margins)</li>\n<li>Size (e.g., icons, borders)</li>\n<li>Style (e.g., focus styles)</li>\n<li>Motion (e.g., animations)</li>\n<li>Shadow.</li>\n</ul>\n<p><img src=\"https://files.smashing.media/articles/integrating-localization-into-design-systems/token-categories.png\" /></p>\n<p><strong>In our early setup:</strong></p>\n<ul>\n<li>A core folder contained JSON files for values unaffected by theme or brand.</li>\n<li>Brand folders included three JSON files (one for each theme). These were considered “English” by default.</li>\n<li>A separate languages folder contained overrides for other locales, stacked on top of brand files to replace specific token values.</li>\n</ul>\n<p>Our JSON files were configured with English as the default. Other locales were managed with a set of JSON files that included overrides for English. These overrides were minimal, focusing mainly on font and typography adjustments. For example, bold typefaces often create issues because many languages like Chinese, Japanese, or Korean (CJK languages) fonts lack distinct bold versions. Thus, we replaced the font-weight token value from 700 to 400 in our CJK locales.</p>\n<p>We also update the values for font-family, letter spacing, font-style, and font-variant tokens. In Figma, our application screens were originally designed in English, and in 2023, we only implemented theme-switching modes, not language options. Additionally, we created detailed lists to document which design tokens could be converted to Figma variables and which could not, as the initial release of variables supported only a limited set.</p>\n<h3>Introducing Density Switching</h3>\n<p>The introduction of <strong>density switching</strong> in our products marked a significant turning point. This change allowed us to revisit and improve how we handled localization and token management. The first thing we had to figure out was the necessary token sorting. We ended up with the following list:</p>\n<p><strong>Tokens Impact By Theme And Density</strong></p>\n<p><strong><em>Unaffected by Theme or Density:</em></strong></p>\n<ul>\n<li>Color</li>\n<li>Brand colors</li>\n<li>Base colors</li>\n<li>Motion</li>\n<li>Shadow</li>\n<li>Size</li>\n<li>Border size</li>\n<li>Outline size</li>\n<li>Typography</li>\n<li>Base font size</li>\n<li>Letter spacing and word spacing</li>\n<li>Overflow, text, and word style tokens.</li>\n</ul>\n<p><strong><em>Tokens Impacted by Density:</em></strong></p>\n<ul>\n<li>Typography</li>\n<li>Font sizes</li>\n<li>Line Height</li>\n<li>Font spacing</li>\n<li>Size</li>\n<li>Border radius</li>\n<li>Icon sizes</li>\n<li>Space</li>\n<li>Base spacing.</li>\n</ul>\n<p><strong><em>Tokens Impacted by Theme:</em></strong></p>\n<ul>\n<li>Colors</li>\n<li>Action, body, container, dataviz, display, heading, highlight, icon, label, status, syntax, tag, text, thumbnail, and zero-stat</li>\n<li>Size</li>\n<li>Border size</li>\n<li>Typography</li>\n<li>Font-family</li>\n<li>Style</li>\n<li>Action (focus styles).</li>\n</ul>\n<p>With density, we expanded locale-specific value changes beyond font-family, letter spacing, font-style, and font-variant tokens to additionally include:</p>\n<ul>\n<li>Font sizes</li>\n<li>Icon sizes</li>\n<li>Line height</li>\n<li>Spacing</li>\n<li>Border radius.</li>\n</ul>\n<p>Revisiting our type scale and performing numerous calculations, we documented the required token value changes for all the locales across the density. This groundwork enabled us to tackle the <strong>restructuring of our JSON files</strong> effectively.</p>\n<p><img src=\"https://files.smashing.media/articles/integrating-localization-into-design-systems/tokens-impacted.png\" /></p>\n<h3>JSON File Restructuring</h3>\n<p>In our token repository, we:</p>\n<ol>\n<li>Updated the tokens in the core folder.</li>\n<li>Added a density folder and a language folder in each brand.</li>\n</ol>\n<p>After collaborating with our front-end development team, we decided to minimize the number of JSON files. Too many files introduce complexity and bugs and hinder performance. Instead of creating a JSON file for each language-density combination, we defined the following language categories:</p>\n<p><strong>Language Categories</strong></p>\n<ul>\n<li>Western European and Slavic Languages<ul>\n<li>Polish, English, French, German, and Spanish</li>\n</ul>\n</li>\n<li>Chinese Languages<ul>\n<li>Simplified and traditional scripts</li>\n</ul>\n</li>\n<li>Middle Eastern and East Asian Languages<ul>\n<li>Arabic, Hebrew, Japanese, Korean, Thai, and Vietnamese</li>\n</ul>\n</li>\n<li>Global Diverse<ul>\n<li>Africa, South Asia, Pacific, and Indigenous languages, Uralic, and Turkic groups.</li>\n</ul>\n</li>\n</ul>\n<p>These categories became our JSON files, with one file per density level. Each file contained tokens for font size, icon size, line height, spacing, and border-radius values. For example, all Chinese locales shared consistent values regardless of font-family.</p>\n<p><img src=\"https://files.smashing.media/articles/integrating-localization-into-design-systems/language-groups.png\" /></p>\n<p>In addition, we added a folder containing JSON files per locale, overriding core values and theme folders, such as font-family.</p>\nFigma Setup: Bridging Tokens And Design\n<h3>Token Studio Challenges</h3>\n<p>After restructuring our JSON files, we anticipated gaining support for typography variables in the Tokens Studio plugin. Instead, Tokens Studio released version 2.0, introducing a major shift in workflow. Previously, we imported JSON files directly into Figma and avoided pushing changes back through the plugin. Adjusting to the new version required us to relearn how to use the plugin effectively.</p>\n<p>Our first challenge was navigating the <strong>complexity of the import process</strong>. The <code>$metadata.json</code> and <code>$themes.json</code> files failed to overwrite correctly during imports, resulting in duplicate collections in Figma when exporting variables. Despite recreating the required theme structure within the plugin, the issue persisted. To resolve this, we deleted the existing <code>$metadata.json</code> and <code>$themes.json</code> files from the repository before pulling the updated GitHub repo into the plugin. However, even with this solution, we had to manually remove redundant collections that appeared during the export process.</p>\n<p>Once we successfully migrated our tokens from JSON files into Figma using the Tokens Studio plugin, we encountered our next challenge.</p>\n<p>Initially, we used only “English” and theme modes in Figma, relying primarily on styles since Figma’s early variable releases lacked support for typography variables. Now, with the goal of implementing theme, density, and language switching, we needed to leverage variables — including typography variables. While the token migration successfully brought in the token names as variable names and the necessary modes, some values were missing.</p>\n<p><strong>Typography variables, though promising in concept, were underwhelming in practice.</strong> For example, Figma’s default line-height multiplier for “auto” was 1.2, below the WCAG minimum of 1.5. Additionally, our token values used line-height multipliers, which weren’t valid as Figma variable values. While a percentage-based line-height value is valid in CSS, Figma variables don’t support percentages.</p>\n<p>Our solution involved manually calculating pixel values for line heights across all typography sizes, locale categories, and densities. These values were entered as local variables in Figma, independent of the design token system. This allowed us to implement correct line-height changes for density and locale switches. The process, however, was labor-intensive, requiring the manual creation of hundreds of local variables. Furthermore, grouping font sizes and line heights into Figma styles required additional manual effort due to the lack of support for line-height multipliers or percentage-based variables.</p>\n<p><strong>Examples:</strong></p>\n<ul>\n<li>For CJK locales, medium and low density use a base font size of 16px, while high density uses 18px.</li>\n<li>Western European and Slavic languages use 14px for medium density, 16px for high, and 12px for low density.</li>\n</ul>\n<h3>Additional Challenges</h3>\n<ul>\n<li><strong>Figma vs. Web Rendering</strong><br />In Figma, line height centers text visually within the text box. In CSS, it affects spacing differently depending on the box model. This mismatch required manual adjustments, especially in light of upcoming CSS properties like <code>leading-trim</code>.</li>\n<li><strong>Letter-Spacing Issues</strong><br />While CSS defaults to “normal” for letter-spacing, Figma requires numeric values. Locale-specific resets to “normal” couldn’t utilize variables, complicating implementation.</li>\n<li><strong>Font-Family Stacks</strong><ul>\n<li>Example stack for Chinese:<br /><code>font-family-primary: 'AnovaUI'</code>, <code>'微软雅黑体'</code>, <code>'Microsoft YaHei New'</code>, <code>'微软雅黑'</code>, <code>'Microsoft Yahei'</code>, <code>'宋体'</code>, <code>'SimSun'</code>, <code>'Helvetica Neue'</code>, <code>'Helvetica'</code>, <code>'Arial'</code>, <code>sans-serif</code>.</li>\n</ul>\n</li>\n</ul>\n<p>Starting with a Western font ensured proper rendering of Latin characters and symbols while maintaining brand consistency. However, Figma’s designs using only AnovaUI (SAS Brand Custom font) couldn’t preview locale-based substitutions via system fonts, complicating evaluations of mixed-content designs.</p>\n<p>Finally, as we prepared to publish our new library, we encountered yet another challenge: Figma Ghosts.</p>\n<h3>What Are Figma Ghost Variables?</h3>\n<blockquote>Figma “ghost variables” refer to variables that remain in a Figma project even after they are no longer linked to any design tokens, themes, or components.</blockquote>\n\n<p>These variables often arise due to incomplete deletions, improper imports, or outdated metadata files. Ghost variables may appear in Figma’s variable management panel but are effectively “orphaned,” as they are disconnected from any meaningful use or reference.</p>\n<p><img src=\"https://files.smashing.media/articles/integrating-localization-into-design-systems/ghost-variables.png\" /></p>\n<p>Why They Cause Issues for Designers:</p>\n<ul>\n<li><strong>Clutter and Confusion</strong><br />Ghost variables make the variable list longer and harder to navigate. Designers might struggle to identify which variables are actively in use and which are obsolete.</li>\n<li><strong>Redundant Work</strong><br />Designers might accidentally try to use these variables, leading to inefficiencies or design inconsistencies when the ghost variables don’t function as expected.</li>\n<li><strong>Export and Sync Problems</strong><br />When exporting or syncing variables with a design system or repository, ghost variables can introduce errors, duplicates, or conflicts. This complicates maintaining alignment between the design system and Figma.</li>\n<li><strong>Increased Maintenance Overhead</strong><br />Detecting and manually deleting ghost variables can be time-consuming, particularly in large-scale projects with extensive variable sets.</li>\n<li><strong>Thematic Inconsistencies</strong><br />Ghost variables can create inconsistencies across themes, as they might reference outdated or irrelevant styles, making it harder to ensure a unified look and feel.</li>\n</ul>\n<p>Addressing ghost variables requires careful management of design tokens and variables, often involving clean-up processes to ensure only relevant variables remain in the system.</p>\n<h3>Cleaning Up Ghost Variables</h3>\n<p>To avoid the issues in our Figma libraries, we first had to isolate ghost variables component by component. By selecting a symbol in Figma and navigating the applied variable modes, we had a good sense of which older versions of variables the symbol was still connected to. We found disconnected variables in the component library and our icon library, which resulted in compounded ghost variables across the system. We found that by traversing the layer panel, along with a fantastic plug-in called “Swap Variables,” we were able to remap all the ghost variables in our symbols.</p>\n<p>If we had not completed the clean-up step, designers would not be able to access the overrides for theme, density, and locale.</p>\n<h3>Designing Symbols For Localization</h3>\n<p>To ensure Figma symbols support language swapping, we linked all text layers to our new variables, including font-family, font-size, and line height.</p>\n<p>We do not use Figma’s variable feature to define text strings for each locale (e.g., English, Spanish, French) because, given the sheer breadth and depth of our Products and solutions, it would simply be too daunting a task to undertake. For us, using an existing plug-in, such as “Translator,” gives us what we need.</p>\n<p>After ensuring all text layers were remapped to variables, along with the “Translator” plug-in, we were able to swap entire screens to a new language. This allowed us to start <strong>testing</strong> our symbols for unforeseen layout issues.</p>\n<p><img src=\"https://files.smashing.media/articles/integrating-localization-into-design-systems/translator-plugin.png\" /></p>\n<p>We discovered that some symbols were not supporting text wrapping when needed (e.g., accommodating longer words in German or shorter ones in Japanese). We isolated those issues and updated them to auto-layout for flexible resizing. This approach ensured all our Figma symbols were scalable and adaptable for multilingual support.</p>\n<h3>Delivering The System</h3>\n<p>With our component libraries set up to support localization, we were ready to deliver our component libraries to product designers. As a part of this step, we crafted a “Multilingual Design Cheat Sheet” to help designers understand how to set up their application mockups with Localization and Internationalization in mind.</p>\n<p><strong>Multilingual Design Cheat Sheet:</strong></p>\n<ol>\n<li><strong>General Principles</strong><ul>\n<li>Design flexible layouts that can handle text wrapping and language-specific requirements such as right-to-left orientations.</li>\n<li>Use real content during design and development to identify localization issues such as spacing and wrapping.</li>\n<li>Research the cultural expectations of your target audience to avoid faux pas.</li>\n</ul>\n</li>\n<li><strong>Text &amp; Typography</strong><ul>\n<li>Use Filament Design Systems fonts to ensure support of all languages.</li>\n<li>Avoid custom fonts that lack bold or italic styles for non-Latin scripts like CJK languages.</li>\n<li>Reserve additional space for languages like German or Finnish.</li>\n<li>Avoid hardcoded widths for text containers and use auto-layout to ensure long text strings are readable.</li>\n<li>The Filament Design System tokens adjust line height per language; make sure you are using variables for line-height.</li>\n<li>Use bold sparingly, as Filament tokens override bold styling in some languages. Instead, opt for alternative emphasis methods (e.g., color or size).</li>\n</ul>\n</li>\n<li><strong>Layout &amp; Design</strong><ul>\n<li>Mirror layouts for RTL languages (e.g., Arabic, Hebrew). Align text, icons, and navigation appropriately for the flow of the language.</li>\n<li>Use auto-layout to accommodate varying text lengths.</li>\n<li>Avoid embedding text in images to simplify localization.</li>\n<li>Allow ample spacing around text elements to prevent crowding.</li>\n</ul>\n</li>\n<li><strong>Language-Specific Adjustments</strong>  <ul>\n<li>Adapt formats based on locale (e.g., YYYY/MM/DD vs. MM/DD/YYYY).</li>\n<li>Use metric or imperial units based on the region.</li>\n<li>Test alignments and flows for LTR and RTL languages.</li>\n</ul>\n</li>\n<li><strong>Localization Readiness</strong>  <ul>\n<li>Avoid idioms, cultural references, or metaphors that may not translate well.</li>\n<li>Provide space for localized images, if necessary.</li>\n<li>Use Figma translation plug-ins to test designs for localization readiness and use real translations rather than Lorem Ipsum.</li>\n<li>Test with native speakers for language-specific usability issues.</li>\n<li>Check mirrored layouts and interactions for usability in RTL languages.</li>\n</ul>\n</li>\n</ol>\nLessons Learned And Future Directions\n<p><strong>Lessons Learned</strong></p>\n<p>In summary, building a localization-ready design system was a complex yet rewarding process that taught Mark and me several critical lessons:</p>\n<ul>\n<li><strong>Localization and internationalization must be prioritized early.</strong><br />Ignoring multilingual principles in the early stages of design creates cascading issues that are costly to fix later.</li>\n<li><strong>Semantic tokens are key.</strong><br />Refactoring our tokens to be more semantic streamlined the localization process, reducing complexity and improving maintainability.</li>\n<li><strong>Figma variables are promising but limited.</strong><br />While Figma Variables introduced new possibilities, their current limitations — such as lack of percentage-based line-height values and manual setup requirements — highlight areas for improvement.</li>\n<li><strong>Automation is essential.</strong><br />Manual efforts, such as recalculating and inputting values for typography and density-specific tokens, are time-intensive and prone to error. Plugins like “Translator” and “Swap Variables” proved invaluable in streamlining this work.</li>\n<li><strong>Collaboration is crucial.</strong><br />Close coordination with front-end developers ensured that our JSON restructuring efforts aligned with performance and usability goals.</li>\n<li><strong>Testing with real content is non-negotiable.</strong><br />Design issues like text wrapping, RTL mirroring, and font compatibility only became apparent when testing with real translations and flexible layouts.</li>\n</ul>\n<p><strong>Future Directions</strong></p>\n<p>As we look ahead, our focus is on enhancing the Filament Design System to better support global audiences and simplify the localization process for designers:</p>\n<ul>\n<li><strong>Automatic mirrored layouts for RTL languages.</strong><br />We plan to develop tools and workflows that enable seamless mirroring of layouts for right-to-left languages, ensuring usability for languages like Arabic and Hebrew.</li>\n<li><strong>Improved figma integration.</strong><br />Advocacy for Figma enhancements, such as percentage-based line-height support and better handling of variable imports, will remain a priority.</li>\n<li><strong>Advanced automation tools.</strong><br />Investing in more robust plugins and custom tools to automate the calculation and management of tokens across themes, densities, and locales will reduce manual overhead.</li>\n<li><strong>Scalable localization testing framework.</strong><br />Establishing a framework for native speaker testing and real-world content validation will help us identify localization issues earlier in the design process.</li>\n<li><strong>Expanding the multilingual design cheat sheet.</strong><br />We will continue to refine and expand the cheat sheet, incorporating feedback from designers to ensure it remains a valuable resource.</li>\n<li><strong>Community engagement.</strong><br />By sharing our findings and lessons, we aim to contribute to the broader design community, fostering discussions around integrating localization and internationalization in design systems.</li>\n</ul>\n<p>Through these efforts, Mark and I hope to create a more inclusive, scalable, and efficient design system that meets the diverse needs of our global audience while empowering SAS designers to think beyond English-first designs.</p>\n<h3>Further Reading On SmashingMag</h3>\n<ul>\n<li>“<a href=\"https://www.smashingmagazine.com/2020/11/internationalization-localization-static-sites/\">Internationalization And Localization For Static Sites</a>,” Sam Richard</li>\n<li>“<a href=\"https://www.smashingmagazine.com/2014/06/css-driven-internationalization-in-javascript/\">CSS-Driven Internationalization In JavaScript</a>,” Maksim Chemerisuk</li>\n<li>“<a href=\"https://www.smashingmagazine.com/2014/12/how-to-conduct-website-localization/\">How To Conduct Website Localization: Don’t Get Lost In Translation</a>,” Julia Rozwens</li>\n<li>“<a href=\"https://www.smashingmagazine.com/2012/07/12-commandments-software-localization/\">12 Commandments Of Software Localization</a>,” Zack Grossbart</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"7dd15a0120da2d24c4c3dc60f0c2b1e6f68a336ff48269c42318b10ab558f0ad","category":"Tech"}