{"title":"Writing Terraform for unsupported resources","link":"https://www.hashicorp.com/blog/writing-terraform-for-unsupported-resources","date":1677085200000,"content":"<p>Codifying your infrastructure with Terraform is a great way to ensure repeatability and <a href=\"https://www.hashicorp.com/resources/what-is-mutable-vs-immutable-infrastructure\">immutability</a> of your infrastructure, but what can you do when a Terraform provider does not support a resource that is required? In this blog, you will learn how to use the TerraCurl provider to bring unsupported resources under Terraform management.</p>\n<h2><a href=\"#introduction-to-terracurl\">»</a><a></a>Introduction to TerraCurl</h2>\n<p>Terraform is a powerful tool for automating the creation and management of infrastructure resources across multiple clouds and platforms, from Azure, AWS, and Google Cloud, to Kubernetes and <a href=\"https://www.nomadproject.io/\">Nomad</a>. Its ability to do so is dependent on the APIs of the target platforms and cloud providers. For Terraform to be able to interface with multiple target platforms, it uses the concept of a Terraform provider, which is a Terraform-centric wrapper around the target APIs, much like a client library in programming ecosystems. These providers implement methods that allow Terraform to create, read, update, and delete the provider resources.</p>\n<p>There are situations where the target API supports a resource which is not yet implemented in the Terraform provider. In some cases, this is by design. For example, the Vault provider purposely does not have a resource to unseal a Vault cluster, but the API exists to do so. Providers are maintained by HashiCorp, our technology partners, or the open source Terraform community and pull requests are welcome; however, while waiting for pull requests to be reviewed and merged, you can still deploy resources with Terraform using a provider called TerraCurl.</p>\n<p><a href=\"https://registry.terraform.io/providers/devops-rob/terracurl/latest\">TerraCurl</a> is a utility provider I developed that allows you to make managed and unmanaged API calls in your Terraform code. A managed API call contains instructions on which API calls to make on create, and delete operations, and Terraform stores the response to the API call in the state file, all of which is accessible for reference by other resources. For all intents and purposes, a managed API call is no different to any normal Terraform resource.</p>\n<p>An unmanaged call operates slightly differently as it makes the instructed API call every time Terraform is run, usually at the beginning of a Terraform run. This is designed for instances where information is required from an API call in order for the rest of the Terraform code to function. An example of this would be to look up <a href=\"https://www.boundaryproject.io/\">Boundary</a> scope ID in order for Terraform to configure a child scope.</p>\n<p>The goal of this provider is to help out in situations where the platform-native provider does not support the resource you require and the platform API does. It is not intended to replace platform-native providers, which should always be preferred to TerraCurl.</p>\n<h2><a href=\"#managed-api-calls\">»</a><a></a>Managed API calls</h2>\n<p>Managed API calls require instructions to create and delete a resource. These instructions include:</p>\n<ul>\n<li>The API endpoint</li>\n<li>The HTTP method</li>\n<li>Any HTTP headers (optional)</li>\n<li>The request body (optional)</li>\n<li>Expected response codes</li>\n</ul>\n<p>All managed calls use the <code>terracurl_request</code> resource. The example below shows this in action:</p><pre><code>terraform {\n  required_providers {\n    terracurl = {\n      source = \"devops-rob/terracurl\"\n      version = \"1.0.0\"\n    }\n  }\n}\n\nprovider \"terracurl\" {\n}\n\nresource \"terracurl_request\" \"token\" {\n  name           = \"rob-token\"\n\n  # Create instructions for Terraform\n  url            = \"http://localhost:8200/v1/auth/token/create\"\n  method         = \"POST\"\n  request_body   = &lt;</code></pre><p>The code example above will create and manage a Vault token with a prespecified ID, which is something not supported in the Vault provider by design.The response is then stored in the state file. If none of the expected response codes are received, the Terraform run will fail, as the API call has likely failed. When <code>terraform destroy</code> is run, the destroy instructions are followed. In this case, it will make an API call to Vault to revoke the token. This use case is a good example of the intended purpose of the TerraCurl provider, because the ability to specify the token ID will likely never be supported in the Vault provider.</p>\n<p><strong>Note:</strong> Generating Vault tokens with Terraform will store them in plaintext in the state file, which has some security implications that may not be suitable for production environments.</p>\n<h2><a href=\"#reading-data-from-the-response\">»</a><a></a>Reading data from the response</h2>\n<p>Terraform has a utility function built in called <a href=\"https://developer.hashicorp.com/terraform/language/functions/jsondecode\"><code>jsondecode</code></a> that allows you to read and access elements of the JSON response to the API call. Adding the code snippet below to the example above will render the full JSON response.</p><pre><code>output \"response\" {\n  value = jsondecode(terracurl_request.token.response)\n}</code></pre><p>To access a specific element from the response, you can drill down further by specifying the element you would like to read. For example, to output the accessor ID of the token, which is nested in the <code>auth</code> object, you can use the following function in the output:</p><pre><code>output \"accessor\" {\n  value = jsondecode(terracurl_request.token.response).auth.accessor\n}</code></pre><p>The process of reading and accessing elements from the response is much like the process of unmarshalling data in programming languages like Golang.</p>\n<h2><a href=\"#unmanaged-api-calls\">»</a><a></a>Unmanaged API calls</h2>\n<p>Unmanaged calls defer from managed calls because they are not intended to be used to manage the lifecycle of resources. For this reason, all unmanaged API calls in TerraCurl use the <code>terracurl_request</code> data source.</p>\n<p>A good example use case for the data source is looking up Boundary resource IDs. The functionality exists in the Boundary API but does not yet exist in the Boundary provider.</p><pre><code>data \"terracurl_request\" \"scope_id\" {\n  name           = \"scope_id\"\n  url            = \"http://127.0.0.1:9200/v1/scopes?filter=%22Rift%22+in+%22%2Fitem%2Fname%22&amp;scope_id=global\"\n  method         = \"GET\"\n}\n\noutput \"scope_response\" {\n  value = jsondecode(data.terracurl_request.scope_id.response)\n}</code></pre><p>The example code above makes an API call to Boundary to list all scopes and filters for a scope named <code>Rift</code>. The output contains the decoded JSON response.</p><pre><code>scope_response = {\n  \"items\" = [\n    {\n      \"authorized_actions\" = [\n        \"no-op\",\n      ]\n      \"authorized_collection_actions\" = {\n        \"auth-methods\" = [\n          \"list\",\n        ]\n        \"scopes\" = [\n          \"list\",\n        ]\n      }\n      \"description\" = \"Scope for Rift Engineering\"\n      \"id\" = \"o_u7vZIrVw3W\"\n      \"name\" = \"Rift Engineering Department\"\n      \"scope\" = {\n        \"description\" = \"Global Scope\"\n        \"id\" = \"global\"\n        \"name\" = \"global\"\n        \"type\" = \"global\"\n      }\n      \"scope_id\" = \"global\"\n      \"type\" = \"org\"\n    },\n  ]\n}</code></pre><p>Just like before, we can drill down further into this response to access a specific element. For example, the scope ID.</p><pre><code>output \"scope_response\" {\n  value = jsondecode(data.terracurl_request.scope_id.response).items.*.id\n}</code></pre><h2><a href=\"#authenticated-and-mutually-authenticated-calls-with-tls\">»</a><a></a>Authenticated and mutually authenticated calls with TLS</h2>\n<p>The <a href=\"https://registry.terraform.io/providers/devops-rob/terracurl/latest\">latest release</a> of TerraCurl has the ability to optionally include TLS materials in API calls, as well as verify the server's identity (<a href=\"https://en.wikipedia.org/wiki/Mutual_authentication\">mTLS)</a>). This is supported in both managed and unmanaged API calls.</p>\n<p>The example below shows this in action with an unmanaged API call to a Vault server that requires TLS. Notice the <code>cert_file</code>, <code>key_file</code>, <code>ca_cert_file</code>, and <code>skip_tls_verify</code> arguments in the example.</p><pre><code>data \"terracurl_request\" \"test\" {\n  name   = \"vault_seal_status\"\n  url    = \"https://localhost:8200/v1/sys/seal-status\"\n  method = \"GET\"\n\n  cert_file       = \"server-vault-0.pem\"\n  key_file        = \"server-vault-0-key.pem\"\n  ca_cert_file    = \"vault-server-ca.pem\"\n  skip_tls_verify = false\n\n  response_codes = [\n    \"200\"\n  ]\n}</code></pre><p>The same can also be done for managed calls. However, TLS materials are individually scoped between creation and destruction API calls, each of which are optional. For example, you could provide TLS materials for creation calls and omit them for destruction calls. This will depend on how your target API works. In most cases, if TLS is required for creation, it will likely be required for destruction. This will also allow the use of different TLS materials for creation and destruction calls if required.</p><pre><code>resource \"terracurl_request\" \"mount\" {\n  name           = \"vault-mount\"\n  url            = \"https://localhost:8200/v1/sys/mounts/aws\"\n  method         = \"POST\"\n  request_body   = &lt;</code></pre><h2><a href=\"#error-handling-and-retry-logic\">»</a><a></a>Error handling and retry logic</h2>\n<p>When interacting with target APIs, there are many reasons why initial calls may fail and subsequent calls succeed. This could be due to a blip in network connectivity or it could be that the behavior of an API is eventually consistent. Whatever the reason is, if there are any errors in the API call, or the expected response code is not received, the Terraform run will fail.</p>\n<p>The latest release of TerraCurl introduces retry logic to cater for these scenarios. This feature isn't enabled by default; however, if you do need TerraCurl to retry failed API calls, this can easily be done by adding the retry arguments to the Terraform code. This is possible in both the resource and the data source.</p><pre><code>data \"terracurl_request\" \"test\" {\n  name   = \"products\"\n  url    = \"https://localhost:5200/v1/sys/seal-status\"\n  method = \"GET\"\n\n  cert_file       = \"server-vault-0.pem\"\n  key_file        = \"server-vault-0-key.pem\"\n  ca_cert_file    = \"vault-server-ca.pem\"\n  skip_tls_verify = false\n\n  response_codes = [\n    200\n  ]\n\n  max_retry      = 3\n  retry_interval = 10\n\n}</code></pre><p>The code example above shows the retry logic in action using the unmanaged data source. If the initial API call returns an error, or the expected response code is not returned, TerraCurl will wait 10 seconds and re-attempt the call. This will be repeated up to 3 times (not including the initial API call).</p>\n<p>As data sources are called at the beginning of Terraform runs, this data source will ensure that Vault is unsealed and ready to accept connections before Terraform attempts to create any resources in Vault. If after 4 attempts (including the initial attempt), there are still failures or a <code>200</code> response code is not returned from Vault, the Terraform run will fail.</p>\n<p>The code example below shows the retry logic in use with the TerraCurl managed resource. The main difference here is the additional <code>destroy_max_retry</code> and <code>destroy_retry_interval</code> arguments to enable and configure the retry logic on the destroy calls.</p><pre><code>resource \"terracurl_request\" \"mount\" {\n  name           = \"vault-mount\"\n  url            = \"https://localhost:8200/v1/sys/mounts/aws\"\n  method         = \"POST\"\n  request_body   = &lt;</code></pre><h2><a href=\"#summary-and-next-steps\">»</a><a></a>Summary and next steps</h2>\n<p>This blog post has examined the challenges that engineers sometimes encounter when developing Terraform modules, specifically unsupported resources in Terraform providers. TerraCurl is a flexible Terraform utility provider that can assist in these scenarios and open more possibilities and use cases in workflows.</p>\n<p>I hope you have this blog useful and please open a <a href=\"https://github.com/devops-rob/terraform-provider-terracurl/issues/new\">github issue</a> if you have any feedback or feature requests for the provider.</p>","author":"Rob Barnes","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"60b206ad107f252357648ac81686617fa72553e5bfef55951305ec24fe27b97a","category":"Tech"}