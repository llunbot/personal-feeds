{"title":"WebGPU now available for testing in Safari Technology Preview","link":"https://webkit.org/blog/14879/webgpu-now-available-for-testing-in-safari-technology-preview/","date":1703179848000,"content":"<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGPU_API\">WebGPU</a> is a new <a href=\"https://www.w3.org/TR/webgpu/\">standards-compliant</a> API that enables high-performance 3D graphics and general-purpose <a href=\"https://en.wikipedia.org/wiki/Data_parallelism\">computations</a> on the Web. WebGPU programs are written in JavaScript but expose GPU functionality, allowing GPU computing to be used in Web content for the first time. Starting in <a href=\"https://developer.apple.com/safari/technology-preview/\">Safari Technology Preview</a> 185, WebGPU can be enabled for early testing and development.</p>\n<p>To enable WebGPU, turn on the “WebGPU”, “GPU Process: DOM Rendering” and “GPU Process: Canvas Rendering” feature flags in the <a href=\"https://developer.apple.com/documentation/safari-developer-tools/feature-flag-settings\">Feature Flags</a> tab in Safari Preferences. If you don’t see the Feature Flags tab, you need to first check “<a href=\"https://developer.apple.com/documentation/safari-developer-tools/enabling-developer-features\">Show features for web developers</a>” in the Advanced tab.</p>\n<p>Once you have WebGPU enabled in Safari Technology Preview 185, <a href=\"https://webgpu.github.io/webgpu-samples/samples/particles\">try out this example of WebGPU</a>. It utilizes many of the best features of WebGPU.</p>\n<figure></figure>\n<h2>WebGPU JavaScript API</h2>\n<p>The WebGPU API is accessed through JavaScript, similar to WebGL.</p>\n<h3>Creating a GPUDevice</h3>\n<p>In order to use WebGPU, a device must be created. Resources and pipeline state are created from a <code>GPUDevice</code> instance. To create a device with default limits and features which are supported on all devices supporting WebGPU, we can pass zero parameters to the invocations of <code>requestAdapter</code> and <code>requestDevice</code>.</p>\n<pre><code><span>const</span> <span>adapter</span> <span>=</span> <span>await</span> <span>navigator</span>.<span>gpu</span>.<span>requestAdapter</span>();\n<span>device</span> <span>=</span> <span>await</span> <span>adapter</span>.<span>requestDevice</span>();\n</code></pre>\n<h3>Configuring a GPUCanvasContext</h3>\n<p>The <code>GPUCanvasContext</code> is an interface that allows you to configure how your content will be displayed in the corresponding <code>HTMLCanvas</code> element on the page.</p>\n<pre><code><span>context</span> <span>=</span> <span>canvas</span>.<span>getContext</span>(<span>'webgpu'</span>);\n<span>const</span> <span>canvasFormat</span> <span>=</span> <span>\"bgra8unorm\"</span>;\n\n<span>const</span> <span>contextConfiguration</span> <span>=</span> {\n    <span>device</span><span>:</span> <span>device</span>,\n    <span>format</span><span>:</span> <span>canvasFormat</span>,\n    <span>alphaMode</span><span>:</span> <span>'opaque'</span>,\n};\n<span>context</span>.<span>configure</span>(<span>contextConfiguration</span>);\n</code></pre>\n<h3>Creating a GPURenderPipeline</h3>\n<p>A <code>GPURenderPipeline</code> or a corresponding <code>GPUComputePipeline</code> are used to configure the pipeline state of the graphics driver. This pipeline state is then used in a <code>GPURenderPassEncoder</code> or <code>GPUComputePassEncoder</code> as later illustrated.</p>\n<pre><code><span>const</span> <span>shaderModule</span> <span>=</span> <span>device</span>.<span>createShaderModule</span>({ <span>code</span><span>:</span> <span>wgslSource</span> });\n<span>const</span> <span>vertexStageDescriptor</span> <span>=</span> { <span>module</span><span>:</span> <span>shaderModule</span>, <span>entryPoint</span><span>:</span> <span>\"vsmain\"</span> };\n<span>const</span> <span>fragmentStageDescriptor</span> <span>=</span> { <span>module</span><span>:</span> <span>shaderModule</span>, <span>entryPoint</span><span>:</span> <span>\"fsmain\"</span> };\n<span>const</span> <span>renderPipelineDescriptor</span> <span>=</span> {\n    <span>layout</span><span>:</span> <span>'auto'</span>,\n    <span>vertex</span><span>:</span> <span>vertexStageDescriptor</span>,\n    <span>fragment</span><span>:</span> <span>fragmentStageDescriptor</span>,\n    <span>primitive</span><span>:</span> {<span>topology</span><span>:</span> <span>\"triangle-list\"</span> },\n};\n<span>const</span> <span>renderPipeline</span> <span>=</span> <span>device</span>.<span>createRenderPipeline</span>(<span>renderPipelineDescriptor</span>);\n</code></pre>\n<h3>Issuing draw calls</h3>\n<p>A <code>GPURenderPassEncoder</code> is created to send draw calls to the graphics driver. In the below example, we draw a simple triangle which contains three vertices. A <code>GPURenderPassEncoder</code> can also draw multiple instances of the same geometry or draw from an offset of a vertex buffer.</p>\n<pre><code><span>const</span> <span>colorAttachmentDescriptor</span> <span>=</span> {\n    <span>view</span><span>:</span> <span>renderAttachment</span>,\n    <span>loadOp</span><span>:</span> <span>\"clear\"</span>,\n    <span>storeOp</span><span>:</span> <span>\"store\"</span>,\n    <span>clearColor</span><span>:</span> { <span>r</span><span>:</span> <span>0.15</span>, <span>g</span><span>:</span> <span>0.15</span>, <span>b</span><span>:</span> <span>0.5</span>, <span>a</span><span>:</span> <span>1</span> }\n};\n<span>const</span> <span>renderPassDescriptor</span> <span>=</span> { <span>colorAttachments</span><span>:</span> [<span>colorAttachmentDescriptor</span>] };\n<span>const</span> <span>commandEncoder</span> <span>=</span> <span>device</span>.<span>createCommandEncoder</span>();\n<span>const</span> <span>renderPassEncoder</span> <span>=</span> <span>commandEncoder</span>.<span>beginRenderPass</span>(<span>renderPassDescriptor</span>);\n<span>renderPassEncoder</span>.<span>setPipeline</span>(<span>renderPipeline</span>);\n<span>const</span> <span>vertexBufferSlot</span> <span>=</span> <span>0</span>;\n<span>renderPassEncoder</span>.<span>setVertexBuffer</span>(<span>vertexBufferSlot</span>, <span>vertexBuffer</span>, <span>0</span>);\n<span>renderPassEncoder</span>.<span>draw</span>(<span>3</span>, <span>1</span>, <span>0</span>, <span>0</span>); <span>// 3 vertices, 1 instance, 0th vertex, 0th instance.\n</span><span>renderPassEncoder</span>.<span>end</span>();\n<span>const</span> <span>commandBuffer</span> <span>=</span> <span>commandEncoder</span>.<span>finish</span>();\n<span>const</span> <span>queue</span> <span>=</span> <span>device</span>.<span>queue</span>;\n<span>queue</span>.<span>submit</span>([<span>commandBuffer</span>]);\n</code></pre>\n<h2>WebGPU Shading Language</h2>\n<p>WebGPU introduces WGSL, a platform independent shading language for the web. Here is an example of a WGSL shader source that would be passed in place of <code>wgslSource</code> in the above API call:</p>\n<pre><code><span>const</span> <span>wgslSource</span> <span>=</span> `\n    <span>struct</span> <span>Vertex</span> {\n        @<span>builtin</span>(<span>position</span>) <span>Position</span><span>:</span> <span>vec4</span><span>&lt;</span><span>f32</span><span>&gt;</span>,\n        @<span>location</span>(<span>0</span>) <span>color</span><span>:</span> <span>vec4</span><span>&lt;</span><span>f32</span><span>&gt;</span>,\n    }\n\n    @<span>vertex</span> <span>fn</span> <span>vsmain</span>(@<span>builtin</span>(<span>vertex_index</span>) <span>VertexIndex</span><span>:</span> <span>u32</span>) <span>-</span><span>&gt;</span> <span>Vertex</span>\n    {\n        <span>var</span> <span>pos</span><span>:</span> <span>array</span><span>&lt;</span><span>vec2</span><span>&lt;</span><span>f32</span><span>&gt;</span>, <span>3</span><span>&gt;</span> <span>=</span> <span>array</span><span>&lt;</span><span>vec2</span><span>&lt;</span><span>f32</span><span>&gt;</span>, <span>3</span><span>&gt;</span>(\n            <span>vec2</span><span>&lt;</span><span>f32</span><span>&gt;</span>( <span>0.0</span>,  <span>0.5</span>),\n            <span>vec2</span><span>&lt;</span><span>f32</span><span>&gt;</span>(<span>-</span><span>0.5</span>, <span>-</span><span>0.5</span>),\n            <span>vec2</span><span>&lt;</span><span>f32</span><span>&gt;</span>( <span>0.5</span>, <span>-</span><span>0.5</span>));\n        <span>var</span> <span>vertex_out</span> <span>:</span> <span>Vertex</span>;\n        <span>vertex_out</span>.<span>Position</span> <span>=</span> <span>vec4</span><span>&lt;</span><span>f32</span><span>&gt;</span>(<span>pos</span>[<span>VertexIndex</span>], <span>0.0</span>, <span>1.0</span>);\n        <span>vertex_out</span>.<span>color</span> <span>=</span> <span>vec4</span><span>&lt;</span><span>f32</span><span>&gt;</span>(<span>pos</span>[<span>VertexIndex</span>] <span>+</span> <span>vec2</span><span>&lt;</span><span>f32</span><span>&gt;</span>(<span>0.5</span>, <span>0.5</span>), <span>0.0</span>, <span>1.0</span>);\n        <span>return</span> <span>vertex_out</span>;\n    }\n\n    @<span>fragment</span> <span>fn</span> <span>fsmain</span>(<span>in</span><span>:</span> <span>Vertex</span>) <span>-</span><span>&gt;</span> @<span>location</span>(<span>0</span>) <span>vec4</span><span>&lt;</span><span>f32</span><span>&gt;</span>\n    {\n        <span>return</span> <span>in</span>.<span>color</span>;\n    }\n`;\n</code></pre>\n<h2>Try WebGPU and file bugs!</h2>\n<p>We’re very excited to have an early version of WebGPU and WGSL in the latest version of Safari Technology Preview. Please do try it out. Check out the <a href=\"https://webgpu.github.io/webgpu-samples/samples/helloTriangle\">public repository of WebGPU samples</a>. And file bugs or issues you discover at <a href=\"http://bugs.webkit.org/\">bugs.webkit.org</a>.</p>","author":"","siteTitle":"Blog – WebKit","siteHash":"7f8dbea0b8f53db2e11a2faa08c6dca9954c01638d09a2ce585b77a60d10f7a1","entryHash":"fc66181e65c342389c8174308af7cdceab3eab12e751f89fae1e2961ad7f40d3","category":"Tech"}