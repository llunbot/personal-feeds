{"title":"Creating A Public/Private Multi-Monorepo For PHP Projects","link":"https://smashingmagazine.com/2021/08/public-private-multi-monorepo-php-projects/","date":1629875400000,"content":"<p>To make the development experience faster, I moved all the PHP packages required by my projects to a <strong>monorepo</strong>. When each package is hosted on its own repo (the \"multirepo\" approach), it'd need be developed and tested on its own, and then published to Packagist before I could install it on other packages via Composer. With the monorepo, because all packages are hosted together, these can be developed, tested, versioned and released at the same time.</p>\n<p>The monorepo hosting my PHP packages is public, accessible to anyone on GitHub. Git repos cannot grant different access to different assets, it's all either public or private. As I plan to release a PRO WordPress plugin, I want its packages to be kept private, meaning they can't be added to the public monorepo.</p>\n<p>The solution I found is to use a \"multi-monorepo\" approach, comprising two monorepos: one public and one private, with the private monorepo embedding the public one as a Git submodule, allowing it to access its files. The public monorepo can be considered the \"upstream\", and the private monorepo the \"downstream\".</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a223ab2b-d926-4fec-a422-bed6e7b02178/01-architecture.png\" /></p>\n<p>As I kept iterating on my code, the repo set-up I needed to use at each stage of my project also needed to be upgraded. Hence, I didn't arrive at the multi-monorepo approach on day 1, but it was a process that spanned several years and took its fair amount of effort, going <a href=\"https://css-tricks.com/from-a-single-repo-to-multi-repos-to-monorepo-to-multi-monorepo/\">from a single repo, to multiple repos, to the monorepo, to finally the multi-monorepo</a>.</p>\n<p>In this article I will describe how I set-up my multi-monorepo using the <a href=\"https://github.com/symplify/monorepo-builder\">Monorepo builder</a>, which works for PHP projects based on Composer.</p>\nReusing Code In The Multi-Monorepo\n<p>The public monorepo <a href=\"https://github.com/leoloso/PoP\"><code>leoloso/PoP</code></a> is where I keep all my PHP projects.</p>\n<p>This monorepo contains workflow <a href=\"https://github.com/leoloso/PoP/blob/3cd9eee/.github/workflows/generate_plugins.yml\"><code>generate_plugins.yml</code></a>, which generates multiple WordPress plugins for distribution <a href=\"https://github.com/leoloso/PoP/actions/runs/1058751996\">when creating a new release on GitHub</a>:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b4c4e80d-e9d3-426d-af78-94151c91c0f4/02-generating-plugins.png\" /></p>\n<p>The workflow configuration is not hard-coded within the YAML but <a href=\"https://github.com/leoloso/PoP/blob/3cd9eee/.github/workflows/generate_plugins.yml#L55-L57\">injected via PHP code</a>:</p>\n<pre><code>  - id: output_data\n    run: |\n      echo \"::set-output name=plugin_config_entries::$(vendor/bin/monorepo-builder plugin-config-entries-json)\"</code></pre>\n\n<p>And the configuration is provided via a <a href=\"https://github.com/leoloso/PoP/blob/1965e044e371d62ed98f88f05559e48c26183fbd/src/Config/Symplify/MonorepoBuilder/DataSources/PluginDataSource.php#L16\">custom PHP class</a>:</p>\n<pre><code>class PluginDataSource\n{\n  public function getPluginConfigEntries(): array\n  {\n    return [\n      // GraphQL API for WordPress\n      [\n        'path' =&gt; 'layers/GraphQLAPIForWP/plugins/graphql-api-for-wp',\n        'zip_file' =&gt; 'graphql-api.zip',\n        'main_file' =&gt; 'graphql-api.php',\n        'dist_repo_organization' =&gt; 'GraphQLAPI',\n        'dist_repo_name' =&gt; 'graphql-api-for-wp-dist',\n      ],\n      // GraphQL API - Extension Demo\n      [\n        'path' =&gt; 'layers/GraphQLAPIForWP/plugins/extension-demo',\n        'zip_file' =&gt; 'graphql-api-extension-demo.zip',\n        'main_file' =&gt; 'graphql-api-extension-demo.php',\n        'dist_repo_organization' =&gt; 'GraphQLAPI',\n        'dist_repo_name' =&gt; 'extension-demo-dist',\n      ],\n    ];\n  }\n}</code></pre>\n\n<p>Generating multiple WordPress plugins all together, and configuring the workflow via PHP, has reduced the amount of time needed managing the project. The workflow currently handles two plugins (the <a href=\"https://github.com/leoloso/PoP/blob/master/layers/GraphQLAPIForWP/plugins/graphql-api-for-wp\">GraphQL API</a> and its extension demo), but it could handle 200 without additional effort on my side.</p>\n<p>It is this set-up that I want to reuse for my private monorepo <code>leoloso/GraphQLAPI-PRO</code>, so that the PRO plugins can also be generated without effort.</p>\n<p>The code to reuse will comprise:</p>\n<ul>\n<li>The GitHub Actions workflows to generate the WordPress plugins (including <a href=\"https://graphql-api.com/blog/graphql-api-for-wp-is-now-scoped-thanks-to-php-scoper/\">scoping</a>, <a href=\"https://graphql-api.com/blog/the-plugin-is-now-transpiled-from-php-80-to-71/\">downgrading from PHP 8.0 to 7.1</a> and <a href=\"https://leoloso.com/posts/github-action-to-release-wp-plugin/\">uploading to the releases page</a>).</li>\n<li>The custom PHP services to configure the workflows.</li>\n</ul>\n<p>The private monorepo can then generate the PRO WordPress plugins, simply by triggering the workflows from the public monorepo, and overriding their configuration in PHP.</p>\nLinking Monorepos Via Git Submodules\n<p>To embed the public repo within the private one we use <a href=\"https://git-scm.com/book/en/v2/Git-Tools-Submodules\">Git submodules</a>:</p>\n<pre><code>git submodule add &lt;public repo URL&gt;</code></pre>\n\n<p>I embedded the public repo under subfolder <code>submodules</code> of the private monorepo, allowing me to add more upstream monorepos in the future if needed. In GitHub, the folder <a href=\"https://github.blog/2016-02-01-working-with-submodules/\">displays the submodule's specific commit</a>, and clicking on it will take me to that commit on <code>leoloso/PoP</code>:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6a567d4e-b656-4e05-9c96-291487f27a8e/03-embedding-public-monorepo.png\" /></p>\n<p>Since it contains submodules, to clone the private repo we must provide the <code>--recursive</code> option:</p>\n<pre><code>git clone --recursive &lt;private repo URL&gt;</code></pre>\n\nReusing The GitHub Actions Workflows\n<p>GitHub Actions only loads workflows from under <code>.github/workflows</code>. Because the public workflows in the downstream monorepo are under <code>submodules/PoP/.github/workflows</code>, these must be duplicated into the expected location.</p>\n<p>In order to keep the upstream workflows as the single source of truth, we can limit ourselves to copying the files to downstream under <code>.github/workflows</code>, but never edit them there. If there is any change to be done, it must be done in the upstream monorepo, and then copied over.</p>\n<p>As a side note, notice how this means that the multi-monorepo leaks: the upstream monorepo is not fully autonomous, and will need to be adapted to suit the downstream monorepo.</p>\n<p>In my first iteration to copy the workflows, I created a simple <a href=\"https://getcomposer.org/doc/articles/scripts.md#defining-scripts\">Composer script</a>:</p>\n<pre><code>\n{\n  \"scripts\": {\n    \"copy-workflows\": [\n      \"php -r \\\"copy('submodules/PoP/.github/workflows/generate_plugins.yml', '.github/workflows/generate_plugins.yml');\\\"\",\n      \"php -r \\\"copy('submodules/PoP/.github/workflows/split_monorepo.yaml', '.github/workflows/split_monorepo.yaml');\\\"\"\n    ]\n  }\n}</code></pre>\n\n<p>Then, after editing the workflows in the upstream monorepo, I would copy them to downstream by executing:</p>\n<pre><code>composer copy-workflows</code></pre>\n\n<p>But then I realized that just copying the workflows is not enough: they must also be modified in the process. This is so because checking out the downstream monorepo requires option <code>--recurse-submodules</code>, as to also checkout the submodules.</p>\n<p>In GitHub Actions, the checkout for downstream is done like this:</p>\n<pre><code>  - uses: actions/checkout@v2\n    with:\n        submodules: recursive</code></pre>\n\n<p>So checking out the downstream repo needs input <code>submodules: recursive</code>, but the upstream one does not, and they both use the same source file.</p>\n<p>The solution I found is to provide the value for input <code>submodules</code> via an environment variable <code>CHECKOUT_SUBMODULES</code>, which is by default <a href=\"https://github.com/leoloso/PoP/blob/aec4615/.github/workflows/coding_standards.yml\">empty for the upstream repo</a>:</p>\n<pre><code>env:\n  CHECKOUT_SUBMODULES: \"\"\n\njobs:\n  provide_data:\n    steps:\n      - uses: actions/checkout@v2\n        with:\n          submodules: ${{ env.CHECKOUT_SUBMODULES }}</code></pre>\n\n<p>Then, when copying the workflows from upstream to downstream, the value of <code>CHECKOUT_SUBMODULES</code> is replaced with <code>\"recursive\"</code>:</p>\n<pre><code>env:\n  CHECKOUT_SUBMODULES: \"recursive\"</code></pre>\n\n<p>When modifying the workflow, it's a good idea to use a regex, so that it works for different formats in the source file (such as <code>CHECKOUT_SUBMODULES: \"\"</code> or <code>CHECKOUT_SUBMODULES:''</code> or <code>CHECKOUT_SUBMODULES:</code>) as to not create bugs from this kind of assumed-to-be-harmless changes.</p>\n<p>Then, the <code>copy-workflows</code> Composer script seen above is not good enough to handle this complexity.</p>\n<p>In my next iteration, I created a PHP command <code>CopyUpstreamMonorepoFilesCommand</code>, to be executed via the Monorepo builder:</p>\n<pre><code>vendor/bin/monorepo-builder copy-upstream-monorepo-files</code></pre>\n\n<p>This command uses a custom service <code>FileCopierSystem</code> to copy all files from a source folder to the indicated destination, while optionally replacing their contents:</p>\n<pre><code>namespace PoP\\GraphQLAPIPRO\\Extensions\\Symplify\\MonorepoBuilder\\SmartFile;\n\nuse Nette\\Utils\\Strings;\nuse Symplify\\SmartFileSystem\\Finder\\SmartFinder;\nuse Symplify\\SmartFileSystem\\SmartFileSystem;\n\nfinal class FileCopierSystem\n{\n  public function __construct(\n    private SmartFileSystem $smartFileSystem,\n    private SmartFinder $smartFinder,\n  ) {\n  }\n\n  /**\n   * @param array $patternReplacements a regex pattern to search, and its replacement\n   */\n  public function copyFilesFromFolder(\n    string $fromFolder,\n    string $toFolder,\n    array $patternReplacements = []\n  ): void {\n    $smartFileInfos = $this-&gt;smartFinder-&gt;find([$fromFolder], '*');\n\n    foreach ($smartFileInfos as $smartFileInfo) {\n      $fromFile = $smartFileInfo-&gt;getRealPath();\n      $fileContent = $this-&gt;smartFileSystem-&gt;readFile($fromFile);\n\n      foreach ($patternReplacements as $pattern =&gt; $replacement) {\n        $fileContent = Strings::replace($fileContent, $pattern, $replacement);\n      }\n\n      $toFile = $toFolder . substr($fromFile, strlen($fromFolder));\n      $this-&gt;smartFileSystem-&gt;dumpFile($toFile, $fileContent);\n    }\n  }\n}</code></pre>\n\n<p>When invoking this method to copy all workflows downstream, I also replace the value of <code>CHECKOUT_SUBMODULES</code>:</p>\n<pre><code>/**\n * Copy all workflows to `.github/`, and convert:\n *   `CHECKOUT_SUBMODULES: \"\"`\n * into:\n *   `CHECKOUT_SUBMODULES: \"recursive\"`\n */\n$regexReplacements = [\n  '#CHECKOUT_SUBMODULES:(\\s+\".*\")?#' =&gt; 'CHECKOUT_SUBMODULES: \"recursive\"',\n];\n(new FileCopierSystem())-&gt;copyFilesFromFolder(\n  'submodules/PoP/.github/workflows',\n  '.github/workflows',\n  $regexReplacements\n);</code></pre>\n\n<p>Workflow <code>generate_plugins.yml</code> needs an additional replacement. When the WordPress plugin is generated, its code is downgraded from PHP 8.0 to 7.1 by <a href=\"https://github.com/leoloso/PoP/blob/3cd9eee96b603a124c18abd6f69f6e937a41477a/.github/workflows/generate_plugins.yml#L116\">invoking script</a> <a href=\"https://github.com/leoloso/PoP/blob/3cd9eee96b603a124c18abd6f69f6e937a41477a/.github/workflows/generate_plugins.yml#L116\"><code>ci/downgrade/downgrade_code.sh</code></a>:</p>\n<pre><code>  - name: Downgrade code for production (to PHP 7.1)\n    run: ci/downgrade/downgrade_code.sh \"${{ matrix.pluginConfig.rector_downgrade_config }}\" \"\" \"${{ matrix.pluginConfig.path }}\" \"${{ matrix.pluginConfig.additional_rector_configs }}\"</code></pre>\n\n<p>In the downstream monorepo, this file will be located under <code>submodules/PoP/ci/downgrade/downgrade_code.sh</code>. Then, we have the downstream workflow point to the right path with this replacement:</p>\n<pre><code>$regexReplacements = [\n  // ...\n  '#(ci/downgrade/downgrade_code\\.sh)#' =&gt; 'submodules/PoP/$1',\n];</code></pre>\n\nConfiguring Packages In Monorepo Builder\n<p>File <code>monorepo-builder.php</code> — placed at the root of the monorepo — holds the <a href=\"https://github.com/symplify/monorepo-builder#1-merge-local-composerjson-to-the-root-one\">configuration for the Monorepo builder</a>. In it we must indicate where the packages (and plugins, clients, or anything else) are located:</p>\n<pre><code>use Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\ContainerConfigurator;\nuse Symplify\\MonorepoBuilder\\ValueObject\\Option;\n\nreturn static function (ContainerConfigurator $containerConfigurator): void {\n  $parameters = $containerConfigurator-&gt;parameters();\n  $parameters-&gt;set(Option::PACKAGE_DIRECTORIES, [\n    __DIR__ . '/packages',\n    __DIR__ . '/plugins',\n  ]);\n};</code></pre>\n\n<p>The private monorepo must have access to all code: its own packages, plus those from the public monorepo. Then, it must define all packages from both monorepos in the config file. The ones from the public monorepo are located under <code>\"/submodules/PoP\"</code>:</p>\n<pre><code>return static function (ContainerConfigurator $containerConfigurator): void {\n  $parameters = $containerConfigurator-&gt;parameters();\n  $parameters-&gt;set(Option::PACKAGE_DIRECTORIES, [\n    // public code\n    __DIR__ . '/submodules/PoP/packages',\n    __DIR__ . '/submodules/PoP/plugins',\n    // private code\n    __DIR__ . '/packages',\n    __DIR__ . '/plugins',\n    __DIR__ . '/clients',\n  ]);\n};</code></pre>\n\n<p>As it can be seen, the configuration for upstream and downstream are pretty much the same, with the difference that the downstream one will:</p>\n<ul>\n<li>Change the path to the public packages.</li>\n<li>Add the private packages.</li>\n</ul>\n<p>Then, it makes sense to rewrite the configuration using object-oriented programming, so that we make code DRY (don't repeat yourself) by having a PHP class in the public repo be extended in the private repo.</p>\nRecreating The Configuration Via OOP\n<p>Let's refactor the configuration. In the public repo, file <code>monorepo-builder.php</code> will simply <a href=\"https://github.com/leoloso/PoP/blob/f958c8f/monorepo-builder.php\">reference a new class</a> <a href=\"https://github.com/leoloso/PoP/blob/f958c8f/monorepo-builder.php\"><code>ContainerConfigurationService</code></a> where all action will happen:</p>\n<pre><code>use PoP\\PoP\\Config\\Symplify\\MonorepoBuilder\\Configurators\\ContainerConfigurationService;\nuse Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\ContainerConfigurator;\n\nreturn static function (ContainerConfigurator $containerConfigurator): void {\n  $containerConfigurationService = new ContainerConfigurationService(\n    $containerConfigurator,\n    __DIR__\n  );\n  $containerConfigurationService-&gt;configureContainer();\n};</code></pre>\n\n<p>The <code>__DIR__</code> param points to the root of the monorepo. It will be needed to obtain the full path to the package directories.</p>\n<p>Class <code>ContainerConfigurationService</code> is now in charge of <a href=\"https://github.com/leoloso/PoP/blob/1965e04/src/Config/Symplify/MonorepoBuilder/Configurators/ContainerConfigurationService.php#L20\">producing the configuration</a>:</p>\n<pre><code>namespace PoP\\PoP\\Config\\Symplify\\MonorepoBuilder\\Configurators;\n\nuse PoP\\PoP\\Config\\Symplify\\MonorepoBuilder\\DataSources\\PackageOrganizationDataSource;\nuse Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\ContainerConfigurator;\nuse Symplify\\MonorepoBuilder\\ValueObject\\Option;\n\nclass ContainerConfigurationService\n{\n  public function __construct(\n    protected ContainerConfigurator $containerConfigurator,\n    protected string $rootDirectory,\n  ) {\n  }\n\n  public function configureContainer(): void\n  {\n    $parameters = $this-&gt;containerConfigurator-&gt;parameters();\n    if ($packageOrganizationConfig = $this-&gt;getPackageOrganizationDataSource($this-&gt;rootDirectory)) {\n      $parameters-&gt;set(\n        Option::PACKAGE_DIRECTORIES,\n        $packageOrganizationConfig-&gt;getPackageDirectories()\n      );\n    }\n  }\n\n  protected function getPackageOrganizationDataSource(): ?PackageOrganizationDataSource\n  {\n    return new PackageOrganizationDataSource($this-&gt;rootDirectory);\n  }\n}</code></pre>\n\n<p>The configuration can be split across several classes. In this case, <code>ContainerConfigurationService</code> retrieves the package configuration through class <code>PackageOrganizationDataSource</code>, which has <a href=\"https://github.com/leoloso/PoP/blob/6260d11/src/Config/Symplify/MonorepoBuilder/DataSources/PackageOrganizationDataSource.php\">this implementation</a>:</p>\n<pre><code>namespace PoP\\PoP\\Config\\Symplify\\MonorepoBuilder\\DataSources;\n\nclass PackageOrganizationDataSource\n{\n  public function __construct(protected string $rootDir)\n  {\n  }\n\n  public function getPackageDirectories(): array\n  {\n    return array_map(\n      fn (string $packagePath) =&gt; $this-&gt;rootDir . '/' . $packagePath,\n      $this-&gt;getRelativePackagePaths()\n    );\n  }\n\n  public function getRelativePackagePaths(): array\n  {\n    return [\n      'packages',\n      'plugins',\n    ];\n  }\n}</code></pre>\n\nOverriding The Configuration In The Downstream Monorepo\n<p>Now that the configuration in the public monorepo is setup via OOP, we can extend it to suit the needs of the private monorepo.</p>\n<p>In order to allow the private monorepo to autoload the PHP code from the public monorepo, we must first configure the downstream <code>composer.json</code> to reference the source code from the upstream, which is under path <code>submodules/PoP/src</code>:</p>\n<pre><code>{\n  \"autoload\": {\n    \"psr-4\": {\n      \"PoP\\\\GraphQLAPIPRO\\\\\": \"src\",\n      \"PoP\\\\PoP\\\\\": \"submodules/PoP/src\"\n    }\n  }\n}</code></pre>\n\n<p>Below is file <code>monorepo-builder.php</code> for the private monorepo. Notice that the referenced class <code>ContainerConfigurationService</code> in the upstream repo belongs to the <code>PoP\\PoP</code> namespace, but now it switched to the <code>PoP\\GraphQLAPIPRO</code> namespace. This class must receive the additional input <code>$upstreamRelativeRootPath</code> (with value <code>\"submodules/PoP\"</code>) as to recreate the full path to the public packages:</p>\n<pre><code>use PoP\\GraphQLAPIPRO\\Config\\Symplify\\MonorepoBuilder\\Configurators\\ContainerConfigurationService;\nuse Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\ContainerConfigurator;\n\nreturn static function (ContainerConfigurator $containerConfigurator): void {\n  $containerConfigurationService = new ContainerConfigurationService(\n    $containerConfigurator,\n    __DIR__,\n    'submodules/PoP'\n  );\n  $containerConfigurationService-&gt;configureContainer();\n};</code></pre>\n\n<p>The downstream class <code>ContainerConfigurationService</code> overrides which <code>PackageOrganizationDataSource</code> class is used in the configuration:</p>\n<pre><code>namespace PoP\\GraphQLAPIPRO\\Config\\Symplify\\MonorepoBuilder\\Configurators;\n\nuse PoP\\PoP\\Config\\Symplify\\MonorepoBuilder\\Configurators\\ContainerConfigurationService as UpstreamContainerConfigurationService;\nuse PoP\\GraphQLAPIPRO\\Config\\Symplify\\MonorepoBuilder\\DataSources\\PackageOrganizationDataSource;\nuse Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\ContainerConfigurator;\n\nclass ContainerConfigurationService extends UpstreamContainerConfigurationService\n{\n  public function __construct(\n    ContainerConfigurator $containerConfigurator,\n    string $rootDirectory,\n    protected string $upstreamRelativeRootPath\n  ) {\n    parent::__construct(\n      $containerConfigurator,\n      $rootDirectory\n    );\n  }\n\n  protected function getPackageOrganizationDataSource(): ?PackageOrganizationDataSource\n  {\n    return new PackageOrganizationDataSource(\n      $this-&gt;rootDirectory,\n      $this-&gt;upstreamRelativeRootPath\n    );\n  }\n}</code></pre>\n\n<p>Finally, downstream class <code>PackageOrganizationDataSource</code> contains the full path to both public and private packages:</p>\n<pre><code>namespace PoP\\GraphQLAPIPRO\\Config\\Symplify\\MonorepoBuilder\\DataSources;\n\nuse PoP\\PoP\\Config\\Symplify\\MonorepoBuilder\\DataSources\\PackageOrganizationDataSource as UpstreamPackageOrganizationDataSource;\n\nclass PackageOrganizationDataSource extends UpstreamPackageOrganizationDataSource\n{\n  public function __construct(\n    string $rootDir,\n    protected string $upstreamRelativeRootPath\n  ) {\n    parent::__construct($rootDir);\n  }\n\n  public function getRelativePackagePaths(): array\n  {\n    return array_merge(\n      // Public packages - Prepend them with \"submodules/PoP/\"\n      array_map(\n        fn ($upstreamPackagePath) =&gt; $this-&gt;upstreamRelativeRootPath . '/' . $upstreamPackagePath,\n        parent::getRelativePackagePaths()\n      ),\n      // Private packages\n      [\n        'packages',\n        'plugins',\n        'clients',\n      ]\n    );\n  }\n}</code></pre>\n\nInjecting The Configuration From PHP Into GitHub Actions\n<p>Monorepo builder offers command <code>packages-json</code>, which we can use to inject the package paths into the GitHub Actions workflow:</p>\n<pre><code>jobs:\n  provide_data:\n    steps:\n      - id: output_data\n        name: Calculate matrix for packages\n        run: |\n          echo \"::set-output name=matrix::$(vendor/bin/monorepo-builder packages-json)\"\n\n    outputs:\n      matrix: ${{ steps.output_data.outputs.matrix }}</code></pre>\n\n<p>This command produces a stringified JSON. In the workflow it must be converted to a JSON object via <code>fromJson</code>:</p>\n<pre><code>jobs:\n  split_monorepo:\n    needs: provide_data\n    strategy:\n      matrix:\n        package: ${{ fromJson(needs.provide_data.outputs.matrix) }}</code></pre>\n\n<p>Unfortunately, command <code>packages-json</code> <a href=\"https://github.com/symplify/symplify/blob/3fddff4c47663d1519f7c97769bade425d6a4e5f/packages/monorepo-builder/src/Json/PackageJsonProvider.php#L23\">outputs the package names</a> but not their paths, which works when all packages are under the same folder (such as <code>packages/</code>). It doesn't work in our case, since public and private packages are located in different folders.</p>\n<p>Fortunately, the <a href=\"https://graphql-api.com/blog/extending-the-monorepo-builder/#heading-optimizing-the-monorepo\">Monorepo builder can be extended with custom PHP services</a>. So I created a custom command <code>package-entries-json</code> (via class <a href=\"https://github.com/leoloso/PoP/blob/57a7a21a378f718e1ecfd378fe34ea99fa62c168/src/Extensions/Symplify/MonorepoBuilder/Command/PackageEntriesJsonCommand.php\"><code>PackageEntriesJsonCommand</code></a>) which does output the path to the package.</p>\n<p>The workflow was then <a href=\"https://github.com/leoloso/PoP/blob/514c27d03b6e438175e887c8dba550355b735b7d/.github/workflows/split_monorepo_tagged.yaml#L34-L37\">updated with the new command</a>:</p>\n<pre><code>    run: |\n      echo \"::set-output name=matrix::$(vendor/bin/monorepo-builder package-entries-json)\"</code></pre>\n\n<p>Executed on the public monorepo, it produces the following packages (among <a href=\"https://github.com/leoloso/PoP/actions/runs/1050692821\">many others</a>):</p>\n<pre><code>[\n  {\n    \"name\": \"graphql-api-for-wp\",\n    \"path\": \"layers/GraphQLAPIForWP/plugins/graphql-api-for-wp\"\n  },\n  {\n    \"name\": \"extension-demo\",\n    \"path\": \"layers/GraphQLAPIForWP/plugins/extension-demo\"\n  },\n  {\n    \"name\": \"access-control\",\n    \"path\": \"layers/Engine/packages/access-control\"\n  },\n  {\n    \"name\": \"api\",\n    \"path\": \"layers/API/packages/api\"\n  },\n  {\n    \"name\": \"api-clients\",\n    \"path\": \"layers/API/packages/api-clients\"\n  }\n]</code></pre>\n\n<p>Executed on the private monorepo, it produces the following entries (among many others):</p>\n<pre><code>[\n  {\n    \"name\": \"graphql-api-for-wp\",\n    \"path\": \"submodules/PoP/layers/GraphQLAPIForWP/plugins/graphql-api-for-wp\"\n  },\n  {\n    \"name\": \"extension-demo\",\n    \"path\": \"submodules/PoP/layers/GraphQLAPIForWP/plugins/extension-demo\"\n  },\n  {\n    \"name\": \"access-control\",\n    \"path\": \"submodules/PoP/layers/Engine/packages/access-control\"\n  },\n  {\n    \"name\": \"api\",\n    \"path\": \"submodules/PoP/layers/API/packages/api\"\n  },\n  {\n    \"name\": \"api-clients\",\n    \"path\": \"submodules/PoP/layers/API/packages/api-clients\"\n  },\n  {\n    \"name\": \"graphql-api-pro\",\n    \"path\": \"layers/GraphQLAPIForWP/plugins/graphql-api-pro\"\n  },\n  {\n    \"name\": \"convert-case-directives\",\n    \"path\": \"layers/Schema/packages/convert-case-directives\"\n  },\n  {\n    \"name\": \"export-directive\",\n    \"path\": \"layers/GraphQLByPoP/packages/export-directive\"\n  }\n]</code></pre>\n\n<p>As it can be appreciated, it works well: the configuration for the downstream monorepo contains both public and private packages, and the paths to the public ones were prepended with <code>\"submodules/PoP\"</code>.</p>\nSkipping Public Packages In The Downstream Monorepo\n<p>So far, the downstream monorepo has included both public and private packages in its configuration. However, not every command needs to be executed on the public packages.</p>\n<p>Take static analysis, for instance. The public monorepo already executes <a href=\"https://phpstan.org/\">PHPStan</a> on all public packages via workflow <a href=\"https://github.com/leoloso/PoP/blob/aec4615/.github/workflows/phpstan.yml\"><code>phpstan.yml</code></a>, as shown in <a href=\"https://github.com/leoloso/PoP/runs/3176485273?check_suite_focus=true#step:6:1\">this run</a>. If the downstream monorepo runs once again PHPStan on the public packages, it is a waste of computing time. Then, the <code>phpstan.yml</code> workflow needs to run on the private packages only.</p>\n<p>That means that depending on the command to execute in the downstream repo, we may want to either include both public and private packages, or only private ones.</p>\n<p>To add public packages or not on the downstream configuration, we adapt downstream class <code>PackageOrganizationDataSource</code> to check this condition via input <code>$includeUpstreamPackages</code>:</p>\n<pre><code>namespace PoP\\GraphQLAPIPRO\\Config\\Symplify\\MonorepoBuilder\\DataSources;\n\nuse PoP\\PoP\\Config\\Symplify\\MonorepoBuilder\\DataSources\\PackageOrganizationDataSource as UpstreamPackageOrganizationDataSource;\n\nclass PackageOrganizationDataSource extends UpstreamPackageOrganizationDataSource\n{\n  public function __construct(\n    string $rootDir,\n    protected string $upstreamRelativeRootPath,\n    protected bool $includeUpstreamPackages\n  ) {\n    parent::__construct($rootDir);\n  }\n\n  public function getRelativePackagePaths(): array\n  {\n    return array_merge(\n      // Add the public packages?\n      $this-&gt;includeUpstreamPackages ?\n        // Public packages - Prepend them with \"submodules/PoP/\"\n        array_map(\n          fn ($upstreamPackagePath) =&gt; $this-&gt;upstreamRelativeRootPath . '/' . $upstreamPackagePath,\n          parent::getRelativePackagePaths()\n        ) : [],\n      // Private packages\n      [\n        'packages',\n        'plugins',\n        'clients',\n      ]\n    );\n  }\n}</code></pre>\n\n<p>Next, we need to provide value <code>$includeUpstreamPackages</code> as either <code>true</code> or <code>false</code> depending on the command to execute.</p>\n<p>We can do this by replacing config file <code>monorepo-builder.php</code> with two other config files: <code>monorepo-builder-with-upstream-packages.php</code> (which passes <code>$includeUpstreamPackages</code> =&gt; <code>true</code>) and <code>monorepo-builder-without-upstream-packages.php</code> (which passes <code>$includeUpstreamPackages</code> =&gt; <code>false</code>):</p>\n<pre><code>// File monorepo-builder-without-upstream-packages.php\nuse PoP\\GraphQLAPIPRO\\Config\\Symplify\\MonorepoBuilder\\Configurators\\ContainerConfigurationService;\nuse Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\ContainerConfigurator;\n\nreturn static function (ContainerConfigurator $containerConfigurator): void {\n  $containerConfigurationService = new ContainerConfigurationService(\n    $containerConfigurator,\n    __DIR__,\n    'submodules/PoP',\n    false, // This is $includeUpstreamPackages\n  );\n  $containerConfigurationService-&gt;configureContainer();\n};</code></pre>\n\n<p>We then update <code>ContainerConfigurationService</code> to receive parameter <code>$includeUpstreamPackages</code> and pass it along to <code>PackageOrganizationDataSource</code>:</p>\n<pre><code>namespace PoP\\GraphQLAPIPRO\\Config\\Symplify\\MonorepoBuilder\\Configurators;\n\nuse PoP\\PoP\\Config\\Symplify\\MonorepoBuilder\\Configurators\\ContainerConfigurationService as UpstreamContainerConfigurationService;\nuse PoP\\GraphQLAPIPRO\\Config\\Symplify\\MonorepoBuilder\\DataSources\\PackageOrganizationDataSource;\nuse Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\ContainerConfigurator;\n\nclass ContainerConfigurationService extends UpstreamContainerConfigurationService\n{\n  public function __construct(\n    ContainerConfigurator $containerConfigurator,\n    string $rootDirectory,\n    protected string $upstreamRelativeRootPath,\n    protected bool $includeUpstreamPackages,\n  ) {\n    parent::__construct(\n      $containerConfigurator,\n      $rootDirectory,\n    );\n  }\n\n  protected function getPackageOrganizationDataSource(): ?PackageOrganizationDataSource\n  {\n    return new PackageOrganizationDataSource(\n      $this-&gt;rootDirectory,\n      $this-&gt;upstreamRelativeRootPath,\n      $this-&gt;includeUpstreamPackages,\n    );\n  }\n}</code></pre>\n\n<p>Next, we should invoke the <code>monorepo-builder</code> with either config file, by providing the <code>--config</code> option:</p>\n<pre><code>jobs:\n  provide_data:\n    steps:\n      - id: output_data\n        name: Calculate matrix for packages\n        run: |\n          echo \"::set-output name=matrix::$(vendor/bin/monorepo-builder package-entries-json --config=monorepo-builder-without-upstream-packages.php)\"</code></pre>\n\n<p>However, as we saw earlier on, we want to keep the GitHub Actions workflows in the upstream monorepo as the single source of truth, and they clearly do not need these changes.</p>\n<p>The solution I found to this issue is to provide a <code>--config</code> option in the upstream repo always, with each command getting its own config file, such as the <a href=\"https://github.com/leoloso/PoP/blob/aec4615e782494d6596d9106cc04a47d0234459b/.github/workflows/monorepo_validation.yml#L32\"><code>validate</code> command receiving the <code>validate.php</code> config file</a>:</p>\n<pre><code>  - name: Run validation\n    run: vendor/bin/monorepo-builder validate --config=config/monorepo-builder/validate.php</code></pre>\n\n<p>Now, there are no config files in the upstream monorepo, since it doesn't need them. But it will not break, because the Monorepo builder <a href=\"https://github.com/symplify/symplify/blob/90714eec76fb7de8aa0088748d006a40ae75a21c/packages/monorepo-builder/bin/monorepo-builder.php#L45-L60\">checks if the config file exists</a> and, if it does not, it loads the default config file instead. So we will either override the config, or nothing happens.</p>\n<p>The downstream repo does provide the config files for each command, specifying if to add the upstream packages or not:</p>\n\n<p>Btw, as a side note, this is another example of how the multi-monorepo leaks.</p> \n\n<pre><code>// File config/monorepo-builder/validate.php\nreturn require_once __DIR__ . '/monorepo-builder-with-upstream-packages.php';</code></pre>\n\nOverriding The Configuration\n<p>We are almost done. By now the downstream monorepo can override the configuration from the upstream monorepo. So all that's left to do is to provide the new configuration.</p>\n<p>In class <code>PluginDataSource</code> I override the configuration of which WordPress plugins must be generated, providing the PRO ones instead:</p>\n<pre><code>namespace PoP\\GraphQLAPIPRO\\Config\\Symplify\\MonorepoBuilder\\DataSources;\n\nuse PoP\\PoP\\Config\\Symplify\\MonorepoBuilder\\DataSources\\PluginDataSource as UpstreamPluginDataSource;\n\nclass PluginDataSource extends UpstreamPluginDataSource\n{\n  public function getPluginConfigEntries(): array\n  {\n    return [\n      // GraphQL API PRO\n      [\n        'path' =&gt; 'layers/GraphQLAPIForWP/plugins/graphql-api-pro',\n        'zip_file' =&gt; 'graphql-api-pro.zip',\n        'main_file' =&gt; 'graphql-api-pro.php',\n        'dist_repo_organization' =&gt; 'GraphQLAPI-PRO',\n        'dist_repo_name' =&gt; 'graphql-api-pro-dist',\n      ],\n      // GraphQL API Extensions\n      // Google Translate\n      [\n        'path' =&gt; 'layers/GraphQLAPIForWP/plugins/google-translate',\n        'zip_file' =&gt; 'graphql-api-google-translate.zip',\n        'main_file' =&gt; 'graphql-api-google-translate.php',\n        'dist_repo_organization' =&gt; 'GraphQLAPI-PRO',\n        'dist_repo_name' =&gt; 'graphql-api-google-translate-dist',\n      ],\n      // Events Manager\n      [\n        'path' =&gt; 'layers/GraphQLAPIForWP/plugins/events-manager',\n        'zip_file' =&gt; 'graphql-api-events-manager.zip',\n        'main_file' =&gt; 'graphql-api-events-manager.php',\n        'dist_repo_organization' =&gt; 'GraphQLAPI-PRO',\n        'dist_repo_name' =&gt; 'graphql-api-events-manager-dist',\n      ],\n    ];\n  }\n}</code></pre>\n\n<p>Creating a new release on GitHub will trigger the <code>generate_plugins.yml</code> workflow and generate the PRO plugins on my private monorepo:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/33ea9f4a-ed86-4208-9b8a-c7b561ac3491/04-generating-pro-plugins.png\" /></p>\n<p>Tadaaaaaaaa! 🎉</p>\nConclusion\n<p>As always, there is no \"best\" solution, only solutions that may work better depending on the context. The multi-monorepo approach is not suitable to every kind of project or team. I believe the biggest beneficiaries are plugin creators who release public plugins to be upgraded to their PRO versions, and agencies customizing plugins for their clients.</p>\n<p>In my case, I'm quite happy with this approach. It takes a bit of time and effort to get right, but it's a one-off investment. Once the set-up is over, I can just focus on building my PRO plugins, and the time savings concerning project management can be huge.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"30210a83bf05053bbbf7808d281ac7f3ad54453253f549211e2a84009583432f","category":"Tech"}