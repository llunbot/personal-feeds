{"title":"How To Build Resilient JavaScript UIs","link":"https://smashingmagazine.com/2021/08/build-resilient-javascript-ui/","date":1627988400000,"content":"<p>Things on the web can break — the odds are stacked against us. Lots can go wrong: a network request fails, a third-party library breaks, a JavaScript feature is unsupported (assuming JavaScript is even available), a CDN goes down, a user behaves unexpectedly (they double-click a submit button), the list goes on.</p>\n<p>Fortunately, we as engineers can avoid, or at least mitigate the impact of breakages in the web apps we build. This however requires a conscious effort and mindset shift towards thinking about unhappy scenarios just as much as happy ones.</p>\n<p><strong>The User Experience (UX) doesn’t need to be all or nothing — just what is usable.</strong> This premise, known as graceful degradation allows a system to continue working when parts of it are dysfunctional — much like an electric bike becomes a regular bike when its battery dies. If something fails only the functionality dependent on that should be impacted.</p>\n<p>UIs should adapt to the functionality they can offer, whilst providing as much value to end-users as possible.</p>\nWhy Be Resilient\n<p>Resilience is <a href=\"https://www.w3.org/TR/html-design-principles/#degrade-gracefully\">intrinsic to the web</a>.</p>\n<p>Browsers ignore invalid HTML tags and unsupported CSS properties. This liberal attitude is known as Postel’s Law, which is conveyed superbly by Jeremy Keith in <a href=\"https://resilientwebdesign.com/chapter4/\">Resilient Web Design</a>:</p>\n<blockquote>“Even if there are errors in the HTML or CSS, the browser will still attempt to process the information, skipping over any pieces that it can’t parse.”</blockquote>\n\n<p>JavaScript is less forgiving. Resilience is extrinsic. We instruct JavaScript what to do if something unexpected happens. If an API request fails the onus falls on us to catch the error, and subsequently decide what to do. And that decision directly impacts users.</p>\n<p>Resilience builds trust with users. A buggy experience reflects poorly on the brand. According to <a href=\"https://hbr.org/2000/09/knowing-a-winning-business-idea-when-you-see-one\">Kim and Mauborgne, convenience (availability, ease of consumption)</a> is one of six characteristics associated with a successful brand, which makes graceful degradation synonymous with brand perception.</p>\n<p>A robust and reliable UX is a signal of quality and trustworthiness, both of which feed into the brand. A user unable to perform a task because something is broken will naturally face disappointment they could associate with your brand.</p>\n<p>Often system failures are chalked up as \"corner cases\" — things that rarely happen, however, the web has many corners. Different browsers running on different platforms and hardware, respecting our user preferences and browsing modes (Safari Reader/ assistive technologies), being served to geo-locations with varying latency and intermittency increase the likeness of something not working as intended.</p>\nError Equality\n<p>Much like content on a webpage has hierarchy, failures — things going wrong — also follow a pecking order. Not all errors are equal, some are more important than others.</p>\n<p>We can categorize errors by their impact. How does XYZ not working prevent a user from achieving their goal? The answer generally mirrors the content hierarchy.</p>\n<p>For example, a dashboard overview of your bank account contains data of varying importance. The total value of your balance is more important than a notification prompting you to check in-app messages. <a href=\"https://en.wikipedia.org/wiki/MoSCoW_method\">MoSCoWs method of prioritization</a> categorizes the former as a must-have, and the latter a nice to have.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f7486947-6755-43ad-9426-5b3773aa7b14/8-resilience-is-a-feature.png\" /></p>\n<p>If primary information is unavailable (i.e: network request fails) we should be transparent and let users know, usually via an error message. If secondary information is unavailable we can still provide the core (must have) experience whilst gracefully hiding the degraded component.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/09ab88dd-1e87-4c40-995f-9cbf380e4fe3/3-resilience-is-a-feature.png\" /></p>\n<p>Knowing when to show an error message or not can be represented using a simple decision tree:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f3b257e8-88c8-4c84-b567-b30641195f2d/14-resilience-is-a-feature.png\" /></p>\n<p>Categorization removes the 1-1 relationship between failures and error messages in the UI. Otherwise, we risk bombarding users and cluttering the UI with too many error messages. Guided by content hierarchy we can cherry-pick what failures are surfaced to the UI, and what happen unbeknownst to end-users.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/86ca5913-57f4-44e7-a77f-20a119a1de39/2-resilience-is-a-feature.png\" /></p>\nPrevention is Better than Cure\n<p>Medicine has an adage that prevention is better than cure.</p>\n<p>Applied to the context of building resilient UIs, preventing an error from happening in the first place is more desirable than needing to recover from one. <strong>The best type of error is one that doesn’t happen.</strong></p>\n<p>It’s safe to assume never to make assumptions, especially when consuming remote data, interacting with third-party libraries, or using newer language features. Outages or unplanned API changes alongside what browsers users choose or must use are outside of our control. Whilst we cannot stop breakages outside our control from occurring, we can protect ourselves against their (side) effects.</p>\n<p>Taking a more defensive approach when writing code helps reduce programmer errors arising from making assumptions. Pessimism over optimism favours resilience. The code example below is too optimistic:</p>\n<pre><code>const debitCards = useDebitCards();\n\nreturn (\n  &lt;ul&gt;\n    {debitCards.map(card =&gt; {\n      &lt;li&gt;{card.lastFourDigits}&lt;/li&gt;\n    })}\n  &lt;/ul&gt;\n);\n</code></pre>\n\n<p>It assumes that debit cards exist, the endpoint returns an Array, the array contains objects, and each object has a property named <code>lastFourDigits</code>. The current implementation forces end-users to test our assumptions. It would be safer, and more user friendly if these assumptions were embedded in the code:</p>\n<pre><code>const debitCards = useDebitCards();\n\nif (Array.isArray(debitCards) &amp;&amp; debitCards.length) {\n  return (\n    &lt;ul&gt;\n      {debitCards.map(card =&gt; {\n        if (card.lastFourDigits) {\n          return &lt;li&gt;{card.lastFourDigits}&lt;/li&gt;\n        }\n      })}\n    &lt;/ul&gt;\n  );\n}\n\nreturn \"Something else\";\n</code></pre>\n\n<p>Using a third-party method without first checking the method is available is equally optimistic:</p>\n<pre><code>stripe.handleCardPayment(/* ... */);\n</code></pre>\n\n<p>The code snippet above assumes that the <code>stripe</code> object exists, it has a property named <code>handleCardPayment</code>, and that said property is a function. It would be safer, and therefore more defensive if these assumptions were verified by us beforehand:</p>\n<pre><code>if (\n  typeof stripe === 'object' &amp;&amp; \n  typeof stripe.handleCardPayment === 'function'\n) {\n  stripe.handleCardPayment(/* ... */);\n}\n</code></pre>\n\n<p>Both examples check something is available before using it. Those familiar with feature detection may recognize this pattern:</p>\n<pre><code>if (navigator.clipboard) {\n  /* ... */\n}\n</code></pre>\n\n<p>Simply asking the browser whether it supports the Clipboard API before attempting to cut, copy or paste is a simple yet effective example of resilience. The UI can adapt ahead of time by hiding clipboard functionality from unsupported browsers, or from users yet to grant permission.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/788ea5b0-a67a-43e8-a2f3-80e1bbb0de6e/5-resilience-is-a-feature.png\" /></p>\n<p>User browsing habits are another area living outside our control. Whilst we cannot dictate how our application is used, we can instill guardrails that prevent what we perceive as \"misuse\". Some people double-click buttons — a behavior mostly redundant on the web, however not a punishable offense.</p>\n<p>Double-clicking a button that submits a form should not submit the form twice, especially for <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Idempotent#technical_knowledge\">non-idempotent HTTP methods</a>. During form submission, prevent subsequent submissions to mitigate any fallout from multiple requests being made.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/396cd330-df81-4582-a8e2-24c189329dd9/12-resilience-is-a-feature.png\" /></p>\n<p>Preventing form resubmission in JavaScript alongside using <code>aria-disabled=\"true\"</code> is more usable and accessible than the <code>disabled</code> HTML attribute. Sandrina Pereira explains <a href=\"https://css-tricks.com/making-disabled-buttons-more-inclusive/\">Making Disabled Buttons More Inclusive</a> in great detail.</p>\nResponding to Errors\n<p>Not all errors are preventable via defensive programming. This means responding to an operational error (those occurring within correctly written programs) falls on us.</p>\n<p>Responding to an error can be modelled using a decision tree. We can either recover, fallback or acknowledge the error:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/4804ef49-a1b1-463f-a579-f290871ca53d/6-resilience-is-a-feature.png\" /></p>\n<p>When facing an error, the first question should be, “can we recover?” For example, does retrying a network request that failed for the first time succeed on subsequent attempts? Intermittent micro-services, unstable internet connections, or eventual consistency are all reasons to try again. Data fetching libraries such as <a href=\"https://swr.vercel.app/\">SWR</a> offer this functionality for free.</p>\n<p>Risk appetite and surrounding context influence what HTTP methods you are comfortable retrying. At Nutmeg we retry failed reads (GET requests), but not writes (POST/ PUT/ PATCH/ DELETE). Multiple attempts to retrieve data (portfolio performance) is safer than mutating it (resubmitting a form).</p>\n<p>The second question should be: If we cannot recover, can we provide a fallback? For example, if an online card payment fails can we offer an alternative means of payment such as via PayPal or Open Banking.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f115d83a-b305-421d-91b6-f8799c1c5a08/1-resilience-is-a-feature.png\" /></p>\n<p>Fallbacks don’t always need to be so elaborate, they can be subtle. Copy containing text dependant on remote data can fallback to less specific text when the request fails:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8a9290b3-a920-4fe4-ba95-32740fb3d100/4-resilience-is-a-feature.png\" /></p>\n<p>The third and final question should be: If we cannot recover, or fallback how important is this failure (which relates to \"Error Equality\"). The UI should acknowledge primary errors by informing users something went wrong, whilst providing actionable prompts such as contacting customer support or linking to relevant support articles.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/66669728-b30a-42f3-ac19-16241d06959b/7-resilience-is-a-feature.png\" /></p>\nObservability\n<p>UIs adapting to something going wrong is not the end. There is another side to the same coin.</p>\n<p>Engineers need visibility on the root cause behind a degraded experience. Even errors not surfaced to end-users (secondary errors) must propagate to engineers. Real-time error monitoring services such as <a href=\"https://sentry.io/\">Sentry</a> or <a href=\"https://rollbar.com/\">Rollbar</a> are invaluable tools for modern-day web development.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/49acff6d-a19d-4d40-a317-6c55fffb59b5/11-resilience-is-a-feature.png\" /></p>\n<p>Most error monitoring providers capture all unhandled exceptions automatically. Setup requires minimal engineering effort that quickly pays dividends for an improved healthy production environment and MTTA (mean time to acknowledge).</p>\n<p>The real power comes when explicitly logging errors ourselves. Whilst this involves more upfront effort it allows us to enrich logged errors with more meaning and context — both of which aid troubleshooting. Where possible aim for error messages that are understandable to non-technical members of the team.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/637a48c0-d69b-40de-8e96-1a715233ce01/13-resilience-is-a-feature.png\" /></p>\n<p>Extending the earlier Stripe example with an else branch is the perfect contender for explicit error logging:</p>\n<pre><code>if (\n  typeof stripe === \"object\" &amp;&amp;\n  typeof stripe.handleCardPayment === \"function\"\n) {\n  stripe.handleCardPayment(/* ... */);\n} else {\n  logger.capture(\n    \"[Payment] Card charge — Unable to fulfill card payment because stripe.handleCardPayment was unavailable\"\n  );\n}\n</code></pre>\n\n<p><strong>Note</strong>: <em>This defensive style needn’t be bound to form submission (at the time of error), it can happen when a component first mounts (before the error) giving us and the UI more time to adapt.</em></p>\n<p>Observability helps pinpoint weaknesses in code and areas that can be hardened. Once a weakness surfaces look at if/ how it can be hardened to prevent the same thing from happening again. Look at trends and risk areas such as third-party integrations to identify what could be wrapped in an operational feature flag (otherwise known as kill switches).</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6e961101-47fc-4939-be4e-fb59d2990c13/10-resilience-is-a-feature.png\" /></p>\n<p>Users forewarned about something not working will be less frustrated than those without warning. Knowing about road works ahead of time helps manage expectations, allowing drivers to plan alternative routes. When dealing with an outage (hopefully discovered by monitoring and not reported by users) be transparent.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/5d900508-6f8f-4fc7-878c-c4e3f2242936/9-resilience-is-a-feature.png\" /></p>\nRetrospectives\n<p>It’s very tempting to gloss over errors.</p>\n<p>However, they provide valuable learning opportunities for us and our current or future colleagues. Removing the stigma from the inevitability that things go wrong is crucial. In <a href=\"https://www.goodreads.com/book/show/24611735-black-box-thinking\">Black box thinking</a> this is described as:</p>\n<blockquote>“In highly complex organizations, success can happen only when we confront our mistakes, learn from our own version of a black box, and create a climate where it’s safe to fail.”</blockquote>\n\n<p>Being analytical helps prevent or mitigate the same error from happening again. Much like black boxes in the aviation industry record incidents, we should document errors. At the very least documentation from prior incidents helps reduce the MTTR (mean time to repair) should the same error occur again.</p>\n<p>Documentation often in the form of RCA (root cause analysis) reports should be honest, discoverable, and include: what the issue was, its impact, the technical details, how it was fixed, and actions that should follow the incident.</p>\nClosing Thoughts\n<p>Accepting the fragility of the web is a necessary step towards building resilient systems. A more reliable user experience is synonymous with happy customers. Being equipped for the worst (proactive) is better than putting out fires (reactive) from a business, customer, and developer standpoint (less bugs!).</p>\n<p>Things to remember:</p>\n<ul>\n<li>UIs should adapt to the functionality they can offer, whilst still providing value to users;</li>\n<li>Always think what can wrong (never make assumptions);</li>\n<li>Categorize errors based on their impact (not all errors are equal);</li>\n<li>Preventing errors is better than responding to them (code defensively);</li>\n<li>When facing an error, ask whether a recovery or fallback is available;</li>\n<li>User facing error messages should provide actionable prompts;</li>\n<li>Engineers must have visibility on errors (use error monitoring services);</li>\n<li>Error messages for engineers/ colleagues should be meaningful and provide context;</li>\n<li>Learn from errors to help our future selves and others.</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"dd4c1eba6da285e40c34c0805bcff62b7739a3d889309868cb8f5192e97d9e1a","category":"Tech"}