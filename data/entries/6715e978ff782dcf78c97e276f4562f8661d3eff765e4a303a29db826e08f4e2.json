{"title":"Vault Secrets in a Browser Plugin","link":"https://www.hashicorp.com/blog/vault-browser-plugin","date":1628096400000,"content":"<p>As the first engineer on the brand-new Vault Developer Experience team, it’s my goal to gain an understanding of the pain points developers run into when working with the product. This means that I often try out the same <a href=\"https://learn.hashicorp.com/vault\">HashiCorp Learn</a> tutorials that our users do.</p>\n<p>Today I’ll be talking about my experience with the new summer activity on the Learn site: the <a href=\"https://learn.hashicorp.com/tutorials/vault/browser-plugin\">Vault Secrets in a Browser Plugin Challenge</a>!</p>\n<h2><a href=\"#getting-to-know-the-vault-api\">»</a><a></a>Getting to Know the Vault API</h2>\n<p>Having used Vault as a practitioner in a previous role, it’s been fascinating to realize that there are so many more ways to use Vault than I’d ever known about. I had used only the Vault CLI and then <a href=\"https://github.com/hashicorp/envconsul\">envconsul</a> or <a href=\"https://github.com/hashicorp/consul-template\">consul-template</a> to feed secrets into my application. While this is also a valid approach with minimal code change, it meant I hadn’t used the HTTP API much, which is the communication method used in this <a href=\"https://learn.hashicorp.com/tutorials/vault/browser-plugin\">browser extension tutorial</a>.</p>\n<p>I found the <a href=\"https://www.vaultproject.io/api-docs/index\">documentation</a> of the HTTP API to be quite extensive, and for languages like JavaScript that do not yet have an official Vault client library from HashiCorp, directly communicating with the API is the best choice for integrating with Vault.</p>\n<p><strong>Here’s a tip:</strong> If you ever know the Vault CLI version of a command and wish you knew how to do it in the API, just add the <code>-output-curl-string</code> flag to your CLI command and Vault will print the equivalent <code>curl</code> request without actually executing the command.</p>\n<p>I’ve found that the more familiar I become with the HTTP API, the quicker I know what to look for when browsing the package documentation for the <a href=\"https://pkg.go.dev/github.com/hashicorp/vault/api\">Go client</a> as well.</p>\n<h2><a href=\"#authenticating-to-vault\">»</a><a></a>Authenticating to Vault</h2>\n<p>This tutorial was my first time trying out the <a href=\"https://www.vaultproject.io/docs/auth/userpass\">Userpass auth method</a>. It’s a great fit for a browser extension when you don’t have access to things like environment variables or cryptographically signed server identities like you might use with Vault’s AWS or Google Cloud auth methods. Users are created in Vault with specific policies attached to encourage least privilege access.</p>\n<p>The question of <a href=\"https://www.hashicorp.com/resources/secret-zero-mitigating-the-risk-of-secret-introduction-with-vault\">how to securely introduce that first Vault client token</a> to your backend application can require some consideration, so it was refreshing to be able to use this simple Userpass method.</p>\n<p>For server-side applications, <a href=\"https://www.vaultproject.io/docs/agent\">Vault Agent</a> is becoming a popular pattern for making authentication to Vault simpler.</p>\n<h2><a href=\"#working-with-secrets\">»</a><a></a>Working with Secrets</h2>\n<p>One of the great things about Vault is that it can be extended with a variety of official and community-maintained backends for <a href=\"https://www.vaultproject.io/docs/secrets\">secret storage</a> and authentication.</p>\n<p>This challenge used the standard <a href=\"https://www.vaultproject.io/docs/secrets/kv/kv-v2\">kv-v2 secrets engine</a>, but unlike in some of the other tutorials, I noticed that this time the secrets engine was mounted to the contextually named path <code>vaultpass</code>. This shows that you can have multiple kv-v2 secrets engines mounted to different paths in Vault, such as having a <code>payment-svc/</code> path for the key-value secrets of one microservice-based application, and <code>shipping-svc/</code> for another.</p>\n<p>One important thing I learned about the kv-v2 engine is the fact that the <code>vault kv</code> CLI commands automatically append <code>/data</code> to the secret path as a convenience for those who upgraded from kv-v1. However, when working with the Vault API, you need to always refer to a secret by its full path (which means including the <code>/data</code> in the path yourself).</p>\n<p>So when creating a new secret via the CLI, you’ll do <code>vault kv put vaultpass/foo</code>, which actually creates a secret at <code>vaultpass/data/foo</code>, and then when you try to read the secret using the Vault API in your code, you will need to do a <code>GET</code> on <code>vaultpass/data/foo</code>.</p>\n<h2><a href=\"#conclusion\">»</a><a></a>Conclusion</h2>\n<p>This challenge was a fun way to experiment with Vault outside of the usual backend service environment.</p>\n<p>I’m looking forward to improving the client libraries and CLI commands so that they become just as intuitive to use as the HTTP API was here, and I’m excited to learn more about other creative ways that users integrate with Vault. Check out the <a href=\"https://learn.hashicorp.com/tutorials/vault/browser-plugin\">Vault Secrets in a Browser Plugin Challenge</a> tutorial for inspiration.</p>","author":"Valerie Conklin","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"6715e978ff782dcf78c97e276f4562f8661d3eff765e4a303a29db826e08f4e2","category":"Tech"}