{"title":"Learning JavaScript With Imagination","link":"https://smashingmagazine.com/2023/05/learning-javascript-with-imagination/","date":1683277200000,"content":"<p>Many years ago, I set my sights on becoming a senior developer. I achieved that goal! I wish I could say it was a matter of hard work and perseverance, but no, that wasn’t enough. JavaScript stood in my way, and it was while grappling with it that I came across one silly sentence in Marijn Habernecker’s classic book, <a href=\"https://eloquentjavascript.net\"><em>Eloquent JavaScript</em></a>. On the topic of variables, it says:</p>\n<blockquote>“You should imagine bindings as tentacles rather than boxes. They do not contain values; they grasp them — two bindings can refer to the same value.”<br /><br />— Marijn Habernecker</blockquote>\n\n<p><img src=\"https://files.smashing.media/articles/learning-javascript-with-imagination/octopus.png\" /></p>\n<p>An analogy like this falls into the category of childish comparisons meant mostly for raw beginners to understand basic concepts. They are fun and entertaining but not something that will turn you into a senior developer.</p>\n<p>But it struck me. Even in a small way, this childish metaphor made me a better developer. It fixed a fundamental misunderstanding: <em>we don’t put values in variables</em>. If variables did behave like buckets or containers, how could this be true?</p>\n<pre><code>const count1 = 10;\nconst count2 = count1;</code></pre>\n\n<p>How is it possible to have the same <code>10</code> value in two different buckets? The same thing can’t be in two places at the same time, right?!</p>\n<p>But the octopus metaphor solved this dilemma for me. Two tentacles can certainly grab the same value! It’s a visualization that reveals the underlying nature of values! Give me all of the world’s computer science literature on variables at my fingertips, and it would not be as useful to me as this imaginary octopus.</p>\n<p>Why can’t all of JavaScript be like this?</p>\nMy Search For More Visual Learning Material\n<p>I noticed a frustrating gap between doing the simple loop and function exercises you find in most beginner courses and actually building programs.</p>\n<p>The problem? I still wasn’t at the level where I could decipher reams of dry technical text. I wanted more octopuses!</p>\n<p>So, I looked everywhere for them. I scanned the internet for visual and abstract learning resources: Google, YouTube, Medium, TikTok, and every book I could possibly find. I discovered most “visual learning” material fits into one of three groups.</p>\n<p>First is a <strong>gamified learning experience</strong>, like the learn-while-playing platforms <a href=\"https://codecombat.com/\">CodeCombat</a> and <a href=\"https://play.elevatorsaga.com/\">ElevatorSaga</a>. While wonderfully creative and full of stories and characters that help you build real programs with real-world patterns, this type of learning is procedural. The focus is on using concepts rather than diving into what they are.</p>\n<p><img src=\"https://files.smashing.media/articles/learning-javascript-with-imagination/codecombat.png\" /></p>\n<p>The second group is the <strong>graphically represented syntax or technical explanation</strong>. Ever seen an array of apple and orange emojis? Or diagrams of the <code>event</code> loop? These can break down scary concepts into an easier-to-digest visual medium. They can be powerful visual aids that transform dense technical jargon. Examples include <a href=\"https://www.lydiahallie.io\">Lydia Hallie’s</a> brilliant “<a href=\"https://dev.to/lydiahallie/javascript-visualized-promises-async-await-5gke\">JavaScript Visualized</a>” series as well as cheat sheets like <a href=\"https://dev.to/rammcodes/my-visual-javascript-array-cheatsheet-that-went-viral-on-linkedin-44bb\">this one from Ram Maheshwari</a>.</p>\n<p><img src=\"https://files.smashing.media/articles/learning-javascript-with-imagination/javascript-vizualized-scope.png\" /></p>\n<p>The third group is closer to what I sought: the <strong>analogy-driven learning experience</strong>. Developers love a good analogy. We use them all the time in blog posts and video tutorials. They help explain very technical concepts. One resource I found, <a href=\"https://www.codeanalogies.com/\">CodeAnalogies</a>, is particularly impressive, with analogies for everything from content distribution networks to MVC frameworks.</p>\n<p><img src=\"https://files.smashing.media/articles/learning-javascript-with-imagination/codeanalogies.jpg\" /></p>\n<p>But analogy-driven learning has limitations for me. All of the analogies were disconnected! They had no relation to one another. They were great for wrapping my head around an isolated topic but not for seeing the big picture. The thing with JavaScript is that <em>everything</em> is connected. How can a newspaper analogy for objects be extended to describe prototypal inheritance?</p>\n<p>Finally, I came to realize the thing I wanted most was something <strong>memorable</strong>. I wanted to consolidate everything I was learning into a visual format that was easy to recall when I needed it — whether in an interview or while writing code. Unfortunately, most analogies are entirely forgettable. How many dog, cat, and banana arrays can one take?</p>\nBuilding My Own Visual Representations\n<p>There was only one solution to this: create my own visual representations for my JavaScript knowledge tree. But first, I needed to figure out how to make something stick in my memory.</p>\n<p>I’ve always had an interest in <strong>mnemonic memory methods</strong>. These are memory “hacks,” such as the <a href=\"https://artofmemory.com/blog/how-to-build-a-memory-palace\">“memory palace”</a>. They help visually encode large amounts of information for easier recall. World memory competitors use it to remember the order of multiple decks of cards and random number sequences.</p>\n<p>The basic principle is this: You can take any idea and turn it into an image. For example, an array could be an ocean sting<em>ray</em>. That’s good, but still not enough. The trick is to make the mental image as weird, funny, and ridiculous as possible. Images that are out of the ordinary are what stick to memory.</p>\nMy First Big Lesson\n<p>So, here is one of my very first mnemonic representations of JavaScript arrays:</p>\n<p><img src=\"https://files.smashing.media/articles/learning-javascript-with-imagination/streetvendor-javascript-analogy.jpg\" /></p>\n<p>I was so proud of this. We have a stingray street vendor selling fruit, reminding me that arrays hold data. He has a special square device for picking up individual items that represent the square bracket syntax for selecting items. He has a monocle to remind me that arrays have methods for searching. He has a cowboy lasso that refers to loops, and so on.</p>\n<p>It’s a fun depiction. But I was trying to learn JavaScript to land a job! If this ridiculous monocled stingray didn’t make me a better developer, it defeated the purpose. The ultimate test: would I use this image of an array streetseller as a point of reference while coding? Nope. It turned out to be entirely, utterly useless. </p>\n<p>I didn’t need a way to remember the term <em>array</em>. Knowing they have methods to search does not tell me how I can perform searches. Even a Swiss Army knife tail with all the main array methods like <code>.sort()</code>, <code>.push()</code>, and <code>.unshift()</code> proved pointless with a two-second Google search.</p>\n<p>This was trickier than I thought. I learned my first big lesson:</p>\n<p>We can’t learn a programming language using pure mnemonic methods because memorizing the lists of things does not help you understand the underlying concepts.</p>\nMy Second Big Lesson\n<p>After much reflection and many, many more failed attempts, I tried to represent something I had always struggled with: <em>functions</em>. What would the makeup of a function look like? I came up with this pretty poor representation:</p>\n<p><img src=\"https://files.smashing.media/articles/learning-javascript-with-imagination/waterslide-javascript-analogy.jpeg\" /></p>\n<p>At the top, we have silly paratroopers that represent parameters. We send parameters through the entrance, <code>( )</code>, and they end up in a contained pool (i.e., the function body). They start arguing, and that’s how we can remember <code>arguments</code>.</p>\n<p>Unfortunately, this went into the failure bucket, too. Representing syntax isn’t helpful. It’s better to gain familiarity through lots of practice writing it. There were also dangerous flaws in the analogy. It suggested parameters and arguments are the same; the only difference is their place. </p>\n<p>An abstraction like this with flawed theory baked into it would actually make me a <em>worse</em> developer! I needed to dig deeper into what things really are.</p>\nThe Breakthrough\n<p>The solution was to go atomic. Focusing on the smallest concept would give me the first layer I could use to paint a picture of JavaScript. I circled back to our friendly octopus, where this all began.</p>\n<p>What were the tentacles grasping? Values!</p>\n<p>Values are often glossed over and don’t seem like the key to unlocking the mysteries of JavaScript. But this simple idea was a breakthrough for me: if the code flows, we can imagine the flowing as an ocean or river. What do we find in this flow? Islands! </p>\n<p><img src=\"https://files.smashing.media/articles/learning-javascript-with-imagination/toilet-island-javascript-analogy.jpg\" /></p>\n<p>Values are the islands, and each island has a set location and size. That was it! It was exactly what I was looking for. It still didn’t improve my skills as a developer. But I knew it had potential. </p>\nFrom Analogies To Models\n<p>Layer upon layer, I began to build up a vision of JavaScript by focusing on what things are and how they are related to other things. First came islands. Then came genies, evil sorcerers, flying ships, and turtle pilots. My excitement grew as the smaller layers, the fundamentals, could be combined to produce a big-picture understanding of more complex topics like closures.</p>\n<p>Each image was not a simple analogy. It was a <strong>mental model</strong> — a way of thinking. It provided a lens to interpret each concept but required imagination. I call them <em>imagimodels</em>.</p>\n<p>I knew from my past attempts that focusing on lists is ineffective. The secret lies in what things are rather than what they do. When I think about it, that was my problem with learning JavaScript all along. I had no issue eventually getting something to work. The problem was I mostly didn’t have the faintest idea <em>why</em>.</p>\nGrowing A Memorable, Multi-Layered Universe\n<p>With this approach, an abstracted world of JavaScript was erected:</p>\n<p><img src=\"https://files.smashing.media/articles/learning-javascript-with-imagination/light-tower-javascript-analogy.png\" /></p>\n<p>This image helps me identify fundamental JavaScript concepts for assignment, local scope, and primitive values. Of course, it is not a standalone image, and you won’t be able to identify these concepts without context. It requires a story to weave JavaScript and analogy together. </p>\n<p>A narrative is what drove the other concepts into the picture, quite literally. Here, we can see a closure:</p>\n<p><img src=\"https://files.smashing.media/articles/learning-javascript-with-imagination/closure-illustration-javascript-analogy.jpeg\" /></p>\n<p>The next image uses mnemonic methods for remembering useful terminology. Unlike arrays and parameters, “execution context” felt like something I would read in an IBM manual from the 1970s. It was a scary term that deserved a scary representation.</p>\n<p><img src=\"https://files.smashing.media/articles/learning-javascript-with-imagination/executioner-javascript-analogy.png\" /></p>\n<p>I found a connection between “execution context” and the phrase “executor got hex,” which inspired an illustration of a medieval-style executioner holding an axe in one hand and a hex, or sorcerer’s spell, in the other.</p>\n<p>Why the spell? It’s not random. It builds on previous existing layers representing other sub-concepts. The spell is tied to our understanding of a function invocation and makes you think of wizards and sorcerers, right? And it is the parenthesis in every function call.  </p>\n<p>This begs the question, <em>what is a function?</em> Is it the result of the hex or the execution? Is it the invocation itself? Only a firm understanding of objects would help me identify what really is going on here.</p>\n<p>As you can see, the visual layers build upon one another, like a tree with a central trunk branching out in different directions. It’s the knowledge tree I wanted — not one containing every detail about JavaScript, but a central, unified mnemonic resource that could be compared and evaluated against, added to, argued over, and above all, retrieved when I needed it. </p>\n<p>I call my illustrations of JavaScript concepts <a href=\"https://thegreatsync.com/\">“The Great Sync”</a>, and I use them to continue to grow my understanding. It is also something I now use to teach others.</p>\n<p><img src=\"https://files.smashing.media/articles/learning-javascript-with-imagination/great-sync-illustrations-javascript-concepts.jpg\" /></p>\nA Celebration Of Alternative Learning Approaches\n<p>Was it all sunshine and daisies for my JavaScript learning journey from this point on? Did building this world make me ace every JavaScript quiz I needed to pass to get that senior-level job?</p>\n<p>Nope! I wish the best of luck to anyone who thinks they can learn JavaScript simply by looking at a few pictures. </p>\n<p>My biggest takeaway from all my learning efforts is this: Despite The Great Sync solving so many of my personal struggles with the language, is it any better than any single one of the resources I mentioned? Does it have any use without actual coding — the tireless, painful process of trying to get your code to work? Certainly not.</p>\n<p>It is one tool, among many, to “see” JavaScript differently and escape the confinement of a code editor or YouTube tutorial.</p>\n<p>All of these approaches celebrate the variety and infinite creative potential of the learning experience. And the more we have, the more learners who are stuck on JavaScript can discover new routes to understanding.</p>\n<h3>Further Reading on Smashing Magazine</h3>\n<ul>\n<li><a href=\"https://www.smashingmagazine.com/2022/09/javascript-api-guide/\">JavaScript APIs You Don’t Know About</a></li>\n<li><a href=\"https://www.smashingmagazine.com/2021/09/interactive-learning-tools-front-end-developers/\">Interactive Learning Tools For Front-End Developers</a></li>\n<li><a href=\"https://www.smashingmagazine.com/2022/03/audio-visualization-javascript-gsap-part1/\">A Guide To Audio Visualization With JavaScript And GSAP</a></li>\n<li><a href=\"https://www.smashingmagazine.com/2021/06/css-javascript-requirements-accessible-components/\">When CSS Isn’t Enough: JavaScript Requirements For Accessible Components</a></li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"f6e67b5fb8e23dad4bb33cf4d682449aae6443a3724e8b11bf7b01f5e7466772","category":"Tech"}