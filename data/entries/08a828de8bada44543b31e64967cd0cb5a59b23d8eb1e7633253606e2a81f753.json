{"title":"Amazon CloudFront now accepts your applications’ gRPC calls","link":"https://aws.amazon.com/blogs/aws/amazon-cloudfront-now-accepts-your-applications-grpc-calls/","date":1732140194000,"content":"<p>Starting today, you can deploy <a href=\"https://aws.amazon.com/cloudfront/\">Amazon CloudFront</a>, our global content delivery network (CDN), in front of your gRPC API endpoints.</p> \n<p><a href=\"https://grpc.io/\">gRPC</a> is a modern, efficient, and language-agnostic framework for building APIs. It uses <a href=\"https://protobuf.dev/overview/\">Protocol Buffers</a> (protobuf) as its <a href=\"https://en.wikipedia.org/wiki/Interface_description_language\">interface definition language</a> (IDL), which enable you to define services and message types in a platform-independent manner. With gRPC, communication between services is achieved through lightweight and high-performance remote procedure calls (RPCs) over HTTP/2. This promotes efficient and low-latency communication across services, making it ideal for microservices architectures.</p> \n<p>gRPC offers features such as bidirectional streaming, flow control, and automatic code generation for a <a href=\"https://grpc.io/docs/languages/\">variety of programming languages</a>. It’s well-suited for scenarios in which you require high performance, efficient communication, and real-time data streaming. If your application needs to handle a large amount of data or requires low-latency communication between client and server, gRPC can be a good choice. However, gRPC might be more challenging to learn compared to REST. For example, gRPC relies on the protobuf serialization format, which requires developers to define their data structures and service methods in <code>.proto</code> files.</p> \n<p>I see two benefits of deploying <span>CloudFront</span> in front of your gRPC API endpoints.</p> \n<p>First, it allows the reduction of latency between the client application and your API implementation. <span>CloudFront</span> offers a global network of over 600+ edge locations with intelligent routing to the closest edge. Edge locations provide TLS termination and optional caching for your static content. <span>CloudFront</span> transfers client application requests to your gRPC origin through the fully managed, low-latency, and high-bandwidth private AWS network.</p> \n<p>Secondly, your applications benefit from additional security services deployed on edge locations, such as traffic encryption, the validation of the HTTP headers through <a href=\"https://aws.amazon.com/waf\">AWS Web Application Firewall</a>, and <a href=\"https://aws.amazon.com/shield/\">AWS Shield</a> Standard protection against <a href=\"https://aws.amazon.com/shield/ddos-attack-protection/\">distributed denial of service (DDoS) attacks</a>.</p> \n<p><span><strong>Let’s see it in action<br /> </strong></span>To start this demo, I use the <a href=\"https://github.com/grpc/grpc/tree/master/examples/python/route_guide\">gRPC route-guide demo</a> from <a href=\"https://github.com/grpc/grpc\">the official gRPC code repository</a>. I deploy this example application in a container for ease of deployment (but any other deployment option is supported too).</p> \n<p>I use this <code>Dockerfile</code></p> \n<pre><code>FROM python:3.7\nRUN pip install protobuf grpcio\nCOPY ./grpc/examples/python/route_guide .\nCMD python route_guide_server.py\nEXPOSE 50051</code></pre> \n<p>I also use the <a href=\"https://aws.github.io/copilot-cli/\">AWS Copilot command line</a> to deploy my container on <a href=\"https://aws.amazon.com/ecs/\">Amazon Elastic Container Service (Amazon ECS)</a>. The Copilot command prompts me to collect the information it requires to build and deploy the container. Then, it creates the <a href=\"https://docs.aws.amazon.com/AmazonECS/latest/developerguide/clusters.html\">ECS cluster</a>, the <a href=\"https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html\">ECS service</a>, and the <a href=\"https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definitions.html\">ECS task</a> automatically. It also creates a TLS certificate and the load balancer for me. I test <a href=\"https://github.com/grpc/grpc/blob/master/examples/python/route_guide/route_guide_client.py\">the client application</a> by modifying <a href=\"https://github.com/grpc/grpc/blob/master/examples/python/route_guide/route_guide_client.py#L122\">line 122</a> to use the DNS name of the load balancer listener endpoint. I also change the client application code to use <code>grpc.secure_channel</code> instead of <code>grpc.insecure_channel</code> because the load balancer provides the application with an HTTPS endpoint.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/05/2023-06-05_12-36-12.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/05/2023-06-05_12-36-12.png\" alt=\"gRPC client application demo - source code with ALB\" width=\"810\" height=\"290\" /></a></p> \n<p>When I’m confident my API is correctly deployed and working, I proceed and configure <span>CloudFront</span>.</p> \n<p>First, in the <span>CloudFront</span> section of the <a href=\"https://console.aws.amazon.com\">AWS Management Console</a>, I select <strong>Create distribution</strong>.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/06/2023-06-06_10-41-48.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/06/2023-06-06_10-41-48.png\" width=\"810\" height=\"186\" /></a></p> \n<p>Under Origin, I enter my gRPC endpoint DNS name as <strong>Origin domain</strong>. I enable <strong>HTTPS only</strong> as <strong>Protocol</strong> and leave the HTTPS port as is (443). Then I choose a <strong>Name</strong> for the distribution.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/06/2023-06-06_10-44-32.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/06/2023-06-06_10-44-32.png\" alt=\"CloudFront - Add origin and name\" width=\"642\" height=\"996\" /></a></p> \n<p>Under <strong>Viewer</strong>, I select<strong> HTTPS only</strong> as <strong>Viewer protocol policy</strong>. Then, I select <strong>GET, HEAD, OPTIONS, PUT, POST, PATCH, DELETE</strong> as <strong>Allowed HTTP methods</strong>. I select <strong>Enable</strong> for <strong>Allow gRPC requests over HTTP/2</strong>.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/11/05/2024-11-05_22-00-49.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/11/05/2024-11-05_22-00-49.png\" alt=\"CloudFront - Viewer Policy\" width=\"400\" height=\"399\" /></a></p> \n<p>Under <strong>Cache key and origin requests</strong>, I select <strong>AllViewer</strong> as <strong>Origin request policy</strong>.</p> \n<p>The default cache policy is <strong>CacheOptimized</strong>, but gRPC isn’t cacheable API traffic. Therefore, I select <strong>CachingDisabled</strong> as <strong>Cache policy</strong>.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/11/05/2024-11-05_22-08-58.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/11/05/2024-11-05_22-08-58.png\" alt=\"CloudFront - Cache policy\" width=\"800\" height=\"598\" /></a></p> \n<p>AWS WAF helps protect you against common web exploits and bots that can affect availability, compromise security, or consume excessive resources. For gRPC traffic, AWS WAF can inspect <a href=\"https://docs.aws.amazon.com/waf/latest/APIReference/API_Headers.html\">the HTTP headers</a> of the request and enforce <a href=\"https://docs.aws.amazon.com/waf/latest/developerguide/web-acl.html\">access control</a>. It doesn’t inspect the request body in protobuf format.</p> \n<p>For this demo, I choose to not use AWS WAF. Under <strong>Web Application Firewall (WAF)</strong>, I select <strong>Do not enable security protections</strong>.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/06/2023-06-06_10-50-39.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/06/2023-06-06_10-50-39.png\" alt=\"CloudFront - Security\" width=\"820\" height=\"243\" /></a></p> \n<p>I also keep all the other options with their default value. HTTP/2 support is selected by default<strong>. Do not disable it because it is required for gRPC</strong>.</p> \n<p>Finally, I select <strong>Create distribution</strong>.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/06/2023-06-06_10-51-45.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/06/2023-06-06_10-51-45.png\" alt=\"CloudFront - Create distribution\" width=\"600\" height=\"430\" /></a></p> \n<p>There is only one switch to enable gRPC on top of the usual setup. When turned on, with HTTP/2 and HTTP POST enabled, <span>CloudFront</span> detects gRPC client traffic and forwards it to your gRPC origin.</p> \n<p>After a few minutes, the distribution is ready. I copy and paste the endpoint URL of the <span>CloudFront</span> distribution, and I change the client-side app to make it point to <span>CloudFront</span> instead of the previously created load balancer.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/05/2023-06-05_12-32-14.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/05/2023-06-05_12-32-14.png\" alt=\"gRPC client application demo - source code\" width=\"810\" height=\"293\" /></a></p> \n<p>I test the application again, and it works.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/05/2023-06-05_11-08-56.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/05/2023-06-05_11-08-56.png\" alt=\"gRPC client application demo - execution\" width=\"810\" height=\"240\" /></a></p> \n<p><span><strong>Pricing and Availability</strong><br /> </span>gRPC origins are available on all the more than 600 <span>CloudFront</span> edge locations at no additional cost. The usual requests and data transfer fees apply.</p> \n<p><strong>Go and point your <span>CloudFront</span> origin to a gRPC endpoint today.</strong></p> \n<p><a href=\"https://twitter.com/sebsto\">-- seb</a></p>","author":"Sébastien Stormacq","siteTitle":"AWS News Blog","siteHash":"6093e072e4117ec22616e844cb857d03ca62c57a411a8affc77cb5e8b6b15bf6","entryHash":"08a828de8bada44543b31e64967cd0cb5a59b23d8eb1e7633253606e2a81f753","category":"Tech"}