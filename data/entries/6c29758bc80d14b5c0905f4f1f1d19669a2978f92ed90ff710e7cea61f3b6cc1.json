{"title":"Lit Framework & the DOM reuse","link":"https://blog.whs.in.th/node/3725","date":1731422265000,"content":"<p>ช่วงนี้เขียน <a href=\"https://lit.dev\">Lit</a> อยู่แล้วสงสัยว่า DOM reuse มันทำงานยังไงเพราะไม่มีใครเขียนบอกไว้</p>\n<p>(Note: บทความนี้มี HTML tags เยอะ และ WordPress มันพยายามปิด tag auto ดังนั้นบางจุดอาจจะเห็น tags บั๊ก ไว้รอเปลี่ยน blog engine แล้วกันนะ)</p>\n<h2>React &amp; Vue</h2>\n<p>หลายๆ คนอาจจะมาจาก React หรือ Vue ที่มีระบบ Virtual DOM</p>\n<p>ใน React ฟังค์ชั่น <code>render()</code> (หรือ stateless functional component) จะคืน DOM tree (<code>return &lt;div&gt;&lt;/div&gt;</code>) ออกไป ซึ่งจริงๆ แล้วมันคือ <code>React.createElement</code> หรือ <code>jsx()</code> ซึ่ง return value ของ function เหล่านี้เป็น <a href=\"https://react.dev/reference/react/createElement#returns\">object</a> หรือบางทีก็เรียก <a href=\"https://vuejs.org/guide/extras/rendering-mechanism#virtual-dom\">vnode</a></p>\n<p>หลังจากได้ data structure ของส่วนที่สนใจแล้ว ระบบ Virtual DOM ก็จะเปรียบเทียบผลของ <code>render()</code> รอบที่แล้วกับรอบปัจจุบันว่าต่างกันตรงไหน แล้ว apply เฉพาะผลตรงนี้กับ DOM จริง ซึ่งในอดีตท่านี้ก็มี performance ดีกว่าการไป mutate DOM จริงทุกรอบ เพราะ DOM implementation ทำงานช้ากว่า และอาจจะมี side effect ต่างๆ ปัจจุบันผมไม่ได้ตามข่าวแล้วแต่ก็มีกระแสว่า virtual DOM is pure overhead อยู่ช่วงหนึ่ง</p>\n<p>อย่างไรก็ตาม ในประเด็นเดิมเวลาเขียน React หรือ Vue การ reuse DOM เป็นเรื่องมาตรฐานอยู่แล้วว่าถ้า DOM tree เหมือนเดิม ก็ไม่มีเหตุผลอะไรที่ที่ framework จะต้องสร้าง element ใหม่ทุกครั้งที่อัพเดตให้เสีย performance</p>\n<h2>Lit</h2>\n<p>สำหรับคนที่ไม่เคยเขียน Lit แล้ว เฟรมเวิร์ค Lit ประกอบด้วยหลายๆ ส่วนที่ต่อยอดกันขึ้นไป</p>\n<p>ในชั้นล่างสุดเป็นไลบรารีชื่อ lit-html ซึ่ง<a href=\"https://github.com/lit/lit/blob/main/dev-docs/design/how-lit-html-works.md\">มันเจ๋งมาก</a> และสามารถใช้เดี่ยวๆ ได้ด้วยโดยไม่ต้องใช้ส่วนอื่นๆ</p>\n<p>โค้ด lit-html หน้าตาแบบนี้</p>\n<pre><code>import {render} from \"lit-html\";\nlet body = (counter) =&gt; html`&lt;div&gt;Counter is ${counter}&lt;/div&gt;`\nrender(body, document.body)\n</code></pre>\n<p>โค้ดนี้สามารถรันได้เลยใน browser สมัยใหม่ โดยไม่ต้องผ่าน transpiler ใดๆ อย่างที่ Vue/React เป็น และมันไม่ใช่ Virtual DOM</p>\n<p>คำถามที่ JS Programmer เห็นแล้วจะต้องถามคือ performance มันน่าจะกากมากเพราะมันไม่ reuse DOM หรือเปล่า มันต่างอะไรกับโค้ดนี้</p>\n<pre><code>function render(counter){\n    document.body.innerHTML = `&lt;div&gt;Counter is ${counter}&lt;/div&gt;`;\n}\n</code></pre>\n<p>แต่จริงๆ แล้ว lit-html มี magic อยู่ที่ทำให้มัน reuse DOM ได้เร็วมากๆ</p>\n<h3>Tagged template literal</h3>\n<p>ใน ES6 มีสิ่งที่เรียกว่า Tagged template literal โดย template literal คือ string ที่ใช้เครื่องหมาย backtick (<code>`example`</code>) แต่มีตัวหนังสืออยู่ข้างหน้า เช่น <code>html`example`</code></p>\n<p>string แบบนี้มีค่าเท่ากับ function call <code>html([\"example\"])</code> แต่ถ้าเรามีการใช้ค่าข้างใน มันจะกลายเป็น variadic arguments: <code>html`hello ${world}.`</code> = <code>html([\"hello \", \".\"], world)</code></p>\n<p>สิ่งที่ lit ทำใน function <code>html</code> คือแค่เก็บ parameter ไว้ใน object เฉยๆ เรียกว่า TemplateResult แต่ยังไม่ทำอะไร</p>\n<h3>render is magic</h3>\n<p>Magic ของ lit อยู่ที่คำสั่ง render ซึ่งสิ่งที่มันจะทำคือสร้าง DOM ขึ้นมาตาม HTML ที่วางไว้โดยยังไม่สนใจส่วนที่เป็นตัวแปร ซึ่งส่วนที่ไม่ใช่ตัวแปรนี้แสดงว่าเป็นค่าคงที่ (constant) ที่มาจาก source code เสมอ จึงมั่นใจได้ว่าไม่มี cross site scripting (XSS)</p>\n<h3>Parsing</h3>\n<p>การสร้าง DOM ของ lit จะ regex parse HTML ที่เราเขียนเพื่อแทนตำแหน่งที่เราเจาะช่องไว้ด้วย marker บางอย่าง โดยที่ทำให้ HTML นั้นเป็น HTML ที่ถูกต้องใช้งานได้จริง เช่น ถ้าเราเจาะช่องไว้ตรงข้อความ ก็จะแทนด้วย HTML comment ที่มีเลข ID แทน แบบนี้ <code>hello &lt;!--?lit$1234$--&gt;.</code></p>\n<p>พอได้ HTML ที่ใช้งานได้แล้ว Lit ก็จะสร้าง <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template\"><code>&lt;template&gt;</code></a> แล้ววาง HTML ลงไปใน innerHTML เพื่อให้ browser parse HTML นี้เป็น DOM แต่ห้ามแสดงผล</p>\n<p>จาก DOM ที่ได้รับมา Lit จะไต่ DOM ไปเรื่อยๆ เพื่อหา marker พอเจอแล้วจะจดไว้ว่าเจอใน loop รอบที่เท่าไร</p>\n<p>จบจากขั้นตอนนี้ สิ่งที่เราจะได้รับคือ</p>\n<ol>\n<li><code>&lt;/template&gt;&lt;template&gt;</code> ที่มี HTML ที่ต้องการแสดงผลอยู่ภายใน</li>\n<li>ลำดับที่ของ marker ที่แทนจุดแทรกข้อความ</li>\n</ol>\n<p>ในอนาคต Lit มีแผนว่าจะสร้าง <a href=\"https://www.npmjs.com/package/@lit-labs/compiler\">compiler</a> ที่ประมวลผล HTML ล่วงหน้าเลย ไม่ต้องไปทำที่ client side อีกต่อไป</p>\n<h3>Caching</h3>\n<p>Tagged template literal มีสมบัติพิเศษอีกอย่างหนึ่งคือ ปกติแล้ว array ใน JS จะไม่เท่ากัน (<code>[] != []</code>) แต่ tagged template literal การันตีว่า parameter แรกที่เรียก function ของเรา จะเป็น array เดิมเสมอถ้าหากเรียกจากโค้ดจุดเดิม ใช้ <code>===</code> เช็คได้เลย ดังนั้น Lit จะใช้ array ตัวหน้าของ function <code>html</code> เป็น cache key</p>\n<p>ในการ re-render ครั้งถัดไป Lit จะเห็นว่าใช้ HTML ส่วนคงที่อันเดิม ก็สามารถใช้ค่าจาก cache ได้เลยโดยไม่ต้อง parse ซ้ำอีกครั้ง</p>\n<h3>Create</h3>\n<p>หลังจาก parse ไม่ว่าจริงหรือ cache แล้ว กระบวนการถัดมา Lit จะสร้าง DOM element จริงโดย clone <code>&lt;/template&gt;&lt;template&gt;</code> ที่สร้างไว้เสร็จแล้วออกมา แล้วไต่ DOM ของ template ไป เมื่อถึงลำดับตามที่จดลำดับของ marker ไว้ ก็จะเก็บ reference ของ DOM node นั้นไว้ เรียกว่า Part (ที่ตอนแรกเก็บเป็นลำดับ ไม่ใช่ reference ก็เพราะว่าพอ clone แล้ว reference ต้องไปหาใหม่ ส่วนลำดับเนื่องจาก template เป็นค่าคงที่ วนกี่ครั้งก็จะต้องได้ node เดิมที่ลำดับเดิม)</p>\n<p>เสร็จแล้ว Lit ก็แค่เอา cloned template ไปแปะไว้ที่ root และแอบวาง <code>_$litPart$</code> ไว้ที่ root ด้วยซึ่งเก็บตัว template string ดั้งเดิมไว้ และ array ของ Part ตามลำดับที่ปรากฏใน template string</p>\n<h3>Update</h3>\n<p>ส่วนที่สำคัญและใช้บ่อยคงเป็นส่วนการ update ซึ่งเมื่อเราเรียก <code>render()</code> ซ้ำรอบที่สอง สิ่งที่เกิดขึ้นก็คือ</p>\n<ol>\n<li>Lit จะดูว่ามี <code>_$litPart$</code> อยู่หรือไม่ ถ้าไม่มี ก็ไปที่ Create ใหม่ได้เลยเพราะเป็นครั้งแรก</li>\n<li>ตรวจดูว่า template string ใน <code>_$litPart$</code> ของเดิม ตรงกับ template ของใหม่หรือไม่ (ซึ่งสามารถใช้ === เช็คได้เลยอย่างที่บอกไปในหัวข้อ caching) ถ้าไม่ตรงก็ไปที่ Create เหมือนกัน</li>\n<li>ถ้าทุกอย่างตรงแสดงว่าเป็นการ update ก็แค่เหลือแค่เอาค่าที่ส่งเข้ามา แปะทับ marker/Part ตามลำดับได้เลย</li>\n</ol>\n<p>ดังนั้นการ update ใน Lit จึงทำได้รวดเร็วมากๆ overhead ในการ update อาจจะต่างจาก Svelte ที่ compile down เป็น update operation โดยตรงไม่มากนัก ไม่ต้อง diff virtual DOM ระหว่างกัน และเนื่องจาก Lit ทราบว่าแต่ละ part อยู่ตรงไหน เช่น เป็น attribute หรือ textContent จึงใช้คำสั่ง update ที่เหมาะสมและไม่ทำให้เกิดปัญหา cross site scripting</p>\n<h1>Lit Element</h1>\n<p>ชั้นถัดมาของ Lit คือระบบ component ของ Lit ซึ่งเดิมเป็นเฟรมเวิร์คชื่อ Lit Element แต่ต่อมาเนื่องจากเป็นโครงการเรือธง ก็เลยเป็นชื่อ Lit เฉยๆ ตาม project</p>\n<p>ระบบ component ของ Lit จะใช้ระบบ <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_components\">Web Component</a> ใน browser โดยตรง โดยปกติจะหน้าตาแบบนี้</p>\n<pre><code>@customElement('hello-world')\nexport class HelloWorld extends LitElement {\n    render() {\n        return html`&lt;div&gt;Hello world&lt;/div&gt;`;\n    }\n}\n</code></pre>\n<p>โดย <code>@customElement</code> decorator จะลงทะเบียนกับ browser ว่าต่อไปนี้ถ้าเจอ tag <code>&lt;hello-world&gt;</code> ในหน้า ให้โอนการควบคุมมาที่ class นี้ ซึ่งถ้าเราไล่ class hierachy แล้ว LitElement extends ReactiveElement extends <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement\">HTMLElement</a> ก็คือตัว class ของเราเป็น DOM node ได้โดยตรงไม่ต้องผ่านการแปลงใดๆ</p>\n<p>เพื่อไม่ให้ชนกัน มาตรฐาน Web Component การันตีว่าในอนาคตจะไม่มี HTML tag ใดๆ ที่มีเครื่องหมายขีด (-) อยู่ภายใน ในขณะเดียวกันเราไม่มีสิทธิ์จะลงทะเบียน custom component ใดๆ ที่ไม่มีเครื่องหมายขีด</p>\n<p>ระบบ component ของ Lit จะพิเศษกว่าเฟรมเวิร์คอื่นๆ คือเมื่อ component หนึ่งใช้งานอีก component หนึ่ง ปกติแล้วจะต้อง import component definition เข้ามาเพื่ออ้างอิง แต่ใน Lit เราไม่ต้อง import (นอกจาก import for side effect ให้ bundler รู้และรวม source code เข้ามา) เราสามารถใช้ tag ของ component อื่นๆ ได้เลย</p>\n<p>ทีนี้พอ application มีความซับซ้อนมากขึ้น ก็กลับมาที่คำถามเดิมว่าแล้ว Lit Element มันครอบ lit-html อย่างไร และการใช้งาน render() จะเหมือนหรือแตกต่างจาก lit-html อย่างไร</p>\n<h2>Shadow DOM</h2>\n<p>เวลาใช้ระบบ component เราจะอยากให้ component ซ่อน implementation detail ของเราออกไปด้วย เช่นบางคนอาจจะใช้ CSS-in-JS หรือ Modular CSS ต่างๆ เพื่อไม่ให้ CSS leak ออกไปที่อื่น</p>\n<p>ใน Lit Element จะใช้ระบบ <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_shadow_DOM\">Shadow DOM</a> ใน browser เป็นตัวแยกนี้ โดย browser มี Shadow DOM มานานแล้วเนื่องจาก element บางอย่างในหน้าเว็บ เช่น <code>&lt;input type=file/&gt;</code> จะมี text field กับปุ่ม browse ซึ่งภายในมันก็คือ 2 element แยกกัน แต่ถูกปิดให้มองเห็นเป็น element เดียว ต่อมาความสามารถนี้ก็เปิดให้ใช้งานได้เองไม่จำกัดเฉพาะ built in เท่านั้น</p>\n<p>ดังนั้นถึงแม้ component ของเราจะเป็น DOM node โดยตรง แต่ Lit จะมีการสร้าง Render root ภายในอีกชั้นหนึ่งก่อน ซึ่งก็คือการทำให้ภายใน component ของเรากลายเป็น Shadow DOM root แล้วค่อย render ลงไปใน Shadow DOM root โดยใช้ <code>render()</code> ของ lit-html บน Shadow DOM root</p>\n<h2>Wait, lit-html render?</h2>\n<p>แต่เดี๋ยวก่อนนะ มันใช้ lit-html render() แล้วทำไมมันส่งของอย่างอื่นที่ไม่ใช่ tagged template literal เข้าไปได้? เช่น บางทีก็อยากส่ง directive เข้าไป หรือบางทีไม่ใช้ lit-html แล้ว render dom คืนเองเลยก็ได้</p>\n<p>แล้วตอนไหนบ้างที่ <code>render()</code> จะ reuse node ถ้า input มันไม่ใช่ TemplateResult? กรณีนี้ไม่เคยเห็นมีใครบอกในเน็ต ก็เลยต้องไปหาคำตอบใน source code</p>\n<h3>Empty</h3>\n<p>กรณีที่เรา return ค่า nothing, null, empty string จะทำให้ Lit clear child ออก กรณีนี้แน่นอนไม่มี reuse child node รวมถึง child เหล่านั้นถ้าไม่มีคนอื่นเก็บไว้ก็หายไปเลย</p>\n<h3>Node</h3>\n<p>ถ้าเราสร้าง DOM node เองจาก <code>document.createElement</code> หรืออื่นๆ แล้วคืนมา กรณีนี้ Lit จะ clear child ออกแล้ว insert node ที่เราส่งให้คืนไป ยกเว้นแต่เป็น node เดิม</p>\n<p>ดังนั้นถ้า render function ของเราใน Lit มัน <code>createElement</code> ใหม่ทุกครั้งก็จะไม่มีการ reuse DOM เราต้องไปทำให้ render function เรา reuse DOM node เอง</p>\n<p>ตรงนี้เป็นจุดที่ต่างกับ Virtual DOM framework อื่นๆ เพราะในเฟรมเวิร์คเหล่านั้นเราคืน JSX ออกมาได้เลยแล้วมันจะไป diff ให้เองว่าต้อง rerender หรือไม่ เราไม่สามารถคืน DOM node ออกมาได้โดยตรงแบบที่ทำได้ใน Lit</p>\n<p>สรุปง่ายๆ คือถ้าไม่จำเป็นอย่าทำ ควรจะใช้ tagged template literal จะ cache node ให้อัตโนมัติ</p>\n<h3>String</h3>\n<p>เราสามารถคืน string ให้มันแสดงผลได้ด้วย แต่ด้านหลังมันจะ create text node ใหม่เสมอไม่ว่าเป็น string ใหม่หรือไม่</p>\n<p>คิดว่าเค้าคงทดสอบมาแล้วว่าไม่ cache เร็วกว่า ก็อาจจะยังใช้ต่อได้</p>\n<h3>Directive</h3>\n<p>ส่วนที่ยากสุดน่าจะอยู่ตรงนี้ คือระบบ Directive ซึ่งจริงๆ ก็เป็นเรื่องของ lit-html ไม่ใช่ Lit Element</p>\n<p>เนื่องจาก lit-html ใช้ tagged template literal ดังนั้นตัว HTML structure ต้องกำหนดมาตั้งแต่เขียนโค้ดเท่านั้น แต่ในความเป็นจริงโครงสร้าง HTML อาจจะมีการเปลี่ยนแปลง</p>\n<h4>cache</h4>\n<p>อย่างง่ายที่สุดคงเป็น if-else เพื่อแสดง-ซ่อน หรือแสดงแตกต่างกันตามเงื่อนไข ซึ่งก็น่าจะไม่ยากอะไรก็เจาะช่องไว้แล้ว render ผลเข้าไปทับช่อง ซึ่งก็เป็นปกติทุกเฟรมเวิร์คว่าเมื่อ if-else ให้ DOM node เปลี่ยนไป ตัวเก่าก็จะถูกทำลาย เอากลับมาแสดงใหม่ก็จะสร้างใหม่ไม่ reuse</p>\n<p>ใน Lit จะมีคำสั่ง <a href=\"https://lit.dev/docs/templates/directives/#cache\"><code>cache</code></a> ซึ่งมันจะ cache TemplateResult ทุกอันที่มันเคยเห็นไว้ ถ้าสลับ template กันไปมาก็จะกลับไปใช้ DOM เก่า</p>\n<h4>repeat</h4>\n<p>คำสั่งถัดมาที่น่าจะใช้กันคือการ loop เพื่อแสดงผลข้อมูลที่มีหลายค่า แต่อาจไม่ทราบจำนวนแน่นอนขณะเขียนโค้ด</p>\n<p>ถ้าเป็น React ก็จะบอกว่าใช้ loop ปกติของ JavaScript ได้เลยโดยใช้คำสั่ง <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\"><code>map</code></a> ซึ่งใน Lit ก็ทำได้เช่นเดียวกัน โดยมันจะพยายาม reuse node ที่ตำแหน่งเดียวกัน</p>\n<p>สำหรับการ loop แบบที่มี key นั้น Lit จะมี directive ชื่อ <a href=\"https://lit.dev/docs/templates/directives/#repeat\"><code>repeat</code></a> ซึ่งหาก array มีการเปลี่ยนลำดับมันจะย้ายที่ตาม key ให้ด้วยและพยายาม reuse node</p>\n<p>ไม่ว่าจะเป็น loop ปกติ หรือ repeat อัลกอริธึมที่ใช้ในการ reuse node ก็คือเท่ากับ <code>render()</code> ปกติ ดังนั้นถ้าเราใช้ keyed loop ก็จริง แล้วไปเรียก <code>document.createElement</code> ข้างใน มันก็ไม่ reuse node เราจะต้อง reuse node ด้วยตัวเองหรือใช้ tagged template เท่านั้น</p>\n<h4>until</h4>\n<p>คำสั่ง <code>until</code> ผมคิดว่ามันเจ๋งดี เป็นอะไรที่ React ทำยากและซับซ้อนกว่ามากเพราะต้องใช้ Suspense API</p>\n<p>คำสั่ง <code>until</code> ทำให้เราสามารถใช้ Promise ได้โดยตรงในการ render เลย โดย until จะรับ parameter ได้หลายๆ ค่า และจะคืนค่าแรกสุดที่ใช้งานได้ โดยปกติแล้วเราก็จะส่งไปสองค่า คือ Promise ที่ต้องการ กับหน้า loading เป็นค่าคงที่ไว้แบบนี้</p>\n<pre><code>render() {\n    return html`&lt;div&gt;Highscore: ${until(this.highscore.then((score) =&gt; html`${score}`, () =&gt; html`Error`), html`Loading...`)}&lt;/div&gt;`\n}\n</code></pre>\n<p>ความเจ๋งของ <code>until</code> คือมันใช้ที่ attribute ก็ได้</p>\n<pre><code>render() {\n    return html`&lt;data-view .data=\"${until(this.dataPromise, null)}\"&gt;&lt;/data-view&gt;`\n}\n</code></pre>\n<p>แบบนี้ data-view ก็จะได้ data ไม่ว่าจะเป็น null หรือเป็นค่าจริง โดยไม่ต้องแตะ Promise เอง</p>\n<p>ปัญหาก็คือในเคสแรกที่เรามีการ then() ใน render แล้ว then() จะคืน promise ใหม่ออกมา เมื่อมีการ rerender component ของเรามันจะได้ promise อันใหม่เรื่อยๆ ทำให้ until เห็นว่า promise มีการเปลี่ยนแล้วไป then() ต่อจาก promise อันใหม่ ส่วนผลของ promise ก็ถูกเซตตาม algorithm ปกติ ดังนั้นในส่วนของผลก็ควรจะมีการ reuse DOM ได้ตามปกติ แต่ถ้าเราไม่ cache promise ที่ then เป็น UI แล้วไว้ มันจะทำให้เรา leak UI promise ไปจนกว่า promise หลักจะ resolve</p>\n<h4>Directive</h4>\n<p>แล้วถ้าเรา return directive โดยตรง แบบไม่ซ้อน <code>html</code> ล่ะ จะเกิดอะไรขึ้น?</p>\n<p>สิ่งที่เกิดขึ้นคือ Lit จะ resolve directive เป็นค่าจริงมาก่อน แล้วดู type ของค่าที่ได้ก่อนนำไป render ดังนั้นสามารถใช้ directive ตรงๆ ได้โดยไม่ต้องซ้อน HTML</p>\n<h2>Benchmark matters</h2>\n<p>ทั้งหมดทั้งปวงที่เขียนมานี้ มาจากการ review source code ของ Lit ในการใช้งานจริง benchmark มาแ้ลวอาจได้ผลอีกอย่างหนึ่ง</p>\n<p>ถ้ามีใครจะขยันไป benchmark ก็มาแชร์กันต่อได้ครับ</p>\n<h1>tl;dr</h1>\n<ol>\n<li>ถ้า create DOM node ด้วยตัวเอง ต้อง cache เองเสมอ</li>\n<li>เวลาใช้ Lit อย่าพยายาม create DOM node เองแล้วคืนให้ Lit ยกเว้นตรงที่มันบอกว่ารับเฉพาะ DOM node</li>\n<li>แต่ถ้า DOM node มันง่ายๆ ไม่ซับซ้อน อาจจะต้องลอง benchmark ดูมันอาจจะไวกว่า tagged template literal ก็เป็นได้\n</li>\n</ol>","author":"whs","siteTitle":"Quietly Verbose","siteHash":"5f972a6fe70a917eb1b1aa165b3cb2be8a9465af33ab38bf05f34c55c0e40587","entryHash":"6c29758bc80d14b5c0905f4f1f1d19669a2978f92ed90ff710e7cea61f3b6cc1","category":"Thai"}