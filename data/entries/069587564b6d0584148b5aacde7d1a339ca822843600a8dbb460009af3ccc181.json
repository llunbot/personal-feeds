{"title":"HTTP/3: Practical Deployment Options (Part 3)","link":"https://smashingmagazine.com/2021/09/http3-practical-deployment-options-part3/","date":1630926000000,"content":"<p>Hello, and welcome to the final installment of this three-part series on the new HTTP/3 and QUIC protocols! If after the previous two parts — <a href=\"https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/\">HTTP/3 history and core concepts</a> and <a href=\"https://www.smashingmagazine.com/2021/08/http3-performance-improvements-part2/\">HTTP/3 performance features</a> — you’re convinced that starting to use the new protocols is a good idea (and you should be!), then this final piece includes all you need to know to get started!</p>\n<p>First, we’ll discuss which changes you need to make to your pages and resources to optimally use the new protocols (that’s the easy part). Next, we’ll look at how to set up servers and clients (that’s the hard part unless you’re using a content delivery network (CDN)). Finally, we’ll see which tools you can use to evaluate the performance impact of the new protocols (that’s the almost impossible part, at least for now).</p>\n<div>\n    <ul>\n    <li><a href=\"https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/\">Part 1: HTTP/3 History And Core Concepts</a><br />This article is targeted at people new to HTTP/3 and protocols in general, and it mainly discusses the basics.</li>\n    <li><a href=\"https://www.smashingmagazine.com/2021/08/http3-performance-improvements-part2/\">Part 2: HTTP/3 Performance Features</a><br />This one is more in depth and technical. People who already know the basics can start here.</li>\n    <li><strong>Part 3: Practical HTTP/3 Deployment Options</strong><br />This third article in the series explains the challenges involved in deploying and testing HTTP/3 yourself. It details how and if you should change your web pages and resources as well.</li>\n</ul>\n</div>\n\nChanges To Pages And Resources\n<p>Let’s begin with some good news: <strong>If you’re already on HTTP/2, you probably won’t have to change anything to your pages or resources when moving to HTTP/3!</strong>. This is because, as we’ve explained in <a href=\"https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/#why-do-we-need-http-3\">part 1</a> and <a href=\"https://www.smashingmagazine.com/2021/08/http3-performance-improvements-part2/#http-3-features\">part 2</a>, HTTP/3 is really more like HTTP/2-over-QUIC, and the high-level features of the two versions have stayed the same. As such, any changes or optimizations made for HTTP/2 will still work for HTTP/3 and vice versa.</p>\n<p>However, if you’re still on HTTP/1.1, or you have forgotten about your transition to HTTP/2, or you never actually tweaked things for HTTP/2, then you might wonder what those changes were and why they were needed. You would, however, be hard-pressed even today to find a good article that details the <em>nuanced</em> best practices. This is because, as I stated in the introduction to <a href=\"https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/\">part 1</a>, much of the early HTTP/2 content was overly optimistic about how well it would work in practice, and some of it, quite frankly, had major mistakes and bad advice. Sadly, much of this misinformation persists today. That’s one of my main motivations in writing this series on HTTP/3, to help prevent that from happening again.</p>\n<p>The best all-in-one nuanced source for HTTP/2 I can recommend at this time is the book <a href=\"https://www.manning.com/books/http2-in-action\"><em>HTTP/2 in Action</em></a> by <a href=\"https://www.tunetheweb.com/\">Barry Pollard</a>. However, since that’s a paid resource and I don’t want you to be left guessing here, I’ve listed a few of the main points below, along with how they relate to HTTP/3:</p>\n<h3>1. Single Connection</h3>\n<p>The biggest difference between HTTP/1.1 and HTTP/2 was the switch from 6 to 30 parallel TCP connections to a single underlying TCP connection. We discussed a bit in <a href=\"https://www.smashingmagazine.com/2021/08/http3-performance-improvements-part2/#congestion-control\">part 2</a> how a single connection can still be as fast as multiple connections, because of how congestion control can cause more or earlier packet loss with more connections (which undoes the benefits of their aggregated faster start). HTTP/3 continues this approach, but “just” switches from one TCP to one QUIC connection. This difference by itself doesn’t do all that much (it mainly reduces the overhead on the server-side), but it leads to most of the following points.</p>\n<h3>2. Server Sharding and Connection Coalescing</h3>\n<p>The switch to the single connection set-up was quite difficult in practice because many pages were sharded across different hostnames and even servers (like <code>img1.example.com</code> and <code>img2.example.com</code>). This was because browsers only opened up to six connections for each individual hostname, so having multiple allowed for more connections! Without changes to this HTTP/1.1 set-up, HTTP/2 would still open up multiple connections, reducing how well other features, such as prioritization (see below), could actually work.</p>\n<p>As such, the original recommendation was to undo server sharding and to consolidate resources on a single server as much as possible. HTTP/2 even provided a feature to make the transition from an HTTP/1.1 set-up easier, called <a href=\"https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/\">connection coalescing</a>. Roughly speaking, if two hostnames resolve to the same server IP (using DNS) and use a similar TLS certificate, then the <strong>browser can reuse a single connection even across the two hostnames</strong>.</p>\n<p>In practice, connection coalescing can be <a href=\"https://nooshu.github.io/blog/2019/12/17/http2-and-sri-dont-always-get-on/\">tricky to get right</a>, e.g. due to several <a href=\"https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/#requests-without-credentials-use-a-separate-connection\">subtle security issues involving CORS</a>. Even if you do set it up properly, you could still easily end up with two separate connections. The thing is, that’s <strong>not always bad</strong>. First, due to poorly implemented prioritization and multiplexing (see below), the single connection could <a href=\"https://twitter.com/zachleat/status/1055219667894259712\">easily be slower</a> than using two or more. Secondly, using too many connections could cause early packet loss due to competing congestion controllers. Using just a few (but still more than one), however, could nicely balance congestion growth with better performance, especially on high-speed networks. For these reasons, I believe that a little <strong>bit of sharding is still a good idea</strong> (say, two to four connections), even with HTTP/2. In fact, I think most modern HTTP/2 set-ups perform as well as they do because they still have a few extra connections or third-party loads in their critical path.</p>\n<h3>3. Resource Bundling and Inlining</h3>\n<p>In HTTP/1.1, you could have only a single <em>active</em> resource per connection, leading to <a href=\"https://calendar.perfplanet.com/2020/head-of-line-blocking-in-quic-and-http-3-the-details/\">HTTP-level head-of-line (HoL) blocking</a>. Because the number of connections was capped at a measly 6 to 30, resource bundling (where smaller subresources are combined into a single larger resource) was a long-time best practice. We still see this today in bundlers such as Webpack. Similarly, resources were often inlined in other resources (for example, critical CSS was inlined in the HTML).</p>\n<p>With HTTP/2, however, the single connection multiplexes resources, so you can have many more outstanding requests for files (put differently, a single request no longer takes up one of your precious few connections). This was originally interpreted as, “<strong>We no longer need to bundle or inline our resources for HTTP/2</strong>”. This approach was touted to be better for fine-grained caching because each subresource could be cached individually and the full bundle didn’t need to be redownloaded if one of them changed. <strong>This is true, but only to a relatively limited extent.</strong></p>\n<p>For example, you could <a href=\"https://blog.khanacademy.org/forgo-js-packaging-not-so-fast/\">reduce</a> <a href=\"https://jakearchibald.com/2021/f1-perf-part-7/#lots-of-little-resources-vs-one-big-resource\">compression efficiency</a>, because that works better with more data. Additionally, each extra request or file has an <a href=\"https://twitter.com/yoavweiss/status/1254650804524507136\">inherent overhead because it needs to be handled by the browser and server</a>. These costs can add up for, say, hundreds of small files compared to a few large ones. <a href=\"https://speeder.edm.uhasselt.be/webist/files/h2bestpractices_RobinMarx_WEBIST2017.pdf\">In our own early tests</a>, I found seriously diminishing returns at about 40 files. Though those numbers are <a href=\"https://twitter.com/youyuxi/status/1425933472871456777\">probably a bit higher now</a>, <strong>file requests are still not as cheap in HTTP/2 as originally predicted</strong>. Finally, not inlining resources has an added latency cost because the file needs to be requested. This, combined with prioritization and server push problems (see below), means that even today you’re still <a href=\"https://calendar.perfplanet.com/2020/implementing-critical-css-from-cms-to-cls/\">better off inlining some of your critical CSS</a>. Maybe someday the <a href=\"https://github.com/WICG/resource-bundles\">Resource Bundles proposal</a> will help with this, but not yet.  </p>\n<p><strong>All of this is, of course, still true for HTTP/3 as well.</strong> Still, I’ve read people claim that many small files would be better over QUIC because more concurrently active independent streams mean more profits from the HoL blocking removal (as we discussed in <a href=\"https://www.smashingmagazine.com/2021/08/http3-performance-improvements-part2/#head-of-line-blocking-removal\">part 2</a>). I think there might be some truth to this, but, as we also saw in part 2, this is a highly complex issue with a lot of moving parameters. I don’t think the benefits would outweigh the other costs discussed, but more research is needed. (An outrageous thought would be to have each file be exactly sized to fit in a single QUIC packet, bypassing HoL blocking completely. I will accept royalties from any startup that implements a resource bundler that does this. ;))</p>\n<h3>4. Prioritization</h3>\n<p>To be able to download multiple files on a single connection, you need to somehow multiplex them. As discussed in <a href=\"https://www.smashingmagazine.com/2021/08/http3-performance-improvements-part2/#head-of-line-blocking-removal\">part 2</a>, in HTTP/2, this multiplexing is steered using its prioritization system. This is why it’s important to have as many resources as possible requested on the same connection as well — to be able to properly prioritize them among each other! As we also saw, however, this <strong>system was very complex</strong>, causing it to often be <a href=\"https://github.com/andydavies/http2-prioritization-issues\">badly used and implemented</a> in practice (see the image below). This, in turn, has meant that some other recommendations for HTTP/2 — such as reduced bundling, because requests are cheap, and reduced server sharding, to make optimal use of the single connection (see above) — have turned out to underperform in practice.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/e8aef424-b7d6-44ce-ba69-d349439fcaa5/http2-prioritization.png\" /></p>\n<p>Sadly, this is something that you, as an average web developer, can’t do much about, because it’s mainly a problem in the browsers and servers themselves. You can, however, try to mitigate the issue by not using too many individual files (which will lower the chances for competing priorities) and by still using (limited) sharding. Another option is to use various priority-influencing techniques, such as <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-loading\">lazy loading</a>, JavaScript <a href=\"https://addyosmani.com/blog/script-priorities/\"><code>async</code> and <code>defer</code></a>, and resource hints such as <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types/preload\"><code>preload</code></a>. Internally, these mainly change the priorities of the resources so that they get sent earlier or later. However, these mechanisms can (and do) <a href=\"https://bugs.chromium.org/p/chromium/issues/detail?id=788757\">suffer from bugs</a>. Additionally, don’t expect to slap a <code>preload</code> on a bunch of resources and make things faster: If everything is suddenly a high priority, then nothing is! It’s even <a href=\"https://twitter.com/programmingart/status/1351557858354225159\">very easy</a> to <a href=\"https://twitter.com/csswizardry/status/1349681832393109510\">delay</a> actually critical resources <a href=\"https://www.debugbear.com/blog/rel-preload-problems\">by using things like <code>preload</code></a>.</p>\n<p>As also explained in <a href=\"https://www.smashingmagazine.com/2021/08/http3-performance-improvements-part2/#head-of-line-blocking-removal\">part 2</a>, HTTP/3 fundamentally changes the internals of this prioritization system. We <em>hope</em> this means that there will be many fewer bugs and problems with its practical deployment, so at least some of this should be solved. We can’t be sure yet, however, because <a href=\"https://qlog.edm.uhasselt.be/epiq/files/QUICImplementationDiversity_Marx_final_11jun2020.pdf\">few HTTP/3 servers and clients</a> fully implement this system today. Nevertheless, the <strong>fundamental concepts of prioritization won’t change</strong>. You still won’t be able to use techniques such as <code>preload</code> without really understanding what happens internally, because it might still mis-prioritize your resources.</p>\n<h3>5. Server Push and First Flight</h3>\n<p>Server push allows a server to send response data without first waiting for a request from the client. Again, this sounds great in theory, and it could be used instead of inlining resources (see above). However, as discussed in <a href=\"https://www.smashingmagazine.com/2021/08/http3-performance-improvements-part2/#http-3-features\">part 2</a>, push is very difficult to use correctly due to <a href=\"https://calendar.perfplanet.com/2016/http2-push-the-details/\">issues with congestion control, caching, prioritization, and buffering</a>. Overall, it’s best <strong>not to use it for general web page loading</strong> unless you <em>really</em> know what you’re doing, and even then it would <a href=\"https://twitter.com/patmeenan/status/1359337536125075460\">probably be a micro-optimization</a>. I still believe it could have a place with (REST) APIs, though, where you can <a href=\"https://github.com/dunglas/vulcain\">push subresources linked to in the (JSON) response</a> on a warmed-up connection. This is true for both HTTP/2 and HTTP/3.</p>\n<p>To generalize a bit, I feel that similar remarks could be made for TLS session resumption and 0-RTT, be it over TCP + TLS or via QUIC. As discussed in <a href=\"https://www.smashingmagazine.com/2021/08/http3-performance-improvements-part2/#0-rtt-connection-set-up\">part 2</a>, 0-RTT is similar to server push (as it’s typically used) in that it tries to accelerate the very first stages of a page load. However, that means it is <strong>equally limited in what it can achieve at that time</strong> (even more so in QUIC, due to security concerns). As such, a micro-optimization is, again, how you probably need to fine-tune things on a low level to really benefit from it. And to think I was once very excited to try out combining server push with 0-RTT.</p>\n<h3>What Does It All Mean?</h3>\n<p>All the above comes down to a simple rule of thumb: <strong>Apply most of the typical HTTP/2 recommendations that you find online, but don’t take them to the extreme</strong>.</p>\n<p>Here are some concrete points that mostly hold for both HTTP/2 and HTTP/3:</p>\n<ol>\n<li>Shard resources over about one to three connections on the critical path (unless your users are mostly on low-bandwidth networks), using <a href=\"https://www.smashingmagazine.com/2019/04/optimization-performance-resource-hints/\"><code>preconnect</code> and <code>dns-prefetch</code></a> where needed.</li>\n<li>Bundle subresources logically per path or feature, or per change frequency. Five to ten JavaScript and five to ten CSS resources per page should be just fine. Inlining critical CSS can still be a good optimization.</li>\n<li>Use complex features, such as <code>preload</code>, sparingly.</li>\n<li>Use a server that <a href=\"https://github.com/andydavies/http2-prioritization-issues\">properly supports</a> HTTP/2 prioritization. For HTTP/2, I recommend <a href=\"https://github.com/h2o/h2o\">H2O</a>. Apache and NGINX are mostly OK (although <a href=\"https://twitter.com/programmingart/status/1245397190194999297\">could do</a> <a href=\"https://blog.cloudflare.com/nginx-structural-enhancements-for-http-2-performance/\">better</a>), while Node.js is to be <a href=\"https://twitter.com/jasnell/status/1245410283582918657\">avoided</a> for HTTP/2. For HTTP/3, things are less clear at this time (see below).</li>\n<li>Make sure that TLS 1.3 is enabled on your HTTP/2 web server.</li>\n</ol>\n<p>As you can see, while far from simple, optimizing pages for HTTP/3 (and HTTP/2) is not rocket science. What will be more difficult, however, is correctly setting up HTTP/3 servers, clients, and tools.</p>\nServers and Networks\n<p>As you probably understand by now, QUIC and HTTP/3 are quite complex protocols. Implementing them from scratch would involve reading (and understanding!) <a href=\"https://quicwg.org/\">hundreds of pages spread over more than seven documents</a>. Luckily, multiple companies have been working on open-source <a href=\"https://github.com/quicwg/base-drafts/wiki/Implementations\">QUIC and HTTP/3 implementations</a> for over five years now, so we have several mature and stable options to choose from.</p>\n<p>Some of the most important and stable ones include the following:</p>\n<table>\n  <thead>\n    <tr>\n      <th>Language</th>\n      <th>Implementation</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Python</td>\n      <td><a href=\"https://github.com/aiortc/aioquic\">aioquic</a></td>\n    </tr>\n    <tr>\n      <td>Go</td>\n      <td><a href=\"https://github.com/lucas-clemente/quic-go\">quic-go</a></td>\n    </tr>\n    <tr>\n      <td>Rust</td>\n      <td><a href=\"https://github.com/cloudflare/quiche\">quiche</a> (Cloudflare), <a href=\"https://github.com/quinn-rs/quinn\">Quinn</a>, <a href=\"https://github.com/mozilla/neqo\">Neqo</a> (Mozilla)</td>\n    </tr>\n    <tr>\n      <td>C and C++</td>\n      <td><a href=\"https://github.com/facebookincubator/mvfst\">mvfst</a> (Facebook), <a href=\"https://github.com/microsoft/msquic\">MsQuic</a>, (Microsoft), &lt;a href<a href=\"https://quiche.googlesource.com/quiche/QUICHE\">https://quiche.googlesource.com/quiche/QUICHE</a> (Google), <a href=\"https://github.com/ngtcp2/ngtcp2\">ngtcp2</a>, <a href=\"https://github.com/litespeedtech/lsquic\">LSQUIC</a> (Litespeed), <a href=\"https://github.com/private-octopus/picoquic\">picoquic</a>, <a href=\"https://github.com/h2o/quicly\">quicly</a> (Fastly)</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>However, many (perhaps most) of these implementations mainly take care of the HTTP/3 and QUIC stuff; they are <strong>not really full-fledged web servers by themselves</strong>. When it comes to your typical servers (think NGINX, Apache, Node.js), things have been a bit slower, for several reasons. First, few of their developers were involved with HTTP/3 from the start, and now they have to play catch-up. Many bypass this by using one of the implementations listed above internally as libraries, but even that integration is difficult.</p>\n<p>Secondly, many servers depend on third-party TLS libraries such as OpenSSL. This is, again, because TLS is very complex and has to be secure, so it’s best to reuse existing, verified work. However, <strong>while QUIC integrates with TLS 1.3, it uses it in ways much different from how TLS and TCP interact</strong>. This means that <a href=\"https://daniel.haxx.se/blog/2019/01/21/quic-and-missing-apis/\">TLS libraries have to provide QUIC-specific APIs</a>, which their developers have long been reluctant or slow to do. The issue here especially is OpenSSL, which has <a href=\"https://www.openssl.org/blog/blog/2020/02/17/QUIC-and-OpenSSL/\">postponed QUIC support</a>, but it is also used by many servers. This problem got so bad that Akamai decided to start a QUIC-specific fork of OpenSSL, called <a href=\"https://github.com/quictls/openssl\">quictls</a>. While <a href=\"https://daniel.haxx.se/blog/2021/04/02/where-is-http-3-right-now/\">other options and workarounds exist</a>, TLS 1.3 support for QUIC is still a blocker for many servers, and it is expected to remain so for some time.  </p>\n<p>A partial list of full web servers that you should be able to use out of the box, along with their current HTTP/3 support, follows:</p>\n<ul>\n<li><strong>Apache</strong><br />Support is unclear at this time. Nothing has been announced. It likely also needs OpenSSL. (Note that there is an <a href=\"https://cwiki.apache.org/confluence/display/TS/QUIC\">Apache Traffic Server</a> implementation, though.)</li>\n<li><a href=\"https://quic.nginx.org/\"><strong>NGINX</strong></a><br />This is a custom implementation. This is relatively new and still highly experimental. It is expected to <a href=\"https://www.nginx.com/blog/our-roadmap-quic-http-3-support-nginx/\">be merged to mainline NGINX by the end of 2021</a>. This is relatively new and still highly experimental. Note that there is a <a href=\"https://blog.cloudflare.com/experiment-with-http-3-using-nginx-and-quiche/\">patch to run Cloudflare’s quiche library on NGINX</a> as well, which is probably more stable for now.</li>\n<li><strong>Node.js</strong><br />This uses the ngtcp2 library internally. It is <a href=\"https://github.com/nodejs/node/pull/37067\">blocked by OpenSSL progress</a>, although they plan to switch to the QUIC-TLS fork to <a href=\"https://github.com/nodejs/node/issues/38478\">get something working sooner</a>.</li>\n<li><strong>IIS</strong><br />Support is unclear at this time, and nothing has been announced. It will likely use the MsQuic library internally, though.</li>\n<li><a href=\"https://pgjones.dev/blog/http-1-2-3-2019/\"><strong>Hypercorn</strong></a><br />This integrates aioquic, with experimental support.</li>\n<li><a href=\"https://ma.ttias.be/how-run-http-3-with-caddy-2/\"><strong>Caddy</strong></a><br />This uses quic-go, with full support.</li>\n<li><a href=\"https://github.com/h2o/h2o\"><strong>H2O</strong></a><br />This uses quicly, with full support.</li>\n<li><a href=\"https://github.com/litespeedtech/lsquic\"><strong>Litespeed</strong></a><br />This uses LSQUIC, with full support.</li>\n</ul>\n<p>Note some important nuances:</p>\n<ul>\n<li>Even “full support” means “as good as it gets at the moment”, not necessarily “production-ready”. For instance, <strong>many implementations don’t yet fully support connection migration, 0-RTT, server push, or HTTP/3 prioritization</strong>.</li>\n<li>Other servers not listed, such as Tomcat, have (to my knowledge) made no announcement yet.</li>\n<li>Of the web servers listed, only Litespeed, Cloudflare’s NGINX patch, and H2O were made by people intimately involved in QUIC and HTTP/3 standardization, so these are most likely to work best early on.  </li>\n</ul>\n<p>As you can see, the server landscape isn’t fully there yet, but there are certainly already options for setting up an HTTP/3 server. However, simply running the server is only the first step. Configuring it and the rest of your network is more difficult.</p>\n<h3>Network Configuration</h3>\n<p>As explained in <a href=\"https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/#what-is-quic\">part 1</a>, QUIC runs on top of the UDP protocol to make it easier to deploy. This, however, mainly just means that most network devices can parse and understand UDP. Sadly, it <strong>does not mean that UDP is universally allowed</strong>. Because UDP is often used for attacks and is not critical to normal day-to-day work besides DNS, many (corporate) networks and firewalls block the protocol almost entirely. As such, <strong>UDP probably needs to be explicitly allowed to/from your HTTP/3 servers</strong>. QUIC can run on any UDP port but expect port 443 (which is typically used for HTTPS over TCP as well) to be most common.</p>\n<p>However, many network administrators will not want to just allow UDP wholesale. Instead, they will specifically want to allow QUIC over UDP. The problem there is that, as we’ve seen, QUIC is almost entirely encrypted. This includes QUIC-level metadata such as packet numbers, but also, for example, signals that indicate the closure of a connection. For TCP, firewalls actively track all of this metadata to check for expected behavior. (Did we see a full handshake before data-carrying packets? Do the packets follow expected patterns? How many open connections are there?) As we saw in <a href=\"https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/#why-do-we-need-http-3\">part 1</a>, this is exactly one of the reasons why TCP is no longer practically evolvable. However, <strong>due to QUIC’s encryption, firewalls can do much less of this connection-level tracking logic</strong>, and the few bits they <em>can</em> inspect are relatively complex.</p>\n<p>As such, many firewall vendors currently recommend blocking QUIC until they can update their software. Even after that, though, many companies might not want to allow it, because firewall QUIC support will always be much less than the TCP features they’re used to.</p>\n<p>This is all complicated even more by the connection migration feature. <a href=\"https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/#quic-supports-connection-migration\">As we’ve seen</a>, this feature allows for the connection to continue from a new IP address without having to perform a new handshake, by the use of connection IDs (CIDs). However, to the firewall, this will look as if a new connection is being used without first using a handshake, which might just as well be an attacker sending malicious traffic. Firewalls can’t just use the QUIC CIDs, because they also change over time to protect users’ privacy! As such, there will be some need for the <strong>servers to communicate with the firewall about which CIDs are expected</strong>, but none of these things exist yet.  </p>\n<p>There are similar concerns for load balancers for larger-scale set-ups. These machines distribute incoming connections over a large number of back-end servers. Traffic for one connection must, of course, always be routed to the same back-end server (the others wouldn’t know what to do with it!). For TCP, this could simply be done based on the <a href=\"https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/#quic-supports-connection-migration\">4-tuple</a>, because that never changes. With QUIC connection migration, however, <a href=\"https://youtu.be/pq_xk_Pecu4?t=1226\">that’s no longer an option</a>. Again, <strong>servers and load balancers will need to somehow agree on which CIDs to choose in order to allow deterministic routing</strong>. Unlike for firewall configuration, however, there is already <a href=\"https://tools.ietf.org/html/draft-ietf-quic-load-balancers\">a proposal</a> to set this up (although this is far from widely implemented).  </p>\n<p>Finally, there are other, higher-level security considerations, mainly around 0-RTT and distributed denial-of-service (DDoS) attacks. As discussed in <a href=\"https://www.smashingmagazine.com/2021/08/http3-performance-improvements-part2/#0-rtt-connection-set-up\">part 2</a>, QUIC includes quite a few mitigations for these issues already, but ideally, they will also use extra lines of defense on the network. For example, proxy or edge servers might block certain 0-RTT requests from reaching the actual back ends to prevent <a href=\"https://blog.cloudflare.com/introducing-0-rtt/#whatsthecatch\">replay attacks</a>. Alternatively, to prevent reflection attacks or DDoS attacks that only send the first handshake packet and then stop replying (called a <a href=\"https://en.wikipedia.org/wiki/SYN_flood\">SYN flood</a> in TCP), QUIC includes the <a href=\"https://www.rfc-editor.org/rfc/rfc9000.html#name-address-validation-using-re\">retry feature</a>. This allows the server to validate that it’s a well-behaved client, without having to keep any state in the meantime (the equivalent of <a href=\"https://en.wikipedia.org/wiki/SYN_cookies\">TCP SYN cookies</a>). This retry process best happens, of course, somewhere before the back-end server — for example, at the load balancer. Again, this requires <a href=\"https://tools.ietf.org/html/draft-ietf-quic-load-balancers-06#section-7\">additional configuration and communication</a> to set up, though.</p>\n<p>These are only the most prominent issues that network and system administrators will have with QUIC and HTTP/3. There are several more, some of which <a href=\"https://youtu.be/pq_xk_Pecu4?t=981\">I’ve talked about</a>. There are also <a href=\"https://datatracker.ietf.org/doc/html/draft-ietf-quic-applicability\">two separate</a> accompanying <a href=\"https://datatracker.ietf.org/doc/html/draft-ietf-quic-manageability\">documents</a> for the QUIC RFCs that discuss these issues and their possible (partial) mitigations.  </p>\n<h3>What Does It All Mean?</h3>\n<p>HTTP/3 and QUIC are complex protocols that rely on a lot of internal machinery. <strong>Not all of that is ready for prime time just yet</strong>, although you already have <em>some</em> options to deploy the new protocols on your back ends. It will probably take a few months to even years for the most prominent servers and underlying libraries (such as OpenSSL) to get updated, however.</p>\n<p>Even then, properly configuring the servers and other network intermediaries, so that the protocols can be used in a secure and optimal fashion, will be non-trivial in larger-scale set-ups. You will need a good development and operations team to correctly make this transition.</p>\n<p>As such, especially in the early days, it is probably best to <strong>rely on a large hosting company or CDN</strong> to set up and configure the protocols for you. As discussed in <a href=\"https://www.smashingmagazine.com/2021/08/http3-performance-improvements-part2/#packet-loss-resilience\">part 2</a>, that’s where QUIC is most likely to pay off anyway, and using a CDN is one of the key performance optimizations you can do. I would personally recommend using Cloudflare or Fastly because they have been intimately involved in the standardization process and will have the most advanced and well-tuned implementations available.</p>\nClients and QUIC Discovery\n<p>So far, we have considered server-side and in-network support for the new protocols. However, several issues are also to be overcome on the client’s side.</p>\n<p>Before getting to that, let’s start with some good news: <strong>Most of the popular browsers already have (experimental) HTTP/3 support!</strong> Specifically, at the time of writing, here is the status of support (see also <a href=\"https://caniuse.com/http3\">caniuse.com</a>):</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/9d4aedbb-8464-4062-93d4-986989202121/caniuse-h3.png\" /></p>\n<ul>\n<li><strong>Google Chrome (version 91+)</strong>: Enabled by default.</li>\n<li><strong>Mozilla Firefox (version 89+)</strong>: Enabled by default.</li>\n<li><strong>Microsoft Edge (version 90+)</strong>: Enabled by default (uses Chromium internally).</li>\n<li><strong>Opera (version 77+)</strong>: Enabled by default (uses Chromium internally).</li>\n<li><strong>Apple Safari (version 14)</strong>: Behind a manual flag. Will be enabled by default in version 15, which is currently in technology preview.</li>\n<li><strong>Other Browsers</strong>: No signals yet that I’m aware of (although other browsers that use Chromium internally, such as Brave, could, in theory, also start enabling it).</li>\n</ul>\n<p>Note some nuances:</p>\n<ul>\n<li>Most browsers are rolling out gradually, whereby not all users will get HTTP/3 support enabled by default from the start. This is done to limit the risks that a single overlooked bug could affect many users or that server deployments become overloaded. As such, there is a small chance that, even in recent browser versions, you won’t get HTTP/3 by default and will have to <a href=\"https://caniuse.com/http3\">manually enable it</a>.</li>\n<li>As with the servers, HTTP/3 support does not mean that all features have been implemented or are being used at this time. Particularly, 0-RTT, connection migration, server push, dynamic QPACK header compression, and HTTP/3 prioritization might still be missing, disabled, used sparingly, or poorly configured.</li>\n<li>If you want to use client-side HTTP/3 outside of the browser (for example, in your native app), then you would have to integrate one of the libraries <a href=\"https://www.smashingmagazine.com/2021/09/http3-practical-deployment-options-part3/#servers-and-networks\">listed above</a> or use <a href=\"https://github.com/curl/curl/blob/master/docs/HTTP3.md\">cURL</a>. Apple will soon <a href=\"https://developer.apple.com/videos/play/wwdc2021/10094/\">bring native HTTP/3 and QUIC support to its built-in networking libraries on macOS and iOS</a>, and Microsoft is adding QUIC to the Windows kernel and their <a href=\"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/kestrel/http3?view=aspnetcore-6.0\">.NET environment</a>, but similar native support has (to my knowledge) not been announced for other systems like Android.</li>\n</ul>\n<h3>Alt-Svc</h3>\n<p>Even if you’ve set up an HTTP/3-compatible server and are using an updated browser, you might be surprised to find that <strong>HTTP/3 isn’t actually being used consistently</strong>. To understand why, let’s suppose you’re the browser for a moment. Your user has requested that you navigate to <code>example.com</code> (a website you’ve never visited before), and you’ve used DNS to resolve that to an IP. You send one or more QUIC handshake packets to that IP. Now several things can go wrong:</p>\n<ol>\n<li>The server might not support QUIC.</li>\n<li>One of the intermediate networks or firewalls might block QUIC and/or UDP completely.</li>\n<li>The handshake packets might be lost in transit.</li>\n</ol>\n<p>However, <strong>how would you know (which) one of these problems has occurred</strong>? In all three cases, you’ll never receive a reply to your handshake packet(s). The only thing you can do is wait, hoping that a reply might still come in. Then, after some waiting time (the timeout), you might decide there’s indeed a problem with HTTP/3. At that point, you would try to open a TCP connection to the server, hoping that HTTP/2 or HTTP/1.1 will work.</p>\n<p>As you can see, this type of approach could introduce major delays, especially in the initial year(s) when many servers and networks won’t support QUIC yet. An easy but naïve solution would simply be to <strong>open both a QUIC and TCP connection at the same time and then use whichever handshake completes first</strong>. This method is called “connection racing” or “<a href=\"https://en.wikipedia.org/wiki/Happy_Eyeballs\">happy eyeballs</a>”. While this is certainly possible, it does have considerable overhead. Even though the losing connection is almost immediately closed, it still takes up some memory and CPU time on both the client and server (especially when using TLS). On top of that, there are also other problems with this method involving IPv4 versus IPv6 networks and the previously discussed <a href=\"https://www.smashingmagazine.com/2021/08/http3-performance-improvements-part2/#0-rtt-connection-set-up\">replay attacks</a> (which <a href=\"https://youtu.be/pq_xk_Pecu4?t=1545\">my talk</a> covers in more detail).</p>\n<p>As such, for QUIC and HTTP/3, browsers would rather prefer to play it safe and <strong>only try QUIC if they know the server supports it</strong>. As such, the first time a new server is contacted, the browser will only use HTTP/2 or HTTP/1.1 over a TCP connection. The server can then let the browser know it also supports HTTP/3 for subsequent connections. This is done by setting a special HTTP header on the responses sent back over HTTP/2 or HTTP/1.1. This header is called <code>Alt-Svc</code>, which stands for “<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Alt-Svc\">alternative services</a>”. <code>Alt-Svc</code> can be used to let a browser know that a certain service is also reachable via another server (IP and/or port), but it also allows for the indication of alternative protocols. This can be seen below in figure 1.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/90f995f5-6b02-4884-a602-f5a526fb40e2/facebook-alt-svc.png\" /></p>\n<p>Upon receipt of a valid <code>Alt-Svc</code> header indicating HTTP/3 support, the browser will <em>cache</em> this and try to set up a QUIC connection from then on. Some clients will do this as soon as possible (even during the initial page load — see below), while others will wait until the existing TCP connection(s) are closed. This means that the browser <strong>will only ever use HTTP/3 after it has downloaded at least a few resources via HTTP/2 or HTTP/1.1 first</strong>. Even then, it’s not smooth sailing. The browser now knows that the server supports HTTP/3, but that doesn’t mean the intermediate network won’t block it. As such, connection racing is still needed in practice. So, you might still end up with HTTP/2 if the network somehow delays the QUIC handshake enough. Additionally, if the QUIC connection fails to establish a few times in a row, some browsers will put the <code>Alt-Svc</code> cache entry on a denylist for some time, not trying HTTP/3 for a while. As such, it can be helpful to manually clear your browser’s cache if things are acting up because that should also empty the <code>Alt-Svc</code> bindings. Finally, <code>Alt-Svc</code> has been shown to pose <a href=\"https://www.usenix.org/system/files/woot19-paper_tiwari.pdf\">some serious security risks</a>. For this reason, some browsers pose extra restrictions on, for instance, which ports can be used (in Chrome, your HTTP/2 and HTTP/3 servers need to be either both on a port below 1024 or both on a port above or equal to 1024, otherwise <code>Alt-Svc</code> will be ignored). All of this logic varies and evolves wildly between browsers, meaning that <strong>getting consistent HTTP/3 connections can be difficult</strong>, which also makes it challenging to test new set-ups.</p>\n<blockquote>There is ongoing work to improve this two-step <code>Alt-Svc</code> process somewhat. The idea is to use new DNS records called <a href=\"https://datatracker.ietf.org/doc/html/draft-ietf-dnsop-svcb-https\">SVCB and HTTPS</a>, which will contain information similar to what is in <code>Alt-Svc</code>. As such, the client can discover that a server supports HTTP/3 <a href=\"https://docs.google.com/document/d/1k461sRbddjDGj7Q8f-ZKHZvmB-ENUWSdX_3Fpp2dmXQ\">during the DNS resolution step instead</a>, meaning that it can try QUIC from the very first page load instead of first having to go through HTTP/2 or HTTP/1.1. For more information on this and <code>Alt-Svc</code>, see last year’s <a href=\"https://almanac.httparchive.org/en/2020/http2#deploying-and-discovering-http3\">Web Almanac chapter on HTTP/2</a>.</blockquote>\n\n<p>As you can see, <code>Alt-Svc</code> and the HTTP/3 discovery process add a layer of complexity to your already challenging QUIC server deployment, because:</p>\n<ul>\n<li>you will always need to deploy your HTTP/3 server next to an HTTP/2 and/or HTTP/1.1 server;</li>\n<li>you will need to configure your HTTP/2 and HTTP/1.1 servers to set the correct <code>Alt-Svc</code> headers on their responses.</li>\n</ul>\n<p>While that should be manageable in production-level set-ups (because, for example, a single Apache or NGINX instance will likely support all three HTTP versions at the same time), it might be <strong>much more annoying in (local) test set-ups</strong> (I can already see myself forgetting to add the <code>Alt-Svc</code> headers or messing them up). This problem is compounded by a (current) lack of browser error logs and DevTools indicators, which means that figuring out why exactly the set-up isn’t working can be difficult.</p>\n<h3>Additional Issues</h3>\n<p>As if that wasn’t enough, another issue will make local testing more difficult: <strong>Chrome makes it very difficult for you to use self-signed TLS certificates for QUIC</strong>. This is because <a href=\"https://tlseminar.github.io/tls-interception/#how-ssl-tls-interception-works\">non-official TLS certificates are often used by companies to decrypt their employees’ TLS traffic</a> (so that they can, for example, have their firewalls scan inside encrypted traffic). However, if companies would start doing that with QUIC, we would again have custom middlebox implementations that make their own assumptions about the protocol. This could lead to them potentially breaking protocol support in the future, which is exactly what we tried to prevent by encrypting QUIC so extensively in the first place! As such, Chrome takes a very opinionated stance on this: <strong>If you’re not using an official TLS certificate (signed by a certificate authority or root certificate that is trusted by Chrome, such as <a href=\"https://letsencrypt.org/\">Let’s Encrypt</a>), then you cannot use QUIC</strong>. This, sadly, also includes self-signed certificates, which are often used for local test set-ups.</p>\n<p>It is still possible to <a href=\"https://centrifugal.github.io/centrifugo/blog/quic_web_transport/#generate-self-signed-tls-certificates\">bypass this</a> with <a href=\"https://github.com/GoogleChrome/samples/issues/697\">some freaky</a> command-line <a href=\"https://github.com/marten-seemann/chrome-quic-interop-runner/blob/master/run.py#L45\">flags</a> (because the common <code>--ignore-certificate-errors</code> doesn’t work for QUIC yet), by using per-developer certificates (although setting this up can be tedious), or by setting up the real certificate on your development PC (but this is rarely an option for big teams because you would have to share the certificate’s private key with each developer). Finally, while you can install a <a href=\"https://www.freecodecamp.org/news/how-to-get-https-working-on-your-local-development-environment-in-5-minutes-7af615770eec/\">custom root certificate</a>, you would then also need to pass both the <code>--origin-to-force-quic-on</code> and <code>--ignore-certificate-errors-spki-list</code> <a href=\"https://www.chromium.org/quic/playing-with-quic\">flags when starting Chrome</a> (see <a href=\"https://www.smashingmagazine.com/2021/09/http3-practical-deployment-options-part3/#tools-and-testing\">below</a>). Luckily, for now, only Chrome is being so strict, and hopefully, its developers will loosen their approach over time.</p>\n<p>If you are having problems with your QUIC set-up from inside a browser, it’s best to first validate it using a tool such as <a href=\"https://github.com/curl/curl/blob/master/docs/HTTP3.md\">cURL</a>. cURL has excellent HTTP/3 support (you can even choose between two different underlying libraries) and also makes it easier to observe <code>Alt-Svc</code> caching logic.</p>\n<h3>What Does It All Mean?</h3>\n<p>Next to the challenges involved with setting up HTTP/3 and QUIC on the server-side, there are also difficulties in getting browsers to use the new protocols consistently. This is due to a <strong>two-step discovery process involving the <code>Alt-Svc</code> HTTP header</strong> and the fact that HTTP/2 connections cannot simply be “upgraded” to HTTP/3, because the latter uses UDP.</p>\n<p>Even if a server supports HTTP/3, however, clients (and website owners!) need to deal with the fact that intermediate networks might block UDP and/or QUIC traffic. As such, <strong>HTTP/3 will never completely replace HTTP/2</strong>. In practice, keeping a well-tuned HTTP/2 set-up will remain necessary both for first-time visitors and visitors on non-permissive networks. Luckily, <a href=\"https://www.smashingmagazine.com/2021/09/http3-practical-deployment-options-part3/#servers-and-networks\">as we discussed</a>, there shouldn’t be many page-level changes between HTTP/2 and HTTP/3, so this shouldn’t be a major headache.</p>\n<p>What could become a problem, however, is testing and verifying whether you are using the correct configuration and whether the protocols are being used as expected. This is true in production, but especially in local set-ups. As such, I expect that <strong>most people will continue to run HTTP/2 (or even HTTP/1.1) development servers</strong>, switching only to HTTP/3 in a later deployment stage. Even then, however, validating protocol performance with the current generation of tools won’t be easy.</p>\nTools and Testing\n<p>As was the case with many major servers, the makers of the most popular web performance testing tools have not been keeping up with HTTP/3 from the start. Consequently, <strong>few tools have dedicated support for the new protocol</strong> as of July 2021, although they support it to a certain degree.</p>\n<h3>Google Lighthouse</h3>\n<p>First, there is the <a href=\"https://developers.google.com/web/tools/lighthouse\">Google Lighthouse</a> tool suite. While this is an amazing tool for web performance in general, I have always found it somewhat lacking in aspects of protocol performance. This is mostly because <a href=\"https://github.com/GoogleChrome/lighthouse/blob/master/docs/throttling.md\">it simulates slow networks in a relatively unrealistic way</a>, in the browser (the same way that Chrome’s DevTools handle this). While this approach is quite usable and typically “<a href=\"https://www.debugbear.com/blog/network-throttling-methods\">good enough</a>” to get an idea of the impact of a slow network, <a href=\"https://twitter.com/patmeenan/status/1410676572596678657\">testing low-level protocol differences is not realistic enough</a>. Because the browser doesn’t have direct access to the TCP stack, it still downloads the page on your normal network, and it then artificially delays the data from reaching the necessary browser logic. This means, for example, that <strong>Lighthouse emulates only delay and bandwidth, but not packet loss</strong> (which, <a href=\"https://www.smashingmagazine.com/2021/08/http3-performance-improvements-part2/#congestion-control\">as we’ve seen</a>, is a major point where HTTP/3 could potentially differ from HTTP/2). Alternatively, Lighthouse <a href=\"https://github.com/GoogleChrome/lighthouse/blob/master/docs/lantern.md\">uses a highly advanced simulation model</a> to guesstimate the real network impact, because, for example, Google Chrome has some complex logic that tweaks several aspects of a page load if it detects a slow network. This model has, to <a href=\"https://github.com/GoogleChrome/lighthouse/issues/12291\">the best</a> of <a href=\"https://twitter.com/patrickhulce/status/1412401838498910213\">my knowledge</a>, not been adjusted to handle IETF QUIC or HTTP/3 yet. As such, if you use Lighthouse today for the sole purpose of comparing HTTP/2 and HTTP/3 performance, then you are likely to get erroneous or oversimplified results, which could lead you to wrong conclusions about what HTTP/3 can do for your website in practice. The silver lining is that, in theory, this can be improved massively in the future, because the browser <em>does</em> have full access to the QUIC stack, and thus Lighthouse could add much more advanced simulations (including packet loss!) for HTTP/3 down the line. <strong>For now, though, while Lighthouse can, in theory, load pages over HTTP/3, I would recommend against it.</strong></p>\n<h3>WebPageTest</h3>\n<p>Secondly, there is <a href=\"https://www.webpagetest.org/\">WebPageTest</a>. This amazing project lets you load pages over real networks from real devices across the world, and it also allows you to add packet-level network emulation on top, including aspects such as packet loss! As such, WebPageTest is conceptually in a prime position to be used to compare HTTP/2 and HTTP/3 performance. However, while it can indeed already load pages over the new protocol, <strong>HTTP/3 has not yet been properly integrated into the tooling or visualizations</strong>. For example, there are currently no easy ways to force a page load over QUIC, to easily view how <code>Alt-Svc</code> was actually used, or even to see QUIC handshake details. In some cases, even seeing whether a response used HTTP/3 or HTTP/2 can be challenging. Still, in April, I was able to use WebPageTest to run quite a few tests on <code>facebook.com</code> and see HTTP/3 in action, which I’ll go over now.</p>\n<p>First, I ran a default test for <code>facebook.com</code>, enabling the “repeat view” option. As <a href=\"https://www.smashingmagazine.com/2021/09/http3-practical-deployment-options-part3/#alt-svc\">explained above</a>, I would expect the first page load to use HTTP/2, which will include the <code>Alt-Svc</code> response header. As such, the repeat view should use HTTP/3 from the start. In <a href=\"https://www.webpagetest.org/result/210420_AiDcQS_8c1a37579b3b6d291868d0242abb26a1/\">Firefox version 89</a>, this is more or less what happens. However, when looking at individual responses, we see that <strong>even during the first page load, Firefox will switch to using HTTP/3 instead of HTTP/2</strong>! As you can see in figure 2, this happens from the 20th resource onwards. This means that Firefox establishes a new QUIC connection as soon as it sees the <code>Alt-Svc</code> header, and it switches to it once it succeeds. If you scroll down to the connection view, it also seems to show that Firefox even opened two QUIC connections: one for credentialed CORS requests and one for no-CORS requests. This would be expected because, as we <a href=\"https://www.smashingmagazine.com/2021/09/http3-practical-deployment-options-part3/#what-does-it-all-mean-2\">discussed above</a>, even for HTTP/2 and HTTP/3, browsers will open multiple connections due to security concerns. However, because WebPageTest doesn’t provide more details in this view, it’s difficult to confirm without manually digging through the data. Looking at the repeat view (second visit), it starts by directly using HTTP/3 for the first request, as expected.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7c3ef819-126d-4140-98ab-2bdf5344854f/firefox-facebook.png\" /></p>\n<p>Next, for <a href=\"https://www.webpagetest.org/result/210420_AiDcP0_6aeaac212f59298cf834ad30b4ec72e6/\">Chrome</a>, we see similar behavior for the first page load, although here Chrome already switches on the 10th resource, much earlier than Firefox. It’s a bit more unclear here whether it switches as soon as possible or only when a new connection is needed (for example, for requests with different credentials), because, unlike for Firefox, the connection view also doesn’t seem to show multiple QUIC connections. For the repeat view, we see some weirder things. <strong>Unexpectedly, Chrome starts off using HTTP/2 there as well</strong>, switching to HTTP/3 only after a few requests! I performed a <a href=\"https://www.webpagetest.org/result/210420_BiDcXS_d2bca9bd9ddce71dfc7bc0618fe7ed11/\">few</a> <a href=\"https://www.webpagetest.org/result/210420_AiDc7G_540eaf6f42de75ba9cdf2785528e36e9\">more</a> <a href=\"https://www.webpagetest.org/result/210420_AiDcBR_84d6accab1a208c4eb801df6ef689e5e\">tests</a> on other pages as well, to confirm that this is indeed consistent behaviour. This could be due to several things: It might just be Chrome’s current policy, it might be that Chrome “<a href=\"https://www.smashingmagazine.com/2021/09/http3-practical-deployment-options-part3/#alt-svc\">raced</a>” a TCP and QUIC connection and TCP won initially, or it might be that the <code>Alt-Svc</code> cache from the first view was unused for some reason. At this point, there is, sadly, no easy way to determine what the problem really is (and whether it can even be fixed).</p>\n<blockquote>Another interesting thing I noticed here is the apparent connection coalescing behavior. As <a href=\"https://www.smashingmagazine.com/2021/09/http3-practical-deployment-options-part3/#http2\">discussed above</a>, both HTTP/2 and HTTP/3 can reuse connections even if they go to other hostnames, to prevent downsides from hostname sharding. However, as shown in figure 3, WebPageTest reports that, for this Facebook load, connection coalescing is used over HTTP/3 for <code>facebook.com</code> and <code>fbcdn.net</code>, but not over HTTP/2 (as Chrome opens a secondary connection for the second domain). I suspect this is a bug in WebPageTest, however, because <code>facebook.com</code> and <code>fbcnd.net</code> resolve to different IPs and, as such, can’t really be coalesced.</blockquote>\n\n<p>The figure also shows that some key QUIC handshake information is missing from the current WebPageTest visualization.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/dc343577-ecc6-4d09-9674-8ce22d290870/chrome-facebook-connection.png\" /></p>\n<p><strong>Note</strong>: <em>As we see, getting “real” HTTP/3 going can be difficult sometimes. Luckily, for Chrome specifically, we have additional options we can use to test QUIC and HTTP/3, in the form of command-line parameters.</em></p>\n<p>On the bottom of WebPageTest’s “Chromium” tab, I used the following command-line options:</p>\n<pre><code>--enable-quic  --quic-version=h3-29 --origin-to-force-quic-on=www.facebook.com:443,static.xx.fbcdn.net:443\n</code></pre>\n\n<p>The <a href=\"https://www.webpagetest.org/result/210420_AiDcY7_ddae6dc06c438d83bb8625cf52951041\">results from this test</a> show that this indeed forces a QUIC connection from the start, even in the first view, thus bypassing the <code>Alt-Svc</code> process. Interestingly, you will notice I had to pass two hostnames to <code>--origin-to-force-quic-on</code>. In the <a href=\"https://www.webpagetest.org/result/210420_BiDcHG_df3438e0dde2f5ea02fc1f865e4e43b8\">version where I didn’t</a>, Chrome, of course, still first opened an HTTP/2 connection to the <code>fbcnd.net</code> domain, even in the repeat view. As such, <strong>you’ll need to manually indicate <em>all</em> QUIC origins in order for this to work</strong>!</p>\n<p>We can see even from these few examples that a lot of stuff is going on with how browsers actually use HTTP/3 in practice. It seems they even switch to the new protocol during the initial page load, abandoning HTTP/2 either as soon as possible or when a new connection is needed. As such, it’s difficult not only getting a full HTTP/3 load, but also <strong>getting a pure HTTP/2 load on a set-up that supports both</strong>! Because WebPageTest doesn’t show much HTTP/3 or QUIC metadata yet, figuring out what’s going on can be challenging, and you can’t trust the tools and visualizations at face value either.</p>\n<p>So, if you use WebPageTest, you’ll need to double-check the results to make sure which protocols were actually used. Consequently, I think this means that <strong>it’s too early to really test HTTP/3 performance at this time</strong> (and especially too early to compare it to HTTP/2). This belief is strengthened by the fact that not all servers and clients have implemented all protocol features yet. Due to the fact that WebPageTest doesn’t yet have easy ways of showing whether advanced aspects such as 0-RTT were used, it will be tricky to know what you’re actually measuring. This is especially true for the <a href=\"https://www.smashingmagazine.com/2021/08/http3-performance-improvements-part2/#packet-loss-resilienceg\">HTTP/3 prioritization feature</a>, which isn’t implemented properly in all browsers yet and which many servers also lack full support for. Because prioritization can be a <a href=\"https://blog.cloudflare.com/better-http-2-prioritization-for-a-faster-web/\">major aspect</a> driving web performance, it would be unfair to compare HTTP/3 to HTTP/2 without making sure that at least this feature works properly (for both protocols!). This is just one aspect, though, as <a href=\"https://qlog.edm.uhasselt.be/epiq/files/QUICImplementationDiversity_Marx_final_11jun2020.pdf\">my research shows how big the differences between QUIC implementations can be</a>. If you do any comparison of this sort yourself (or if you read articles that do), <strong>make 100% sure that you’ve checked what’s actually going on</strong>.  </p>\n<p>Finally, also note that other higher-level tools (or data sets such as the amazing <a href=\"https://httparchive.org/\">HTTP Archive</a>) are often based on WebPageTest or Lighthouse (or use similar methods), so I suspect that most of my comments here will be widely applicable to most web performance tooling. Even for those tool vendors announcing HTTP/3 support in the coming months, I would be a bit skeptical and would validate that they’re actually doing it correctly. For some tools, things are probably even worse, though; for example, Google’s PageSpeed Insights only got <a href=\"https://developers.google.com/speed/docs/insights/release_notes\">HTTP/2 support this year</a>, so I wouldn’t wait for HTTP/3 arriving anytime soon.</p>\n<h3>Wireshark, qlog and qvis</h3>\n<p>As the discussion above shows, it can be tricky to analyze HTTP/3 behavior by just using Lighthouse or WebPageTest at this point. Luckily, other lower-level tools are available to help with this. First, the excellent <a href=\"https://www.wireshark.org/\">Wireshark</a> tool has advanced support for QUIC, and it can experimentally dissect HTTP/3 as well. This allows you to observe which QUIC and HTTP/3 packets are actually going over the wire. However, in order for that to work, you need to obtain the TLS decryption keys for a given connection, which most implementations (including Chrome and Firefox) allow you to extract by using the <code>SSLKEYLOGFILE</code> <a href=\"https://www.steffr.ch/inspect-ssl-tls-traffic-from-chrome-firefox-curl-with-wireshark-no-mitm/\">environment variable</a>. While this can be useful for some things, really figuring out what’s happening, especially for longer connections, could entail a lot of manual work. You would also need a pretty advanced understanding of the protocols’ inner workings.</p>\n<p>Luckily, there is a second option, qlog and qvis. <a href=\"https://github.com/quicwg/qlog\">qlog</a> is a JSON-based logging format specifically for QUIC and HTTP/3 that is supported by the majority of QUIC implementations. Instead of looking at the packets going over the wire, qlog captures this information on the client and server directly, which allows it to include some additional information (for example, congestion control details). Typically, you can trigger qlog output when starting servers and clients with the <code>QLOGDIR</code> environment variable. (Note that in Firefox, you need to set the <a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=1649495\"><code>network.http.http3.enable_qlog</code></a> preference. Apple devices and Safari use <a href=\"https://developer.apple.com/videos/play/wwdc2021/10094/\"><code>QUIC_LOG_DIRECTORY</code></a> instead. Chrome doesn’t yet support qlog.)</p>\n<p>These qlog files can then be uploaded to the qvis tool suite at <a href=\"https://qvis.quictools.info\">qvis.quictools.info</a>. There, you’ll get a <strong>number of advanced interactive visualizations that make it easier to interpret QUIC and HTTP/3 traffic</strong>. qvis also has support for uploading Wireshark packet captures (<code>.pcap</code> files), and it has experimental support for <a href=\"https://www.chromium.org/for-testers/providing-network-details\">Chrome’s netlog files</a>, so you can also analyze Chrome’s behavior. A full tutorial on qlog and qvis is beyond the scope of this article, but more details can be found in <a href=\"https://www.youtube.com/watch?v=HQ1uIClmzkU\">tutorial form</a>, as <a href=\"https://qlog.edm.uhasselt.be/anrw/files/DebuggingQUICWithQlog_Marx_final_21jun2020.pdf\">a paper</a>, and even in <a href=\"https://cloudflare.tv/event/3OM7upT7p3vpAdzphFdhnx\">talk-show format</a>. You can also <a href=\"https://twitter.com/programmingart\">ask me about them</a> directly because I’m the main implementer of qlog and qvis. ;)</p>\n<p>However, I am under no illusion that most readers here should ever use Wireshark or qvis, because these are quite low-level tools. Still, as we have few alternatives at the moment, I strongly recommend <strong>not extensively testing HTTP/3 performance without using this type of tool</strong>, to make sure you really know what’s happening on the wire and whether what you’re seeing is really explained by the protocol’s internals and not by other factors.</p>\n<h3>What Does It All Mean?</h3>\n<p>As we’ve seen, setting up and using HTTP/3 over QUIC can be a complex affair, and many things can go wrong. Sadly, no good tool or visualization is available that exposes the necessary details at an appropriate level of abstraction. This makes it very <strong>difficult for most developers to assess the potential benefits that HTTP/3 can bring to their website at this time</strong> or even to validate that their set-up works as expected.</p>\n<p>Relying only on high-level metrics is very dangerous because these could be skewed by a plethora of factors (such as unrealistic network emulation, a lack of features on clients or servers, only partial HTTP/3 usage, etc.). Even if everything did work better, as we’ve seen in <a href=\"https://www.smashingmagazine.com/2021/08/http3-performance-improvements-part2/#conclusion\">part 2</a>, the differences between HTTP/2 and HTTP/3 will likely be relatively small in most cases, which makes it even more difficult to get the necessary information from high-level tools without targeted HTTP/3 support.</p>\n<p>As such, <strong>I recommend leaving HTTP/2 versus HTTP/3 performance measurements alone for a few more months and focusing instead on making sure that our server-side set-ups are functioning as expected</strong>. For this, it’s easiest to use WebPageTest in combination with Google Chrome’s command-line parameters, with a fallback to curl for potential issues — this is currently the most consistent set-up I can find.</p>\nConclusion and Takeaways\n<p>Dear reader, if you’ve read the full three-part series and made it here, <strong>I salute you</strong>! Even if you’ve only read a few sections, I thank you for your interest in these new and exciting protocols. Now, I will summarize the key takeaways from this series, provide a few key recommendations for the coming months and year, and finally provide you with some additional resources, in case you’d like to know more.</p>\n<h3>Summary</h3>\n<p>First, in <a href=\"https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/\">part 1</a>, we discussed that <strong>HTTP/3 was needed mainly because of the new underlying QUIC transport protocol</strong>. QUIC is the spiritual successor to TCP, and it integrates all of its best practices, as well as TLS 1.3. This was mainly needed because TCP, due to its ubiquitous deployment and integration in middleboxes, has become too inflexible to evolve. QUIC’s usage of UDP and almost full encryption means that we (hopefully) only have to update the endpoints in the future in order to add new features, which should be easier. QUIC, however, also adds some interesting new capabilities. First, QUIC’s combined transport and cryptographic handshake is faster than TCP + TLS, and it can make good use of the 0-RTT feature. Secondly, QUIC knows it is carrying multiple independent byte streams and can be smarter about how it handles loss and delays, mitigating the head-of-line blocking problem. Thirdly, QUIC connections can survive users moving to a different network (called connection migration) by tagging each packet with a connection ID. Finally, QUIC’s flexible packet structure (employing frames) makes it more efficient but also more flexible and extensible in the future. In conclusion, it’s clear that <strong>QUIC is the next-generation transport protocol and will be used and extended for many years to come</strong>.</p>\n<p>Secondly, in <a href=\"https://www.smashingmagazine.com/2021/08/http3-performance-improvements-part2/\">part 2</a>, we took a bit of a <strong>critical look at these new features, especially their performance implications</strong>. First, we saw that QUIC’s use of UDP doesn’t magically make it faster (nor slower) because QUIC uses congestion control mechanisms very similar to TCP to prevent overloading the network. Secondly, the faster handshake and 0-RTT are more micro-optimizations, because they are really only one round trip faster than an optimized TCP + TLS stack, and QUIC’s true 0-RTT is further affected by a range of security concerns that can limit its usefulness. Thirdly, connection migration is really only needed in a few specific cases, and it still means resetting send rates because the congestion control doesn’t know how much data the new network can handle. Fourthly, the effectiveness of QUIC’s head-of-line blocking removal severely depends on how stream data is multiplexed and prioritized. Approaches that are optimal to recover from packet loss seem detrimental to general use cases of web page loading performance and vice versa, although more research is needed. Fifthly, QUIC could easily be slower to send packets than TCP + TLS, because UDP APIs are less mature and QUIC encrypts each packet individually, although this can be largely mitigated in time. Sixthly, HTTP/3 itself doesn’t really bring any major new performance features to the table, but mainly reworks and simplifies the internals of known HTTP/2 features. Finally, some of the most exciting performance-related features that QUIC allows (multipath, unreliable data, WebTransport, forward error correction, etc.) are not part of the core QUIC and HTTP/3 standards, but rather are proposed extensions that will take some more time to be available. In conclusion, this means <strong>QUIC will probably not improve performance much for users on high-speed networks, but will mainly be important for those on slow and less-stable networks</strong>.</p>\n<p>Finally, <a href=\"#changes-to-pages-and-resources\">in this part 3</a>, we looked at <strong>how to practically use and deploy QUIC and HTTP/3</strong>. First, we saw that most best practices and lessons learned from HTTP/2 should just carry over to HTTP/3. There is no need to change your bundling or inlining strategy, nor to consolidate or shard your server farm. Server push is still not the best feature to use, and <code>preload</code> can similarly be a powerful footgun. Secondly, we’ve discussed that it might take a while before off-the-shelf web server packages provide full HTTP/3 support (partly due to TLS library support issues), although plenty of open-source options are available for early adopters and several major CDNs have a mature offering. Thirdly, it’s clear that most major browsers have (basic) HTTP/3 support, even enabled by default. There are major differences in how and when they practically use HTTP/3 and its new features, though, so understanding their behavior can be challenging. Fourthly, we’ve discussed that this is worsened by a lack of explicit HTTP/3 support in popular tools such as Lighthouse and WebPageTest, making it especially difficult to compare HTTP/3 performance to HTTP/2 and HTTP/1.1 at this time. In conclusion, <strong>HTTP/3 and QUIC are probably not <em>quite</em> ready for primetime yet, but they soon will be</strong>.</p>\n<h3>Recommendations</h3>\n<p>From the summary above, it might seem like I am making strong arguments against using QUIC or HTTP/3. However, that is quite opposite to the point I want to make.</p>\n<p>First, as discussed at the end of <a href=\"https://www.smashingmagazine.com/2021/08/http3-performance-improvements-part2/#conclusion\">part 2</a>, even though your “average” user might not encounter <em>major</em> performance gains (depending on your target market), a <strong>significant portion of your audience <em>will</em> likely see impressive improvements</strong>. 0-RTT might only save a single round trip, but that can still mean several hundred milliseconds for some users. Connection migration might not sustain consistently fast downloads, but it will definitely help people trying to fetch that PDF on a high-speed train. Packet loss on cable might be bursty, but wireless links might benefit more from QUIC’s head-of-line blocking removal. What’s more, these users are those who would typically encounter the <em>worst</em> performance of your product and, consequently, be most heavily affected by it. If you wonder why that matters, read Chris Zacharias’ famous <a href=\"https://blog.chriszacharias.com/page-weight-matters\">web performance anecdote</a>.</p>\n<p>Secondly, <strong>QUIC and HTTP/3 will only get better and faster over time</strong>. Version 1 has focused on getting the basic protocol done, keeping more advanced performance features for later. As such, I feel it pays to start investing in the protocols now, to make sure you can use them and the new features to optimal effect when they become available down the line. Given the complexity of the protocols and their deployment aspects, it would be good to give yourself some time to get acquainted with their quirks. Even if you don’t want to get your hands dirty quite yet, several major CDN providers offer mature “flip the switch” HTTP/3 support (particularly, Cloudflare and Fastly). I struggle to find a reason not to try that out if you’re using a CDN (which, if you care about performance, you really should be).</p>\n<p>As such, while I wouldn’t say that it’s <em>crucial</em> to start using QUIC and HTTP/3 as soon as possible, I do feel there are <strong>plenty of benefits already to be had, and they will only increase in the future</strong>.</p>\n<h3>Further Reading</h3>\n<p>While this has been a long body of text, sadly, it really only scratches the technical surface of the complex protocols that QUIC and HTTP/3 are.</p>\n<p>Below you will find a list of additional resources for continued learning, more or less in order of ascending technical depth:</p>\n<ul>\n<li>“<a href=\"https://http3-explained.haxx.se/en/\">HTTP/3 Explained</a>,” Daniel Stenberg<br />This e-book, by the creator of cURL, summarizes the protocol.</li>\n<li>“<a href=\"https://www.manning.com/books/http2-in-action\">HTTP/2 in Action</a>,” Barry Pollard<br />This excellent all-round book on HTTP/2 has reusable advice and a section on HTTP/3.</li>\n<li><a href=\"https://twitter.com/programmingart\">@programmingart</a>, Twitter<br />My tweets are mostly dedicated to QUIC, HTTP/3, and web performance (including news) in general. See for example my <a href=\"https://twitter.com/search?q=%40programmingart%20%23RFC9000&amp;src=typed_query&amp;f=live\">recent threads</a> on QUIC features.</li>\n<li>“<a href=\"https://www.youtube.com/results?search_query=robin+marx+quic\">YouTube</a>,” Robin Marx<br />My over 10 in-depth talks cover various aspects of the protocols.</li>\n<li>“<a href=\"https://blog.cloudflare.com/tag/quic/\">The Cloudlare Blog</a>”<br />This is the main product of a company that also runs a CDN on the side.</li>\n<li>“<a href=\"https://www.fastly.com/blog/standardization\">The Fastly Blog</a>”<br />This blog has excellent discussions of technical aspects, embedded in the wider context.</li>\n<li><a href=\"https://quicwg.org/\">QUIC</a>, the actual RFCs<br />You’ll find links to the IETF QUIC and HTTP/3 RFC documents and other official extensions.</li>\n<li><a href=\"https://eng-blog.iij.ad.jp/quic\">IIJ Engineers Blog</a>: Excellent deep technical explanations of QUIC feature details.</li>\n<li><a href=\"https://h3.edm.uhasselt.be/\">HTTP/3</a> and <a href=\"https://qlog.edm.uhasselt.be/\">QUIC</a> academic papers, Robin Marx<br />My research papers cover stream multiplexing and prioritization, tooling, and implementation differences.</li>\n<li><a href=\"https://www.ndss-symposium.org/ndss2020/cfp-quips-workshop/\">QUIPS</a>, <a href=\"https://conferences2.sigcomm.org/co-next/2018/#!/epiqprogram\">EPIQ 2018</a>, and <a href=\"https://conferences.sigcomm.org/sigcomm/2020/workshop-epiq.html\">EPIQ 2020</a><br />These papers from academic workshops contain in-depth research on security, performance, and extensions of the protocols.</li>\n</ul>\n<p>With that, I leave you, dear reader, with a hopefully much-improved understanding of this brave new world. I am always <a href=\"https://twitter.com/programmingart\">open to feedback</a>, so please let me know what you think of this series!</p>\n<div>\n    <ul>\n    <li><a href=\"https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/\">Part 1: HTTP/3 History And Core Concepts</a><br />This article is targeted at people new to HTTP/3 and protocols in general, and it mainly discusses the basics.</li>\n    <li><a href=\"https://www.smashingmagazine.com/2021/08/http3-performance-improvements-part2/\">Part 2: HTTP/3 Performance Features</a><br />This one is more in depth and technical. People who already know the basics can start here.</li>\n    <li><strong>Part 3: Practical HTTP/3 Deployment Options</strong><br />This third article in the series explains the challenges involved in deploying and testing HTTP/3 yourself. It details how and if you should change your web pages and resources as well.</li>\n</ul>\n</div>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"069587564b6d0584148b5aacde7d1a339ca822843600a8dbb460009af3ccc181","category":"Tech"}