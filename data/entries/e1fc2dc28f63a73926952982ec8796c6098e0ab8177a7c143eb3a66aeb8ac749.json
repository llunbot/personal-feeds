{"title":"Optimizing Amazon Simple Queue Service (SQS) for speed and scale","link":"https://aws.amazon.com/blogs/aws/optimizing-amazon-simple-queue-service-sqs-for-speed-and-scale/","date":1719410602000,"content":"<p><a href=\"https://aws.amazon.com/blogs/aws/amazon_simple_q/\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/01/31/sqs_launch_1.png\" width=\"405\" height=\"293\" /></a>After several public betas, we <a href=\"https://aws.amazon.com/blogs/aws/amazon_simple_q/\">launched</a> <a href=\"https://aws.amazon.com/sqs/\">Amazon Simple Queue Service (Amazon SQS)</a> in 2006. Nearly two decades later, this fully managed service is still a fundamental building block for microservices, distributed systems, and serverless applications, processing over 100 million messages per second at peak times.</p> \n<p>Because there’s always a better way, we continue to look for ways to improve performance, security, internal efficiency, and so forth. When we do find a potential way to do something better, we are careful to preserve existing behavior, and often run new and old systems in parallel to allow us to compare results.</p> \n<p>Today I would like to tell you how we recently made improvements to <a href=\"https://aws.amazon.com/sqs/\">Amazon SQS</a> to reduce latency, increase fleet capacity, mitigate an approaching scalability cliff, and reduce power consumption.</p> \n<p><span><strong>Improving SQS</strong></span><br /> Like many AWS services, <a href=\"https://aws.amazon.com/sqs/\">Amazon SQS</a> is implemented using a collection of internal microservices. Let’s focus on two of them today:</p> \n<p><strong>Customer Front-End</strong> – The customer-facing front-end accepts, authenticates, and authorizes API calls such as <code><a href=\"https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_CreateQueue.html\">CreateQueue</a></code> and <code><a href=\"https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_SendMessage.html\">SendMessage</a></code>. It then routes each request to the storage back-end.</p> \n<p><strong>Storage Back-End</strong> -This internal microservice is responsible for persisting messages sent to standard (non-FIFO) queues. Using a cell-based model, each cluster in the cell contains multiple hosts, each customer queue is assigned to one or more clusters, and each cluster is responsible for a multitude of queues:</p> \n<p><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/03/25/sqs_fleets_3.png\" width=\"874\" height=\"580\" /></p> \n<p><span><strong>Connections – Old and New</strong></span><br /> The original implementation used a connection per request between these two services. Each front-end had to connect to many hosts, which mandated the use of a connection pool, and also risked reaching an ultimate, hard-wired limit on the number of open connections. While it is often possible to simply throw hardware at problems like this and scale out, that’s not always the best way. It simply moves the moment of truth (the “scalability cliff”) into the future and does not make efficient use of resources.</p> \n<p>After carefully considering several long-term solutions, the <a href=\"https://aws.amazon.com/sqs/\">Amazon SQS</a> team invented a new, proprietary binary framing protocol between the customer front-end and storage back-end. The protocol multiplexes multiple requests and responses across a single connection, using 128-bit IDs and checksumming to prevent crosstalk. <a href=\"https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-server-side-encryption.html\">Server-side encryption</a> provides an additional layer of protection against unauthorized access to queue data.</p> \n<p><span><strong>It Works!</strong></span><br /> The new protocol was put into production earlier this year and has processed 744.9 trillion requests as I write this. The scalability cliff has been eliminated and we are already looking for ways to put this new protocol to work in other ways.</p> \n<p>Performance-wise, the new protocol has reduced dataplane latency by 11% on average, and by 17.4% at the P90 mark. In addition to making SQS itself more performant, this change benefits services that build on SQS as well. For example, messages sent through <a href=\"https://aws.amazon.com/sns/\">Amazon Simple Notification Service (Amazon SNS)</a> now spend 10% less time “inside” before being delivered. Finally, due to the protocol change, the existing fleet of SQS hosts (a mix of X86 and Graviton-powered instances) can now handle 17.8% more requests than before.</p> \n<p><span><strong>More to Come</strong></span><br /> I hope that you have enjoyed this little peek inside the implementation of <a href=\"https://aws.amazon.com/sqs/\">Amazon SQS</a>. Let me know in the comments, and I will see if I can find some more stories to share.</p> \n<p>— <a href=\"https://twitter.com/jeffbarr\">Jeff</a>;</p>","author":"Jeff Barr","siteTitle":"AWS News Blog","siteHash":"6093e072e4117ec22616e844cb857d03ca62c57a411a8affc77cb5e8b6b15bf6","entryHash":"e1fc2dc28f63a73926952982ec8796c6098e0ab8177a7c143eb3a66aeb8ac749","category":"Tech"}