{"title":"ห้าม Compare Struct ใน Go","link":"https://blog.whs.in.th/node/3545","date":1621791424000,"content":"<p>หลายเดือนก่อนทีมทำเรื่อง data encryption ใน Go ซึ่งเราจะมี struct <code>EncryptedString</code> ซึ่งเก็บ string แบบเข้ารหัสไว้แล้ว</p>\n<p>ปัญหาก็คือเรากังวลว่า developer อาจจะคิดว่ามันใช้งานเหมือน string ปกติแล้วไป compare (<code>encryptedA == encryptedB</code>) ซึ่งมันอาจจะเท่าหรือไม่เท่ากันก็ได้ขึ้นอยู่กับ internal state ของ string ก็ต้องแจ้ง developer ไปว่าให้ใช้ <code>Equal()</code> เสมอ อย่าใช้ ==</p>\n<p>บังเอิญช่วงนั้นผมเขียน Protobuf อยู่พอดีเลยไปเห็น <a href=\"https://pkg.go.dev/google.golang.org/protobuf@v1.26.0/internal/pragma\">google.golang.org/protobuf/internal/pragma</a> ซึ่งผมว่ามันมีแต่ hack เทพๆ ที่อ่านแล้วฉลาดขึ้นเลย</p>\n<h2>DoNotCompare</h2>\n<p><a href=\"https://www.hyrumslaw.com/\">Hyrum’s Law</a> บอกว่าถ้ามีคนใช้ API มากพอ ต่อให้ไม่ได้บอกว่าใช้แบบนี้ได้ มันจะมีคนไปใช้ตามพฤติกรรมที่สังเกตได้เสมอ ซึ่งเราอาจจะเคยได้ยินว่าบางระบบอาจจะถึงกับต้อง emulate bug เพื่อให้มันใช้งานได้ เช่นใน <a href=\"https://0xeb.net/wp-content/uploads/2018/02/StarCraft_EUD_Emulator.pdf\">StarCraft Remastered นั้น Blizzard ถึงกับต้องจำลอง buffer overflow เพราะ map เก่าๆ บางอันใช้</a></p>\n<p>ในเคสของ Protobuf แปลว่าถ้าใช้ == กับ Protobuf message ได้แถม return ค่าถูกต้อง ก็คงจะมีคนใช้ == แน่นอน พอออก version ใหม่ที่เปลี่ยนโครงสร้างของ struct ก็พัง ทั้งๆ ที่ไม่เคยบอกว่าใช้ == ได้ ดังนั้น Go Protobuf เลยมี “pragma” หรือสูตรสำเร็จที่ฝังเข้าไปใน struct เพื่อทำให้พฤติกรรมต้องห้ามนั้นมี error หรือ warning เกิดขึ้นได้</p>\n<p>ในบล็อคนี้ผมจะพาไล่ทั้ง 4 pragma ในแพคเกจขณะที่เขียนนี้ พร้อมทั้งเฉลยว่ามันทำได้อย่างไร อ่านแล้วผมแนะนำให้<strong>ลองคิดตามก่อนที่จะอ่านเฉลยครับ</strong></p>\n<p>โค้ด DoNotCompare มีอยู่ว่า</p>\n<pre><code>type DoNotCompare [0]func()\n</code></pre>\n<p>โดยเวลาใช้งานให้ฝังเข้าไปใน struct เช่น</p>\n<pre><code>type X struct {\n    Value int\n\n    DoNotCompare\n}\n</code></pre>\n<p>เมื่อเรา compile จะได้ข้อความว่า</p>\n<pre><code>./prog.go:17:20: invalid operation: a == b (struct containing DoNotCompare cannot be compared)\n</code></pre>\n<p>เหตุผลที่เป็นอย่างนี้เพราะใน Go เราไม่สามารถเปรียบเทียบ function ได้</p>\n<pre><code>./prog.go:17:31: invalid operation: fmt.Println == fmt.Println (func can only be compared to nil)\n</code></pre>\n<p>การ compare struct นั้นมันจะ compare ทุก field ภายใน struct เมื่อเจอ field นี้ที่ type เป็น function ซึ่ง compare ไม่ได้แล้ว compiler จึงจะไม่ยอมให้ compile</p>\n<p>ส่วน <code>[0]</code> ด้านหน้า ไว้เดี๋ยวจะเฉลยครับ…</p>\n<h2>DoNotCopy</h2>\n<p>ใน Go เราอาจจะมีการ pass by value ในบางครั้งซึ่งมันจะ copy object เข้าไปใน function เช่น</p>\n<pre><code>type X struct {\n    Value string\n}\n\nfunc RecvX(v X) {\n    v.Value = \"changed\"\n}\n\nfunc main() {\n    x := X{value: \"init\"}\n    RecvX(x)\n    fmt.Println(x.Value)\n}\n</code></pre>\n<p>ในกรณีนี้ เนื่องจาก <code>RecvX</code> ได้รับ X แบบ pass by value ทำให้ <code>v</code> เป็น copy ของ <code>x</code> ใน main เมื่อ print ออกมาจะได้ผลลัพท์ว่า “init” ไม่ใช่ “changed”</p>\n<p>เพื่อป้องกันการใช้งานแบบ pass by value โค้ด DoNotCopy จึงมีดังนี้</p>\n<pre><code>type DoNotCopy [0]sync.Mutex\n</code></pre>\n<p>โค้ดนี้จะต่างกับ <code>DoNotCompare</code> คือสามารถ compile ผ่านได้ตามปกติ แต่ถ้ารัน <code>go vet</code> แล้วจะมี error ดังนี้</p>\n<pre><code>./prog.go:16:14: RecvX passes lock by value: play.X contains sync.Mutex\n</code></pre>\n<p>สำหรับคนที่เคยใช้งาน sync.Mutex แล้วน่าจะทราบดีว่าห้าม copy sync.Mutex เด็ดขาดเนื่องจากจะทำให้มี lock 2 ชุดแทนที่จะมีชุดเดียว ซึ่ง <code>go vet</code> จับให้อยู่แล้ว ดังนั้นการฝัง <code>sync.Mutex</code> เข้าไปใน struct ถึงแม้ไม่ได้ใช้ก็ทำให้ go vet ทำงาน</p>\n<p>คำถามจากหัวเรื่องที่แล้วคือ แล้ว <code>[0]</code> คืออะไร? syntax นี้ผู้เริ่มต้น Go บางคนอาจจะเรียน บางคนอาจจะข้ามไปเลยเพราะไม่ค่อยได้ใช้ syntax นี้คือ fixed size array ใน Go เช่น <code>[10]int</code> คือ slice ที่มีสมาชิกเป็น int 10 ตัวไม่สามารถเพิ่มลดได้ (และมันเป็นคนละ type ไม่ใช่ slice ใช้แทนที่ slice ปกติไม่ได้)</p>\n<p>เนื่องจากจำนวนสมาชิกเป็นค่าที่ทราบตั้งแต่ compile ทำให้ compiler สามารถจอง memory ให้สมาชิกทั้ง 10 ตัวได้ล่วงหน้า ในกรณีของ pragma 2 ตัวก่อนหน้านี้เราระบุเป็น <code>[0]</code> ก็คือไม่มีสมาชิก ทำให้ compiler ไม่จองพื้นที่สำหรับเก็บข้อมูลไว้เลย ทำให้ไม่มี overhead จากการใช้งาน</p>\n<h2>NoUnkeyedLiterals</h2>\n<p>ปัญหาถัดมาที่เจอคือมันจะมีคนมักง่าย แบบนี้…</p>\n<pre><code>type X struct {\n    Value1 string\n    Value2 int\n}\n\nfunc main() {\n    X{\"v\", 1}\n}\n</code></pre>\n<p>พอสร้าง struct โดยไม่ระบุชื่อ field ปัญหาที่ตามมาคือถ้าจะเพิ่ม field คนที่เพิ่มจะกรีดร้องเพราะต้องไล่ตามแก้ของเก่าให้หมด</p>\n<p>โค้ด NoUnkeyedLiteral ง่ายๆ แค่</p>\n<pre><code>type NoUnkeyedLiterals struct{}\n</code></pre>\n<p>ใช่แล้ว มันคือ struct ง่ายๆ ไม่มีอะไรเลย เนื่องจากมันจะทำให้ struct มี 3 field (ไม่ใช้ 3 field) โค้ดด้านบนจึงจะเจอ</p>\n<pre><code>./prog.go:14:27: too few values in X{...}\n</code></pre>\n<p>ทำให้ไม่สามารถระบุแค่ 2 field ที่ใช้งานได้ ต้องระบุค่าของ NoUnkeyedLiteral ด้วย ก็คือต้องพิมพ์</p>\n<pre><code>X{\"v\", 1, NoUnkeyedLiteral{}}\n</code></pre>\n<p>ซึ่งก็ควรจะเอะใจได้แล้วนะว่าเค้าไม่ให้ทำแบบนี้ !!</p>\n<h2>DoNotImplement</h2>\n<p>Pragma ตัวสุดท้ายคือ DoNotImplement ซึ่งไม่อนุญาตให้แพคเกจอื่น implement interface นี้ เนื่องจากใน Go นั้น interface ไม่จำเป็นต้องประกาศ implement ขอแค่มี method ตรงกันเป็นอันใช้ได้ จึงไม่สามารถประกาศ interface เป็น private ได้</p>\n<p>โค้ดของ DoNotImplement หน้าตาแบบนี้</p>\n<pre><code>type DoNotImplement interface{ ProtoInternal(DoNotImplement) }\n</code></pre>\n<p>โดยการใช้งานก็ให้ฝังเข้าไปใน Interface อื่น</p>\n<pre><code>type Printable interface {\n    Print()\n\n    DoNotImplement\n}\n</code></pre>\n<p>ผมใช้เวลาหลายชั่วโมงพยายามทำความเข้าใจโค้ดนี้ ใคร declare <code>ProtoInternal</code>? แล้วมัน recursive มันช่วยยังไง?</p>\n<p>ถ้าจัดรูปใหม่แล้ว มันจะเป็น</p>\n<pre><code>type DoNotImplement interface {\n    ProtoInternal(value DoNotImplement)\n}\n</code></pre>\n<p>ก็คือเป็น interface ที่มี 1 method ชื่อ <code>ProtoInternal</code> รับ argument 1 อย่างเป็น type ตัวเอง</p>\n<p>แต่ เอ มันก็แก้ด้วยการเขียน implementation ง่ายๆ แบบนี้</p>\n<pre><code>func (x *X) ProtoInternal(value DoNotImplement) {}\n</code></pre>\n<p>หรือเปล่า….</p>\n<p>ผมอ่าน docs อยู่ 2 ชั่วโมงก่อนจะไปสังเกตชื่อแพคเกจ google.golang.org/protobuf<strong>/internal/</strong>pragma</p>\n<p>ใน <a href=\"https://golang.org/doc/go1.4#internalpackages\">Go แพคเกจจะไม่อนุญาตให้ import package ที่มี path internal มาจากแพคเกจอื่นๆ</a> ดังนั้นถ้าจะ implement interface นี้ได้จริง ก็ต้อง import <code>DoNotImplement</code> มาใส่ใน argument ให้ได้ด้วย และเนื่องจากว่ามันเป็น internal จึงมีเฉพาะ package ที่ได้รับอนุญาตเท่านั้นจึงจะ import ได้</p>\n<p>ทริคนี้ยังใช้ใน <code>NoUnkeyedLiteral</code> ในหัวข้อก่อนหน้าด้วย โดยถ้าจะดันทุรังใช้ <code>X{\"v\", 1, NoUnkeyedLiteral{}}</code> ก็จะเจอปัญหาเหมือนกันว่า import <code>NoUnkeyedLiteral</code> ไม่ได้</p>\n<h2>Genius</h2>\n<p>ทั้ง 4 ทริคนี้ผมว่าเป็นโค้ดที่เขียนได้ฉลาดมากๆ เหมือนเป็น puzzle และตอนอ่านผมก็คิดว่ามันลับสมองมากๆ ที่จะไล่ดูกลวิธีของผู้สร้างว่าเค้าวางกับดักโดยใช้แค่ Go standard tools ได้อย่างไร</p>\n<p>ในทีมผมก็คุยกันแล้วว่าทริคลักษณะนี้อาจจะยังไม่อยากใช้เท่าไรนักเพราะภายในบริษัทอาจจะยังพอตกลงกันหรือตรวจกันใน code review ได้โดยไม่ต้องพึ่ง hack แต่ในระดับ protobuf ที่เป็น library ใช้กันแพร่หลายแล้วการบังคับทางเทคนิคนี้ก็เป็นเรื่องจำเป็นที่จะไม่ให้คนเขียนโค้ดแบบ genius เล่นท่าพิสดารที่อัพเกรดไม่ได้</p>","author":"whs","siteTitle":"Quietly Verbose","siteHash":"5f972a6fe70a917eb1b1aa165b3cb2be8a9465af33ab38bf05f34c55c0e40587","entryHash":"6124f0fbba4a57301b97398407b8e6695dd7a098e2e7ec694aca2d7ec6136c8a","category":"Thai"}