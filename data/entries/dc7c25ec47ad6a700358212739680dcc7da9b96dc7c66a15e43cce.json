{"title":"Try out CSS Nesting today","link":"https://webkit.org/blog/13813/try-css-nesting-today-in-safari-technology-preview/","date":1675879202000,"content":"<p>Back in December, we wrote an article <a href=\"https://webkit.org/blog/13607/help-choose-from-options-for-css-nesting-syntax/\">detailing three different options</a> for CSS Nesting. In it, we explained the differences between Option 3, Option 4 and Option 5, demonstrating how each would work through a series of examples. Then we asked a simple question: “Which option is best for the future of CSS?”</p>\n<p>Web developers responded to the poll with great clarity. Option 3 won in a landslide.</p>\n<p>And so now, <a href=\"https://caniuse.com/css-nesting\">both Safari and Chrome</a> have implemented Option 3. Two weeks ago, on January 25th, <a href=\"https://w3c.github.io/csswg-drafts/css-nesting-1/\">CSS Nesting</a> shipped in <a href=\"https://webkit.org/blog/13703/release-notes-for-safari-technology-preview-162/\">Safari Technology Preview 162</a>, on by default. If you have a Mac, simply <a href=\"https://developer.apple.com/safari/resources/\">download</a> and open Safari Technology Preview, write some nested CSS, and experience how it works!</p>\n<h2>How CSS Nesting Works</h2>\n<p>Imagine you have some CSS that you’d like to write in a more compact way.</p>\n<pre><code><span>.foo</span> {\n  <span>color</span>: <span>green</span>;\n}\n<span>.foo</span> <span>.bar</span> {\n  <span>font-size</span>: <span>1.4</span><span>rem</span>;\n}\n</code></pre>\n<p>With CSS Nesting, you can write such code as:</p>\n<pre><code><span>.foo</span> {\n  <span>color</span>: <span>green</span>;\n .<span>bar</span> {\n    <span>font-size</span>: <span>1.4</span><span>rem</span>;\n  }\n}\n</code></pre>\n<p>If you’ve been nesting styles in <a href=\"https://sass-lang.com/\">Sass</a>, you will find this very familiar.</p>\n<p>Unlike Sass, however, this kind of nesting will not always work. Because of limitations in browser parsing engines, you must make sure the nested selector (<code>.bar</code> in the above example) always starts with a symbol. If it’s a class, ID, pseudo-class, pseudo-element, attribute selector, or any selector that uses a symbol at the beginning — you’ve succeeded. For example, all of these will be fine. All of the following nested selectors start with a symbol —  <code>.</code>  <code>#</code>  <code>:</code>  <code>[</code>  <code>*</code>  <code>+</code>  <code>&gt;</code>  <code>~</code>  — not a letter:</p>\n<pre><code><span>main</span> {\n .<span>bar</span> { ... }\n <span>#baz</span> { ...}\n <span>:has</span>(<span>p</span>) { ... }\n ::<span>backdrop</span> { ... }\n [<span>lang</span>|=<span>\"zh\"</span>] { ... }\n * { ... }\n + <span>article</span> { ... }\n &gt; <span>p</span> { ... }\n ~ <span>main</span> { ... }\n}\n</code></pre>\n<p>There is one kind of selector that starts with a letter, however — a nested element selector. This example will not work:</p>\n<pre><code><span>main</span> {\n <span>article</span> { ... }\n}\n</code></pre>\n<p>That code will fail, because <code>article</code> begins with a letter, and not a symbol. How will it fail? The same way it would fail if you’d misspelled <code>article</code> as <code>atirlce</code>. The nested CSS which depends on that particular selector is simply ignored.</p>\n<p>You have several options for what to do about this limitation. Let’s start by looking at the solution that you’ll probably use most often. You can simply put an <code>&amp;</code> before the element selector, like this:</p>\n<pre><code><span>main</span> {\n &amp; <span>article</span> { ... }\n}\n</code></pre>\n<p>The <code>&amp;</code> signals to the browser “this is where I want the selector from outside this nest to go”. By using an <code>&amp;</code> before any element selectors, you succeed at starting the nested selector with a symbol, not a letter. Therefore, it will work.</p>\n<pre><code><span>aside</span> {\n &amp; <span>p</span> { ... }\n}\n</code></pre>\n<p>is the nested equivalent to:</p>\n<pre><code><span>aside</span> <span>p</span> { ... }\n</code></pre>\n<p>The <code>&amp;</code> is also super handy for other use cases.</p>\n<p>Imagine you have this unnested code:</p>\n<pre><code><span>ul</span> {\n  <span>padding-left</span>: <span>1em</span>;\n}\n<span>.component</span> <span>ul</span> {\n  <span>padding-left</span>: <span>0</span>;\n}\n</code></pre>\n<p>You’ll notice that the intended selector is <code>.component ul</code> — where the <code>ul</code> is second.</p>\n<p>To write nested rules that yield such a result, you can write:</p>\n<pre><code><span>ul</span> {\n  <span>padding-left</span>: <span>1em</span>;\n  .<span>component</span> &amp; {\n    <span>padding-left</span>: <span>0</span>;\n  }\n}\n</code></pre>\n<p>Again, the <code>&amp;</code> gives you a way to say “this is is where I want the nested selector to go”.</p>\n<p>It’s also handy when you don’t want a space between your selectors. For example:</p>\n<pre><code><span>a</span> {\n  <span>color</span>: <span>blue</span>;\n  &amp;:<span>hover</span> {\n    <span>color</span>: <span>lightblue</span>;\n  }\n}\n</code></pre>\n<p>Such code yields the same result as <code>a:hover {</code>. Without the <code>&amp;</code>, you’d get <code>a :hover {</code> — notice the space between <code>a</code> and <code>:hover</code> — which would fail to style your hover link.</p>\n<p>But what if you have this unnested code?</p>\n<pre><code><span>ul</span> {\n  <span>padding-left</span>: <span>1em</span>;\n}\n<span>article</span> <span>ul</span> {\n  <span>padding-left</span>: <span>0</span>;\n}\n</code></pre>\n<p>You do <em>not</em> want to write the nested version like this:</p>\n<pre><code><span>ul</span> {\n  <span>padding-left</span>: <span>1em</span>;\n  &amp; <span>article</span> &amp; {\n    <span>padding-left</span>: <span>0</span>;\n  }\n}\n</code></pre>\n<p>Why not? Because that will actually behave in the same way as these unnested rules:</p>\n<pre><code><span>ul</span> {\n  <span>padding-left</span>: <span>1em</span>;\n}\n<span>ul</span> <span>article</span> <span>ul</span> {\n  <span>padding-left</span>: <span>0</span>;\n}\n</code></pre>\n<p>Two unordered lists in <code>ul article ul</code>? No, that’s not what we want.</p>\n<p>So, what do we do instead, since we need to start <code>article &amp;</code> with a symbol?</p>\n<p>We can write our code like this:</p>\n<pre><code><span>ul</span> {\n  <span>padding-left</span>: <span>1em</span>;\n  :<span>is</span>(<span>article</span>) &amp; {\n    <span>padding-left</span>: <span>0</span>;\n  }\n}\n</code></pre>\n<p>Any selector can be wrapped by an <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/:is\"><code>:is()</code></a> pseudo-class and maintain the same specificity and meaning (when it’s the only selector inside the parentheses). Put an element selector inside <code>:is()</code>, and you get a selector that starts with a symbol for the purposes of CSS Nesting.</p>\n<p>In summary, CSS Nesting will work just like Sass, but with one new rule: you must make sure the nested selector always starts with a symbol.</p>\n<p>Investigations are currently underway to see if this restriction can be relaxed without making the parsing engine slower. The restriction may very well be removed — whether sometime very soon or years in the future. Everyone agrees Nesting will be much better without any such restriction. But we also all agree that web pages <em>must</em> appear in the browser window right away. Adding even the slightest pause before rendering begins is not an option.</p>\n<p>What is an option? You being able to structure your nested code however you’d like. You can nest more than one layer deep — nesting CSS inside already-nested CSS — in as many levels as you desire. You can mix Nesting with Container Queries, Feature Queries, Media Queries, and/or Cascade Layers however you want. Anything can go inside of anything.</p>\n<p>Try out CSS Nesting today and see what you think. Test to your code in both Safari Technology Preview and Chrome Dev (after flipping the “Experimental Web Platform features” flag) to make sure it yields the same results. This is the best time to find bugs — before this new feature has shipped in any browser. You can report issues at <a href=\"http://bugs.webkit.org/\">bugs.webkit.org</a> or <a href=\"https://bugs.chromium.org/p/chromium/issues/list\">bugs.chromium.org</a>. Also, <a href=\"https://webkit.org/\">keep an eye out</a> for the release notes for next several versions of Safari Technology Preview. Each might add polish to our CSS Nesting implementation, including <a href=\"https://github.com/WebKit/WebKit/pull/9332/files\">efforts</a> that add support for CSSOM or other updates to match any potential spec changes made by the CSS Working Group.</p>\n<p>A lot of people across multiple companies have been working to bring nesting to CSS for almost five years. The syntax has been hotly debated, in long conversations about the pros and cons of many different solutions. We hope you find the result immensely helpful.</p>","author":"","siteTitle":"Blog – WebKit","siteHash":"f53db2e11a2faa08c6dca9954c01638d09a2ce585b77a60d10f7a1","entryHash":"dc7c25ec47ad6a700358212739680dcc7da9b96dc7c66a15e43cce","category":"Tech"}