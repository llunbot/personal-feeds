{"title":"Running Vault on Nomad, Part 2","link":"https://www.hashicorp.com/blog/running-vault-on-nomad-part-2","date":1715101200000,"content":"<p><a href=\"https://www.hashicorp.com/blog/running-vault-on-hashicorp-nomad-part-1\">Part 1</a> of this blog series, demonstrated how to deploy the infrastructure for a single Nomad server and four Nomad clients. In this installment of the blog series, you will deploy and configure <a href=\"https://www.vaultproject.io\">HashiCorp Vault</a> as a <a href=\"https://developer.hashicorp.com/nomad/docs/job-specification\">Nomad job</a>.</p>\n\n<h2>Deployment overview</h2>\n<img src=\"https://www.datocms-assets.com/2885/1715098348-nomad-vault-job.png\" alt=\"Vault\" /><p>The diagram above gives an overview of how the Nomad jobs will be deployed and some of the Nomad features you will use to enable this. In total, there will be three Nomad jobs deployed to a Vault cluster namespace. However, this installment will focus on the Vault server cluster. Everything will be deployed using <a href=\"https://www.terraform.io/\">Terraform</a>. In this installment, you will be working in the <code>2-nomad-configuration</code> directory of the <a href=\"https://github.com/devops-rob/vault-on-nomad-demo\">Vault on Nomad demo GitHub repository</a>.</p>\n\n<h2>Reading outputs from remote state</h2>\n\n<p>The infrastructure deployed using Terraform in part 1 of this blog series included some outputs that you need to deploy Vault as a Nomad job. These outputs are:</p>\n\n<ul>\n<li> <code>nomad_clients_private_ips</code></li>\n<li> <code>nomad_clients_public_ips</code></li>\n<li> <code>nomad_server_public_ip</code></li>\n<li> <code>terraform_management_token</code></li>\n</ul>\n\n<p>In order to read the values of these outputs, you can use the <a href=\"https://developer.hashicorp.com/terraform/language/state/remote-state-data\">Terraform remote state data source</a> to configure the <a href=\"https://registry.terraform.io/providers/hashicorp/nomad/latest\">Terraform provider for Nomad</a>.</p>\n<pre><code>data \"terraform_remote_state\" \"tfc\" {\n backend = \"remote\"\n config = {\n   organization = \"org name\"\n\n   workspaces = {\n     name = \"1-nomad-infrastructure\"\n   }\n }\n}</code></pre><p>The code above points to the Terraform workspace from part 1 of the series: <code>1-nomad-infrastructure</code>. This means you can access outputs from that workspace within this post’s workspace: <code>2-nomad-configuration</code>. The full code example of how you use this to configure the provider can be found <a href=\"https://github.com/devops-rob/vault-on-nomad-demo/blob/f57fa5bd70508d291bbd3b7dbddc4ee1a4869d8f/2-nomad-configuration/providers.tf#L26\">here</a>.</p>\n\n<h2>Nomad namespaces</h2>\n\n<p>Nomad has the concept of <a href=\"https://developer.hashicorp.com/nomad/tutorials/manage-clusters/namespaces\">namespaces</a>, which is a way to isolate jobs from one another. This allows you to create granular ACL policies specific to a namespace.</p>\n\n<p>The first thing you need to do is create a namespace for all of your jobs related to Vault management. The code below creates a namespace named <code>vault-cluster</code>:</p>\n<pre><code>resource \"nomad_namespace\" \"vault\" {\n name        = \"vault-cluster\"\n description = \"Vault servers namespace\"\n}</code></pre><h2>Nomad job for Vault cluster</h2>\n\n<p>The next step is to write a Nomad job. Deploy a 3-node Vault cluster with the following parameters:</p>\n\n<ul>\n<li>Each Vault server must run on a separate Nomad client.</li>\n<li>They can only run on Nomad clients in the <code>vault-servers</code> <a href=\"https://developer.hashicorp.com/nomad/docs/concepts/node-pools\">node pool</a>.</li>\n<li>Vault will run as a <a href=\"https://developer.hashicorp.com/nomad/docs/drivers/docker\">Docker job</a>.</li>\n<li>The job will use the <a href=\"https://developer.hashicorp.com/nomad/tutorials/stateful-workloads/stateful-workloads-host-volumes\">host volumes</a> configured on the Nomad clients to provide persistent storage for Vault.</li>\n</ul>\n\n<p>Below is the complete Nomad jobspec:</p>\n<pre><code>job \"vault-cluster\" {\n namespace   = \"vault-cluster\"\n datacenters = [\"dc1\"]\n type        = \"service\"\n node_pool   = \"vault-servers\"\n\n group \"vault\" {\n   count = 3\n\n   constraint {\n     attribute = \"${node.class}\"\n     value     = \"vault-servers\"\n   }\n\n   volume \"vault_data\" {\n     type      = \"host\"\n     source    = \"vault_vol\"\n     read_only = false\n   }\n\n   network {\n\n     mode = \"host\"\n\n     port \"api\" {\n       to     = \"8200\"\n       static = \"8200\"\n     }\n\n     port \"cluster\" {\n       to     = \"8201\"\n       static = \"8201\"\n     }\n   }\n\n   task \"vault\" {\n     driver = \"docker\"\n\n     volume_mount {\n       volume      = \"vault_data\"\n       destination = \"/vault/file\"\n       read_only   = false\n     }\n\n     config {\n       image   = \"hashicorp/vault:1.15\"\n       cap_add = [\"ipc_lock\"]\n\n       ports = [\n         \"api\",\n         \"cluster\"\n       ]\n\n       volumes = [\n         \"local/config:/vault/config\"\n       ]\n\n       command = \"/bin/sh\"\n       args = [\n         \"-c\",\n         \"vault operator init -status; if [ $? -eq 2 ]; then echo 'Vault is not initialized, starting in server mode...'; vault server -config=/vault/config; else echo 'Vault is already initialized, starting in server mode...'; vault server -config=/vault/config; fi\"\n       ]\n     }\n\n     template {\n       data = &lt;</code></pre><p>There are three layers to the jobspec: the <a href=\"https://developer.hashicorp.com/nomad/docs/job-specification\">job</a>, the <a href=\"https://developer.hashicorp.com/nomad/docs/job-specification/group\">groups</a>, and the <a href=\"https://developer.hashicorp.com/nomad/docs/job-specification/task\">tasks</a>. A job can have one or more groups within it. Each group is a collection of individual units of work that will all run on the same client. A task is an individual unit within a group. A group can have one or more tasks within it.</p>\n\n<p>Let's break down the jobspec above:</p>\n\n<h3>Job</h3>\n\n<p>The main specifications at the job layer are:</p>\n\n<ul>\n<li><strong>Namespace</strong>: Created in the previous step, it tells Nomad to run the job within this namespace.</li>\n<li><strong>Datacenters</strong>: Nomad has the concept of regions, which is an availability zone approach to managing compute. A region can have multiple datacenters. Clients and servers belong to datacenters. In the jobspec you are specifying that the job will run in the <code>dc1</code> datacenter. To read more about regions and datacenters, see the <a href=\"https://developer.hashicorp.com/nomad/docs/concepts/architecture\">Nomad architecture overview</a>.</li>\n<li><strong>Type</strong>: Nomad provides four different types of workload schedulers, <a href=\"https://developer.hashicorp.com/nomad/docs/schedulers#service\"><code>service</code></a>, <a href=\"https://developer.hashicorp.com/nomad/docs/schedulers#batch\"><code>batch</code></a>, <a href=\"https://developer.hashicorp.com/nomad/docs/schedulers#system-batch\"><code>sysbatch</code></a>, and <a href=\"https://developer.hashicorp.com/nomad/docs/schedulers#system-batch\"><code>system</code></a>. In this case you are using the service type because Vault should be a long-lived job that never goes down.</li>\n<li><strong>Node pool</strong>: The node pool specifies which pool of compute nodes the job can run on. You have a dedicated Vault node pool because you do not want other non-Vault related jobs to be scheduled on these Nomad clients.</li>\n</ul>\n\n<h3>Group</h3>\n\n<p>At the group layer you have the following specifications:</p>\n\n<ul>\n<li><strong>Count</strong>: This tells Nomad how many instances of the tasks within the group it should run concurrently. In this tutorial, you are running a 3-node Vault cluster and you have specified <code>3</code> as the value.</li>\n<li><strong>Constraint</strong>: This is a way to tell Nomad which nodes are eligible to run this job. For this tutorial, you want to constrain the job to nodes in the <code>vault-servers</code> <a href=\"https://developer.hashicorp.com/nomad/docs/concepts/scheduling/placement#node-class\">node class</a>. You also created a <code>vault-servers</code> node pool and you can also constrain the job to that.</li>\n<li><strong>Volume</strong>: This tells Nomad that the group requires a particular <a href=\"https://developer.hashicorp.com/nomad/docs/job-specification/volume\">volume</a> to run the tasks within it. There are two types of volumes in Nomad, <a href=\"https://developer.hashicorp.com/nomad/tutorials/stateful-workloads/stateful-workloads-host-volumes\">host volumes</a> and <a href=\"https://developer.hashicorp.com/nomad/tutorials/stateful-workloads/stateful-workloads-csi-volumes\">Container Storage Interface (CSI) volumes</a>. In this case you are using the host volumes that you created in part 1 when you deployed the Nomad clients. This is to ensure that if Vault restarts, its data will persist.</li>\n<li><strong>Network</strong>: This is where you can tell Nomad the <a href=\"https://developer.hashicorp.com/nomad/docs/job-specification/network\">network requirements</a> of the group.\n\n<ul>\n<li><strong>Mode</strong>: Nomad supports four different network modes: <a href=\"https://developer.hashicorp.com/nomad/docs/job-specification/network#none\"><code>none</code></a>, <a href=\"https://developer.hashicorp.com/nomad/docs/job-specification/network#bridge\"><code>bridge</code></a>, <a href=\"https://developer.hashicorp.com/nomad/docs/job-specification/network#host\"><code>host</code></a>, and <a href=\"https://developer.hashicorp.com/nomad/docs/job-specification/network#cni\"><code>Container Network Interface (CNI)</code></a>. In this case, you are running it using the host network mode, which means it will join the host's network namespace.</li>\n<li><strong>Port</strong>: As part of your network configuration, you need to tell Nomad which ports you need allocated to the tasks within the group. In this case, the Vault API runs on port <code>8200</code> and the cluster communications run on port <code>8201</code>. The job configuration above names these ports, so you can reference them later.</li>\n</ul></li>\n</ul>\n\n<h3>Task</h3>\n\n<p>The task level specifications include:</p>\n\n<ul>\n<li><strong>Driver</strong>: Nomad supports multiple driver types that allow you to schedule a wide variety of jobs. Because you want to run our Vault servers as containers, you are using the Docker driver. For more information about task drivers, see the <a href=\"https://developer.hashicorp.com/nomad/docs/drivers\">drivers documentation</a>.</li>\n<li><strong>Volume mount</strong>: This mounts the volume you specified at the group layer to the task and sets the task permissions on the volume. Since Vault will need to be able to write data to this volume, its <code>read_only</code> permission is set to <code>false</code>.</li>\n<li><strong>Config</strong>: The config block is where the bulk of the task configuration takes place.\n\n<ul>\n<li><strong>Image</strong>: As this is a Docker task, it needs to point to a Docker image. The <a href=\"https://hub.docker.com/r/hashicorp/vault\">Vault image</a> is publicly accessible so there is no additional configuration required for Nomad to be able to pull this image from the <a href=\"https://hub.docker.com/u/hashicorp\">Docker Hub registry</a>.</li>\n<li><strong>Cap add</strong>: The Vault container image by default will attempt to lock memory to prevent sensitive values from being swapped to disk and as a result must have the <code>ipc_lock</code> capability set to work. This capability is not allowed in Nomad by default and must be explicitly enabled in the client configuration file.</li>\n<li><strong>Ports</strong>: This adds the ports created at the group layer to the task. As mentioned before, naming the ports means they can be referenced in the task layer. In this case, the <code>api</code> and <code>cluster</code> ports are attached to the task.</li>\n<li><strong>Volumes</strong>: The volume created at the group layer was mounted to the task; however, this volume is not yet exposed inside the container due to the nature of how containers operate. Because they are isolated units of work, the volume mount needs to be further mounted within the container itself. This piece of configuration takes care of that.</li>\n<li><strong>Command</strong>: In order to start the Vault server within the container, a command needs to be run inside the container with an argument that is essentially a small bash script.</li>\n<li><strong>Args</strong>: This one-liner script checks the seal status of Vault and advises on whether it is initialized or not. Either way, it starts Vault in server mode. This script is useful for troubleshooting startup issues with the server.</li>\n<li><strong>Template</strong>: This is where a lot of the magic happens to configure each Vault server. Nomad has a built-in <a href=\"https://developer.hashicorp.com/nomad/docs/job-specification/template\">templating engine</a> that renders files for jobs. In this case, it renders a Vault config file for each server. This is useful because without it, you would need to hard code some values, many of which you do not know upfront.</li>\n<li><strong>Range function</strong>: The templating engine includes a range function, which is very similar to the <a href=\"https://go.dev/tour/moretypes/16\">range loop in Go</a>. This loops over a list of things, in this case the Nomad service called Vault, then creates a <code>retry_join</code> stanza for each instance using the <code>.Address</code> and <code>.Port</code> values it retrieves from the service to populate the stanza. More on the Nomad service registration in the next section.</li>\n<li><strong>Runtime environment variables</strong>: Nomad exposes a series of <a href=\"https://developer.hashicorp.com/nomad/docs/runtime/environment\">runtime environment variables</a> that can be accessed and used as part of the template. In this case, the <code>cluster_addr</code> and <code>api_addr</code> configuration values are partially set using these variables to populate the IP address of the node.</li>\n<li><strong>Destination</strong>: This tells Nomad where to write the file it renders from this template.</li>\n<li><strong>Change Mode</strong>: This configuration option tells Nomad how to handle file changes. In this case, the template is using runtime variables to render the file. If these values were to change, a new file would be rendered. This configuration tells Nomad what to do if that occurs. For example, Nomad could restart the job using the new file. In this case, Vault running on Nomad has been configured in a very static way (static ports, static IP addresses) so the job does not need to restart, hence why the <a href=\"https://developer.hashicorp.com/nomad/docs/job-specification/template#noop\"><code>noop</code></a> option has been chosen. Other configuration options are <a href=\"https://developer.hashicorp.com/nomad/docs/job-specification/template#signal\"><code>signal</code></a>, <a href=\"https://developer.hashicorp.com/nomad/docs/job-specification/template#restart\"><code>restart</code></a>, and <a href=\"https://developer.hashicorp.com/nomad/docs/job-specification/template#script\"><code>script</code></a>.</li>\n<li><strong>Service</strong>: Nomad supports two service registration providers. The first is the built-in <a href=\"https://www.hashicorp.com/blog/nomad-service-discovery\">Nomad service registry</a>, and the other is <a href=\"https://developer.hashicorp.com/nomad/docs/integrations/consul\">Consul service mesh</a>. In this case, the built-in Nomad provider is being used. It registers a service called <code>vault</code>, using the <code>api</code> port specified at the group layer.</li>\n<li><strong>Check</strong>: This is an optional health check that can be run to determine if the service should be marked as healthy.\n\n<ul>\n<li><strong>Type</strong>: Because this tutorial is using the Nomad built-in service registry, there are two types of health checks that are supported, <code>http</code>, and <code>tcp</code>. In this case, the health check is an API call to a Vault endpoint so <code>http</code> has been specified.</li>\n<li><strong>Path</strong>: This specifies the endpoint to call for the health check. Out of the box, Vault uses these <a href=\"https://developer.hashicorp.com/vault/api-docs/system/health\">standard responses</a>. Vault could be uninitialized and sealed, which would normally return a <code>501</code> for an uninitialized node, and a <code>503</code> for a sealed node. This would mark the service as unhealthy, so to get around that issue, there are a series of <a href=\"https://developer.hashicorp.com/vault/api-docs/system/health#parameters\">parameters</a> that can be added to the path that ensure that Vault responds with a <code>204</code> code for sealed and uninitialized nodes, and a <code>200</code> code for standby nodes.</li>\n<li><strong>Interval</strong>: This configuration specifies the interval between each health check.</li>\n<li><strong>Timeout</strong>: For each health check, if it does not respond within a certain timeframe, it is best for it to timeout. This configuration specifies what that timeout threshold should be.</li>\n</ul></li>\n<li><strong>Resources</strong>: This configuration specifies the CPU and memory requirements for each instance of the task. This can be adjusted according to individual requirements and based on the compute available.</li>\n<li><strong>Affinity</strong> - This is how task placement preference is specified. In this case, there are three nodes in the node pool and there should only be one task running on each node. This configuration uses runtime variables to express this and ensure the desired outcome is met.</li>\n</ul></li>\n</ul>\n\n<h2>Vault configuration file</h2>\n\n<p>In the last section, I went through the Nomad templating configuration to render the Vault configuration file.</p>\n<pre><code>ui = true\n\nlistener \"tcp\" {\n address         = \"[::]:8200\"\n cluster_address = \"[::]:8201\"\n tls_disable     = \"true\"\n}\n\nstorage \"raft\" {\n path    = \"/vault/file\"\n retry_join {\n   leader_api_addr = \"http://10.0.101.190:8200\"\n }\n retry_join {\n   leader_api_addr = \"http://10.0.101.233:8200\"\n }\n retry_join {\n   leader_api_addr = \"http://10.0.101.162:8200\"\n }\n}\n\ncluster_addr = \"http://10.0.101.162:8201\"\napi_addr     = \"http://10.0.101.162:8200\"</code></pre><p>The above snippet is the rendered Vault configuration file from the Nomad template. I'll break down the different configurations:</p>\n\n<ul>\n<li><strong>UI</strong>: This setting configures whether the Vault UI is enabled.</li>\n<li><strong>Listener</strong>: Vault supports two types of listeners, <a href=\"https://developer.hashicorp.com/vault/docs/configuration/listener/tcp\"><code>tcp</code></a> and <a href=\"https://developer.hashicorp.com/vault/docs/configuration/listener/unix\"><code>unix</code></a>. The purpose of the listener is to tell Vault what address and ports to listen to for cluster operation and api call requests. TLS specifics for the listener can also be configured here; however, as this is a demo, I have not enabled TLS.</li>\n<li><strong>Storage</strong>: Vault needs to store its secrets somewhere. For that, it uses <a href=\"https://developer.hashicorp.com/vault/docs/configuration/storage\">storage backends</a>. Vault supports 23 storage backends, each with their own pros and cons. Most backends are decoupled from Vault except the <a href=\"https://developer.hashicorp.com/vault/docs/configuration/storage/raft\">Raft integrated storage</a> and <a href=\"https://developer.hashicorp.com/vault/docs/configuration/storage/in-memory\">in-memory</a> backends, which are both coupled with Vault. In this case, Raft is being used because it lowers the complexity of management and allows high availability (HA) by replicating its data to all Vault servers in the cluster.\n\n<ul>\n<li><strong>Path</strong>: Since the Raft storage backend is being used, it needs to know where to store its data. This configuration option gives it the path to use for this purpose.</li>\n<li><strong>Retry join</strong>: Raft supports HA and does this by creating a cluster using the <a href=\"https://en.wikipedia.org/wiki/Raft_(algorithm)\">Raft algorithm</a>. The series of <code>retry_join</code> stanzas tell Vault which addresses it should contact to attempt to join the cluster.</li>\n</ul></li>\n<li><strong>Cluster addr</strong>: This configuration tells Vault what address and port to advertise to other nodes in the cluster when forwarding requests.</li>\n<li><strong>API addr</strong>: This configuration tells Vault what address and port to advertise to other nodes in the cluster when redirecting clients.</li>\n</ul>\n\n<p>For a full set of Vault configuration options, see the <a href=\"https://developer.hashicorp.com/vault/docs/configuration\">server configuration documentation</a>.</p>\n\n<h2>Deploying the Vault Nomad job</h2>\n\n<p>With the Nomad jobspec complete, Vault can now be deployed to Nomad. The Terraform code below will read the jobspec file and run it on Nomad:</p>\n<pre><code>resource \"nomad_job\" \"vault\" {\n jobspec = file(\"vault.nomad\")\n depends_on = [\n   nomad_namespace.vault\n ]\n}</code></pre><p>There is an explicit dependency on the namespace resource declared here to ensure Terraform does not try to deploy this job until the namespace is in place.</p>\n\n<h2>Initializing Vault</h2>\n\n<p>So far, the steps taken will provide three Vault servers running on different VMs, but the cluster is not yet formed because Vault has not been initialized and unsealed. The first server to be initialized and unsealed will become the cluster leader and the following two servers will join that cluster. The <a href=\"https://registry.terraform.io/providers/hashicorp/vault/latest/docs\">Terraform provider for Vault</a> does not have the ability to perform these actions by design so instead, TerraCurl can be used. Now to initialize Vault.</p>\n<pre><code>resource \"terracurl_request\" \"init\" {\n method         = \"POST\"\n name           = \"init\"\n response_codes = [200]\n url            = \"http://${data.terraform_remote_state.tfc.outputs.nomad_clients_public_ips[0]}:8200/v1/sys/init\"\n\n request_body   = &lt;</code></pre><p>This will make an API call to the first node in the pool to initialize it.</p>\n\n<ul>\n<li>It expects a <code>200</code> response to the call.</li>\n<li>The call is made to the <code>/v1/sys/init</code> endpoint.</li>\n<li>It specifies that the <a href=\"https://developer.hashicorp.com/vault/docs/concepts/seal#shamir-seals\">master key</a> should be split into 3 shards and will require a minimum of any 2 of these shards to unseal Vault.</li>\n</ul>\n\n<p>Vault will respond by returning 3 unseal keys and a root token.</p>\n\n<h2>Storing unseal keys in Nomad variables</h2>\n\n<p>Now that Vault has been initialized, the unseal keys and root token need to be stored as Nomad variables. <a href=\"https://developer.hashicorp.com/nomad/docs/concepts/variables\">Nomad variables</a> are encrypted key/value pairs that can be used by Nomad jobs. They have full ACL support meaning that granular policies can be written to ensure that only authorized entities are able to access them.</p>\n<pre><code>resource \"nomad_variable\" \"unseal\" {\n path      = \"nomad/jobs/vault-unsealer\"\n namespace = \"vault-cluster\"\n\n items = {\n   key1       = jsondecode(terracurl_request.init.response).keys[0]\n   key2       = jsondecode(terracurl_request.init.response).keys[1]\n   key3       = jsondecode(terracurl_request.init.response).keys[2]\n }\n}</code></pre><p>This Nomad variable is only accessible to the <code>vault-unsealer</code> job and the job must be running within the <code>vault-cluster</code> namespace.</p>\n\n<h2>Summary</h2>\n\n<p>This blog post has shown how to deploy a 3-node Vault cluster as a Nomad job. It has also taken a deep dive into Nomad, different aspects of the jobspec file including templates and runtime variables, and also Vault server configurations. Part 3 of this blog series will explore deploying some automation to assist in the day-to-day operations of Vault on Nomad.</p>\n","author":"Rob Barnes","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"30306dfca1b7918e25ad184ad687f44325b34f16f152ac0d8d256c784b80226b","category":"Tech"}