{"title":"Vanilla JavaScript, Libraries, And The Quest For Stateful DOM Rendering","link":"https://smashingmagazine.com/2024/02/vanilla-javascript-libraries-quest-stateful-dom-rendering/","date":1708624800000,"content":"<p>In his seminal piece “<a href=\"https://infrequently.org/2023/02/the-market-for-lemons/\">The Market For Lemons</a>”, renowned web crank Alex Russell lays out the myriad failings of our industry, focusing on the disastrous consequences for end users. This indignation is entirely appropriate according to the <a href=\"https://www.w3.org/TR/html-design-principles/#priority-of-constituencies\">bylaws of our medium</a>.</p>\n<p>Frameworks factor highly in that equation, yet there can also be good reasons for front-end developers to choose a framework, <a href=\"https://johan.hal.se/wrote/2023/02/17/what-to-expect-from-your-framework/\">or library</a> for that matter: Dynamically updating web interfaces can be tricky in non-obvious ways. Let’s investigate by starting from the beginning and going back to the first principles.</p>\nMarkup Categories\n<p>Everything on the web starts with markup, i.e. HTML. Markup structures can roughly be divided into three categories:</p>\n<ol>\n<li>Static parts that always remain the same.</li>\n<li>Variable parts that are defined once upon instantiation.</li>\n<li>Variable parts that are updated dynamically at runtime.</li>\n</ol>\n<p>For example, an article’s header might look like this:</p>\n<pre><code>&lt;header&gt;\n  &lt;h1&gt;«Hello World»&lt;/h1&gt;\n  &lt;small&gt;«123» backlinks&lt;/small&gt;\n&lt;/header&gt;\n</code></pre>\n\n<p>Variable parts are wrapped in «guillemets» here: “Hello World” is the respective title, which only changes between articles. The backlinks counter, however, might be continuously updated via client-side scripting; we’re ready to go viral in the blogosphere. Everything else remains identical across all our articles.</p>\n<p>The article you’re reading now subsequently focuses on the third category: Content that needs to be updated at runtime.</p>\nColor Browser\n<p>Imagine we’re building a simple color browser: A little widget to explore a pre-defined set of <a href=\"https://www.w3.org/TR/css-color-3/#svg-color\">named colors</a>, presented as a list that pairs a color swatch with the corresponding color value. Users should be able to search colors names and toggle between hexadecimal color codes and Red, Blue, and Green (RGB) triplets. We can create an <a href=\"https://web.archive.org/web/20130924061832/http://alistair.cockburn.us/Walking+skeleton\">inert skeleton</a> with just a little bit of HTML and CSS:</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/RwdmbGd\">Color Browser (inert) [forked]</a> by <a href=\"https://codepen.io/f-n-d\">FND</a>.</p>\nClient-Side Rendering\n<p>We’ve grudgingly decided to employ client-side rendering for the interactive version. For our purposes here, it doesn’t matter whether this widget constitutes a complete application or merely a <a href=\"https://jasonformat.com/islands-architecture\">self-contained island</a> embedded within an otherwise static or server-generated HTML document.</p>\n<p>Given our predilection for vanilla JavaScript (cf. first principles and all), we start with the browser’s built-in DOM APIs:</p>\n<pre><code>function renderPalette(colors) {\n  let items = [];\n  for(let color of colors) {\n    let item = document.createElement(\"li\");\n    items.push(item);\n\n    let value = color.hex;\n    makeElement(\"input\", {\n      parent: item,\n      type: \"color\",\n      value\n    });\n    makeElement(\"span\", {\n      parent: item,\n      text: color.name\n    });\n    makeElement(\"code\", {\n      parent: item,\n      text: value\n    });\n  }\n\n  let list = document.createElement(\"ul\");\n  list.append(...items);\n  return list;\n}\n</code></pre>\n\n<blockquote><strong>Note:</strong><br />The above relies on a small utility function for more concise element creation:<br />\n<pre><code>function makeElement(tag, { parent, children, text, ...attribs }) {\n  let el = document.createElement(tag);\n\n  if(text) {\n    el.textContent = text;\n  }\n\n  for(let [name, value] of Object.entries(attribs)) {\n    el.setAttribute(name, value);\n  }\n\n  if(children) {\n    el.append(...children);\n  }\n\n  parent?.appendChild(el);\n  return el;\n}\n</code></pre>\nYou might also have noticed a stylistic inconsistency: Within the <code>items</code> loop, newly created elements attach themselves to their container. Later on, we flip responsibilities, as the <code>list</code> container ingests child elements instead.</blockquote>\n\n<p>Voilà: <code>renderPalette</code> generates our list of colors. Let’s add a form for interactivity:</p>\n<pre><code>function renderControls() {\n  return makeElement(\"form\", {\n    method: \"dialog\",\n    children: [\n      createField(\"search\", \"Search\"),\n      createField(\"checkbox\", \"RGB\")\n    ]\n  });\n}\n</code></pre>\n\n<p>The <code>createField</code> utility function encapsulates DOM structures required for input fields; it’s a little reusable markup component:</p>\n<pre><code>function createField(type, caption) {\n  let children = [\n    makeElement(\"span\", { text: caption }),\n    makeElement(\"input\", { type })\n  ];\n  return makeElement(\"label\", {\n    children: type === \"checkbox\" ? children.reverse() : children\n  });\n}\n</code></pre>\n\n<p>Now, we just need to combine those pieces. Let’s wrap them in a custom element:</p>\n<div>\n<pre><code>import { COLORS } from \"./colors.js\"; // an array of <code>{ name, hex, rgb }</code> objects\n\ncustomElements.define(\"color-browser\", class ColorBrowser extends HTMLElement {\n  colors = [...COLORS]; // local copy\n\n  connectedCallback() {\n    this.append(\n      renderControls(),\n      renderPalette(this.colors)\n    );\n  }\n});\n</code></pre>\n</div>\n\n<p>Henceforth, a <code>&lt;color-browser&gt;</code> element anywhere in our HTML will generate the entire user interface right there. (I like to think of it as a <a href=\"https://en.wikipedia.org/wiki/Macro_%28computer_science%29\">macro</a> expanding in place.) This implementation is somewhat declarative1, with DOM structures being created by composing a variety of straightforward markup generators, clearly delineated components, if you will.</p>\n<p>1 The most useful explanation of the differences between declarative and imperative programming I’ve come across focuses on readers. Unfortunately, that particular source escapes me, so I’m paraphrasing here: Declarative code portrays the <em>what</em> while imperative code describes the <em>how</em>. One consequence is that imperative code requires cognitive effort to sequentially step through the code’s instructions and build up a mental model of the respective result.</p>\n\n\n\nInteractivity\n<p>At this point, we’re merely recreating our inert skeleton; there’s no actual interactivity yet. Event handlers to the rescue:</p>\n<pre><code>class ColorBrowser extends HTMLElement {\n  colors = [...COLORS];\n  query = null;\n  rgb = false;\n\n  connectedCallback() {\n    this.append(renderControls(), renderPalette(this.colors));\n    this.addEventListener(\"input\", this);\n    this.addEventListener(\"change\", this);\n  }\n\n  handleEvent(ev) {\n    let el = ev.target;\n    switch(ev.type) {\n    case \"change\":\n      if(el.type === \"checkbox\") {\n        this.rgb = el.checked;\n      }\n      break;\n    case \"input\":\n      if(el.type === \"search\") {\n        this.query = el.value.toLowerCase();\n      }\n      break;\n    }\n  }\n}\n</code></pre>\n\n<blockquote><strong>Note:</strong><br /><code>handleEvent</code> means we don’t have to <a href=\"https://gomakethings.com/the-handleevent-method-is-the-absolute-best-way-to-handle-events-in-web-components/\">worry about function binding</a>. It also comes with <a href=\"https://web.archive.org/web/20240121164212/https://scribe.rip/webreflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38#a0ff\">various advantages</a>. Other patterns are available.</blockquote>\n\n<p>Whenever a field changes, we update the corresponding instance variable (sometimes called one-way data binding). Alas, changing this internal state2 is not reflected anywhere in the UI so far.</p>\n<p>2 In your browser’s developer console, check <code>document.querySelector(\"color-browser\").query</code> after entering a search term.</p>\n\n<p>Note that this event handler is tightly coupled to <code>renderControls</code> internals because it expects a checkbox and search field, respectively. Thus, any corresponding changes to <code>renderControls</code> — perhaps switching to radio buttons for color representations — now need to take into account this other piece of code: <a href=\"https://en.wikipedia.org/wiki/Action_at_a_distance_%28computer_programming%29\">action at a distance</a>! Expanding this component’s contract to include\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#name\">field names</a> could alleviate those concerns.</p>\n<p>We’re now faced with a choice between:</p>\n<ol>\n<li>Reaching into our previously created DOM to modify it, or</li>\n<li>Recreating it while incorporating a new state.</li>\n</ol>\nRerendering\n<p>Since we’ve already defined our markup composition in one place, let’s start with the second option. We’ll simply rerun our markup generators, feeding them the current state.</p>\n<pre><code>class ColorBrowser extends HTMLElement {\n  // [previous details omitted]\n\n  connectedCallback() {\n    this.#render();\n    this.addEventListener(\"input\", this);\n    this.addEventListener(\"change\", this);\n  }\n\n  handleEvent(ev) {\n    // [previous details omitted]\n    this.#render();\n  }\n\n  #render() {\n    this.replaceChildren();\n    this.append(renderControls(), renderPalette(this.colors));\n  }\n}\n</code></pre>\n\n<p>We’ve moved all rendering logic into a dedicated method3, which we invoke not just once on startup but whenever the state changes.</p>\n<p>3 You might want to <a href=\"https://lea.verou.me/blog/2023/04/private-fields-considered-harmful/\">avoid private properties</a>, especially if others might conceivably build upon your implementation.</p>\n\n<p>Next, we can turn <code>colors</code> into a getter to only return entries matching the corresponding state, i.e. the user’s search query:</p>\n<div>\n<pre><code>class ColorBrowser extends HTMLElement {\n  query = null;\n  rgb = false;\n\n  // [previous details omitted]\n\n  get colors() {\n    let { query } = this;\n    if(!query) {\n      return [...COLORS];\n    }\n\n    return COLORS.filter(color =&gt; color.name.toLowerCase().includes(query));\n  }\n}\n</code></pre>\n</div>\n\n<blockquote><strong>Note:</strong><br />I’m partial to the <a href=\"https://rikschennink.nl/thoughts/the-bouncer-pattern/\">bouncer pattern</a>.<br />Toggling color representations is left as an exercise for the reader. You might pass <code>this.rgb</code> into <code>renderPalette</code> and then populate <code>&lt;code&gt;</code> with either <code>color.hex</code> or <code>color.rgb</code>, perhaps employing this utility:<br />\n<pre><code>function formatRGB(value) {\n  return value.split(\",\").\n    map(num =&gt; num.toString().padStart(3, \" \")).\n    join(\", \");\n}\n</code></pre></blockquote>\n\n<p>This now produces interesting (annoying, really) behavior:</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/YzgbKab\">Color Browser (defective) [forked]</a> by <a href=\"https://codepen.io/f-n-d\">FND</a>.</p>\n<p>Entering a query seems impossible as the input field loses focus after a change takes place, leaving the input field empty. However, entering an uncommon character (e.g. “v”) makes it clear that <em>something</em> is happening: The list of colors does indeed change.</p>\n<p>The reason is that our current do-it-yourself (DIY) approach is quite crude: <code>#render</code> erases and recreates the DOM wholesale with each change. Discarding existing DOM nodes also resets the corresponding state, including form fields’ value, focus, and scroll position. That’s no good!</p>\nIncremental Rendering\n<p>The previous section’s <a href=\"https://rauchg.com/2015/pure-ui\">data-driven UI</a> seemed like a nice idea: Markup structures are defined once and re-rendered at will, based on a data model cleanly representing the current state. Yet our component’s explicit state is clearly insufficient; we need to reconcile it with the browser’s implicit state while re-rendering.</p>\n<p>Sure, we might attempt to make that <em>implicit</em> state <em>explicit</em> and incorporate it into our data model, like including a field’s <code>value</code> or <code>checked</code> properties. But that still leaves many things unaccounted for, including focus management, scroll position, and <a href=\"https://daverupert.com/2024/02/ui-states/\">myriad details</a> we probably haven’t even thought of (frequently, that means accessibility features). Before long, we’re effectively recreating the browser!</p>\n<p>We might instead try to identify which parts of the UI need updating and leave the rest of the DOM untouched. Unfortunately, that’s far from trivial, which is where libraries like React came into play more than a decade ago: On the surface, they provided a more declarative way to define DOM structures4 (while also encouraging componentized composition, establishing a single source of truth for each individual UI pattern). Under the hood, such libraries introduced mechanisms5 to provide granular, incremental DOM updates instead of recreating DOM trees from scratch — both to avoid state conflicts and to improve performance6.</p>\n<p>4 In this context, that essentially means writing something that looks like HTML, which, <a href=\"https://en.wikipedia.org/wiki/False_equivalence\">depending on your belief system</a>, is either essential or revolting. The state of HTML templating was somewhat dire back then and remains subpar in some environments.<br />5 Nolan Lawson’s “<a href=\"https://nolanlawson.com/2023/12/02/lets-learn-how-modern-javascript-frameworks-work-by-building-one/\">Let’s learn how modern JavaScript frameworks work by building one</a>” provides plenty of valuable insights on that topic. For even more details, <a href=\"https://github.com/lit/lit/blob/9c02b3876dc927c6a82b4420411256ecbb47c08c/dev-docs/design/how-lit-html-works.md\">lit-html’s developer documentation</a> is worth studying.<br />6 We’ve since learned that <em>some</em> of those mechanisms are actually <a href=\"https://infrequently.org/2024/01/performance-inequality-gap-2024/\">ruinously expensive</a>.</p>\n\n<p>The bottom line: <strong>If we want to encapsulate markup definitions and then derive our UI from a variable data model, we kinda have to rely on a third-party library for reconciliation.</strong></p>\nActus Imperatus\n<p>At the other end of the spectrum, we might opt for surgical modifications. If we know what to target, our application code can reach into the DOM and modify only those parts that need updating.</p>\n<p>Regrettably, though, that approach typically leads to calamitously tight coupling, with interrelated logic being spread all over the application while targeted routines inevitably violate components’ encapsulation. Things become even more complicated when we consider increasingly complex UI permutations (think edge cases, error reporting, and so on). Those are the very issues that the aforementioned libraries had hoped to eradicate.</p>\n<p>In our color browser’s case, that would mean finding and hiding color entries that do not match the query, not to mention replacing the list with a substitute message if no matching entries remain. We’d also have to swap color representations in place. You can probably imagine how the resulting code would end up dissolving any separation of concerns, messing with elements that originally belonged exclusively to <code>renderPalette</code>.</p>\n<div>\n<pre><code>class ColorBrowser extends HTMLElement {\n  // [previous details omitted]\n\n  handleEvent(ev) {\n    // [previous details omitted]\n\n    for(let item of this.#list.children) {\n      item.hidden = !item.textContent.toLowerCase().includes(this.query);\n    }\n    if(this.#list.children.filter(el =&gt; !el.hidden).length === 0) {\n      // inject substitute message\n    }\n  }\n\n  #render() {\n    // [previous details omitted]\n\n    this.#list = renderPalette(this.colors);\n  }\n}\n</code></pre>\n</div>\n\n<p>As a <a href=\"https://en.wikipedia.org/wiki/Has_Been\">once wise man</a> once said: That’s too much knowledge!</p>\n<p>Things get even more perilous with form fields: Not only might we have to update a field’s specific state, but we would also need to know where to inject error messages. While reaching into <code>renderPalette</code> was bad enough, here we would have to pierce several layers: <code>createField</code> is a generic utility used by <code>renderControls</code>, which in turn is invoked by our top-level <code>ColorBrowser</code>.</p>\n<p>If things get hairy even in this minimal example, imagine having a more complex application with even more layers and indirections. Keeping on top of all those interconnections becomes all but impossible. Such systems commonly devolve into a big ball of mud where nobody dares change anything for fear of inadvertently breaking stuff.</p>\nConclusion\n<p>There appears to be a glaring omission in standardized browser APIs. Our preference for dependency-free vanilla JavaScript solutions is thwarted by the need to non-destructively update existing DOM structures. That’s assuming we value a declarative approach with inviolable encapsulation, otherwise known as “Modern Software Engineering: The Good Parts.”</p>\n<p>As it currently stands, my personal opinion is that a small library like lit-html or Preact is often warranted, particularly when employed with <a href=\"https://adactio.com/journal/20837\">replaceability</a> in mind: A standardized API might still happen! Either way, <a href=\"https://infrequently.org/2023/02/the-market-for-lemons/#fn-alex-approved-1\">adequate libraries</a> have a light footprint and don’t typically present much of an encumbrance to end users, especially when combined with <a href=\"https://cloudfour.com/thinks/html-web-components-are-having-a-moment/\">progressive enhancement</a>.</p>\n<p>I don’t wanna leave you hanging, though, so I’ve tricked our vanilla JavaScript implementation to <em>mostly</em> do what we expect it to:</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/vYPwBro\">Color Browser [forked]</a> by <a href=\"https://codepen.io/f-n-d\">FND</a>.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"8ecfd36964f33118d0cd75d686670df7514036de5c14096f6e9b3f1035cfc521","category":"Tech"}