{"title":"Full Stack GraphQL With Next.js, Neo4j AuraDB And Vercel","link":"https://smashingmagazine.com/2023/03/full-stack-graphql-nextjs-neo4j-auradb-vercel/","date":1678960800000,"content":"<p>This article is a sponsored by <a href=\"https://srv.buysellads.com/ads/long/x/TCZPLYDDTTTTTTFR6JINCTTTTTTGPUIVKKTTTTTTCT2NTYYTTTTTTBSEP3H6KN4FKWYNLEZCVQAF5OZNFHIU4RPY27HE\">Neo4j</a></p>\n<p>Recently I was chatting with some folks about a book I wrote last year titled <a href=\"https://dev.neo4j.com/graphql-book\"><em>Full Stack GraphQL Applications</em></a>. In the book, we demonstrate how to use GraphQL, React.js, and Neo4j to build and deploy full stack applications. One of the most common questions I get from readers is, “Can we use Next.js with this stack?” Next.js is a powerful React framework that adds many additional features and conventions on top of React, so the answer is “Of course!” </p>\n<p>In this article, we will explore how to build a full stack GraphQL application that takes advantage of the API Routes feature of Next.js API to combine our GraphQL server and front-end React applications into a single framework.</p>\n<p>We’ll use the Neo4j graph database as our data source. Graph databases like Neo4j use the property graph model to enable developers to model, store, and query data as a graph. Both graph databases and GraphQL use the concept of a ‘graph’ to work with application data, making them perfect to use together. The open source <a href=\"https://neo4j.com/product/graphql-library/\">Neo4j GraphQL Library</a> makes it even easier to build GraphQL APIs backed by Neo4j, as I’ll illustrate in this article. </p>\n<p>Let’s see how to leverage the power of graph data by working with graphs in a full stack GraphQL application with Next.js, Neo4j, and Vercel!</p>\nNeo4j AuraDB Overview: Graph Data In The Cloud\n<p>First, we’ll set up our database. The easiest way to get started with Neo4j is by using the free tier of <a href=\"https://dev.neo4j.com/neo4j-aura\">Neo4j AuraDB</a>, Neo4j’s cloud database service. The free tier allows us to spin up a Neo4j cluster for building applications without a credit card. We can also choose from several sample datasets to get started. We’ll choose to load the “Graph-based Recommendations” dataset. This dataset contains information about movies and user ratings to demonstrate approaches for personalized recommendations, a common use case for graph databases.</p>\n<p><img src=\"https://files.smashing.media/articles/full-stack-graphql-nextjs-neo4j-auradb-vercel/8-neo4j-auradb-cloud-database-service.png\" /></p>\n<p>While our database is being provisioned, we’ll be presented with a randomly generated password and the option to download a <code>.env</code> file that contains the connection credentials for our newly created database. Be sure to download this file, as we’ll use it to set environment variables in our Next.js application.</p>\n<div>\n\n<pre><code># Wait 60 seconds before connecting using these details, or login to <a href=\"https://console.neo4j.io\">https://console.neo4j.io</a> to validate the Aura Instance is available\nNEO4J_URI=neo4j+s://2826d3f8.databases.neo4j.io\nNEO4J_USERNAME=neo4j\nNEO4J_PASSWORD=vePwrRzzD23JjCug5tLSPF-pBNsmocHQ45hOc11d6ZY\nAURA_INSTANCENAME=Instance01\n</code></pre>\n</div>\n\n<p>Once our database is ready, click the Open button to start exploring the data in Neo4j Workspace. Neo4j uses the <a href=\"https://neo4j.com/developer/cypher/\">Cypher query language</a> to interact with the database. The ‘Query’ tab allows us to execute Cypher statements and visualize the results as a graph. Cypher allows us to declaratively define graph patterns using ASCII-art notation. Later, we’ll see how we can use Cypher to find movie recommendations, but for now, this example demonstrates how to filter for a movie by title and traverse the graph to find the actors and genres of the movie as well.</p>\n<p><img src=\"https://files.smashing.media/articles/full-stack-graphql-nextjs-neo4j-auradb-vercel/7-query-tab-cypher-statements-graph.png\" /></p>\n<p>Now that we have our database up and running, we can start to think about the API layer. To build our movies search application, we don’t want just to expose our database to the world — we want an API application to act as a type of gatekeeper, handling things like authorization and business logic. Thanks to a feature of Next.js called <a href=\"https://nextjs.org/docs/api-routes/introduction\">API routes</a>, we can combine our GraphQL API application and our React front-end application in a single Next.js project.</p>\nGetting Started With Next.js\n<p>One of the easiest ways to get started with Next.js is with the <code>create-next-app</code> command line tool. This tool will ask us a few questions to help us create a skeleton Next.js project.</p>\n<pre><code>npx create-next-app fullstack-graphql-movies\n</code></pre>\n\n<p>This will generate a Next.js project with the following structure:</p>\n<pre><code>├── README.md\n├── jsconfig.json\n├── next.config.js\n├── package-lock.json\n├── package.json\n├── pages\n│   ├── _app.js\n│   ├── _document.js\n│   ├── api\n│   │   └── hello.js\n│   └── index.js\n├── public\n│   ├── favicon.ico\n│   ├── next.svg\n│   ├── thirteen.svg\n│   └── vercel.svg\n└── styles\n    ├── Home.module.css\n    └── globals.css\n</code></pre>\n\n<p>We will concern ourselves mostly with the files in the pages directory. With the Next.js file-based routing feature, any files we add to the pages directory will be given their own route using the filename. Let’s start our Next.js application by running the following command:</p>\n<pre><code>npm run dev\n</code></pre>\n\n<p>This will launch a local web server and serve our Next.js application at <code>http://localhost:3000</code> by default. If we go to this address, we’ll see the default Next.js splash screen. The code for this page can be found in <code>pages/index.js</code>.</p>\n<p>If we navigate in our web browser to <a href=\"http://localhost:3000/api/hello\"><code>http://localhost:3000/api/hello</code></a>, we’ll see an example of a Next.js API route.</p>\n<pre><code>{\n  name: \"John Doe\"\n}\n</code></pre>\n\n<p>If we examine the code at <code>pages/api/hello.js</code>, we can see the logic powering this API endpoint, defined as a single function:</p>\n<div>\n\n<pre><code>// Next.js API route support: <a href=\"https://nextjs.org/docs/api-routes/introduction\">https://nextjs.org/docs/api-routes/introduction</a>\n\nexport default function handler(req, res) {\n  res.status(200).json({ name: 'John Doe' })\n}\n</code></pre>\n</div>\n\n<p>Similar to its parent pages directory, any file created in the API directory results in a new endpoint matching the name of the file. Unlike pages that define React components, the API directory defines new API routes which can be deployed as serverless functions. </p>\n<p>In the next section, we’ll learn how to create a GraphQL server using a Next.js API route and the <a href=\"https://neo4j.com/product/graphql-library/\">Neo4j GraphQL Library</a>.</p>\n<p>First, let’s bring over the <code>.env</code> file we downloaded from Aura and rename it <code>.env.local</code> in the root directory of our project. Next.js supports setting environment variables using <code>.env</code> files by default, so we’ll be able to use our Neo4j AuraDB credentials in our API route to connect to the database. </p>\nBuilding A Serverless GraphQL Server With Next.js API Routes\n<p>Now we’re ready to build our GraphQL API application as a Next.js API route. First, let’s install some dependencies, including the <a href=\"https://neo4j.com/product/graphql-library/\">Neo4j GraphQL Library</a> and <a href=\"https://the-guild.dev/graphql/yoga-server\">GraphQL Yoga</a>.</p>\n<pre><code>npm install graphql-yoga @neo4j/graphql graphql neo4j-driver\n</code></pre>\n\n<p>Since <a href=\"https://the-guild.dev/graphql/yoga-server/docs/integrations/integration-with-nextjs\">GraphQL Yoga supports Next.js API Routes</a>, we’ll use it as our GraphQL ‘server’ framework. We’re going to use the Neo4j GraphQL Library to generate a full GraphQL API, including database queries, using just GraphQL type definitions. Let’s create a new file, <code>graphql.js</code>, in the API directory.</p>\n<p>We saw the graph data model containing movies, actors, and genres for our movie’s dataset above, so we’ll write GraphQL-type definitions to match.</p>\n<div>\n\n<pre><code> type Movie {\n    title: String!\n    plot: String\n    poster: String\n    imdbRating: Float\n    actors: [Actor!]! @relationship(type: \"ACTED_IN\", direction: IN)\n    genres: [Genre!]! @relationship(type: \"IN_GENRE\", direction: OUT)\n  }\n\n  type Genre {\n    name: String!\n    movies: [Movie!]! @relationship(type: \"IN_GENRE\", direction: IN)\n  }\n\n  type Actor {\n    name: String\n  }\n</code></pre>\n</div>\n\n<p>Note the use of the <a href=\"https://neo4j.com/docs/graphql-manual/current/type-definitions/relationships/\"><code>@relationship</code> directive</a>. GraphQL schema directives are GraphQL’s built-in extension mechanism and allow us to add additional information used in the Neo4j GraphQL Library’s schema generation process to configure the API. You can see more examples of directives in <a href=\"https://neo4j.com/docs/graphql-manual/current/directives/\">the documentation</a>.</p>\n<p>Next, we’ll read our Neo4j connection credentials from environment variables defined in the <code>.env.local</code> file and create a Neo4j driver instance to connect to the database.</p>\n<div>\n\n<pre><code>// Read our Neo4j connection credentials from environment variables (see .env.local)\nconst { NEO4J_URI, NEO4J_USERNAME, NEO4J_PASSWORD } = process.env;\n\n// Create a Neo4j driver instance to connect to Neo4j AuraDB\nconst driver = neo4j.driver(\n  NEO4J_URI,\n  neo4j.auth.basic(NEO4J_USERNAME, NEO4J_PASSWORD)\n);\n</code></pre>\n</div>\n\n<p>Next, we’re ready to pass our GraphQL type definitions and Neo4j driver instance as we create a new Neo4j GraphQL instance:</p>\n<div>\n\n<pre><code>// Type definitions and a Neo4j driver instance are all that's required for\n// building a GraphQL API with the Neo4j GraphQL Library - no resolvers!\nconst neoSchema = new Neo4jGraphQL({\n  typeDefs,\n  driver,\n});\n</code></pre>\n</div>\n\n<p>Because it involves verifying the schema and some database state, building the Neo4j GraphQL schema is an asynchronous process. I’ve moved the asynchronous bit to a function called <code>initServer</code>, which logs when it’s called. I did this so we can see in the application logs each time our GraphQL server is rebuilt. We’ll want to monitor this and make sure we aren’t rebuilding the GraphQL schema at each request, and this will help us do that.</p>\n<pre><code>// Building the Neo4j GraphQL schema is an async process\nconst initServer = async () =&gt; {\n  console.log(\"Building GraphQL server\");\n  return await neoSchema.getSchema();\n};\n\n// Note the use of the top-level await here in the call to initServer()\nexport default createYoga({\n  schema: await initServer(),\n  graphqlEndpoint: \"/api/graphql\",\n});\n</code></pre>\n\n<p>You’ll see that we used <code>await</code>with our top-level module export. This is currently an experimental feature that we’ll need to explicitly enable in <code>next.config.js</code>. </p>\n<pre><code>const nextConfig = {\n  reactStrictMode: true,\n  webpack: (config, options) =&gt; {\n    config.experiments = {\n      topLevelAwait: true,\n      layers: true,\n    };\n    return config;\n  },\n};\n</code></pre>\n\n<p>Enabling usage of top-level await will allow us to gracefully handle the asynchronous server setup in our API Route.</p>\n<p>Now, if we run <code>npm run dev</code>, open our web browser, and navigate to <code>http://localhost:3000/api/graphql</code>, we’ll see the GraphQL Yoga GraphiQL in-browser IDE and be able to start querying our GraphQL API to fetch movie data from Neo4j. Note that we didn’t need to write any resolver functions or database querying logic to implement our GraphQL API. The Neo4j GraphQL Library generated operations for each type defined in our type definitions, including arguments for filtering and pagination.</p>\n<p><img src=\"https://files.smashing.media/articles/full-stack-graphql-nextjs-neo4j-auradb-vercel/2-nextjs-api-route-graphal-endpoint.png\" /></p>\n<p>Now that we’ve created a Next.js API route for our GraphQL endpoint, let’s see how we can use our GraphQL endpoint in our React application.</p>\nClient Side Data Fetching With Apollo Client In Next.js\n<p>There are several ways to approach data fetching with Next.js, such as static site generation, server-side rendering, and client-side rendering. We’re going to focus on client-side rendering with GraphQL — executing GraphQL requests from the client web browser to fetch data and update the DOM in our application. For an overview of other approaches to data fetching with Next.js, see <a href=\"https://dev.to/adamcowley/using-neo4j-in-your-next-nextjs-project-77\">this blog post</a> that also shows other ways of using Neo4j with Next.js.</p>\n<p>We’ll be using <a href=\"https://www.apollographql.com/docs/react/\">Apollo Client</a> in our React application to execute GraphQL data fetching queries. Apollo Client has a React integration that uses hooks as the primary interface. Hooks are functions that allow us to ‘hook’ into React state and other lifecycle methods and are commonly used with data fetching in React applications. Let’s install Apollo Client and start using it in our React application.</p>\n<pre><code>npm install @apollo/client\n</code></pre>\n\n<p>We’ll need to update <code>pages/_app.js</code> to create our Apollo Client instance and inject it into the React component hierarchy so that we can make use of the <code>useQuery</code> and <code>useMutation</code> hooks that Apollo Client provides for interacting with a GraphQL API from our React application.</p>\n<p>In <code>pages/_app.js</code>, we first import the modules we’ll need from Apollo Client.</p>\n<pre><code>import {\n  ApolloProvider,\n  ApolloClient,\n  InMemoryCache,\n  HttpLink,\n} from \"@apollo/client\";\n</code></pre>\n\n<p>The <code>ApolloProvider</code> component uses the React Context API to make our Apollo Client instance available throughout our React application. The <code>InMemoryCache</code> and <code>HttpLink</code>modules are used to configure the cache and networking layer for connections to our GraphQL API.</p>\n<p>Next, we’ll define a function to create a new ApolloClient instance, specifying the endpoint for our GraphQL API served as an API route.</p>\n<pre><code>const createApolloClient = () =&gt; {\n  const link = new HttpLink({\n    uri: \"/api/graphql\",\n  });\n\n  return new ApolloClient({\n    link,\n    cache: new InMemoryCache(),\n  });\n};\n</code></pre>\n\n<p>Then we can inject the <code>ApolloProvider</code> component into our React component hierarchy.</p>\n<pre><code>export default function App({ Component, pageProps }) {\n  return (\n    &lt;ApolloProvider client={createApolloClient()}&gt;\n      &lt;Component {...pageProps} /&gt;\n    &lt;/ApolloProvider&gt;\n  );\n</code></pre>\n\n<p>Now we’re ready to start fetching data in our application. Let’s replace the Next.js default landing page with a movies search page that will allow us to search for movies by genre and see details about the top-rated movies. Later, we’ll add a movie recommendation feature to show recommended movies based on the top results.</p>\n<p>We’ll replace the existing <code>index.js</code>, starting with some imports.</p>\n<pre><code>import React, { useState } from \"react\";\nimport { gql, useQuery } from \"@apollo/client\";\n</code></pre>\n\n<p><code>useState</code> is a hook function that allows us to work with React state variables. <code>useQuery</code> is a hook function provided by Apollo Client that we’ll use to query data from our GraphQL API. The <code>gql</code> template tag helps with parsing GraphQL operations.</p>\n<p>As you can see, hooks are such a fundamental part of React that we use a hook to manage state variables as well. To enable the user to search for movies by genre, we’ll declare a state variable to keep track of the user’s selected genre.</p>\n<pre><code> const [selectedGenre, setSelectedGenre] = useState(\"Action\");\n</code></pre>\n\n<p>Next, we need to define the GraphQL query used to search for movies by genre. We’ll also return information about the movie, like the poster URL and who acted in it. We’ll use a GraphQL variable in the query to filter for movies matching the selected genre.</p>\n<pre><code>const MOVIE_SEARCH_QUERY = gql`\n    query MovieSearch($selectedGenre: String!) {\n      movies(\n        where: {\n          genres: { name: $selectedGenre }\n          imdbRating_GTE: 0.0\n          poster_NOT:\"\"\n        }\n        options: { limit: 100, sort: { imdbRating: DESC } }\n      ) {\n        title\n        plot\n        poster\n        imdbRating\n        actors {\n          name\n        }\n        genres {\n          name\n        }\n      }\n    }\n  `;\n</code></pre>\n\n<p>We’ll use this query with the <code>useQuery</code> hook to fetch data, passing in the value of our <code>selectedGenre</code> state variable. If we have an error or loading state from our GraphQL operation, then we render a placeholder. </p>\n<pre><code> const { loading, error, data } = useQuery(MOVIE_SEARCH_QUERY, {\n    variables: { selectedGenre },\n  });\n\n  if (error) return &lt;p&gt;Error&lt;/p&gt;;\n  if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;\n</code></pre>\n\n<p>We’ll use a simple select form input to let the user choose the movie genre. By binding the value of the form to our <code>selectedGenre</code> state variable, we have created what’s called a <strong>controlled component</strong> — a form that is controlled by React state.</p>\n<p>To render the results of the movie search GraphQL query, we’ll map over the movie results and add a row to a table with the details for each movie. We can find the results of our GraphQL operation in the <code>data</code> variable, the shape of which matches the selection set of our GraphQL query.</p>\n<div>\n\n<pre><code>&lt;h2&gt;Results&lt;/h2&gt;\n      &lt;table&gt;\n        &lt;thead&gt;\n          &lt;tr&gt;\n            &lt;th&gt;Poster&lt;/th&gt;\n            &lt;th&gt;Title&lt;/th&gt;\n            &lt;th&gt;Genre&lt;/th&gt;\n            &lt;th&gt;Rating&lt;/th&gt;\n          &lt;/tr&gt;\n        &lt;/thead&gt;\n        &lt;tbody&gt;\n          {data &amp;&amp;\n            data.movies &amp;&amp;\n            data.movies.map((m, i) =&gt; (\n              &lt;tr key={i}&gt;\n                &lt;td&gt;\n                  &lt;img src={m.poster} style={{ height: \"50px\" }}&gt;&lt;/img&gt;\n                &lt;/td&gt;\n                &lt;td&gt;{m.title}&lt;/td&gt;\n                &lt;td&gt;\n                  {m.genres.reduce(\n                    (acc, c, i) =&gt;\n                      acc + (i === 0 ? \" \" : \", \") + c.name,\n                    \"\"\n                  )}\n                &lt;/td&gt;\n                &lt;td&gt;{m.imdbRating}&lt;/td&gt;\n              &lt;/tr&gt;\n            ))}\n        &lt;/tbody&gt;\n      &lt;/table&gt;\n</code></pre>\n</div>\n\n<p>If we return to our web browser, we can see our application up and running. Try choosing a different genre in the form to see the results of our GraphQL search.</p>\n<p><img src=\"https://files.smashing.media/articles/full-stack-graphql-nextjs-neo4j-auradb-vercel/6-graphql-search-results-table-genre-adventure.png\" /></p>\n<p>Now that we have our application running locally, let’s see how we can deploy this simple movie search application to the web using Vercel and Neo4j AuraDB.</p>\nDeploying to Vercel And Neo4j AuraDB\n<p>Next.js is a powerful React framework when used on its own, but when we pair Next.js with <a href=\"https://vercel.com/\">Vercel</a>, a platform for deploying web applications, we can leverage some huge developer experience benefits. To deploy our application on Vercel, we’ll first push it to GitHub and connect the GitHub repository to a new project in Vercel. Later, we’ll show an advantage of using this approach when adding new features to our app: ‘preview’ deployments that allow us to test and share our updated application to gather feedback before updating the production deployment.</p>\n<p>First, we’ll create a new GitHub repository and push our Next.js application to it. By default, create-next-app generated a git repository for us when we started the project. Let’s commit our changes and push them to our new GitHub repository.</p>\n<pre><code>git add -A\ngit commit -m \"add fullstack graphql app\"\ngit remote add origin git@github.com:johnymontana/fullstack-graphql-movies.git\ngit push -u origin main\n</code></pre>\n\n<p>Next, we’ll sign in to Vercel and create a new project. If you don’t have a Vercel account, you can create one for free. The free tier of Vercel includes all the features we need to deploy our Next.js application.</p>\n<p>Since our <code>.env.local</code> file with our database credentials wasn’t checked for version control to keep our secrets safe, we’ll need to specify our Neo4j AuraDB credentials as environment variables when configuring the project in Vercel. We can use a different database here to have multiple development, staging, and production environments.</p>\n<p><img src=\"https://files.smashing.media/articles/full-stack-graphql-nextjs-neo4j-auradb-vercel/1-vercel-deploy-nextjs-application.png\" /></p>\n<p>Hit the Deploy button, and after a few seconds (and some confetti), our application will be deployed to the web. Vercel will even assign our app a new domain name and SSL certificate. Our React application is deployed to Vercel’s CDN, while our API Routes are deployed as serverless functions.</p>\n<p>This is great, but let’s see how we can take advantage of Vercel’s preview deployment feature. We’ll add a new feature to our app and push it to a new branch of our GitHub repository, which will trigger a new preview deployment on Vercel.</p>\nAdding A New Feature And Vercel Preview Deployments\n<p>Preview deployments allow us to test and share new features to our application without updating our production deployment. To see how this works, let’s add a recommended movie feature to our application. To do this, we’ll add a new field to the Movie type in our GraphQL API called <code>similar</code> that will return a list of similar movies a user might be interested in watching if they liked the original movie. We’ll use the <a href=\"https://neo4j.com/docs/graphql-manual/current/type-definitions/cypher/\">@cypher schema directive</a> to attach custom logic to our GraphQL API using a Cypher statement.</p>\n<p>First, we’ll write a Cypher query to find similar movies. We saw earlier that Cypher allows us to declare graph patterns using ASCII-art syntax, so our Cypher query will define a graph pattern to find similar movies by traversing through the actors and genres of the movie.</p>\n<pre><code>MATCH (m:Movie {title: \"Matrix, The\"})\nMATCH (m)-[:ACTED_IN|:IN_GENRE]-()-[:ACTED_IN|:IN_GENRE]-(rec:Movie)\nWITH rec, COUNT(*) AS score ORDER BY score DESC\nRETURN rec LIMIT 3\n</code></pre>\n\n<p>We could also use things like user ratings to improve our movie recommendations, but this is a good start. In our GraphQL type definitions in api/graphql.js, we’ll add our new similar field and annotate it with our movie recommendation Cypher statement.</p>\n<pre><code> extend type Movie {\n    similar(first: Int = 4): [Movie!]! @cypher(statement: \"\"\"\n    MATCH (this)-[:ACTED_IN|:IN_GENRE]-()-[:ACTED_IN|:IN_GENRE]-(rec:Movie)\n    WITH rec, COUNT(*) AS score ORDER BY score DESC\n    RETURN rec LIMIT $first\n    \"\"\")\n }\n </code></pre>\n\n<p>We use the <code>this</code> variable in the Cypher statement to refer to the currently resolved movie. Similarly, any GraphQL field arguments we define will be passed to the Cypher statement as Cypher parameters, like the <code>$first</code> parameter that will allow for specifying the maximum number of similar movies to return.</p>\n<p>If we include this new similar field in our GraphQL movies search query and in the result table, we’ll see a recommended movie for each movie in our search results.</p>\n<p><img src=\"https://files.smashing.media/articles/full-stack-graphql-nextjs-neo4j-auradb-vercel/3-graphql-search-results-table-genre-adventure.png\" /></p>\n<p>Let’s create a new git branch and commit our changes to this new branch. This will trigger a preview deployment on Vercel. Our updates will be deployed to a new domain, which we’ll be able to share and test before merging the changes to the main branch and moving the deployment to our main domain.</p>\n<pre><code>git checkout -b recommendations\ngit add -A\ngit commit -m \"add recommendations feature\"\ngit push origin recommendations\n</code></pre>\n\n<p><img src=\"https://files.smashing.media/articles/full-stack-graphql-nextjs-neo4j-auradb-vercel/4-git-branch-recommendations.png\" /></p>\n<p>One neat feature included in each preview deployment is the ability for our users to add annotations and feedback to our app just by clicking on the screen. This is a great way to gather feedback on a new feature just by sharing the URL to your preview deployment!</p>\n<p><img src=\"https://files.smashing.media/articles/full-stack-graphql-nextjs-neo4j-auradb-vercel/5-users-annotations-feedback-preview-deploymjent.png\" /></p>\n<p>In this blog post, we saw how to use Next.js and Neo4j AuraDB to build and deploy a full stack GraphQL web application. We used the <a href=\"https://neo4j.com/product/graphql-library/\">Neo4j GraphQL Library</a> in a Next.js API route to quickly create a fully featured GraphQL API backed by a native graph database as a serverless function. We also saw some of the advantages of using Vercel to deploy our full stack application, like the preview deployment functionality.</p>\nWhere To Go From Here\n<p>To learn more about building full stack GraphQL applications, be sure to download my book <a href=\"https://dev.neo4j.com/graphql-book\"><em>Full Stack GraphQL Applications</em></a>. Thanks to Neo4j, you can download the ebook version for <a href=\"https://dev.neo4j.com/graphql-book\">free</a>! The book covers more advanced features of the Neo4j GraphQL Library, like adding authorization rules, how to work with mutations, using GraphQL for client state management, and more. You can find the code for this blog post on <a href=\"https://github.com/johnymontana/fullstack-graphql-movies\">GitHub</a>.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"ab486c0e763c41d845be656843507164894f2ce54b0bd0064086dc465c239f12","category":"Tech"}