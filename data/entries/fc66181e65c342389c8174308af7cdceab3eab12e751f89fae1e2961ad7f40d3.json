{"title":"WebGPU now available for testing in Safari Technology Preview","link":"https://webkit.org/blog/14879/webgpu-now-available-for-testing-in-safari-technology-preview/","date":1703179848000,"content":"<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGPU_API\">WebGPU</a> is a new <a href=\"https://www.w3.org/TR/webgpu/\">standards-compliant</a> API that enables high-performance 3D graphics and general-purpose <a href=\"https://en.wikipedia.org/wiki/Data_parallelism\">computations</a> on the Web. WebGPU programs are written in JavaScript but expose GPU functionality, allowing GPU computing to be used in Web content for the first time. Starting in <a href=\"https://developer.apple.com/safari/technology-preview/\">Safari Technology Preview</a> 185, WebGPU can be enabled for early testing and development.</p>\n<p>To enable WebGPU, turn on the “WebGPU”, “GPU Process: DOM Rendering” and “GPU Process: Canvas Rendering” feature flags in the <a href=\"https://developer.apple.com/documentation/safari-developer-tools/feature-flag-settings\">Feature Flags</a> tab in Safari Preferences. If you don’t see the Feature Flags tab, you need to first check “<a href=\"https://developer.apple.com/documentation/safari-developer-tools/enabling-developer-features\">Show features for web developers</a>” in the Advanced tab.</p>\n<p>Once you have WebGPU enabled in Safari Technology Preview 185, <a href=\"https://webgpu.github.io/webgpu-samples/samples/particles\">try out this example of WebGPU</a>. It utilizes many of the best features of WebGPU.</p>\n<figure></figure>\n<h2>WebGPU JavaScript API</h2>\n<p>The WebGPU API is accessed through JavaScript, similar to WebGL.</p>\n<h3>Creating a GPUDevice</h3>\n<p>In order to use WebGPU, a device must be created. Resources and pipeline state are created from a <code>GPUDevice</code> instance. To create a device with default limits and features which are supported on all devices supporting WebGPU, we can pass zero parameters to the invocations of <code>requestAdapter</code> and <code>requestDevice</code>.</p>\n<pre><code>const adapter = await navigator.gpu.requestAdapter();\ndevice = await adapter.requestDevice();\n</code></pre>\n<h3>Configuring a GPUCanvasContext</h3>\n<p>The <code>GPUCanvasContext</code> is an interface that allows you to configure how your content will be displayed in the corresponding <code>HTMLCanvas</code> element on the page.</p>\n<pre><code>context = canvas.getContext('webgpu');\nconst canvasFormat = \"bgra8unorm\";\n\nconst contextConfiguration = {\n    device: device,\n    format: canvasFormat,\n    alphaMode: 'opaque',\n};\ncontext.configure(contextConfiguration);\n</code></pre>\n<h3>Creating a GPURenderPipeline</h3>\n<p>A <code>GPURenderPipeline</code> or a corresponding <code>GPUComputePipeline</code> are used to configure the pipeline state of the graphics driver. This pipeline state is then used in a <code>GPURenderPassEncoder</code> or <code>GPUComputePassEncoder</code> as later illustrated.</p>\n<pre><code>const shaderModule = device.createShaderModule({ code: wgslSource });\nconst vertexStageDescriptor = { module: shaderModule, entryPoint: \"vsmain\" };\nconst fragmentStageDescriptor = { module: shaderModule, entryPoint: \"fsmain\" };\nconst renderPipelineDescriptor = {\n    layout: 'auto',\n    vertex: vertexStageDescriptor,\n    fragment: fragmentStageDescriptor,\n    primitive: {topology: \"triangle-list\" },\n};\nconst renderPipeline = device.createRenderPipeline(renderPipelineDescriptor);\n</code></pre>\n<h3>Issuing draw calls</h3>\n<p>A <code>GPURenderPassEncoder</code> is created to send draw calls to the graphics driver. In the below example, we draw a simple triangle which contains three vertices. A <code>GPURenderPassEncoder</code> can also draw multiple instances of the same geometry or draw from an offset of a vertex buffer.</p>\n<pre><code>const colorAttachmentDescriptor = {\n    view: renderAttachment,\n    loadOp: \"clear\",\n    storeOp: \"store\",\n    clearColor: { r: 0.15, g: 0.15, b: 0.5, a: 1 }\n};\nconst renderPassDescriptor = { colorAttachments: [colorAttachmentDescriptor] };\nconst commandEncoder = device.createCommandEncoder();\nconst renderPassEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\nrenderPassEncoder.setPipeline(renderPipeline);\nconst vertexBufferSlot = 0;\nrenderPassEncoder.setVertexBuffer(vertexBufferSlot, vertexBuffer, 0);\nrenderPassEncoder.draw(3, 1, 0, 0); // 3 vertices, 1 instance, 0th vertex, 0th instance.\nrenderPassEncoder.end();\nconst commandBuffer = commandEncoder.finish();\nconst queue = device.queue;\nqueue.submit([commandBuffer]);\n</code></pre>\n<h2>WebGPU Shading Language</h2>\n<p>WebGPU introduces WGSL, a platform independent shading language for the web. Here is an example of a WGSL shader source that would be passed in place of <code>wgslSource</code> in the above API call:</p>\n<pre><code>const wgslSource =\n    struct Vertex {\n        @builtin(position) Position: vec4&amp;ltf32&amp;gt,\n        @location(0) color: vec4&amp;ltf32&amp;gt,\n    }\n\n    @vertex fn vsmain(@builtin(vertex_index) VertexIndex: u32) -&amp;gt Vertex\n    {\n        var pos: array&amp;ltvec2&amp;ltf32&amp;gt, 3&amp;gt = array&amp;ltvec2&amp;ltf32&amp;gt, 3&amp;gt(\n            vec2&amp;ltf32&amp;gt( 0.0,  0.5),\n            vec2&amp;ltf32&amp;gt(-0.5, -0.5),\n            vec2&amp;ltf32&amp;gt( 0.5, -0.5));\n        var vertex_out : Vertex;\n        vertex_out.Position = vec4&amp;ltf32&amp;gt(pos[VertexIndex], 0.0, 1.0);\n        vertex_out.color = vec4&amp;ltf32&amp;gt(pos[VertexIndex] + vec2&amp;ltf32&amp;gt(0.5, 0.5), 0.0, 1.0);\n        return vertex_out;\n    }\n\n    @fragment fn fsmain(in: Vertex) -&amp;gt @location(0) vec4&amp;ltf32&amp;gt\n    {\n        return in.color;\n    }\n;\n</code></pre>\n<h2>Try WebGPU and file bugs!</h2>\n<p>We’re very excited to have an early version of WebGPU and WGSL in the latest version of Safari Technology Preview. Please do try it out. Check out the <a href=\"https://webgpu.github.io/webgpu-samples/samples/helloTriangle\">public repository of WebGPU samples</a>. And file bugs or issues you discover at <a href=\"http://bugs.webkit.org/\">bugs.webkit.org</a>.</p>","author":"","siteTitle":"Blog – WebKit","siteHash":"7f8dbea0b8f53db2e11a2faa08c6dca9954c01638d09a2ce585b77a60d10f7a1","entryHash":"fc66181e65c342389c8174308af7cdceab3eab12e751f89fae1e2961ad7f40d3","category":"Tech"}