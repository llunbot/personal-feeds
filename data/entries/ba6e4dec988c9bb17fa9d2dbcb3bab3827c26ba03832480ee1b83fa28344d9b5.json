{"title":"Configuring dynamic secrets for a PostgreSQL and GitLab CI using HashiCorp Vault","link":"https://www.hashicorp.com/blog/configuring-dynamic-secrets-for-a-postgresql-and-gitlab-ci-using-hashicorp-vault","date":1743436800000,"content":"<p>Many teams begin with static, hardcoded credentials for databases — often buried in config files or environment variables. Getting your <a href=\"https://www.hashicorp.com/en/blog/rotated-vs-dynamic-secrets-which-should-you-use\">secret rotation automated</a> on a fixed schedule (daily, weekly, monthly) is a good first step, but to truly minimize the risks of credential theft as much as possible requires adoption of <a href=\"https://developer.hashicorp.com/vault/tutorials/get-started/understand-static-dynamic-secrets\">“dynamic” secrets</a> (sometimes called “ephemeral secrets” or “just-in-time secrets”). By issuing short-lived credentials that expire automatically — often within minutes or hours — organizations can drastically minimize the attack window if a secret becomes compromised.</p>\n\n<p>In this follow-up to <a href=\"https://www.hashicorp.com/blog/why-we-need-short-lived-credentials-and-how-to-adopt-them\">Why we need short-lived credentials and how to adopt them</a> — a manager and architect-oriented post on this topic, I’ll walk through two practical scenarios: Issuing short-lived credentials for a PostgreSQL database and retrieving static vs. dynamic secrets in GitLab CI. Both examples use HashiCorp Vault to create ephemeral database users with a limited lifespan using dynamic secrets.</p>\n\n<h2>Before and after dynamic secrets in PostgreSQL</h2>\n\n<p>The first example shows how the configurations and commands typically look starting with hardcoded credentials and migrating into dynamic credentials in a PostgreSQL database.</p>\n\n<h3>Before: Hardcoded credentials</h3>\n\n<p>Developers and database administrators are familiar with how hardcoded credentials look. In this example below, the PostgreSQL database is using hardcoded credentials in environment variables.</p>\n<pre><code>#!/usr/bin/env bash\n\n# Hardcoded credentials in environment variables\nDB_HOST=\"my-postgres-host\"\nDB_USER=\"legacy_user\"\nDB_PASS=\"staticPasswordxyz\"\nDB_PORT=5432\n\n# The script connects using these long-lived credentials\npsql -h \"$DB_HOST\" -U \"$DB_USER\" -d my_database -c \"SELECT * FROM user_schema;\"</code></pre><p>The goal is to move these credentials into a secrets manager like Vault and put leases on them that expunge the credentials after a reasonably short window and re-generate the credentials automatically so that no manual effort is required.</p>\n\n<h3>After: Dynamic credentials</h3>\n\n<p>Vault uses <a href=\"https://developer.hashicorp.com/vault/docs/secrets\">secrets engines</a> to manage dynamic secrets. In this example, you would enable the database secrets engine with the PostgreSQL plugin. This 4-step example will show how you manually implement dynamic secrets through the command line. In the second example later in the article, you’ll see how to make your application or CI/CD pipeline request these credentials via API calls or a Vault client library.</p>\n\n<h4>1. Enable and configure the database secrets engine</h4>\n\n<p>In the command line, here’s how you enable and configure the database secrets engine for PostgreSQL in Vault:</p>\n<pre><code># Enable the database secrets engine (if not already enabled)\nvault secrets enable database\n\n# Configure Vault to connect to your PostgreSQL database\nvault write database/config/my-postgres-database \\\nplugin_name=\"postgresql-database-plugin\" \\\nallowed_roles=\"my-db-role\" \\  connection_url=\"postgresql://{{username}}:{{password}}@my-postgres-host:5432/postgres?\\\nsslmode=disable\" \\\nusername=\"vault_admin\" \\\npassword=\"SuperSecurePassword123\"</code></pre><ul>\n<li><code>plugin_name</code>: Identifies which database plugin to use (PostgreSQL in this case).</li>\n<li><code>allowed_roles</code>: Lists which Vault roles can be mapped to this database config.</li>\n<li><code>connection_url</code>: Contains the placeholder parameters for username and password, replaced by  Vault.</li>\n<li><code>username</code>/<code>password</code>: The admin-level credentials Vault uses to dynamically create new roles in  PostgreSQL.</li>\n</ul>\n\n<h4>2. Create a role with a short lease</h4>\n\n<p>Next you create a role in the command line and give it a time-to-live (TTL):</p>\n<pre><code>vault write database/roles/my-db-role \\\ndb_name=\"my-postgres-database\" \\\ncreation_statements=\"CREATE ROLE \\\"{{name}}\\\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}'; \\\nGRANT SELECT ON ALL TABLES IN SCHEMA public TO \\\"{{name}}\\\";\" \\\ndefault_ttl=\"15m\" \\\nmax_ttl=\"30m\"</code></pre><ul>\n<li><code>creation_statements</code>: A PostgreSQL command that defines what privileges the new user gets (e.g., SELECT on all tables).</li>\n<li><code>default_ttl</code>: The initial time-to-live (in this case 15 minutes).</li>\n<li><code>max_ttl</code>: The maximum extension if you renew (30 minutes max).</li>\n</ul>\n\n<h4>3. Request dynamic secrets</h4>\n\n<p>Finally you use the command line to put the dynamic secrets variable into the configuration for PostgreSQL:</p>\n<pre><code>DB_CREDS=$(vault read -format=json database/creds/my-db-role)\nDB_USER=$(echo \"$DB_CREDS\" | jq -r '.data.username')\nDB_PASS=$(echo \"$DB_CREDS\" | jq -r '.data.password')\n\necho \"Ephemeral username: $DB_USER\"\n# Avoid echoing DB_PASS in logs if possible\n# Use them to connect to PostgreSQL, e.g.:\n\npsql -h \"my-postgres-host\" -U \"$DB_USER\" -d my_database -c \"SELECT * FROM user_schema;\"</code></pre><ul>\n<li><code>vault read</code> obtains <strong>unique</strong> credentials each time, valid only for default_ttl (15 minutes).</li>\n<li><code>lease_duration</code> indicates these credentials automatically expire in 15 minutes.</li>\n<li>If leaked, the credentials are only useful for 15 minutes (default TTL). If they’re acquired or used after the TTL expiration, they won’t work.</li>\n<li><code>lease_id</code> can be used to manually revoke or renew the credential ahead of time if needed.</li>\n</ul>\n\n<h4>4. Testing revocation</h4>\n\n<p>After the lease expires, Vault revokes the user from PostgreSQL automatically.  Here’s the command you would type if you want to manually revoke the user at any time:</p>\n<pre><code>vault lease revoke database/creds/my-db-role/abc123</code></pre><p>After the lease expires (or upon manual revoke), Vault removes the DB user automatically. You can try using the old credentials for subsequent login attempts and those credentials will fail. You’ve just created, used, and revoked a short-lived PostgreSQL credential.</p>\n\n<p>In practice, your application or CI/CD pipeline would request these credentials via API calls or a Vault client library, ensuring they’re fetched securely each time they’re needed. Now that you’ve seen how Vault issues ephemeral DB credentials, let’s see how you can retrieve secrets — both static and dynamic — in a real CI/CD environment like GitLab.</p>\n\n<h2>Retrieving secrets in GitLab</h2>\n\n<p>When integrating Vault into your CI pipelines, you can either pull static secrets from Vault’s KV store or generate short-lived dynamic secrets via one of Vault’s dynamic secrets engines. Below are two code snippets, each showing a different approach.</p>\n\n<h3>Static KV-based secret retrieval</h3>\n\n<p>This example reads a static secret from Vault’s <a href=\"https://developer.hashicorp.com/vault/docs/secrets/kv\">KV engine</a>. While it demonstrates Vault integration, it’s not ephemeral: the secret remains valid until it’s manually rotated or overwritten:</p>\n<pre><code>variables:\n  VAULT_SERVER_URL: \"https://vault.example.com\"\n  VAULT_AUTH_ROLE: \"gitlab-role\"\n  # Make sure to configure GitLab so it can authenticate to Vault (e.g., AppRole).\n \nstages:\n  - build\n \nbuild_job:\n  stage: build\n  script:\n    - echo \"Fetching a static secret from Vault's KV store...\"\n    # If you're using KV v2, adjust the path to secret/data/myapp/settings\n    - export STATIC_SECRET=$(vault kv get -field=value secret/myapp/settings)\n    - echo \"Got static secret: $STATIC_SECRET\"\n    # Proceed with your build steps\n    - ./build-script.sh</code></pre><ul>\n<li>This snippet retrieves a static secret from secret/myapp/settings. There’s no automatic TTL or revocation associated with it.</li>\n<li>You must configure how GitLab obtains Vault credentials (<a href=\"https://developer.hashicorp.com/vault/docs/auth/approle\">AppRole</a> or another auth method). If you’re on KV v2, your actual path may look like secret/data/myapp/settings.</li>\n</ul>\n\n<h3>Dynamic secrets retrieval via the database secrets engine</h3>\n\n<p>Below is a truly ephemeral approach, using Vault’s database secrets engine to generate short-lived, just-in-time credentials for a PostgreSQL database. Each time the pipeline runs, it requests new credentials that automatically expire after a set TTL — reducing the blast radius/timeframe for stolen secrets.</p>\n<pre><code>variables:\n  VAULT_SERVER_URL: \"https://vault.example.com\"\n  VAULT_AUTH_ROLE: \"gitlab-role\"\n  # Configure GitLab -&gt; Vault auth just like in the KV example.\n \nstages:\n  - deploy\n \ndeploy_job:\n  stage: deploy\n  script:\n    - echo \"Fetching ephemeral DB credentials...\"\n    # This reads from the database secrets engine (e.g., database/creds/my-db-role)\n    - DB_CREDS=$(vault read -format=json database/creds/my-db-role)\n    - DB_USER=$(echo \"$DB_CREDS\" | jq -r '.data.username')\n    - DB_PASS=$(echo \"$DB_CREDS\" | jq -r '.data.password')\n \n    - echo \"Ephemeral Username: $DB_USER\"\n    # Avoid echoing $DB_PASS in logs for security reasons\n    # The credential automatically expires after its TTL (e.g. 15m)\n \n    - ./deploy.sh --db-user=\"$DB_USER\" --db-pass=\"$DB_PASS\"</code></pre><p>The database secrets engine’s role sets a default TTL (e.g. 15 minutes). Once that time passes, the credential is automatically revoked. Once the credential expires, the application or pipeline would need to request fresh credentials from Vault again. If in any worst-case scenario, these credentials are ever leaked, attackers have only a short window before they become invalid.</p>\n\n<h2>Learn more</h2>\n\n<p>Short-lived dynamic credentials dramatically reduce risk compared to static secrets, minimizing the window in which attackers can exploit stolen credentials. By centralizing secrets in Vault, automating rotation, and gradually moving services to dynamic secrets, you align with zero trust principles and improve operational efficiency.</p>\n\n<p>To learn more about dynamic secrets and HashiCorp Vault, visit:</p>\n\n<ul>\n<li><a href=\"https://developer.hashicorp.com/well-architected-framework/security/security-cicd-vault\">Retrieving CI/CD secrets from Vault</a></li>\n<li><a href=\"https://developer.hashicorp.com/vault/tutorials/get-started/understand-static-dynamic-secrets\">Understand static and dynamic secrets</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=aErDyZvQjWg\">How to get dynamic with secrets management</a></li>\n<li><a href=\"https://www.hashicorp.com/en/resources/why-you-need-a-faster-secrets-rotation-strategy\">Why you need a faster secrets rotation strategy</a></li>\n<li><a href=\"https://www.hashicorp.com/blog/why-we-need-short-lived-credentials-and-how-to-adopt-them\">Why we need short-lived credentials and how to adopt them</a></li>\n</ul>\n","author":"Roopesh Chandran","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"ba6e4dec988c9bb17fa9d2dbcb3bab3827c26ba03832480ee1b83fa28344d9b5","category":"Tech"}