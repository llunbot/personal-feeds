{"title":"Vector search for Amazon MemoryDB is now generally available","link":"https://aws.amazon.com/blogs/aws/vector-search-for-amazon-memorydb-is-now-generally-available/","date":1720629312000,"content":"<p>Today, we are announcing the general availability of <a href=\"https://aws.amazon.com/memorydb/features/#Vector_search\">vector search for Amazon MemoryDB</a>, a new capability that you can use to store, index, retrieve, and search vectors to develop real-time machine learning (ML) and <a href=\"https://aws.amazon.com/what-is/generative-ai/\">generative artificial intelligence</a> (generative AI) applications with in-memory performance and multi-AZ durability.</p> \n<p>With this launch, Amazon MemoryDB delivers the fastest vector search performance at the highest recall rates among popular vector databases on Amazon Web Services (AWS). You no longer have to make trade-offs around throughput, recall, and latency, which are traditionally in tension with one another.</p> \n<p>You can now use one MemoryDB database to store your application data and millions of vectors with single-digit millisecond query and update response times at the highest levels of recall. This simplifies your generative AI application architecture while delivering peak performance and reducing licensing cost, operational burden, and time to deliver insights on your data.</p> \n<p>With vector search for Amazon MemoryDB, you can use the existing MemoryDB API to implement generative AI use cases such as <a href=\"https://aws.amazon.com/what-is/retrieval-augmented-generation/\">Retrieval Augmented Generation (RAG)</a>, anomaly (fraud) detection, document retrieval, and real-time recommendation engines. You can also generate vector embeddings using artificial intelligence and machine learning (AI/ML) services like <a href=\"https://aws.amazon.com/bedrock\">Amazon Bedrock</a> and <a href=\"https://aws.amazon.com/sagemaker\">Amazon SageMaker</a> and store them within MemoryDB.</p> \n<p><strong><u>Which use cases would benefit most from vector search for MemoryDB?</u></strong><br /> You can use vector search for MemoryDB for the following specific use cases:</p> \n<p><strong>1. Real-time semantic search for retrieval-augmented generation (RAG)</strong><br /> You can use vector search to retrieve relevant passages from a large corpus of data to augment a large language model (LLM). This is done by taking your document corpus, chunking them into discrete buckets of texts, and generating vector embeddings for each chunk with embedding models such as the <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/titan-multiemb-models.html\">Amazon Titan Multimodal Embeddings G1 model</a>, then loading these vector embeddings into Amazon MemoryDB.</p> \n<p><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/07/01/2024-vector-search-memorydb-1-rag.png\" width=\"1526\" height=\"368\" /></p> \n<p>With RAG and MemoryDB, you can build real-time generative AI applications to find similar products or content by representing items as vectors, or you can search documents by representing text documents as dense vectors that capture semantic meaning.</p> \n<p><strong>2. Low latency durable semantic caching</strong><br /> Semantic caching is a process to reduce computational costs by storing previous results from the foundation model (FM) in-memory. You can store prior inferenced answers alongside the vector representation of the question in MemoryDB and reuse them instead of inferencing another answer from the LLM.</p> \n<p><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/07/01/2024-vector-search-memorydb-2-cache.png\" width=\"1492\" height=\"356\" /></p> \n<p>If a user’s query is semantically similar based on a defined similarity score to a prior question, MemoryDB will return the answer to the prior question. This use case will allow your generative AI application to respond faster with lower costs from making a new request to the FM and provide a faster user experience for your customers.</p> \n<p><strong>3. Real-time anomaly (fraud) detection </strong><br /> You can use vector search for anomaly (fraud) detection to supplement your rule-based and batch ML processes by storing transactional data represented by vectors, alongside metadata representing whether those transactions were identified as fraudulent or valid.</p> \n<p><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/07/01/2024-vector-search-memorydb-3-fraud-detect.png\" width=\"1478\" height=\"366\" /></p> \n<p>The machine learning processes can detect users’ fraudulent transactions when the net new transactions have a high similarity to vectors representing fraudulent transactions. With vector search for MemoryDB, you can detect fraud by modeling fraudulent transactions based on your batch ML models, then loading normal and fraudulent transactions into MemoryDB to generate their vector representations through statistical decomposition techniques such as principal component analysis (PCA).</p> \n<p>As inbound transactions flow through your front-end application, you can run a vector search against MemoryDB by generating the transaction’s vector representation through PCA, and if the transaction is highly similar to a past detected fraudulent transaction, you can reject the transaction within single-digit milliseconds to minimize the risk of fraud.</p> \n<p><strong><u>Getting started with vector search for Amazon MemoryDB</u></strong><br /> Look at how to implement a simple semantic search application using vector search for MemoryDB.</p> \n<p><strong>Step 1. Create a cluster to support vector search</strong><br /> You can create a MemoryDB cluster to enable vector search within the <a href=\"https://console.aws.amazon.com/memorydb/home?#/clusters\">MemoryDB console</a>. Choose <strong>Enable vector search</strong> in the <strong>Cluster settings</strong> when you create or update a cluster. Vector search is available for MemoryDB version 7.1 and a single shard configuration.</p> \n<p><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/07/01/2024-vector-search-memorydb-setting.jpg\" width=\"1664\" height=\"374\" /></p> \n<p><strong>Step 2. Create vector embeddings using the Amazon Titan Embeddings model</strong><br /> You can use <a href=\"https://aws.amazon.com/bedrock/titan/\">Amazon Titan Text Embeddings</a> or other embedding models to create vector embeddings, which is available in Amazon Bedrock. You can load your PDF file, split the text into chunks, and get vector data using a single API with <a href=\"https://python.langchain.com/v0.2/docs/integrations/platforms/aws/\">LangChain libraries</a> integrated with AWS services.</p> \n<pre><code>import redis\nimport numpy as np\nfrom langchain.document_loaders import PyPDFLoader\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\nfrom langchain.embeddings import BedrockEmbeddings\n\n# Load a PDF file and split document\nloader = PyPDFLoader(file_path=pdf_path)\n        pages = loader.load_and_split()\n        text_splitter = RecursiveCharacterTextSplitter(\n            separators=[\"\\n\\n\", \"\\n\", \".\", \" \"],\n            chunk_size=1000,\n            chunk_overlap=200,\n        )\n        chunks = loader.load_and_split(text_splitter)\n\n# Create MemoryDB vector store the chunks and embedding details\nclient = RedisCluster(\n        host=' mycluster.memorydb.us-east-1.amazonaws.com',\n        port=6379,\n        ssl=True,\n        ssl_cert_reqs=\"none\",\n        decode_responses=True,\n    )\n\nembedding =  BedrockEmbeddings (\n           region_name=\"us-east-1\",\n endpoint_url=\" https://bedrock-runtime.us-east-1.amazonaws.com\",\n    )\n\n#Save embedding and metadata using hset into your MemoryDB cluster\nfor id, dd in enumerate(chucks*):\n     y = embeddings.embed_documents([dd])\n     j = np.array(y, dtype=np.float32).tobytes()\n     client.hset(f'oakDoc:{id}', mapping={'embed': j, 'text': chunks[id] } )</code></pre> \n<p>Once you generate the vector embeddings using the Amazon Titan Text Embeddings model, you can connect to your MemoryDB cluster and save these embeddings using the MemoryDB <code>HSET</code> command.</p> \n<p><strong>Step 3. Create a vector index</strong><br /> To query your vector data, create a vector index using the<code><a href=\"https://docs.aws.amazon.com/memorydb/latest/devguide/vector-search-commands-ft.create.html\">FT.CREATE</a></code> command. Vector indexes are also constructed and maintained over a subset of the MemoryDB keyspace. Vectors can be saved in JSON or HASH data types, and any modifications to the vector data are automatically updated in a keyspace of the vector index.</p> \n<pre><code>from redis.commands.search.field import TextField, VectorField\n\nindex = client.ft(idx:testIndex).create_index([\n        VectorField(\n            \"embed\",\n            \"FLAT\",\n            {\n                \"TYPE\": \"FLOAT32\",\n                \"DIM\": 1536,\n                \"DISTANCE_METRIC\": \"COSINE\",\n            }\n        ),\n        TextField(\"text\")\n        ]\n    )</code></pre> \n<p>In MemoryDB, you can use four types of fields: numbers fields, tag fields, text fields, and vector fields. Vector fields support K-nearest neighbor searching (KNN) of fixed-sized vectors using the flat search (FLAT) and hierarchical navigable small worlds (HNSW) algorithm. The feature supports various distance metrics, such as euclidean, cosine, and inner product. We will use the euclidean distance, a measure of the angle distance between two points in vector space. The smaller the euclidean distance, the closer the vectors are to each other.</p> \n<p><strong>Step 4. Search the vector space</strong><br /> You can use <a href=\"https://docs.aws.amazon.com/memorydb/latest/devguide/vector-search-commands-ft.search.html\"><code>FT.SEARCH</code></a> and <a href=\"https://docs.aws.amazon.com/memorydb/latest/devguide/vector-search-commands-ft.aggregate.html\"><code>FT.AGGREGATE</code></a> commands to query your vector data. Each operator uses one field in the index to identify a subset of the keys in the index. You can query and find filtered results by the distance between a vector field in MemoryDB and a query vector based on some predefined threshold (<code>RADIUS</code>).</p> \n<pre><code>from redis.commands.search.query import Query\n\n# Query vector data\nquery = (\n    Query(\"@vector:[VECTOR_RANGE $radius $vec]=&gt;{$YIELD_DISTANCE_AS: score}\")\n     .paging(0, 3)\n     .sort_by(\"vector score\")\n     .return_fields(\"id\", \"score\")     \n     .dialect(2)\n)\n\n# Find all vectors within 0.8 of the query vector\nquery_params = {\n    \"radius\": 0.8,\n    \"vec\": np.random.rand(VECTOR_DIMENSIONS).astype(np.float32).tobytes()\n}\n\nresults = client.ft(index).search(query, query_params).docs</code></pre> \n<p>For example, when using cosine similarity, the <code>RADIUS</code> value ranges from 0 to 1, where a value closer to 1 means finding vectors more similar to the search center.</p> \n<p>Here is an example result to find all vectors within 0.8 of the query vector.</p> \n<pre><code>[Document {'id': 'doc:a', 'payload': None, 'score': '0.243115246296'},\n Document {'id': 'doc:c', 'payload': None, 'score': '0.24981123209'},\n Document {'id': 'doc:b', 'payload': None, 'score': '0.251443207264'}]</code></pre> \n<p>To learn more, you can look at a <a href=\"https://github.com/aws-samples/amazon-memorydb-for-redis-samples/tree/main/tutorials/memorydb-rag\">sample generative AI application</a> using RAG with MemoryDB as a vector store.</p> \n<p><strong><u>What’s new at GA</u></strong><br /> At re:Invent 2023, we released vector search for MemoryDB in <a href=\"https://aws.amazon.com/about-aws/whats-new/2023/11/vector-search-amazon-memorydb-redis-preview/\">preview</a>. Based on customers’ feedback, here are the new features and improvements now available:</p> \n<ul> \n <li><code>VECTOR_RANGE</code> to allow MemoryDB to operate as a low latency durable semantic cache, enabling cost optimization and performance improvements for your generative AI applications.</li> \n <li><code>SCORE</code> to better filter on similarity when conducting vector search.</li> \n <li>Shared memory to not duplicate vectors in memory. Vectors are stored within the MemoryDB keyspace and pointers to the vectors are stored in the vector index.</li> \n <li>Performance improvements at high filtering rates to power the most performance-intensive generative AI applications.</li> \n</ul> \n<p><strong><u>Now available</u></strong><br /> Vector search is available in all Regions that MemoryDB is currently available. Learn more about <a href=\"https://docs.aws.amazon.com/memorydb/latest/devguide/vector-search.html\">vector search for Amazon MemoryDB</a> in the AWS documentation.</p> \n<p>Give it a try in the <a href=\"https://console.aws.amazon.com/memorydb/home?#/clusters\">MemoryDB console</a> and send feedback to the <a href=\"https://repost.aws/tags/TAaN8jinFyTyaQpXj2GiMr0w/amazon-memorydb-for-redis\">AWS re:Post for Amazon MemoryDB</a> or through your usual AWS Support contacts.</p> \n<p>— <a href=\"https://twitter.com/channyun\">Channy</a></p>","author":"Channy Yun","siteTitle":"AWS News Blog","siteHash":"6093e072e4117ec22616e844cb857d03ca62c57a411a8affc77cb5e8b6b15bf6","entryHash":"58bbd2d43406133546ab0581452bb23302b626911b59b0e0014826f60f093c18","category":"Tech"}