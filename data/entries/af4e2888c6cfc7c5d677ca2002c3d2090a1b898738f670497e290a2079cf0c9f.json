{"title":"A Guide To Redux Toolkit With TypeScript","link":"https://smashingmagazine.com/2023/05/guide-redux-toolkit-typescript/","date":1683712800000,"content":"<p>If you are a React developer working on a complex application, you will need to use global state management for your app at some point. <a href=\"https://react-redux.js.org/\">React Redux</a> is one of the most popular libraries for state management used by many developers. However, React Redux has a complex setup process that I’ve found inefficient, not to mention it requires a lot of boilerplate code. The official developer of Redux developed the <a href=\"https://redux-toolkit.js.org/introduction/getting-started\">Redux Toolkit</a> to simplify the process.</p>\n<p>This article is for those with enough knowledge of React and TypeScript to work with Redux.</p>\nAbout Redux\n<p>Redux is the global state management library for React applications. If you have used <code>useState()</code> hooks for managing your app state, you will find it hard to access the state when you need it in the other parts of the application. With <code>useState()</code> hooks, the state can be passed from the parent component to the child, and you will be stuck with the problem of <a href=\"https://kentcdodds.com/blog/prop-drilling\">prop drilling</a> if you need to pass it to multiple children. That’s where Redux comes in to manage the application state.</p>\nIntroducing Redux Toolkit\n<p>Redux Toolkit is a set of opinionated and standardised tools that simplify application development using the Redux state management library.</p>\n<p>The primary benefit of using Redux Toolkit is that it removes the overhead of writing a lot of boilerplates like you’d have to do with plain Redux.</p>\n<p>It eliminates the need to write standard Redux setup code, such as defining actions, reducers, and store configuration, which can be a significant amount of code to write and maintain.</p>\n<p>Jerry Navi has a <a href=\"https://www.smashingmagazine.com/2020/08/redux-real-world-application/\">great tutorial that shows the full Redux setup process</a>.</p>\nWhy I Prefer Redux Toolkit Over Redux\n<p>The Redux Toolkit has several key features which make me use this library over plain Redux:</p>\n<ol>\n<li><strong>Defining reducers</strong><br />With Redux Toolkit, you can specify a slice with a few lines of code to define a reducer instead of defining actions and reducers separately, like Redux.</li>\n<li><strong>Immutability helpers</strong><br />Redux Toolkit includes a set of utility functions that make it easy to update objects and arrays in an immutable way. This makes writing code that follows the Redux principles of immutability simpler.</li>\n<li><strong>Built-in middleware</strong><br />Redux Toolkit includes built-in middleware that can handle asynchronous request tasks.</li>\n<li><strong>DevTools integration</strong><br />Redux Toolkit includes integration with the Redux DevTools browser extension, which makes it easier to debug and analyse Redux code.</li>\n</ol>\nUsing Redux Toolkit To Build A Project Issue Tracker\n<p>I think the best way to explain the value and benefits of using Redux Toolkit is simply to show them to you in a real-world context. So, let’s develop an app with it that is designed to create and track GitHub issues.</p>\n<p><img src=\"https://files.smashing.media/articles/guide-redux-toolkit-typescript/project-issue-tracker.jpg\" /></p>\n<p>You can follow along with the code examples as we go and <a href=\"https://github.com/smashingmagazine/project_issue_tracker/blob/master/src/components/ProjectCard.tsx\">reference the full code anytime by grabbing it from GitHub</a>. There is also a <a href=\"https://master--relaxed-lamington-5fba83.netlify.app/\">live deployment of this example</a> that you can check out.</p>\n<p>Start creating a new React app with the following command:</p>\n<pre><code>yarn create react-app project_issue_tracker --template typescript\n</code></pre>\n\n<p>This generates a folder for our project with the basic files we need for development. The <code>–template typescript</code> part of the command is used to add TypeScript to the stack.</p>\n<p>Now, let’s install the dependencies packages required for our project and build the primary UI for the application before we implement Redux Toolkit. First, navigate to the <code>project_issue_tracker</code> project folder we just created:</p>\n<pre><code>cd project_issue_tracker\n</code></pre>\n\n<p>Then run the following command to install <a href=\"https://mui.com/material-ui/\">Material UI</a> and <a href=\"https://emotion.sh/docs/introduction\">Emotion</a>, where the former is a design library we can use to style components, and the latter enables writing CSS in JavaScript files.</p>\n<pre><code>yarn add @mui/material @emotion/react @emotion/styled\n</code></pre>\n\n<p>Now we can install Redix Toolkit and Redux itself:</p>\n<pre><code>yarn add @reduxjs/toolkit react-redux\n</code></pre>\n\n<p>We have everything we need to start developing! We can start by building the user interface.</p>\nDeveloping The User Interface\n<p>In this section, we will be developing the UI of the app. Open the main project folder and create a new <code>components</code> subfolder directly in the root. Inside this new folder, create a new file called <code>ProjectCard.tsx</code>. This is where we will write the code for a <code>ProjectCard</code> component that contains information about an open issue in the project issue tracker.</p>\n<p>Let’s import some design elements from the Material UI package we installed to the new <code>/components/ProjectCard.tsx</code> file to get us started:</p>\n<div>\n<pre><code>import React from \"react\";\nimport { Typography, Grid, Stack, Paper} from \"@mui/material\";\ninterface IProps {\n    issueTitle: string\n}\nconst ProjectCard : React.FC&lt;IProps&gt; = ({ issueTitle }) =&gt; {\n    return(\n        &lt;div className=\"project_card\"&gt;\n            &lt;Paper elevation={1} sx={{p: '10px', m:'1rem'}}&gt;\n                &lt;Grid container spacing={2}&gt;\n                    &lt;Grid item xs={12} md={6}&gt;\n                        &lt;Stack spacing={2}&gt;\n                            &lt;Typography variant=\"h6\" sx={{fontWeight: 'bold'}}&gt;\n                                Issue Title: {issueTitle}\n                            &lt;/Typography&gt;\n                            &lt;Stack direction='row' spacing={2}&gt;\n                                &lt;Typography variant=\"body1\"&gt;\n                                    Opened: yesterday\n                                &lt;/Typography&gt;\n                                &lt;Typography variant=\"body1\"&gt;\n                                    Priority: medium\n                                &lt;/Typography&gt;\n                            &lt;/Stack&gt;\n                        &lt;/Stack&gt;\n                    &lt;/Grid&gt;\n                &lt;/Grid&gt;\n            &lt;/Paper&gt;\n        &lt;/div&gt;\n    )\n}\nexport default ProjectCard;\n</code></pre>\n</div>\n\n<p>This creates the project card that displays an issue title, issue priority level, and the time the issue was “opened.” Notice that we are using an <code>issueTitle</code> prop that will be passed to the <code>ProjectCard</code> component to render the issue with a provided title.</p>\n<p>Now, let’s create the component for the app’s <code>HomePage</code> to display all the issues. We’ll add a small form to the page for submitting new issues that contain a text field for entering the issue name and a button to submit the form. We can do that by opening up the <code>src/HomePage.tsx</code> file in the project folder and importing React’s <code>useState</code> hook, a few more styled elements from Material UI, and the <code>ProjectCard</code> component we set up earlier:</p>\n<div>\n<pre><code>import React, { useState } from \"react\";\nimport { Box, Typography, TextField, Stack, Button } from \"@mui/material\";\nimport ProjectCard from \"./components/ProjectCard\";\nconst HomePage = () =&gt; {\n    const [textInput, setTextInput] = useState('');\n    const handleTextInputChange = (e:any) =&gt; {\n        setTextInput(e.target.value);\n    };\n    return(\n        &lt;div className=\"home_page\"&gt;\n            &lt;Box sx={{ml: '5rem', mr: '5rem'}}&gt;\n                &lt;Typography variant=\"h4\" sx={{textAlign: 'center'}}&gt;\n                    Project Issue Tracker\n                &lt;/Typography&gt;\n                &lt;Box sx={{display: 'flex'}}&gt;\n                    &lt;Stack spacing={2}&gt;\n                        &lt;Typography variant=\"h5\"&gt;\n                            Add new issue\n                        &lt;/Typography&gt;\n                        &lt;TextField \n                        id=\"outlined-basic\" \n                        label=\"Title\" \n                        variant=\"outlined\" \n                        onChange={handleTextInputChange}\n                        value={textInput}\n                        /&gt;\n                        &lt;Button variant=\"contained\"&gt;Submit&lt;/Button&gt;\n                    &lt;/Stack&gt;\n                &lt;/Box&gt;\n                &lt;Box sx={{ml: '1rem', mt: '3rem'}}&gt;\n                    &lt;Typography variant=\"h5\" &gt;\n                        Opened issue\n                    &lt;/Typography&gt;\n                        &lt;ProjectCard issueTitle=\"Bug: Issue 1\" /&gt;\n                        &lt;ProjectCard issueTitle=\"Bug: Issue 2\" /&gt;\n                &lt;/Box&gt;\n            &lt;/Box&gt;\n        &lt;/div&gt;\n    )\n}\nexport default HomePage;\n</code></pre>\n</div>\n\n<p>This results in a new <code>HomePage</code> component that a user can interact with to add new issues by entering an issue name in a form text input. When the issue is submitted, a new <code>ProjectCard</code> component is added to the <code>HomePage</code>, which acts as an index for viewing all open issues.</p>\n<p>The only thing left for the interface is to render the <code>HomePage</code>, which we can do by adding it to the <code>App.tsx</code> file. <a href=\"https://github.com/smashingmagazine/project_issue_tracker/blob/master/src/App.tsx\">The full code is available here on GitHub.</a></p>\nUsing Redux Toolkit\n<p>Now that our UI is finalised, we can move on to implementing Redux Toolkit to manage the state of this app. We will use Redux Toolkit to manage the state of the <code>ProjectCard</code> list by <a href=\"https://redux-toolkit.js.org/tutorials/quick-start#create-a-redux-store\">storing all the issues in a store</a> that can be accessed from anywhere in the application.</p>\n<p>Before we move to the actual implementation, let’s understand a few Redux Toolkit concepts to help understand what we’re implementing:</p>\n<ol>\n<li><a href=\"https://redux-toolkit.js.org/usage/usage-with-typescript#createslice\"><code>createSlice</code></a><br />This function makes it easy to define the reducer, actions, and the <code>initialState</code> under one object. Unlike the plain redux, you don’t need to use a switch for actions and need to define the actions separately. This function accepts an object as a name (i.e., the name of the slice) and the initial state of the store and the reducer, where you define all the reducers along with their action types.</li>\n<li><a href=\"https://redux-toolkit.js.org/usage/usage-with-typescript#configurestore\"><code>configureStore</code></a><br />This function is an abstraction for the Redux <code>createStore()</code> function. It removes the dependency of defining reducers separately and creating a store again. This way, the store is configured automatically and can be passed to the <a href=\"https://redux-toolkit.js.org/tutorials/rtk-query/#wrap-your-application-with-the-provider\"><code>Provider</code></a>.</li>\n<li><a href=\"https://redux-toolkit.js.org/usage/usage-with-typescript#createasyncthunk\"><code>createAsyncThunk</code></a><br />This function simplifies making asynchronous calls. It automatically dispatches many different actions for managing the state of the calls and provides a standardised way to handle errors.</li>\n</ol>\n<p>Let’s implement all of this! We will create the <code>issueReducer</code> with an <code>addIssue()</code> action that adds any new submitted issue to the <code>projectIssues</code> store. This can be done by creating a new file in <code>src/redux/</code> called <code>IssueReducer.ts</code> with this code:</p>\n<div>\n<pre><code>// Part 1\nimport { createSlice, PayloadAction } from \"@reduxjs/toolkit\"\n\n// Part 2\nexport interface IssueInitialState {\n    projectIssues: string[]\n}\nconst initialState: IssueInitialState = {\n    projectIssues: []\n}\n\n// Part 3\nexport const issueSlice = createSlice({\n    name: 'issue',\n    initialState,\n    reducers: {\n        addIssue: (state, action: PayloadAction&lt;string&gt;) =&gt; {\n            state.projectIssues = [...state.projectIssues, action.payload]\n        }\n    }\n})\n\n// Part 4\nexport const { addIssue } = issueSlice.actions\nexport default issueSlice.reducer\n</code></pre>\n</div>\n\n<p>Let’s understand each part of the code. First, we are importing the necessary functions from the Redux <code>@reduxjs/toolkit</code> package.</p>\n<p>Then, we create the type definition of our initial state and initialise the <code>initialState</code> for the <code>issueReducer</code>. The <code>initialState</code> has a <code>projectIssues[]</code> list that will be used to store all the submitted issues. We can have as many properties defined in the <code>initialState</code> as we need for the application.</p>\n<p>Thirdly, we are defining the <code>issueSlice</code> using Redux Toolkit’s <code>createSlice</code> function, which has the logic of the <code>issueReducer</code> as well as the different actions associated with it. <code>createSlice</code> accepts an object with a few properties, including:</p>\n<ul>\n<li><code>name</code>: the name of the slice,</li>\n<li><code>initialState</code>: the initial state of the reducer function,</li>\n<li><code>reducers</code>: an object that accepts different actions we want to define for our reducer.</li>\n</ul>\n<p>The slice name for the <code>issueReducer</code> is <code>issueSlice</code>. The <code>initalState</code> of it is defined, and a single <code>adIssue</code> action is associated with it. The <code>addIssue</code> action is dispatched whenever a new issue is submitted. We can have other actions defined, too, if the app requires it, but this is all we need for this example.</p>\n<p>Finally, in the last part of the code, we export the actions associated with our reducer and the <code>issueSlice</code> reducer. We have fully implemented our <code>issueReducer</code>, which stores all the submitted issues by dispatching the <code>addIssue</code> action.</p>\n<p>Now let’s configure the <code>issueReducer</code> in our store so we can use it in the app. Create a new file in <code>src/redux/</code> called <code>index.ts</code>, and add the following code:</p>\n<pre><code>import { configureStore } from \"@reduxjs/toolkit\";\nimport IssueReducer from \"./IssueReducer\";\nexport const store = configureStore({\n    reducer: {\n        issue: IssueReducer\n    }\n})\nexport type RootState = ReturnType&lt;typeof store.getState&gt;\nexport type AppDispatch = typeof store.dispatch\n</code></pre>\n\n<p>This code configures and creates the store using the <code>configureStore()</code> function that accepts a reducer where we can pass all of the different reducers.</p>\n<p>We are done adding the reducer and configuring the store with Redux Toolkit. Let’s do the final step of passing the store to our app. Start by updating the <code>App.tsx</code> file to pass the store using the <code>Provider</code>:</p>\n<pre><code>import React from 'react';\nimport { Provider } from \"react-redux\"\nimport { store } from './redux';\nimport HomePage from './HomePage';\nfunction App() {\n    return (\n        &lt;div className=\"App\"&gt;\n            &lt;Provider store={store}&gt;\n                &lt;HomePage /&gt;\n            &lt;/Provider&gt;\n        &lt;/div&gt;\n     );\n}\nexport default App;\n</code></pre>\n\n<p>Here, you can see that we are importing the store and directly passing through the <code>Provider</code>. We don’t need to write anything extra to create a store or configure DevTools like we would using plain Redux. This is definitely one of the ways Redux Toolkit streamlines things.</p>\n<p>OK, we have successfully set up a store and a reducer for our app with Redux Toolkit. Let’s use our app now and see if it works. To quickly sum things up, the <code>dispatch()</code> function is used to dispatch any actions to the store, and <code>useSelector()</code> is used for accessing any state properties.</p>\n<p>We will dispatch the <code>addIssue</code> action when the form button is clicked:</p>\n<pre><code>const handleClick = () =&gt; {\n    dispatch(addIssue(textInput))\n}\n</code></pre>\n\n<p>To access the <code>projectIssue</code> list stored in our reducer store, we can make use of <code>useSelector()</code> like this:</p>\n<pre><code>const issueList = useSelector((state: RootState) =&gt; state.issue.projectIssues)\n</code></pre>\n\n<p>Finally, we can render all the issues by <code>map()</code>-ping the <code>issueList</code> to the <code>ProjectCard</code> component:</p>\n<pre><code>{\n    issueList.map((issue) =&gt; {\n        return(\n            &lt;ProjectCard issueTitle={issue} /&gt;\n        )\n    })\n}\n</code></pre>\n\n<p>The final code for <code>HomePage.tsx</code> looks like this:</p>\n<div>\n<pre><code>import React, { useState } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { RootState } from \"./redux/index\"\nimport { Box, Typography, TextField, Stack, Button } from \"@mui/material\";\nimport ProjectCard from \"./components/ProjectCard\";\nimport { addIssue } from \"./redux/IssueReducer\";\nconst HomePage = () =&gt; {\n    const dispatch = useDispatch();\n    const issueList = useSelector((state: RootState) =&gt; state.issue.projectIssues)\n    const [textInput, setTextInput] = useState('');\n    const handleTextInputChange = (e:any) =&gt; {\n        setTextInput(e.target.value);\n    };\n    const handleClick = () =&gt; {\n        dispatch(addIssue(textInput))\n    }\n    return(\n        &lt;div className=\"home_page\"&gt;\n            &lt;Box sx={{ml: '5rem', mr: '5rem'}}&gt;\n                &lt;Typography variant=\"h4\" sx={{textAlign: 'center'}}&gt;\n                    Project Issue Tracker\n                &lt;/Typography&gt;\n                &lt;Box sx={{display: 'flex'}}&gt;\n                    &lt;Stack spacing={2}&gt;\n                        &lt;Typography variant=\"h5\"&gt;\n                            Add new issue\n                        &lt;/Typography&gt;\n                        &lt;TextField \n                        id=\"outlined-basic\" \n                        label=\"Title\" \n                        variant=\"outlined\" \n                        onChange={handleTextInputChange}\n                        value={textInput}\n                        /&gt;\n                        &lt;Button variant=\"contained\" onClick={handleClick}&gt;Submit&lt;/Button&gt;\n                    &lt;/Stack&gt;\n                &lt;/Box&gt;\n                &lt;Box sx={{ml: '1rem', mt: '3rem'}}&gt;\n                    &lt;Typography variant=\"h5\" &gt;\n                        Opened issue\n                    &lt;/Typography&gt;\n                    {\n                        issueList.map((issue) =&gt; {\n                            return(\n                                &lt;ProjectCard issueTitle={issue} /&gt;\n                            )\n                        })\n                    }\n                &lt;/Box&gt;\n            &lt;/Box&gt;\n        &lt;/div&gt;\n    )\n}\nexport default HomePage;\n</code></pre>\n</div>\n\n<p>Now, when we add and submit an issue using the form, that issue will be rendered on the homepage.</p>\n<p>This section covered how to define any reducer and how they’re used in the app. The following section will cover how Redux Toolkit makes asynchronous calls a relatively simple task.</p>\nMaking Asynchronous Calls With Redux Toolkit\n<p>We implemented our store to save and render any newly added issue to our app. What if we want to call GitHub API for any repository and list all the issues of it in our app? In this section, we will see how to use the <code>createAsyncThunk()</code> API with the slice to get data and render all the repository issues using an API call.</p>\n<p>I always prefer to use the <code>createAsyncThunk()</code> API of the redux toolkit because it <strong>standardises the way different states are handled</strong>, such as <code>loading</code>, <code>error</code>, and <code>fulfilled</code>. Another reason is that we <strong>don’t need to add extra configurations for the middleware</strong>.</p>\n<p>Let’s add the code for creating a <code>GithubIssue</code> reducer first before we break it down to understand what’s happening. Add a new <code>GithubIssueReducer.ts</code> file in the <code>/redux</code> folder and add this code: </p>\n<div>\n<pre><code>import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\nexport const fetchIssues = createAsyncThunk&lt;string[], void, { rejectValue: string }&gt;(\n  \"githubIssue/fetchIssues\",\n  async (_, thunkAPI) =&gt; {\n    try {\n      const response = await fetch(\"<a href=\"https://api.github.com/repos/github/hub/issues&quot;)\">https://api.github.com/repos/github/hub/issues\")</a>;\n      const data = await response.json();\n      const issues = data.map((issue: { title: string }) =&gt; issue.title);\n      return issues;\n    } catch (error) {\n      return thunkAPI.rejectWithValue(\"Failed to fetch issues.\");\n    }\n  }\n);\ninterface IssuesState {\n  issues: string[];\n  loading: boolean;\n  error: string | null;\n}\nconst initialState: IssuesState = {\n  issues: [],\n  loading: false,\n  error: null,\n};\nexport const issuesSliceGithub = createSlice({\n  name: 'github_issues',\n  initialState,\n  reducers: {},\n  extraReducers: (builder) =&gt; {\n    builder\n      .addCase(fetchIssues.pending, (state) =&gt; {\n        state.loading = true;\n        state.error = null;\n      })\n      .addCase(fetchIssues.fulfilled, (state, action) =&gt; {\n        state.loading = false;\n        state.issues = action.payload;\n      })\n      .addCase(fetchIssues.rejected, (state, action) =&gt; {\n        state.loading = false;\n        state.error = action.error.message || 'Something went wrong';\n      });\n  },\n});\nexport default issuesSliceGithub.reducer;\n</code></pre>\n</div>\n\n<p>Let’s understand the <code>fetchIssues</code> part first:</p>\n<ol>\n<li>We are using the <code>createAsyncThunk()</code> API provided by the Redux Toolkit. It helps create asynchronous actions and handles the app’s loading and error states.</li>\n<li>The action type name is the first argument passed to <code>createAsyncThunk()</code>. The specific action type name we have defined is <code>githubIssue/fetchIssues</code>.</li>\n<li>The second argument is a function that returns a <code>Promise</code>, which resolves to the value that dispatches the action. This is when the asynchronous function fetches data from a GitHub API endpoint and maps the response data to a list of issue titles.</li>\n<li>The third argument is an object that contains configuration options for the async thunk. In this case, we have specified that the async thunk will not be dispatched with any arguments (hence the <code>void</code> type) and that if the <code>Promise</code> returned by the async function is rejected, the async thunk will return an action with a rejected status along with a <code>rejectValue</code> property that contains the string “Failed to fetch issues.”</li>\n</ol>\n<p>When this action is dispatched, the API calls will be made, and the <code>githubIssuesList</code> data will be stored. We can follow this exact same sequence of steps to make any API calls we need.</p>\n<p>The second section of the code is similar to what we used when we created the <code>issueSlice</code>, but with three differences:</p>\n<ol>\n<li><code>extraReducers</code><br />This object contains the reducers logic for the reducers not defined in the <code>createSlice</code> reducers object. It takes a builder object where different cases can be added using <code>addCase</code> for specific action types.</li>\n<li><code>addCase</code><br />This method on the builder object creates a new case for the reducer function.</li>\n<li><strong>API call states</strong><br />The callback function passed to the <code>addCase</code> method is dispatched by <code>createAsyncThunk()</code>, which updates the different store objects based on the API call states (<code>pending</code>, <code>fulfilled</code>, and <code>error</code>).</li>\n</ol>\n<p>We can now use the <code>GithubIssue</code> reducer actions and the store in our app. Let’s add the <code>GithubIssueReducer</code> to our store first. Update the <code>/redux/index.ts</code> file with this code:</p>\n<pre><code>\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport { useDispatch } from \"react-redux\";\nimport IssueReducer from \"./IssueReducer\";\nimport GithubIssueReducer from \"./GithubIssueReducer\";\nexport const store = configureStore({\n    reducer: {\n        issue: IssueReducer,\n        githubIssue: GithubIssueReducer\n    }\n})\nexport type RootState = ReturnType&lt;typeof store.getState&gt;\nexport type AppDispatch = typeof store.dispatch\nexport const useAppDispatch = () =&gt; useDispatch&lt;AppDispatch&gt;()\n</code></pre>\n\n<p>We just added the <code>GithubIssueReducer</code> to our store with the name mapped to <code>githubIssue</code>. We can now use this reducer in our <code>HomePage</code> component to dispatch the <code>fetchIssues()</code> and populate our page with all the issues received from the GitHub API repo.</p>\n<div>\n<pre><code>import React, { useState, useEffect } from \"react\";\nimport { useSelector } from \"react-redux\";\nimport { useAppDispatch, RootState, AppDispatch } from \"./redux/index\";\nimport { Box, Typography, TextField, Stack, Button } from \"@mui/material\";\nimport ProjectCard from \"./components/ProjectCard\";\nimport { addIssue } from \"./redux/IssueReducer\";\nimport { fetchIssues } from \"./redux/GithubIssueReducer\";\nconst HomePage = () =&gt; {\n    const dispatch: AppDispatch = useAppDispatch();\n    const [textInput, setTextInput] = useState('');\n    const githubIssueList = useSelector((state: RootState) =&gt; state.githubIssue.issues)\n    const loading = useSelector((state: RootState) =&gt; state.githubIssue.loading);\n    const error = useSelector((state: RootState) =&gt; state.githubIssue.error);\n    useEffect(() =&gt; {\n        dispatch(fetchIssues())\n      }, [dispatch]);\n\n    if (loading) {\n      return &lt;div&gt;Loading...&lt;/div&gt;;\n    }\n\n    if (error) {\n      return &lt;div&gt;Error: {error}&lt;/div&gt;;\n    }\n    const handleTextInputChange = (e:any) =&gt; {\n        setTextInput(e.target.value);\n    };\n    const handleClick = () =&gt; {\n        console.log(textInput)\n        dispatch(addIssue(textInput))\n    }\n    return(\n        &lt;div className=\"home_page\"&gt;\n            &lt;Box sx={{ml: '5rem', mr: '5rem'}}&gt;\n                &lt;Typography variant=\"h4\" sx={{textAlign: 'center'}}&gt;\n                    Project Issue Tracker\n                &lt;/Typography&gt;\n                &lt;Box sx={{display: 'flex'}}&gt;\n                    &lt;Stack spacing={2}&gt;\n                        &lt;Typography variant=\"h5\"&gt;\n                            Add new issue\n                        &lt;/Typography&gt;\n                        &lt;TextField \n                        id=\"outlined-basic\" \n                        label=\"Title\" \n                        variant=\"outlined\" \n                        onChange={handleTextInputChange}\n                        value={textInput}\n                        /&gt;\n                        &lt;Button variant=\"contained\" onClick={handleClick}&gt;Submit&lt;/Button&gt;\n                    &lt;/Stack&gt;\n                &lt;/Box&gt;\n                &lt;Box sx={{ml: '1rem', mt: '3rem'}}&gt;\n                    &lt;Typography variant=\"h5\" &gt;\n                        Opened issue\n                    &lt;/Typography&gt;\n                    {\n                        githubIssueList?.map((issue : string) =&gt; {\n                            return(\n                                &lt;ProjectCard issueTitle={issue} /&gt;\n                            )\n                        })\n                    }\n                &lt;/Box&gt;\n            &lt;/Box&gt;\n        &lt;/div&gt;\n    )\n}\nexport default HomePage;\n</code></pre>\n</div>\n\n<p>This updates the code in <code>HomePage.tsx</code> with two minor changes:</p>\n<ol>\n<li>We dispatch <code>fetchIssue</code> and use the  <code>createAsync()</code> action to make the API calls under the <code>useEffect</code> hook.</li>\n<li>We use the <code>loading</code> and <code>error</code> states when the component renders.</li>\n</ol>\n<p>Now, when loading the app, you will first see the “Loading” text rendered, and once the API call is fulfilled, the <code>issuesList</code> will be populated with all the titles of GitHub issues fetched from the repo.</p>\n<p>Once again, the complete code for this project <a href=\"https://github.com/smashingmagazine/project_issue_tracker\">can be found on GitHub</a>. You can also <a href=\"https://master--relaxed-lamington-5fba83.netlify.app/\">check out a live deployment of the app</a>, which displays all the issues fetched from GitHub.</p>\nConclusion\n<p>There we have it! We used Redux Toolkit in a React TypeScript application to build a fully functional project issue tracker that syncs with GitHub and allows us to create new issues directly from the app.</p>\n<p>We learned many of the foundational concepts of Redux Toolkit, such as defining reducers, immutability helpers, built-in middleware, and DevTools integration. I hope you feel powered to use Redux Toolkit effectively in your projects. With Redux Toolkit, you can improve the performance and scalability of your React applications by effectively managing the global state.</p>\n<h3>Further Reading on Smashing Magazine</h3>\n<ul>\n<li><a href=\"https://www.smashingmagazine.com/2020/12/how-redux-reducers-work/\">How Redux Reducers Work</a>, Fortune Ikechi</li>\n<li><a href=\"https://www.smashingmagazine.com/2018/07/redux-designers-guide/\">What Is Redux: A Designer’s Guide</a>, Linton Ye</li>\n<li><a href=\"https://www.smashingmagazine.com/2021/01/dynamic-static-typing-typescript/\">Dynamic Static Typing In TypeScript</a>, Stefan Baumgartner</li>\n<li><a href=\"https://www.smashingmagazine.com/2021/11/deep-dive-into-serverless-ui-typescript/\">A Deep Dive Into Serverless UI With TypeScript</a>, Ikeh Akinyemi</li>\n<li><a href=\"https://www.smashingmagazine.com/2020/08/redux-real-world-application/\">Setting Up Redux For Use In A Real-World Application</a>, Jerry Navi</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"af4e2888c6cfc7c5d677ca2002c3d2090a1b898738f670497e290a2079cf0c9f","category":"Tech"}