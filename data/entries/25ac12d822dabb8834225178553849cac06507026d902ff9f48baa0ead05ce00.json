{"title":"ว่าด้วยเรื่องของ Monolithic App มันมีรูปแบบไหนบ้าง ?","link":"https://www.somkiat.cc/note-monolithic-app/","date":1717304650000,"content":"<p><img width=\"150\" height=\"150\" src=\"https://www.somkiat.cc/wp-content/uploads/2024/06/monolith-app-01-150x150.png\" loading=\"lazy\" srcset=\"https://www.somkiat.cc/wp-content/uploads/2024/06/monolith-app-01-150x150.png 150w, https://www.somkiat.cc/wp-content/uploads/2024/06/monolith-app-01-75x75.png 75w\" /></p>\n<figure><a href=\"https://www.somkiat.cc/wp-content/uploads/2024/06/monolith-app-01.png\"><img src=\"https://www.somkiat.cc/wp-content/uploads/2024/06/monolith-app-01-1024x548.png\" width=\"687\" height=\"367\" /></a></figure>\n\n\n\n<p>จากการแบ่งปันเรื่อง Microservices นั้น มักจะแนะนำให้เริ่มจาก <strong><a href=\"https://glossary.cncf.io/monolithic-apps/\" target=\"_blank\">Monolithic app</a></strong> ไปก่อน<br />ทำให้มันดีก่อน ที่จะแยกไปเป็น service ย่อย ๆ<br />จากนั้นทำการ monitor ว่าแนวทางนั้นมันส่งผลกระทบต่อระบบ และ การทำงานหรือไม่<br />เช่น productivity ของการส่งมอบ ผลกระทบจากการส่งมอบ<br />รวมถึงการ maintain ระบบ ว่ายากขึ้นหรือไม่ ?</p>\n\n\n\n<span></span>\n\n\n\n<p><strong>มีคำถามว่า Monolithic App นั้นมีรูปแบบไหนบ้าง ?</strong></p>\n\n\n\n<p>จึงทำการสรุปไว้คร่าว ๆ ดังนี้</p>\n\n\n\n<ul>\n<li>รูปแบบที่ 1 มุมมองของ code คือ Single repository นั่นเอง เข้าที่เดียวมีครบ เช่นรวม frontend กับ backend เป็นต้น</li>\n\n\n\n<li>รูปแบบที่ 2 มุมมองของ  database คือ Single database มีจำนวน table เยอะ ๆ หนักกว่านั้นแยก database scahema นะ แต่ join ข้าม database​ซะงั้น</li>\n\n\n\n<li>รูปแบบที่ 3 Service ใหญ่ ๆ มีหน้าที่รับผิดชอบเยอะมาก ๆ เพิ่มไปเรื่อย ๆ รูปว่าไม่ดีก็ยังเพิ่มเข้าไปอีก ไม่ใช่หน้าที่โดยตรงก็ดันเพิ่มเข้าไป</li>\n\n\n\n<li>รูปแบบที่ 4 App ใหญ่ ๆ เพิ่ม feature ไปเรื่อย ๆ ส่งช้าลงเรื่อย ๆ มีปัญหาขึ้นเรื่อย ๆ เช่น Supur app เป็นต้น แต่ถ้าจัดการดีก็ดีไป</li>\n</ul>\n\n\n\n<p>ในการรวมกันนั้นมีทั้งข้อดีและข้อเสีย<br />แต่ถ้ามาแนวทางนี้แล้ว จำเป็นต้องมีการออกแบบและลงมือทำที่ดีด้วย<br />ยกตัวอย่างเช่น</p>\n\n\n\n<ul>\n<li>ความเข้าใจใน requirement แบบ end-to-end ไม่ใช่เพียงรู้ในส่วนที่ตัวเองทำหรือรับผิดชอบเท่านั้น</li>\n\n\n\n<li>แบ่งส่วนการทำงานแบบ modular ให้ดี ลดการผูกมักระหว่าง module ลงไปให้เยอะ (loose couple)</li>\n\n\n\n<li>ออกแบบโครงสร้างข้อมูลของแต่ละ module/domain ให้ชัดเจน แยก database schema ให้ชัดเจน</li>\n\n\n\n<li>แนวทางในการทดสอบที่ดี </li>\n\n\n\n<li>ในแต่ละ service ควรมีการแยกการ deploy ให้เป็นอิสระมากยิ่งขึ้น</li>\n\n\n\n<li>ระบบ monitoring และ observability ที่ดี เพื่อเป็นข้อมูลในการตัดสินใจ</li>\n</ul>\n\n\n\n<p><strong>ข้อควรระวัง !!!</strong></p>\n\n\n\n<ul>\n<li>เมื่อแยก database schema แล้ว ก็อย่าให้เรียกข้ามกัน</li>\n\n\n\n<li>เมื่อแยก module แล้วก็อย่าให้ผูกมัดกัน</li>\n\n\n\n<li>เมื่อแยก service กัน ก็อย่าเรียกกันไปมา มันจะเกิด Distributed monolithic ได้</li>\n\n\n\n<li>เมื่อ productivity เริ่มลดลง ก็ได้เวลาหยุด เพื่อทำการปรับปรุง ( Later === Never )</li>\n</ul>\n","author":"somkiat","siteTitle":"cc :: somkiat","siteHash":"3a23a5a4389e1e40c6fbb16520a8cc20df5b3591c25145ce72aaa18b19e48201","entryHash":"25ac12d822dabb8834225178553849cac06507026d902ff9f48baa0ead05ce00","category":"Thai"}