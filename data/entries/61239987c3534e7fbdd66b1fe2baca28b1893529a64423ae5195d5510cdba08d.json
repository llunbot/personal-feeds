{"title":"How To Fix Largest Contentful Issues With Subpart Analysis","link":"https://smashingmagazine.com/2025/03/how-fix-largest-contentful-issues-subpart-analysis/","date":1741255200000,"content":"<p>This article is a sponsored by <a href=\"https://www.debugbear.com/?utm_campaign=sm-9\">DebugBear</a></p>\n<p>The <a href=\"https://www.debugbear.com/docs/metrics/largest-contentful-paint?utm_campaign=sm-9\">Largest Contentful Paint</a> (LCP) in Core Web Vitals measures how quickly a website loads from a visitor’s perspective. It looks at how long after opening a page the largest content element becomes visible. If your website is loading slowly, that’s bad for user experience and can also cause your site to <a href=\"https://developers.google.com/search/docs/appearance/page-experience#ranking\">rank lower in Google</a>.</p>\n<p>When trying to fix LCP issues, it’s not always clear what to focus on. Is the server too slow? Are images too big? Is the content not being displayed? Google has been working to address that recently by introducing <a href=\"https://www.debugbear.com/blog/lcp-subparts?utm_campaign=sm-9\">LCP subparts</a>, which tell you where page load delays are coming from. They’ve also added this data to the <a href=\"https://www.debugbear.com/blog/chrome-user-experience-report?utm_campaign=sm-9\">Chrome UX Report</a>, allowing you to see what causes delays for real visitors on your website!</p>\n<p>Let’s take a look at what the LCP subparts are, what they mean for your website speed, and how you can measure them.</p>\nThe Four LCP Subparts\n<p>LCP subparts split the Largest Contentful Paint metric into four different components:</p>\n<ol>\n<li><strong>Time to First Byte (TTFB)</strong>: How quickly the server responds to the document request.</li>\n<li><strong>Resource Load Delay</strong>: Time spent before the LCP image starts to download.</li>\n<li><strong>Resource Load Time</strong>: Time spent downloading the LCP image.</li>\n<li><strong>Element Render Delay</strong>: Time before the LCP element is displayed.</li>\n</ol>\n<p>The resource timings only apply if the largest page element is an image or background image. For text elements, the Load Delay and Load Time components are always zero.</p>\nHow To Measure LCP Subparts\n<p>One way to measure how much each component contributes to the LCP score on your website is to use DebugBear’s <a href=\"https://www.debugbear.com/test/website-speed?utm_campaign=sm-9\">website speed test</a>. Expand the Largest Contentful Paint metric to see subparts and other details related to your LCP score.</p>\n<p>Here, we can see that TTFB and image Load Duration together account for 78% of the overall LCP score. That tells us that these two components are the most impactful places to start optimizing.</p>\n<p><img src=\"https://files.smashing.media/articles/how-fix-largest-contentful-issues-subpart-analysis/1-lcp-subparts.png\" /></p>\n<p>What’s happening during each of these stages? A network <a href=\"https://www.debugbear.com/docs/waterfall?utm_campaign=sm-9\">request waterfall</a> can help us understand what resources are loading through each stage.</p>\n<p>The LCP Image Discovery view filters the waterfall visualization to just the resources that are relevant to displaying the Largest Contentful Paint image. In this case, each of the first three stages contains one request, and the final stage finishes quickly with no new resources loaded. But that depends on your specific website and won’t always be the case.</p>\n<p><img src=\"https://files.smashing.media/articles/how-fix-largest-contentful-issues-subpart-analysis/2-lcp-image-discovery.png\" /></p>\nTime To First Byte\n<p>The first step to display the largest page element is fetching the document HTML. We recently published an <a href=\"https://www.smashingmagazine.com/2025/02/time-to-first-byte-beyond-server-response-time/\">article about how to improve the TTFB metric</a>.</p>\n<p>In this example, we can see that creating the server connection doesn’t take all that long. Most of the time is spent waiting for the server to generate the page HTML. So, to improve the TTFB, we need to speed up that process or cache the HTML so we can skip the HTML generation entirely.</p>\nResource Load Delay\n<p>The “resource” we want to load is the LCP image. Ideally, we just have an <code>&lt;img&gt;</code> tag near the top of the HTML, and the browser finds it right away and starts loading it.</p>\n<p>But sometimes, we get a <a href=\"https://www.debugbear.com/blog/lcp-resource-load-delay?utm_campaign=sm-9\">Load Delay</a>, as is the case here. Instead of loading the image directly, the page uses <code>lazysize.js</code>, <strong>an image lazy loading library</strong> that only loads the LCP image once it has detected that it will appear in the viewport.</p>\n<p>Part of the Load Delay is caused by having to download that JavaScript library. But the browser also needs to complete the page layout and start rendering content before the library will know that the image is in the viewport. After finishing the request, there’s a CPU task (in orange) that leads up to the <a href=\"https://www.debugbear.com/docs/metrics/first-contentful-paint?utm_campaign=sm-9\">First Contentful Paint</a> milestone, when the page starts rendering. Only then does the library trigger the LCP image request.</p>\n<p><img src=\"https://files.smashing.media/articles/how-fix-largest-contentful-issues-subpart-analysis/3-load-delay.png\" /></p>\n<p>How do we optimize this? First of all, instead of using a lazy loading library, you can use the native <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#loading\"><code>loading=\"lazy\"</code> image attribute</a>. That way, loading images <strong>no longer depends on first loading JavaScript code</strong>.</p>\n<p>But more specifically, <a href=\"https://www.debugbear.com/docs/lcp-lazily-loaded?utm_campaign=sm-9\">the LCP image should not be lazily loaded</a>. That way, the browser can start loading it as soon as the HTML code is ready. According to Google, you should aim to <a href=\"https://web.dev/articles/optimize-lcp#1_eliminate_resource_load_delay\">eliminate resource load delay entirely</a>.</p>\nResources Load Duration\n<p>The <a href=\"https://www.debugbear.com/blog/lcp-resource-load-duration?utm_campaign=sm-9\">Load Duration subpart</a> is probably the most straightforward: you need to download the LCP image before you can display it!</p>\n<p>In this example, the image is loaded from the same domain as the HTML. That’s good because the browser doesn’t have to connect to a new server.</p>\n<p>Other techniques you can use to reduce load delay:</p>\n<ul>\n<li>Use a <a href=\"https://www.debugbear.com/blog/image-formats?utm_campaign=sm-9\">modern image format</a> that provides better compression.</li>\n<li>Load images at a size that <a href=\"https://developer.chrome.com/docs/lighthouse/performance/uses-responsive-images\">matches the size they are displayed at</a>.</li>\n<li>Deprioritize other resources that might <a href=\"https://www.debugbear.com/blog/bandwidth-competition-page-speed?utm_campaign=sm-9\">compete with the LCP image</a>.</li>\n</ul>\nElement Render Delay\n<p>The fourth and final LCP component, <a href=\"https://www.debugbear.com/blog/lcp-render-delay?utm_campaign=sm-9\">Render Delay</a>, is often the most confusing. The resource has loaded, but for some reason, the browser isn’t ready to show it to the user yet!</p>\n<p>Luckily, in the example we’ve been looking at so far, the LCP image appears quickly after it’s been loaded. One common reason for render delay is that <strong>the LCP element is not an image</strong>. In that case, the render delay is caused by <strong>render-blocking scripts</strong> and <strong>stylesheets</strong>. The text can only appear after these have loaded and the browser has completed the rendering process.</p>\n<p><img src=\"https://files.smashing.media/articles/how-fix-largest-contentful-issues-subpart-analysis/4-render-delay.png\" /></p>\n<p>Another reason you might see render delay is when the website <a href=\"https://www.debugbear.com/blog/preload-largest-contentful-paint-image?utm_campaign=sm-9\">preloads the LCP image</a>. Preloading is a good idea, as it practically eliminates any load delay and ensures the image is loaded early.</p>\n<p>However, if the image finishes downloading before the page is ready to render, you’ll see an increase in render delay on the page. And that’s fine! You’ve improved your website speed overall, but after optimizing your image, you’ve uncovered a new bottleneck to focus on.</p>\n<p><img src=\"https://files.smashing.media/articles/how-fix-largest-contentful-issues-subpart-analysis/5-render-delay-preloaded-lcp-image.png\" /></p>\nLCP Subparts In Real User CrUX Data\n<p>Looking at the Largest Contentful Paint subparts in lab-based tests can provide a lot of insight into where you can optimize. But all too often, the LCP in <a href=\"https://www.debugbear.com/blog/lcp-lab-field-differences?utm_campaign=sm-9\">the lab doesn’t match what’s happening for real users</a>!</p>\n<p>That’s why, in February 2025, Google started <a href=\"https://developer.chrome.com/blog/crux-2025-02\">including subpart data in the CrUX data report</a>. It’s not (yet?) included in PageSpeed Insights, but you can see those metrics in DebugBear’s “Web Vitals” tab.</p>\n<p><img src=\"https://files.smashing.media/articles/how-fix-largest-contentful-issues-subpart-analysis/6-crux-lcp-subparts.png\" /></p>\n<p>One super useful bit of info here is <strong>the LCP resource type</strong>: it tells you how many visitors saw the LCP element as a text element or an image.</p>\n<p>Even for the same page, different visitors will see slightly different content. For example, different elements are visible based on the device size, or some visitors will see a cookie banner while others see the actual page content.</p>\n<p>To make the data easier to interpret, Google only reports subpart data for images.</p>\n<blockquote>If the LCP element is usually text on the page, then the subparts info won’t be very helpful, as it won’t apply to most of your visitors.</blockquote>\n\n<p>But breaking down text LCP is relatively easy: everything that’s not part of the TTFB score is render-delayed.</p>\nTrack Subparts On Your Website With Real User Monitoring\n<p><a href=\"https://www.smashingmagazine.com/2023/08/running-page-speed-test-monitoring-versus-measuring/\">Lab data doesn’t always match what real users experience.</a> CrUX data is superficial, <strong>only reported for high-traffic pages</strong>, and takes at least <strong>4 weeks</strong> to fully update after a change has been rolled out.</p>\n<p>That’s why a <a href=\"https://www.debugbear.com/real-user-monitoring?utm_campaign=sm-9\">real-user monitoring tool like DebugBear</a> comes in handy when fixing your LCP scores. You can <strong>track scores across all pages</strong> on your website over time and get dedicated dashboards for each LCP subpart.</p>\n<p><img src=\"https://files.smashing.media/articles/how-fix-largest-contentful-issues-subpart-analysis/7-dashboards-each-lcp-subpart.png\" /></p>\n<p>You can also <strong>review specific visitor experiences</strong>, see what the LCP image was for them, inspect a request waterfall, and check LCP subpart timings. <a href=\"https://www.debugbear.com/signup?utm_campaign=sm-9\">Sign up for a free trial</a>.</p>\n<p><img src=\"https://files.smashing.media/articles/how-fix-largest-contentful-issues-subpart-analysis/8-lcp-scores-visitor-experiences.png\" /></p>\nConclusion\n<p>Having more granular metric data available for the Largest Contentful Paint gives web developers a big leg up when making their website faster.</p>\n<p>Including subparts in CrUX provides new insight into how real visitors experience your website and can tell if the optimizations you’re considering would really be impactful.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"61239987c3534e7fbdd66b1fe2baca28b1893529a64423ae5195d5510cdba08d","category":"Tech"}