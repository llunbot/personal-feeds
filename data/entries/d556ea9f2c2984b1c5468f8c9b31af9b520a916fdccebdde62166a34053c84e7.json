{"title":"Exploring The Potential Of Web Workers For Multithreading On The Web","link":"https://smashingmagazine.com/2023/04/potential-web-workers-multithreading-web/","date":1682071200000,"content":"<p>Web Workers are a powerful feature of modern web development and were introduced as part of the <a href=\"https://en.wikipedia.org/wiki/Web_worker\">HTML5 specification in 2009</a>. They were designed to provide a way to execute JavaScript code in the background, separate from the main execution thread of a web page, in order to improve performance and responsiveness.</p>\n<p>The main thread is the single execution context that is responsible for rendering the UI, executing JavaScript code, and handling user interactions. In other words, <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Main_thread\">JavaScript is “single-threaded”</a>. This means that any time-consuming task, such as complex calculations or data processing that is executed, would block the main thread and cause the UI to freeze and become unresponsive.</p>\n<p>This is where Web Workers come in.</p>\n<p>Web Workers were implemented as a way to address this problem by allowing time-consuming tasks to be executed in a separate thread, called a <strong>worker thread</strong>. This enabled JavaScript code to be executed in the background without blocking the main thread and causing the page to become unresponsive.</p>\n<p>Creating a web worker in JavaScript is not much of a complicated task. The following steps provide a starting point for integrating a web worker into your application:</p>\n<ol>\n<li>Create a new JavaScript file that contains the code you want to run in the worker thread. This file should not contain any references to the DOM, as it will not have access to it.</li>\n<li>In your main JavaScript file, create a new worker object using the <code>Worker</code> constructor. This constructor takes a single argument, which is the URL of the JavaScript file you created in step 1.<br />\n<pre><code>const worker = new Worker('worker.js');\n</code></pre>\n  </li>\n<li>Add event listeners to the worker object to handle messages sent between the main thread and the worker thread. The <code>onmessage</code> event handler is used to handle messages sent from the worker thread, while the <code>postMessage</code> method is used to send messages to the worker thread.<br />\n<pre><code>worker.onmessage = function(event) {\n  console.log('Worker said: ' + event.data);\n};\nworker.postMessage('Hello, worker!');\n</code></pre>\n  </li>\n<li>In your worker JavaScript file, add an event listener to handle messages sent from the main thread using the <code>onmessage</code> property of the <code>self</code> object. You can access the data sent with the message using the <code>event.data</code> property.<br />\n<pre><code>self.onmessage = function(event) {\n  console.log('Main thread said: ' + event.data);\n  self.postMessage('Hello, main thread!');\n};\n</code></pre>\n  </li>\n</ol>\n\n<p>Now let’s run the web application and test the worker. We should see messages printed to the console indicating that messages were sent and received between the main thread and the worker thread.</p>\n<p><img src=\"https://files.smashing.media/articles/potential-web-workers-multithreading-web/1-messages-console-between-main-worker-threads.png\" /></p>\n<p>One key difference between Web Workers and the main thread is that Web Workers have <strong>no access to the DOM or the UI</strong>. This means that they cannot directly manipulate the HTML elements on the page or interact with the user.</p>\n<p>Web Workers are designed to perform tasks that do not require direct access to the UI, such as data processing, image manipulation, or calculations.</p>\n<p>Another important difference is that Web Workers are designed to run in a <strong>sandboxed environment</strong>, separate from the main thread, which means that they have limited access to system resources and cannot access certain APIs, such as the <a href=\"https://www.smashingmagazine.com/2010/10/local-storage-and-how-to-use-it/\"><code>localStorage</code></a> or <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage\"><code>sessionStorage</code></a> APIs. However, they can communicate with the main thread through a messaging system, allowing data to be exchanged between the two threads.</p>\nImportance And Benefits Of Web Workers For Multithreading On The Web\n<p>Web Workers provide a way for web developers to achieve multithreading on the web, which is crucial for building high-performance web applications. By enabling time-consuming tasks to be executed in the background, separate from the main thread, Web Workers improve the overall responsiveness of web pages and allow for a more seamless user experience. The following are some of the importance and benefits of Web Workers for multithreading on the Web.</p>\n<h3>Improved Resource Utilization</h3>\n<p>By allowing time-consuming tasks to be executed in the background, Web Workers make more efficient use of system resources, enabling faster and more efficient processing of data and improving overall performance. This is especially important for web applications that involve large amounts of data processing or image manipulation, as Web Workers can perform these tasks without impacting the user interface.</p>\n<h3>Increased Stability And Reliability</h3>\n<p>By isolating time-consuming tasks in separate worker threads, Web Workers help to prevent crashes and errors that can occur when executing large amounts of code on the main thread. This makes it easier for developers to write stable and reliable web applications, reducing the likelihood of user frustration or loss of data.</p>\n<h3>Enhanced Security</h3>\n<p>Web Workers run in a sandboxed environment that is separate from the main thread, which helps to enhance the security of web applications. This isolation prevents malicious code from accessing or modifying data in the main thread or other Web Workers, reducing the risk of data breaches or other security vulnerabilities.</p>\n<h3>Better Resource Utilization</h3>\n<p>Web Workers can help to improve resource utilization by freeing up the main thread to handle user input and other tasks while the Web Workers handle time-consuming computations in the background. This can help to improve overall system performance and reduce the likelihood of crashes or errors. Additionally, by leveraging multiple CPU cores, Web Workers can make more efficient use of system resources, enabling faster and more efficient processing of data.</p>\n<p>Web Workers also enable better <a href=\"https://www.ibm.com/topics/load-balancing\">load balancing</a> and scaling of web applications. By allowing tasks to be executed in parallel across multiple worker threads, Web Workers can help <strong>distribute the workload evenly across multiple cores or processors</strong>, enabling faster and more efficient processing of data. This is particularly important for web applications that experience high traffic or demand, as Web Workers can help to ensure that the application can handle an increased load without impacting performance.</p>\nPractical Applications Of Web Workers\n<p>Let us explore some of the most common and useful applications of Web Workers. Whether you’re building a complex web application or a simple website, understanding how to leverage Web Workers can help you improve performance and provide a better user experience.</p>\n<h3>Offloading CPU-Intensive Work</h3>\n<p>Suppose we have a web application that needs to perform a large, CPU-intensive computation. If we perform this computation in the main thread, the user interface will become unresponsive, and the user experience will suffer. To avoid this, we can use a Web Worker to perform the computation in the background.</p>\n<pre><code>// Create a new Web Worker.\nconst worker = new Worker('worker.js');\n\n// Define a function to handle messages from the worker.\nworker.onmessage = function(event) {\n  const result = event.data;\n  console.log(result);\n};\n\n// Send a message to the worker to start the computation.\nworker.postMessage({ num: 1000000 });\n\n// In worker.js:\n\n// Define a function to perform the computation.\nfunction compute(num) {\n  let sum = 0;\n  for (let i = 0; i &lt; num; i++) {\n    sum += i;\n  }\n  return sum;\n}\n\n// Define a function to handle messages from the main thread.\nonmessage = function(event) {\n  const num = event.data.num;\n  const result = compute(num);\n  postMessage(result);\n};\n</code></pre>\n\n<p>In this example, we create a new Web Worker and define a function to handle messages from the worker. We then send a message to the worker with a parameter (<code>num</code>) that specifies the number of iterations to perform in the computation. The worker receives this message and performs the computation in the background. When the computation is complete, the worker sends a message back to the main thread with the result. The main thread receives this message and logs the result to the console.</p>\n<p><img src=\"https://files.smashing.media/articles/potential-web-workers-multithreading-web/2-console-number-message-main-thread.png\" /></p>\n<p>This task involves adding up all the numbers from <code>0</code> to a given number. While this task is relatively simple and straightforward for small numbers, it can become computationally intensive for very large numbers.</p>\n<p>In the example code we used above, we passed the number <code>1000000</code> to the <code>compute()</code> function in the Web Worker. This means that the compute function will need to add up all the numbers from 0 to one million. This involves a large number of additional operations and can take a significant amount of time to complete, especially if the code is running on a slower computer or in a browser tab that is already busy with other tasks.</p>\n<p>By offloading this task to a Web Worker, the main thread of the application can continue to run smoothly without being blocked by the computationally intensive task. This allows the user interface to remain responsive and ensures that other tasks, such as user input or animations, can be handled without delay.</p>\n<h3>Handling Network Requests</h3>\n<p>Let us consider a scenario where a web application needs to initiate a significant number of network requests. Performing these requests within the main thread could cause the user interface to become unresponsive and result in a poor user experience. In order to prevent this issue, we can utilize Web Workers to handle these requests in the background. By doing so, the main thread remains free to execute other tasks while the Web Worker handles the network requests simultaneously, resulting in improved performance and a better user experience.</p>\n<pre><code>// Create a new Web Worker.\nconst worker = new Worker('worker.js');\n\n// Define a function to handle messages from the worker.\nworker.onmessage = function(event) {\n  const response = event.data;\n  console.log(response);\n};\n\n// Send a message to the worker to start the requests.\nworker.postMessage({ urls: ['https://api.example.com/foo', 'https://api.example.com/bar'] });\n\n// In worker.js:\n\n// Define a function to handle network requests.\nfunction request(url) {\n  return fetch(url).then(response =&gt; response.json());\n}\n\n// Define a function to handle messages from the main thread.\nonmessage = async function(event) {\n  const urls = event.data.urls;\n  const results = await Promise.all(urls.map(request));\n  postMessage(results);\n};\n</code></pre>\n\n<p>In this example, we create a new Web Worker and define a function to handle messages from the worker. We then send a message to the worker with an array of URLs to request. The worker receives this message and performs the requests in the background using the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\"><code>fetch</code> API</a>. When all requests are complete, the worker sends a message back to the main thread with the results. The main thread receives this message and logs the results to the console.</p>\n<h3>Parallel Processing</h3>\n<p>Suppose we have a web application that needs to perform a large number of independent computations. If we perform these computations in sequence in the main thread, the user interface will become unresponsive, and the user experience will suffer. To avoid this, we can use a Web Worker to perform the computations in parallel.</p>\n<pre><code>// Create a new Web Worker.\nconst worker = new Worker('worker.js');\n\n// Define a function to handle messages from the worker.\nworker.onmessage = function(event) {\n  const result = event.data;\n  console.log(result);\n};\n\n// Send a message to the worker to start the computations.\nworker.postMessage({ nums: [1000000, 2000000, 3000000] });\n\n// In worker.js:\n\n// Define a function to perform a single computation.\nfunction compute(num) {\n  let sum = 0;\n  for (let i = 0; i &lt; num; i++) {\n    sum += i;\n}\n  return sum;\n}\n\n// Define a function to handle messages from the main thread.\nonmessage = function(event) {\n  const nums = event.data.nums;\n  const results = nums.map(compute);\n  postMessage(results);\n};\n</code></pre>\n\n<p>In this example, we create a new Web Worker and define a function to handle messages from the worker. We then send a message to the worker with an array of numbers to compute. The worker receives this message and performs the computations in parallel using the map method. When all computations are complete, the worker sends a message back to the main thread with the results. The main thread receives this message and logs the results to the console.</p>\nLimitations And Considerations\n<p>Web workers are a powerful tool for improving the performance and responsiveness of web applications, but they also have some limitations and considerations that you should keep in mind when using them. Here are some of the most important ones:</p>\n<h3>Browser Support</h3>\n<p>Web workers are supported in all major browsers, including Chrome, Firefox, Safari, and Edge. However, there are still some other browsers that do not support web workers or may have limited support.</p>\n<p>For a more extensive look at browser support, see <a href=\"https://caniuse.com/webworkers\">Can I Use</a>.</p>\n<p>It is important that you check out the browser support for any feature before using them in production code and test your application thoroughly to ensure compatibility. </p>\n<h3>Limited Access To The DOM</h3>\n<p>Web workers run in a separate thread and do not have access to the DOM or other global objects in the main thread. This means you <strong>cannot directly manipulate the DOM from a web worker or access global objects</strong> like windows or documents.</p>\n<p>To work around this limitation, you can use the <code>postMessage</code> method to communicate with the main thread and update the DOM or access global objects indirectly. For example, you can send data to the main thread using <code>postMessage</code> and then update the DOM or global objects in response to the message.</p>\n<p>Alternatively, there are some libraries that help solve this issue. For example, the <a href=\"https://github.com/ampproject/worker-dom\">WorkerDOM</a> library enables you to run the DOM in a web worker, allowing for faster page rendering and improved performance. </p>\n<h3>Communication Overhead</h3>\n<p>Web workers communicate with the main thread using the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage\"><code>postMessage</code></a> method, and as a result, could introduce communication overhead, which refers to the amount of time and resources required to establish and maintain communication between two or more computing systems, such as between a Web Worker and the main thread in a web application. This could result in a delay in processing messages and potentially slow down the application. To minimize this overhead, you should <strong>only send essential data</strong> between threads and <strong>avoid sending large amounts of data or frequent messages</strong>.</p>\n<h3>Limited Debugging Tools</h3>\n<p>Debugging Web Workers can be more challenging than debugging code in the main thread, as there are fewer debugging tools available. To make debugging easier, you can use the <code>console</code> API to log messages from the worker thread and use <a href=\"https://developer.mozilla.org/en-US/docs/Learn/Common_questions/Tools_and_setup/What_are_browser_developer_tools\">browser developer tools</a> to inspect messages sent between threads.</p>\n<h3>Code Complexity</h3>\n<p>Using Web Workers can increase the complexity of your code, as you need to manage communication between threads and ensure that data is passed correctly. This can make it more difficult to write, debug, and maintain your code, so you should carefully consider whether using web workers is necessary for your application.</p>\nStrategies For Mitigating Potential Issues With Web Workers\n<p>Web Workers are a powerful tool for improving the performance and responsiveness of web applications. However, when using Web Workers, there are several potential issues that can arise. Here are some strategies for mitigating these issues:</p>\n<h3>Minimize Communication Overhead With Message Batching</h3>\n<p>Message batching involves grouping multiple messages into a single batch message, which can be more efficient than sending individual messages separately. This approach reduces the number of round-trips between the main thread and Web Workers. It can help to minimize communication overhead and improve the overall performance of your web application.</p>\n<p>To implement message batching, you can <strong>use a queue to accumulate messages and send them together as a batch</strong> when the queue reaches a certain threshold or after a set period of time. Here’s an example of how you can implement message batching in your Web Worker:</p>\n<pre><code>// Create a message queue to accumulate messages.\nconst messageQueue = [];\n\n// Create a function to add messages to the queue.\nfunction addToQueue(message) {\n  messageQueue.push(message);\n\n  // Check if the queue has reached the threshold size.\n  if (messageQueue.length &gt;= 10) {\n    // If so, send the batched messages to the main thread.\n    postMessage(messageQueue);\n\n    // Clear the message queue.\n    messageQueue.length = 0;\n  }\n}\n\n// Add a message to the queue.\naddToQueue({type: 'log', message: 'Hello, world!'});\n\n// Add another message to the queue.\naddToQueue({type: 'error', message: 'An error occurred.'});\n</code></pre>\n\n<p>In this example, we create a message queue to accumulate messages that need to be sent to the main thread. Whenever a message is added to the queue using the <code>addToQueue</code> function, we check if the queue has reached the threshold size (in this case, ten messages). If so, we send the batched messages to the main thread using the <code>postMessage</code> method. Finally, we clear the message queue to prepare it for the next batch.</p>\n<p>By batching messages in this way, we can reduce the overall number of messages sent between the main thread and Web Workers, </p>\n<h3>Avoid Synchronous Methods</h3>\n<p>These are JavaScript functions or operations that block the execution of other code until they are complete. Synchronous methods can block the main thread and cause your application to become unresponsive. To avoid this, you should avoid using synchronous methods in your Web Worker code. Instead, use <strong>asynchronous methods</strong> such as <code>setTimeout()</code> or <code>setInterval()</code> to perform long-running computations.</p>\n<p>Here is a little demonstration:</p>\n<pre><code>// In the worker\nself.addEventListener('message', (event) =&gt; {\n  if (event.data.action === 'start') {\n    // Use a setTimeout to perform some computation asynchronously.\n    setTimeout(() =&gt; {\n      const result = doSomeComputation(event.data.data);\n\n      // Send the result back to the main thread.\n      self.postMessage({ action: 'result', data: result });\n    }, 0);\n  }\n});\n</code></pre>\n\n<h3>Be Mindful Of Memory Usage</h3>\n<p>Web Workers have their own memory space, which can be limited depending on the user’s device and browser settings. To avoid memory issues, you should be mindful of the amount of memory your Web Worker code is using and avoid creating large objects unnecessarily. For example:</p>\n<div>\n<pre><code>// In the worker\nself.addEventListener('message', (event) =&gt; {\n  if (event.data.action === 'start') {\n    // Use a for loop to process an array of data.\n    const data = event.data.data;\n    const result = [];\n\n    for (let i = 0; i &lt; data.length; i++) {\n      // Process each item in the array and add the result to the result array.\n      const itemResult = processItem(data[i]);\n      result.push(itemResult);\n    }\n\n    // Send the result back to the main thread.\n    self.postMessage({ action: 'result', data: result });\n  }\n});\n</code></pre>\n</div>\n\n<p>In this code, the Web Worker processes an array of data and returns the result to the main thread using the <code>postMessage</code> method. However, the <code>for</code> loop used to process the data may be time-consuming.</p>\n<p>The reason for this is that the code is processing an entire array of data at once, meaning that all the data must be loaded into memory at the same time. If the data set is very large, this can cause the Web Worker to consume a significant amount of memory, potentially exceeding the memory limit allocated to the Web Worker by the browser.</p>\n<p>To mitigate this issue, you can consider using built-in JavaScript methods like <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\"><code>forEach</code></a> or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce\"><code>reduce</code></a>, which can process data one item at a time and avoid the need to load the entire array into memory at once.</p>\n<h3>Browser Compatibility</h3>\n<p>Web Workers are supported in most modern browsers, but some older browsers may not support them. To ensure compatibility with a wide range of browsers, you should test your Web Worker code in different browsers and versions. You can also use <strong>feature detection</strong> to check if Web Workers are supported before using them in your code, like this:</p>\n<pre><code>if (typeof Worker !== 'undefined') {\n  // Web Workers are supported.\n  const worker = new Worker('worker.js');\n} else {\n  // Web Workers are not supported.\n  console.log('Web Workers are not supported in this browser.');\n}\n</code></pre>\n\n<p>This code checks if Web Workers are supported in the current browser and creates a new Web Worker if they are supported. If Web Workers are not supported, the code logs a message to the console indicating that Web Workers are not supported in the browser.</p>\n<p>By following these strategies, you can ensure that your Web Worker code is efficient, responsive, and compatible with a wide range of browsers.</p>\nConclusion\n<p>As web applications become increasingly complex and demanding, the importance of efficient multithreading techniques — such as Web Workers — is likely to increase. Web Workers are an essential feature of modern web development that allows developers to offload CPU-intensive tasks to separate threads, improving application performance and responsiveness. However, there are significant limitations and considerations to keep in mind when working with Web Workers, such as the lack of access to the DOM and limitations on the types of data that can be passed between threads.</p>\n<p>To mitigate these potential issues, developers can follow strategies as mentioned earlier, such as using asynchronous methods and being mindful of the complexity of the task being offloaded.</p>\n<p>Multithreading with Web Workers is likely to remain an important technique for improving web application performance and responsiveness in the future. While there are other techniques for achieving multithreading in JavaScript, such as using <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\">WebSockets</a> or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\"><code>SharedArrayBuffer</code></a>, Web Workers have several advantages that make them a powerful tool for developers.</p>\n<p>Adopting more recent technology such as <a href=\"https://developer.mozilla.org/en-US/docs/WebAssembly\">WebAssembly</a> may open up new opportunities for using Web Workers to offload even more complex and computationally-intensive tasks. Overall, Web Workers are likely to continue to evolve and improve in the coming years, helping developers create more efficient and responsive web applications.</p>\n<p>Additionally, many libraries and tools exist to help developers work with Web Workers. For example, <a href=\"https://github.com/GoogleChromeLabs/comlink\">Comlink</a> and <a href=\"https://github.com/developit/workerize\">Workerize</a> provide a simplified API for communicating with Web Workers. These libraries abstract away some of the complexity of managing Web Workers, making it easier to leverage their benefits.</p>\n<p>Hopefully, this article has given you a good understanding of the potential of web workers for multithreading and how to use them in your own code.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"d556ea9f2c2984b1c5468f8c9b31af9b520a916fdccebdde62166a34053c84e7","category":"Tech"}