{"title":"Introducing Claude 4 in Amazon Bedrock, the most powerful models for coding from Anthropic","link":"https://aws.amazon.com/blogs/aws/claude-opus-4-anthropics-most-powerful-model-for-coding-is-now-in-amazon-bedrock/","date":1747943249000,"content":"<p><a href=\"https://www.anthropic.com/\">Anthropic</a> launched the next generation of <a href=\"https://aws.amazon.com/bedrock/anthropic/\">Claude</a> models today—Opus 4 and Sonnet 4—designed for coding, advanced reasoning, and the support of the next generation of capable, autonomous AI agents. Both models are now generally available in <a href=\"https://aws.amazon.com/bedrock/\">Amazon Bedrock</a>, giving developers immediate access to both the model’s advanced reasoning and agentic capabilities.</p> \n<p>Amazon Bedrock expands your AI choices with Anthropic’s most advanced models, giving you the freedom to build transformative applications with <a href=\"https://aws.amazon.com/bedrock/security-compliance/\">enterprise-grade security</a> and <a href=\"https://aws.amazon.com/ai/responsible-ai/\">responsible AI</a> controls. Both models extend what’s possible with AI systems by improving task planning, tool use, and agent steerability.</p> \n<p>With Opus 4’s advanced intelligence, you can build agents that handle long-running, high-context tasks like refactoring large codebases, synthesizing research, or coordinating cross-functional enterprise operations. Sonnet 4 is optimized for efficiency at scale, making it a strong fit as a subagent or for high-volume tasks like code reviews, bug fixes, and production-grade content generation.</p> \n<p>When building with <a href=\"https://aws.amazon.com/ai/generative-ai/\">generative AI</a>, many developers work on long-horizon tasks. These workflows require deep, sustained reasoning, often involving multistep processes, planning across large contexts, and synthesizing diverse inputs over extended timeframes. Good examples of these workflows are developer <a href=\"https://aws.amazon.com/bedrock/agents/\">AI agents</a> that help you to refactor or transform large projects. Existing models may respond quickly and fluently, but maintaining coherence and context over time—especially in areas like coding, research, or enterprise workflows—can still be challenging.</p> \n<p><span><strong>Claude Opus 4<br /> </strong></span>Claude Opus 4 is the most advanced model to date from Anthropic, designed for building sophisticated AI agents that can reason, plan, and execute complex tasks with minimal oversight. Anthropic benchmarks show it is the best coding model available on the market today. It excels in software development scenarios where extended context, deep reasoning, and adaptive execution are critical. Developers can use Opus 4 to write and refactor code across entire projects, manage full-stack architectures, or design agentic systems that break down high-level goals into executable steps. It demonstrates <a href=\"https://www.anthropic.com/news/claude-4\">strong performance on coding and agent-focused benchmarks</a> like <a href=\"https://www.swebench.com/\">SWE-bench</a> and <a href=\"https://github.com/sierra-research/tau-bench\">TAU-bench</a>, making it a natural choice for building agents that handle multistep development workflows. For example, Opus 4 can analyze technical documentation, plan a software implementation, write the required code, and iteratively refine it—while tracking requirements and architectural context throughout the process.</p> \n<p><span><strong>Claude Sonnet 4<br /> </strong></span>Claude Sonnet 4 complements Opus 4 by balancing performance, responsiveness, and cost, making it well-suited for high-volume production workloads. It’s optimized for everyday development tasks with enhanced performance, such as powering code reviews, implementing bug ﬁxes, and new feature development with immediate feedback loops. It can also power production-ready AI assistants for near real-time applications. Sonnet 4 is a drop-in replacement from Claude Sonnet 3.7. In multi-agent systems, Sonnet 4 performs well as a task-speciﬁc subagent—handling responsibilities like targeted code reviews, search and retrieval, or isolated feature development within a broader pipeline. You can also use Sonnet 4 to manage continuous integration and delivery (CI/CD) pipelines, perform bug triage, or integrate APIs, all while maintaining high throughput and developer-aligned output.</p> \n<p>Opus 4 and Sonnet 4 are hybrid reasoning models offering two modes: near-instant responses and extended thinking for deeper reasoning. You can choose near-instant responses for interactive applications, or enable extended thinking when a request benefits from deeper analysis and planning. Thinking is especially useful for long-context reasoning tasks in areas like software engineering, math, or scientific research. By configuring the model’s thinking budget—for example, by setting a maximum token count—you can tune the tradeoff between latency and answer depth to fit your workload.</p> \n<p><span><strong>How to get started<br /> </strong></span>To see Opus 4 or Sonnet 4 in action, <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/model-access-modify.html\">enable the new model</a> in your AWS account. Then, you can start coding using the <a href=\"https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html\">Bedrock Converse API</a> with model ID<code>anthropic.claude-opus-4-20250514-v1:0</code> for Opus 4 and <code>anthropic.claude-sonnet-4-20250514-v1:0</code> for Sonnet 4. We recommend using the Converse API, because it provides a consistent API that works with all Amazon Bedrock models that support messages. This means you can write code one time and use it with different models.</p> \n<p>For example, let’s imagine I write an agent to review code before merging changes in a code repository. I write the following code that uses the <a href=\"https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html\">Bedrock Converse API</a> to send a system and user prompts. Then, the agent consumes the streamed result.</p> \n<pre><code>private let modelId = \"us.anthropic.claude-sonnet-4-20250514-v1:0\"\n\n// Define the system prompt that instructs Claude how to respond\nlet systemPrompt = \"\"\"\nYou are a senior iOS developer with deep expertise in Swift, especially Swift 6 concurrency. Your job is to perform a code review focused on identifying concurrency-related edge cases, potential race conditions, and misuse of Swift concurrency primitives such as Task, TaskGroup, Sendable, @MainActor, and @preconcurrency.\n\nYou should review the code carefully and flag any patterns or logic that may cause unexpected behavior in concurrent environments, such as accessing shared mutable state without proper isolation, incorrect actor usage, or non-Sendable types crossing concurrency boundaries.\n\nExplain your reasoning in precise technical terms, and provide recommendations to improve safety, predictability, and correctness. When appropriate, suggest concrete code changes or refactorings using idiomatic Swift 6\n\"\"\"\n@preconcurrency import AWSBedrockRuntime\n\n@main\nstruct Claude {\n\n    static func main() async throws {\n        // Create a Bedrock Runtime client in the AWS Region you want to use.\n        let config =\n            try await BedrockRuntimeClient.BedrockRuntimeClientConfiguration(\n                region: \"us-east-1\"\n            )\n        let bedrockClient = BedrockRuntimeClient(config: config)\n\n        // set the model id\n        let modelId = \"us.anthropic.claude-sonnet-4-20250514-v1:0\"\n\n        // Define the system prompt that instructs Claude how to respond\n        let systemPrompt = \"\"\"\n        You are a senior iOS developer with deep expertise in Swift, especially Swift 6 concurrency. Your job is to perform a code review focused on identifying concurrency-related edge cases, potential race conditions, and misuse of Swift concurrency primitives such as Task, TaskGroup, Sendable, @MainActor, and @preconcurrency.\n\n        You should review the code carefully and flag any patterns or logic that may cause unexpected behavior in concurrent environments, such as accessing shared mutable state without proper isolation, incorrect actor usage, or non-Sendable types crossing concurrency boundaries.\n\n        Explain your reasoning in precise technical terms, and provide recommendations to improve safety, predictability, and correctness. When appropriate, suggest concrete code changes or refactorings using idiomatic Swift 6\n        \"\"\"\n        let system: BedrockRuntimeClientTypes.SystemContentBlock = .text(systemPrompt)\n\n        // Create the user message with text prompt and image\n        let userPrompt = \"\"\"\n        Can you review the following Swift code for concurrency issues? Let me know what could go wrong and how to fix it.\n        \"\"\"\n        let prompt: BedrockRuntimeClientTypes.ContentBlock = .text(userPrompt)\n\n        // Create the user message with both text and image content\n        let userMessage = BedrockRuntimeClientTypes.Message(\n            content: [prompt],\n            role: .user\n        )\n\n        // Initialize the messages array with the user message\n        var messages: [BedrockRuntimeClientTypes.Message] = []\n        messages.append(userMessage)\n        var streamedResponse: String = \"\"\n\n        // Configure the inference parameters\n        let inferenceConfig: BedrockRuntimeClientTypes.InferenceConfiguration = .init(maxTokens: 4096, temperature: 0.0)\n\n        // Create the input for the Converse API with streaming\n        let input = ConverseStreamInput(inferenceConfig: inferenceConfig, messages: messages, modelId: modelId, system: [system])\n\n        // Make the streaming request\n        do {\n            // Process the stream\n            let response = try await bedrockClient.converseStream(input: input)\n\n            // verify the response\n            guard let stream = response.stream else {\n                print(\"No stream found\")\n                return\n            }\n            // Iterate through the stream events\n            for try await event in stream {\n                switch event {\n                case .messagestart:\n                    print(\"AI-assistant started to stream\")\n\n                case let .contentblockdelta(deltaEvent):\n                    // Handle text content as it arrives\n                    if case let .text(text) = deltaEvent.delta {\n                        streamedResponse.append(text)\n                        print(text, terminator: \"\")\n                    }\n\n                case .messagestop:\n                    print(\"\\n\\nStream ended\")\n                    // Create a complete assistant message from the streamed response\n                    let assistantMessage = BedrockRuntimeClientTypes.Message(\n                        content: [.text(streamedResponse)],\n                        role: .assistant\n                    )\n                    messages.append(assistantMessage)\n\n                default:\n                    break\n                }\n            }\n\n        }\n    }\n}\n</code></pre> \n<p>To help you get started, my colleague Dennis maintains a <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/service_code_examples_bedrock-runtime_anthropic_claude.html\">broad range of code examples</a> for multiple use cases and a variety of programming languages.</p> \n<p><strong><span>Available today in Amazon Bedrock</span><br /> </strong>This release gives developers immediate access in Amazon Bedrock, a fully managed, serverless service, to the next generation of Claude models developed by Anthropic. Whether you’re already building with Claude in Amazon Bedrock or just getting started, this seamless access makes it faster to experiment, prototype, and scale with cutting-edge foundation models—without managing infrastructure or complex integrations.</p> \n<p>Claude Opus 4 is available in the following <a href=\"https://docs.aws.amazon.com/glossary/latest/reference/glos-chap.html#region\">AWS Regions</a> in North America: US East (Ohio, N. Virginia) and US West (Oregon). Claude Sonnet 4 is available not only in AWS Regions in North America but also in APAC, and Europe: US East (Ohio, N. Virginia), US West (Oregon), Asia Pacific (Hyderabad, Mumbai, Osaka, Seoul, Singapore, Sydney, Tokyo), and Europe (Spain). You can access the two models through <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html\">cross-Region inference</a>. Cross-Region inference helps to automatically select the optimal AWS Region within your geography to process your inference request.</p> \n<p>Opus 4 tackles your most challenging development tasks, while Sonnet 4 excels at routine work with its optimal balance of speed and capability.</p> \n<p>Learn more about the <a href=\"https://aws.amazon.com/bedrock/pricing/\">pricing</a> and <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html\">how to use these new models in Amazon Bedrock</a> today!</p> \n<a href=\"https://linktr.ee/sebsto\">— seb</a>","author":"Sébastien Stormacq","siteTitle":"AWS News Blog","siteHash":"6093e072e4117ec22616e844cb857d03ca62c57a411a8affc77cb5e8b6b15bf6","entryHash":"3a550203cf945105a9064ed027ca8c14a2c4a8b583df1982cea2287951a1334b","category":"Tech"}