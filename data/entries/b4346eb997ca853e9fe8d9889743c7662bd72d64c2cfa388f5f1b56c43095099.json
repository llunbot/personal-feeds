{"title":"การแปลงสัมพรรค","link":"https://neizod.dev/2024/04/04/affine-transformation.html","date":1712194938000,"content":"<p>การสร้างภาพในคอมพิวเตอร์ก็คือการจัดการกับพิกัดจุดต่างๆ ซึ่งโดยมาก(และโดยพื้นฐาน)แล้วก็คือเราต้องการเลื่อน/ขยาย/หมุน/สะท้อนบรรดาจุดเหล่านั้น<em>ด้วยกฎเดียวกัน</em>เพื่อให้ผลลัพธ์พิกัดของทุกจุดไปอยู่ ณ ตำแหน่งที่ถูกต้องตามที่เราต้องการ ซึ่งถ้าเรายังจำกันได้จากความรู้ด้านพีชคณิตเชิงเส้น เราสามารถใช้เมทริกซ์เข้ามาช่วยคำนวณได้อย่างง่ายดาย</p>\n\n<p>เพื่อความง่ายเราจะดูตัวอย่างที่สองมิติพอ นั่นคือเราจะสนใจจุดต่างๆ ที่ถูกเขียนแทนด้วยเวกเตอร์ $\\vec{p}=[\\;\\begin{smallmatrix}x\\newline y\\end{smallmatrix}\\;]$ ซึ่งทำให้ได้ว่า</p>\n\n<ul>\n  <li>\n    <p>เลื่อนด้วยเวกเตอร์ $\\vec{v}=[\\;\\begin{smallmatrix}a\\newline b\\end{smallmatrix}\\;]$ (เลื่อนตามแกนนอนด้วยระยะ $a$ และเลื่อนตามแกนตั้งด้วยระยะ $b$)</p>\n\n\\[T_\\vec{v}(\\vec{p}) = \\begin{bmatrix}x\\\\y\\end{bmatrix} + \\begin{bmatrix}a\\\\b\\end{bmatrix}\\]\n  </li>\n  <li>\n    <p>ขยายขนาดออกจากจุดกำเนิดอย่างเท่ากันในทุกทิศทางด้วยสเกลาร์ $s$</p>\n\n\\[M_s(\\vec{p}) = s\\begin{bmatrix}x\\\\y\\end{bmatrix}\\]\n  </li>\n  <li>\n    <p>ขยายขนาดด้วยเวกเตอร์ $\\vec{v}=[\\;\\begin{smallmatrix}a\\newline b\\end{smallmatrix}\\;]$ (ขยายตามแกนนอน $a$ เท่า และขยายตามแกนตั้ง $b$ เท่า)</p>\n\n\\[M_\\vec{v}(\\vec{p}) = \\begin{bmatrix}a&amp;0\\\\0&amp;b\\end{bmatrix} \\begin{bmatrix}x\\\\y\\end{bmatrix}\\]\n  </li>\n  <li>\n    <p>สะท้อนในแนวแกนนอน (หรือพูดอีกอย่างก็คือการขยายตามแกนนอนด้วยขนาดลบหนึ่งเท่า)</p>\n\n\\[M_{-1}^x(\\vec{p}) = \\begin{bmatrix}-1&amp;0\\\\0&amp;1\\end{bmatrix} \\begin{bmatrix}x\\\\y\\end{bmatrix}\\]\n  </li>\n  <li>\n    <p>หมุนทวนเข็มนาฬิกาด้วยมุม $\\theta$ รอบจุดกำเนิด</p>\n\n\\[R_\\theta(\\vec{p}) = \\begin{bmatrix}\\cos\\theta&amp;-\\sin\\theta\\\\\\sin\\theta&amp;\\cos\\theta\\end{bmatrix} \\begin{bmatrix}x\\\\y\\end{bmatrix}\\]\n  </li>\n  <li>\n    <p><a href=\"//en.wikipedia.org/wiki/Shear_mapping\"><em>เฉือน</em> (shear)</a> ตามแกนนอนด้วยความชัน $1/a$</p>\n\n\\[S_a^x(\\vec{p}) = \\begin{bmatrix}1&amp;a\\\\0&amp;1\\end{bmatrix} \\begin{bmatrix}x\\\\y\\end{bmatrix}\\]\n  </li>\n</ul>\n\n<blockquote>\n  <p><img src=\"/images/math/affine-lisa.png\" /></p>\n\n  <p>ตัวอย่างการแปลงพื้นฐานแบบต่างๆ บนภาพ <a href=\"//en.wikipedia.org/wiki/Mona_Lisa\">Mona Lisa</a> ขอขอบคุณภาพจาก <a href=\"//twitter.com/srakrn\">@srakrn</a></p>\n</blockquote>\n\n<p>ความเจ๋งของการอธิบายมันในรูปฟังก์ชันได้เช่นนี้ คือเราสามารถนำผลลัพธ์มาส่งต่อกันเป็น<em>ลูกโซ่</em>ได้ เช่น หากเราเริ่มด้วยการเลื่อนตามแกนนอนเป็นระยะ $4$ หน่วย หลังจากนั้นหมุนด้วยมุม $30^\\circ$ แล้วปิดท้ายด้วยการสะท้อนในแนวแกนตั้ง เราจะเขียนอธิบายการกระทำตามลำดับดังกล่าวออกมาเป็นสมการออกมาได้ว่า</p>\n\n\\[{\\color{blue}M_{-1}^y({\\color{red}R_{30^\\circ}({\\color{green}T_4^x({\\color{black}\\vec{p}})})})}\n=\n{\\color{blue}\\left(\n\\begin{bmatrix}1&amp;0\\\\0&amp;-1\\end{bmatrix}\n{\\color{red}\\left(\n\\begin{bmatrix}\\cos30^\\circ&amp;-\\sin30^\\circ\\\\\\sin30^\\circ&amp;\\cos30^\\circ\\end{bmatrix}\n{\\color{green}\\left(\n{\\color{black}\\begin{bmatrix}x\\\\y\\end{bmatrix}} + \\begin{bmatrix}4\\\\0\\end{bmatrix}\n\\right)}\n\\right)}\n\\right)}\\]\n\n<p>ยิ่งไปกว่านั้น ถ้าเรามองในแง่การรีดประสิทธิภาพโค้ด แทนที่เราจะเริ่มจากการเอาแต่ละจุด $\\vec{p}$ ไปค่อยๆ ผ่านทีละฟังก์ชันไล่ย้อนกลับมา เราสามารถ “รวบ” ฟังก์ชันที่คำนวณเมทริกซ์ทั้งหมดทิ้งไว้ก่อนได้เลย นั่นคือเราจะมองการดำเนินการต่างๆ เป็น<a href=\"//en.wikipedia.org/wiki/Function_composition\">ฟังก์ชันประกอบ (function composition)</a> เช่นนี้</p>\n\n\\[\\begin{align}\n(M_{-1}^y \\circ R_{30^\\circ} \\circ T_4^x)\\; \\vec{p}\n&amp;= M_{-1}^y(R_{30^\\circ}(T_4^x(\\vec{p}))) \\\\\n&amp;=\n\\begin{bmatrix}1&amp;0\\\\0&amp;-1\\end{bmatrix}\n\\begin{bmatrix}\\sqrt3/2&amp;-1/2\\\\1/2&amp;\\sqrt3/2\\end{bmatrix}\n\\left(\n\\begin{bmatrix}x\\\\y\\end{bmatrix} + \\begin{bmatrix}4\\\\0\\end{bmatrix}\n\\right) \\\\\n&amp;=\n\\begin{bmatrix}\\sqrt3/2&amp;-1/2\\\\-1/2&amp;-\\sqrt3/2\\end{bmatrix}\n\\left(\n\\begin{bmatrix}x\\\\y\\end{bmatrix} + \\begin{bmatrix}4\\\\0\\end{bmatrix}\n\\right) \\\\\n&amp;=\n\\begin{bmatrix}\\sqrt3/2&amp;-1/2\\\\-1/2&amp;-\\sqrt3/2\\end{bmatrix}\n\\begin{bmatrix}x\\\\y\\end{bmatrix}\n+\n\\begin{bmatrix}2\\sqrt3\\\\-2\\end{bmatrix}\n\\end{align}\\]\n\n<p>สังเกตว่าการดำเนินการแทบทุกตัวข้างต้น (ยกเว้นการเลื่อนเพียงตัวเดียวที่ไม่เหมือนเพื่อน) นั้นมีลักษณะร่วมกัน คือ มันจะนำเมทริกซ์อันหนึ่งมาคูณกับเวกเตอร์ที่เราใส่เข้าไป หรือพูดอีกอย่างก็คือผลลัพธ์มันจะอยู่ในรูป $\\mathbf{A}\\vec{p}$ เราเรียกการกระทำในลักษณะนี้ว่า <a href=\"//en.wikipedia.org/wiki/Linear_map\"><em>การแปลงเชิงเส้น</em> (linear transformation)</a> ซึ่งมีลักษณะร่วมที่สำคัญคือทุกการกระทำมันจะต้องอ้างอิงอยู่บนจุดกำเนิดเสมอ</p>\n\n<p>แต่อย่างที่เห็นว่าการเลื่อนนั้นแตกต่างจากการดำเนินการอื่น (และเมื่อนำมันมาใช้ร่วมกับการแปลงอันอื่นๆ) จะทำให้ได้ว่าเราต้องเขียนมันในรูป $\\mathbf{A}\\vec{p}+\\vec{v}$ แทน และเราจะเปลี่ยนไปเรียกมันว่า <a href=\"//en.wikipedia.org/wiki/Affine_transformation\"><em>การแปลงสัมพรรค</em> (affine transformation)</a> โดยความสามารถที่เพิ่มขึ้นมาก็คือเราไม่จำเป็นต้องอ้างอิงจุดกำเนิดเพียงอย่างเดียวแล้ว เช่น หากเราต้องการหมุนด้วยมุม $\\theta$ รอบจุด $\\vec{v}=[\\;\\begin{smallmatrix}a\\newline b\\end{smallmatrix}\\;]$ เราจะเขียนได้ว่า</p>\n\n\\[(T_\\vec{v} \\circ R_\\theta \\circ T_{-\\vec{v}})\\; \\vec{p}\n=\n\\begin{bmatrix}\\cos\\theta&amp;-\\sin\\theta\\\\\\sin\\theta&amp;\\cos\\theta\\end{bmatrix}\n\\begin{bmatrix}x\\\\y\\end{bmatrix}\n+\n\\begin{bmatrix}\na(1 - \\cos\\theta) + b \\sin\\theta \\\\\nb(1 - \\cos\\theta) - a \\sin\\theta\n\\end{bmatrix}\\]\n\n<p>ถึงตรงนี้ทุกอย่างก็ดูเข้าท่าน่าจะเอาไปใช้งานได้โดยไม่มีปัญหาแล้ว แต่ว่ามันก็ยังมี<em>ความไม่สวย</em>อยู่ในสมการตรงที่มันติดการบวกเวกเตอร์การเลื่อนห้อยท้าย แทนที่เราจะสามารถเขียนทั้งสมการด้วยการคูณเมทริกซ์เพียงอย่างเดียว (หรือก็คือ ทำให้มันเป็นการแปลงเชิงเส้น) คำถามคือแล้วเราจะสามารถกำจัดพจน์เวกเตอร์นั้นทิ้งไปได้หรือเปล่า?</p>\n\n<p>หากเรายังคิดในกรอบสองมิติเช่นเดิมก็คือทำไม่ได้ ดังนั้นเราจะเพิ่มมิติเข้าไปในข้อมูลของเราโดยอาศัยข้อสังเกตที่ว่า ถ้าเราให้ค่าประจำมิติใหม่นี้เป็นค่าคงที่ เราสามารถสร้างผลบวกขึ้นมาได้ฟรีๆ โดยการเอาเมทริกซ์ไปคูณกับค่าคงที่ในมิติใหม่นั้น</p>\n\n<p>พูดอย่างเป็นสมการหน่อยก็คือ สำหรับข้อมูลสองมิติ $\\vec{p}=[\\;\\begin{smallmatrix}x\\newline y\\end{smallmatrix}\\;]$ เดิมที่เรามี เราจะเปลี่ยนไปเขียนด้วยเวกเตอร์สามมิติแทน ดังนี้</p>\n\n\\[\\vec{p} = \\begin{bmatrix}x\\\\y\\\\1\\end{bmatrix}\\]\n\n<p>ซึ่งจะทำให้เราได้ฟังก์ชันสำหรับการแปลงเชิงเส้นที่มีหน้าตาแบบเดิม เพิ่มเติมก็คือมีแถวและหลักเพิ่มเข้ามาโดยมีค่าทุกช่องเป็นศูนย์หมดยกเว้นช่องทะแยงมุมที่มีค่าเป็นหนึ่ง เช่น การหมุนรอบจุดกำเนิดจะกลายเป็น</p>\n\n\\[R_\\theta(\\vec{p}) =\n\\begin{bmatrix}\\cos\\theta&amp;-\\sin\\theta&amp;0\\\\\\sin\\theta&amp;\\cos\\theta&amp;0\\\\0&amp;0&amp;1\\end{bmatrix}\n\\begin{bmatrix}x\\\\y\\\\1\\end{bmatrix}\\]\n\n<p>ส่วนการเลื่อนด้วย $\\vec{v}=[\\;\\begin{smallmatrix}a\\newline b\\end{smallmatrix}\\;]$ ที่เคยเป็นตัวปัญหา เราก็สามารถเปลี่ยนไปเขียนในรูปของการคูณเมทริกซ์ได้แล้วว่า</p>\n\n\\[T_\\vec{v}(\\vec{p}) =\n\\begin{bmatrix}1&amp;0&amp;a\\\\0&amp;1&amp;b\\\\0&amp;0&amp;1\\end{bmatrix}\n\\begin{bmatrix}x\\\\y\\\\1\\end{bmatrix}\\]\n\n<p>แน่นอนว่าเราอาจลองเช็คคำตอบดูได้ เช่น กลับไปพิจารณาการหมุนด้วยมุม $\\theta$ รอบจุด $\\vec{v}$ เราจะได้</p>\n\n\\[\\begin{align}\n(T_\\vec{v} \\circ R_\\theta \\circ T_{-\\vec{v}})\\; \\vec{p}\n&amp;=\n\\begin{bmatrix}1&amp;0&amp;a\\\\0&amp;1&amp;b\\\\0&amp;0&amp;1\\end{bmatrix}\n\\begin{bmatrix}\\cos\\theta&amp;-\\sin\\theta&amp;0\\\\\\sin\\theta&amp;\\cos\\theta&amp;0\\\\0&amp;0&amp;1\\end{bmatrix}\n\\begin{bmatrix}1&amp;0&amp;-a\\\\0&amp;1&amp;-b\\\\0&amp;0&amp;1\\end{bmatrix}\n\\begin{bmatrix}x\\\\y\\\\1\\end{bmatrix} \\\\\n&amp;=\n\\begin{bmatrix}\n\\cos\\theta &amp; -\\sin\\theta &amp; a(1 - \\cos\\theta) + b \\sin\\theta \\\\\n\\sin\\theta &amp;  \\cos\\theta &amp; b(1 - \\cos\\theta) - a \\sin\\theta \\\\\n0 &amp; 0 &amp; 1\n\\end{bmatrix}\n\\begin{bmatrix}x\\\\y\\\\1\\end{bmatrix}\n\\end{align}\\]\n\n<p>สังเกตว่าผลลัพธ์สุดท้ายจะออกมาอยู่ในรูป $[x’\\;y’\\;1]^T$ เสมอ นั่นก็คือเราสามารถหยิบค่า $x’$ และ $y’$ ไปใช้งาน (เช่น พล็อตกราฟ) แบบสองมิติได้เลย โดยไม่ต้องสนใจค่าคงที่ในมิติที่เพิ่มขึ้นมาเลยก็ได้ (มันจะมีค่าเป็นหนึ่งตลอดกาล)</p>\n\n<p>ดังนั้นจริงๆ แล้วการแปลงสัมพรรคในมิติที่เราสนใจ มันก็คือการแปลงเชิงเส้นในมิติที่สูงขึ้นมาอีกหนึ่งมิตินั่นเอง ซึ่งพอมันเขียนเป็นการคูณกันของเมทริกซ์เพียวๆ ได้แบบนี้แล้ว แปลว่าเราก็ไม่จำเป็นต้องพึ่งพาการเขียนด้วยฟังก์ชันอีกต่อไป เพราะเราสามารถหยิบเอาเมทริกซ์สำหรับการแปลงอันต่างๆ ที่เราสนใจมาวางเรียงต่อกันเป็นผลคูณได้เลย</p>","author":"","siteTitle":"neizod's speculation","siteHash":"939338c5557b1743f2c128736c6006e145dcabc81da9970f1c0dc8ae2feb0830","entryHash":"b4346eb997ca853e9fe8d9889743c7662bd72d64c2cfa388f5f1b56c43095099","category":"Thai"}