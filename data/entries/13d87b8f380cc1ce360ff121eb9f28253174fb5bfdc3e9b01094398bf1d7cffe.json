{"title":"Nomad’s internal garbage collection and optimization discovery during the Nomad Bench project","link":"https://www.hashicorp.com/blog/nomad-garbage-collection-optimization-discovery-during-nomad-bench","date":1723489200000,"content":"<p>During the work on Nomad’s 1.8 LTS release, the team spent some time creating a <a href=\"https://github.com/hashicorp-forge/nomad-bench\">benchmarking infrastructure for Nomad</a>, running performance tests and trying to find places where we could improve Nomad’s efficiency. This short article describes a process for finding a problem within Nomad’s garbage collection mechanism and <a href=\"https://github.com/hashicorp/nomad/pull/20510\">an optimization</a> that we made. </p>\n\n<h2>What’s Nomad’s garbage collection and how does it work?</h2>\n\n<p>Much like Go, the programming language in which it’s written, the Nomad workload orchestrator supports garbage collection. It can be triggered manually with the <a href=\"https://developer.hashicorp.com/nomad/docs/commands/system/gc\">CLI</a> or <a href=\"https://developer.hashicorp.com/nomad/api-docs/system\">an API call</a>, but some users may not know how Nomad servers handle garbage collection implicitly. This article will go into detail about that implicit side of Nomad garbage collection. </p>\n\n<p>Nomad garbage collection is not the same as garbage collection in a programming language, but the motivation behind its design is similar: it’s there to free up memory allocated for objects that are no longer being referenced or needed by the scheduler. Nomad garbage collection applies to evaluations, nodes, jobs, deployments, and plugins (consult the <a href=\"https://developer.hashicorp.com/nomad/docs/concepts/scheduling/scheduling\">Nomad scheduling overview article</a> to understand these concepts better), and can be <a href=\"https://developer.hashicorp.com/nomad/docs/configuration/server#node_gc_threshold\">configured</a> by users. </p>\n\n<p>When one of the Nomad servers becomes a leader, it starts periodic garbage collection <a href=\"https://pkg.go.dev/time#Ticker\">“tickers”</a> that clean objects marked for garbage collection from memory. Some of these objects, like evaluations, are marked for GC automatically, and some, like jobs, can get marked for GC by RPC calls initiated by users.</p>\n\n<p>An interesting example is job deregistration. Whenever users issue a <a href=\"https://developer.hashicorp.com/nomad/docs/commands/job/stop\"><code>job stop</code> command</a> or <a href=\"https://developer.hashicorp.com/nomad/api-docs/jobs#stop-a-job\">API call</a>, Nomad stops the job but doesn’t remove information about it from memory. You can still see information about a stopped job, such as its deployments or allocations, e.g.</p>\n<pre><code>$ nomad job status example\nID            = example\nName          = example\nSubmit Date   = 2024-05-17T13:49:28+02:00\nType          = service\nPriority      = 50\nDatacenters   = *\nNamespace     = default\nNode Pool     = default\nStatus        = dead (stopped)\nPeriodic      = false\nParameterized = false\n\nSummary\nTask Group  Queued  Starting  Running  Failed  Complete  Lost  Unknown\necho        0       0         0        0       1         0     0\n\nLatest Deployment\nID          = 82460a04\nStatus      = successful\nDescription = Deployment completed successfully\n\nDeployed\nTask Group  Desired  Placed  Healthy  Unhealthy  Progress Deadline\necho        1        1       1        0          2024-05-17T13:59:11+02:00\n\nAllocations\nID        Node ID   Task Group  Version  Desired  Status    Created  Modified\ndaa3693d  459490f1  echo        0        stop     complete  30s ago  3s ago</code></pre><p>This default behavior can be overridden using a <code>-purge</code> flag, which will force GC on a given job and objects that depend on it, but by default jobs won’t be GCd until <code><a href=\"https://developer.hashicorp.com/nomad/docs/configuration/server#job_gc_interval\">job<em>gc</em>interval</a></code> time passes. </p>\n\n<p>Nomad’s basic unit of work is an <em>evaluation</em>. Every evaluation is essentially a “work order” for the Nomad scheduler; something that needs to be done. A new job creates an evaluation (or multiple evaluations), and so does a job update, or stopping a job. The “tickers” mentioned earlier also create evaluations, which end up in the “core” internal <a href=\"https://developer.hashicorp.com/nomad/docs/concepts/scheduling/scheduling\">scheduler</a>. Since Nomad is a distributed system that coordinates its actions using <a href=\"https://raft.github.io/\">Raft</a>, most of the new evaluations are created by RPC calls that can then be replicated using Raft transactions.</p>\n\n<h2>Discovery</h2>\n\n<p>While running an experiment that measured how many job dispatch requests Nomad could handle per second, we noticed periodic spiking in the number of “<code>nomad.nomad.eval.ack</code>” data points being emitted, among other evaluation-related metrics. Each invocation of this metric in particular indicates an evaluation has been successfully processed and reached a completed state.</p>\n<img src=\"https://www.datocms-assets.com/2885/1723487667-spiking-perf-issue-nomad.png\" alt=\"Periodic\" /><p>Why then was Nomad creating evaluations in large numbers at a periodic interval, which was well outside the bounds of evaluations created due to job dispatch requests?</p>\n\n<h3>Job garbage collection</h3>\n\n<p>As previously discussed, Nomad runs an internal garbage collection process to remove old and obsolete state objects. This process can be manually triggered via the “<a href=\"https://developer.hashicorp.com/nomad/api-docs/system#force-gc\"><code>/v1/system/gc</code></a>” API and was a process we were using within the experiment to control memory growth. Without this, the Nomad servers running within the experiment would fail due to out of memory (OOM) errors, because the load test was creating approximately 2,400 job objects each minute, and each job would move to a completed state after ~3s.</p>\n\n<h3>Job batch deregister RPC</h3>\n\n<p>When Nomad determines a job can be garbage collected, it performs an RPC call to the “<a href=\"https://github.com/hashicorp/nomad/blob/50414600435b298474d9b61848ac8f4677b7112c/nomad/job_endpoint.go#L929\"><code>Job.BatchDeregister</code></a>” endpoint. As the naming implies, Nomad can provide an array of jobs to deregister that are deleted in a single Raft transaction, providing write efficiency.</p>\n\n<p>Inside the RPC handler, we can see a section of code that <a href=\"https://github.com/hashicorp/nomad/blob/b0c4cdc85544bd1f6b9f5f5493bc8236cd657b00/nomad/job_endpoint.go#L965-L1001\">loops through the job array and creates an evaluation per job</a>. Evaluations need to be created when a user submits a job deregistration, as we need to calculate what allocations need to be stopped, however, the batch deregister endpoint is not exposed via the HTTP API.</p>\n\n<h2>Optimization</h2>\n\n<p>We double and triple checked that garbage collection was the only process to use the batch deregister RPC, then we added some additional tests and removed the loop and code that creates evaluations from the handler via <a href=\"https://github.com/hashicorp/nomad/pull/20510\">#20510</a>. This change means Nomad no longer creates an evaluation when garbage collecting a job, reducing both Raft and eval broker load.</p>\n\n<p>Running the same experiment from when the evaluation spikes were first noticed with the modified code, we no longer see spikes in “<code>nomad.nomad.eval.ack</code>”.</p>\n<img src=\"https://www.datocms-assets.com/2885/1723487755-nomad-spikes-issue-resolved.png\" alt=\"No\" /><p>Across the two experiments, it was also found that Nomad subsystems such as Raft and the eval broker were comparatively put under less load with the new changes. This means we are now able to achieve higher throughput and greater stability along with minor improvements in CPU and memory consumption.</p>\n\n<h2>Final notes</h2>\n\n<p>We hope this article shed some light on Nomad internals and in particular how its garbage collection works. If you’re interested in more Nomad deep dives, have a look at <a href=\"https://www.hashicorp.com/blog/load-shedding-in-the-nomad-eval-broker\">a recent article on Nomad’s eval broker</a>, and of course feel free to <a href=\"https://developer.hashicorp.com/nomad/install\">try Nomad for yourself</a>. You can download it from the <a href=\"https://www.nomadproject.io/\">project’s website</a>, and we have lots of <a href=\"https://developer.hashicorp.com/nomad/docs\">documentation</a> to get started.</p>\n","author":"Piotr Kazmierczak","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"13d87b8f380cc1ce360ff121eb9f28253174fb5bfdc3e9b01094398bf1d7cffe","category":"Tech"}