{"title":"New – AWS Migration Hub Refactor Spaces Helps to Incrementally Refactor Your Applications","link":"https://aws.amazon.com/blogs/aws/new-aws-migration-hub-refactor-spaces-helps-to-incrementally-refactor-your-applications/","date":1638203780000,"content":"<p>I am excited to announce the preview of <a href=\"https://aws.amazon.com/migration-hub\">AWS Migration Hub Refactor Spaces</a>, a new capability of <a href=\"http://aws.amazon.com/migration-hub\">AWS Migration Hub</a> to let you refactor existing applications into distributed applications, typically based on microservices.</p> \n<p>There are multiple reasons why you want to refactor existing applications. You might want to make your code more modular, use more modern frameworks, use different data storage, etc. In general, when refactoring, your objective is to make your application easier to maintain and evolve over time. Other benefits might include handling larger workloads, increasing resiliency, or lowering costs. But let’s face it, refactoring is hard. I usually compare refactoring to changing the engines, cabin seats, and entertainment system of a plane while keeping the plane in the air, fully loaded with passengers, and without having them notice any change.</p> \n<p>When talking with customers who have successfully been through these refactoring projects, we noticed a common pattern: <a href=\"https://martinfowler.com/bliki/StranglerFigApplication.html\">the Strangler Fig design pattern</a>.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/11/17/AdobeStock_289229858.jpeg\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/11/17/AdobeStock_289229858.jpeg\" /></a></p> \n<p>A <a href=\"https://en.wikipedia.org/wiki/Strangler_fig\">strangler fig</a> is a family of plants that grow their roots from the top of the trees that host them, eventually enveloping or replacing their host. Author <a href=\"https://en.wikipedia.org/wiki/Martin_Fowler_(software_engineer)\">Martin Fowler</a> first coined the term <a href=\"https://martinfowler.com/bliki/StranglerFigApplication.html\">to describe a migration design pattern</a>. The idea is “to gradually create a new system around the edges of the old, letting it grow slowly over several years until the old system is strangled”.</p> \n<p><span><strong>How Can I Apply This Plant Behavior To My Application Migration?</strong></span><br /> Inspired by this family of plants, I might want to extract capabilities from a monolithic application and rewrite them as microservices. Then, I incrementally route traffic away from the old to the new. Over time, all of the requests are routed to microservices, and the existing application is retired.</p> \n<p>While effective, this approach to application transformation creates hurdles. I must create the required infrastructure to separate the existing applications and the microservices. In the AWS cloud, <a href=\"https://aws.amazon.com/organizations/getting-started/best-practices/\">this often involves creating multiple AWS accounts</a>, so teams or services can more easily operate independently. Having multiple accounts is the most efficient way to separate concerns and billing across teams. When dealing with multiple AWS accounts, it is required to maintain networking infrastructure to connect my existing application and new services together. Furthermore, I must create a routing control system to route traffic gradually from the old application to the new services in different accounts. Creating and managing that infrastructure at scale is complex. It introduces additional risks and costs to the refactor project.</p> \n<p><span><strong>How Refactor Spaces Helps<br /> </strong></span><a href=\"http://aws.amazon.com/migration-hub\">AWS Migration Hub</a> Refactor Spaces takes care of the heavy lifting for me. First, it lays down the networking infrastructure to enable connectivity between multiple AWS accounts. Second, it creates and manages a mechanism to route API calls away from my legacy application.</p> \n<p>Let’s imagine I have a monolithic application that I want to refactor. The application is made of a web-based front-end using <a href=\"https://reactjs.org/\">ReactJS</a>. The front-end application is hosted on <a href=\"https://aws.amazon.com/s3/\">Amazon Simple Storage Service (Amazon S3)</a> and distributed through <a href=\"https://aws.amazon.com/cloudfront/\">Amazon CloudFront</a>. The front-end makes API calls to a monolithic application developed in NodeJS or Python and deployed on several EC2 instances. The API uses a relational database, because this is how we store data since the company existed.</p> \n<p>The architecture of this application is illustrated by the following diagram.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/11/17/Slide1-2.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/11/17/Slide1-2-1024x577.png\" /></a></p> \n<p>Each API has a distinct URI. For example the <code>/cart</code> API handles the shopping basket, the <code>/order</code> API handles the ordering system, etc. I apply the <a href=\"https://martinfowler.com/bliki/StranglerFigApplication.html\">strangler fig pattern</a> and decide to extract the <code>/cart</code> capabilities to a set of new microservices. I create an AWS account for these microservices. I develop and deploy a set of AWS Lambda functions to implement the cart management functionalities. I chose to use <a href=\"https://aws.amazon.com/dynamodb/\">Amazon DynamoDB</a> for the shopping basket data storage because of its low latency at scale.</p> \n<p>The schema of my new architecture is shown in the following diagram:</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/11/17/Slide3.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/11/17/Slide3-1024x577.png\" /></a>But now I have two challenges. First, I have to design, code, and deploy a routing mechanism to route API calls made by the front-end application to the correct back-end: either the monolith, or the new microservices. This service will likely be deployed into a distinct AWS account. Then, I have to configure network connectivity between these multiple AWS accounts.</p> \n<p>This is where Refactor Spaces comes into the picture.</p> \n<p><span><strong>Introducing AWS Migration Hub Refactor Spaces</strong></span><br /> Refactor Spaces makes it easy to manage application refactoring by taking care of the two challenges I just described: the routing of the API calls and the network connectivity between AWS accounts. It is made of Environments, Services, and an Application proxy. Let’s see it in action.</p> \n<p>I open the <a href=\"https://console.aws.amazon.com\">AWS Management Console</a>, navigate to AWS Migration Hub, and select <strong>Refactor Spaces.</strong></p> \n<p>I first create a Refactor Spaces Environment. An Environment is a multi-account network fabric consisting of peered VPCs. This lets AWS resources in service VPCs added to the environment communicate directly across AWS accounts. It also provides a unified view of networking and services across accounts.</p> \n<p>In Create environment, I give my environment a <strong>name</strong> and a <strong>description,</strong> and then select <strong>Next</strong>.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/11/17/2021-11-17_10-08-24.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/11/17/2021-11-17_10-08-24-1022x1024.png\" /></a></p> \n<p>Then, I define my application. I give my application a <strong>name,</strong> and select the <strong>VPC</strong> where the proxy will be deployed.</p> \n<p>An application is a services container. It has a proxy that defines routes. The proxy lets your front-end application use a single endpoint to contact multiple services. All of the traffic hits the single proxy endpoint, and then it’s sent to multiple services based on your rules.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/11/17/2021-11-17_10-09-07.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/11/17/2021-11-17_10-09-07-914x1024.png\" /></a></p> \n<p>You may want to use multiple AWS accounts as explained before. Typically, an application is made of one AWS Account that hosts the Refactor Spaces Application proxy, one or multiple AWS accounts to host the legacy application, and one AWS account for the first microservice. Therefore, I invite the other AWS account owners to join this Refactor Spaces environment. I add one principal per AWS Account. Refactor Spaces doesn’t reinvent the wheel, but it leverages <a href=\"https://aws.amazon.com/ram/\">AWS Resource Access Manager (RAM)</a> to do so.</p> \n<p>This step is optional. Refactor Spaces may work within one AWS Account. It is possible to share the environments with other AWS accounts at a later stage.</p> \n<p>I enter the AWS account IDs as <strong>Principals,</strong> and then select <strong>Next</strong>.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/11/17/2021-11-17_10-10-01.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/11/17/2021-11-17_10-10-01-1007x1024.png\" /></a></p> \n<p>Finally, I review my choices and select <strong>Create &amp; share environment </strong>(not shown here).</p> \n<p>Assuming that the microservices are ready to use, the next step is registering them as Refactor Spaces Services. Refactor Spaces Services are entities that provide business capabilities, typically microservices. These services are reachable through unique endpoints, and they can interoperate across accounts in a Refactor Spaces Environment. In this example, there are four services:</p> \n<ul> \n <li>The monolithic app. This is the default service where Refactor Spaces routes all API calls initiated by the front-end.</li> \n <li>Three microservices to implement the <code>/cart</code> capability. I decided to refactor this capability with three distinct sevices: <code>AddItem</code>, <code>RemoveItem</code>, and <code>ListItems</code>.</li> \n</ul> \n<p>A Refactor Spaces Service may target any compute resource type: EC2, containers deployed on <a href=\"https://aws.amazon.com/fargate/\">AWS Fargate</a>, an <a href=\"https://docs.aws.amazon.com/elasticloadbalancing/latest/application/introduction.html\">Application Load Balancer</a>, an <a href=\"https://aws.amazon.com/lambda/\">AWS Lambda</a> function, etc.</p> \n<p>I select <strong>Create service</strong> from the left menu. The service configuration is in three steps. First, I select the Refactor Spaces <strong>Environment</strong> and <strong>Application</strong> where I want to define this service. Second, I give my service a <strong>name</strong> and a <strong>description</strong>. And third, I select the service <strong>endpoint</strong>: either an HTTP/HTTPS URL in a <strong>VPC</strong>, or a <strong>Lambda function</strong>.</p> \n<p>The monolithic application is the default route where Refactor Spaces Application proxy routes all of the API calls, unless otherwise specified. I enter <code>/</code> as <strong>Source path</strong> and select <strong>Include child paths.</strong> Then, I make make sure <strong>Match all</strong> is selected for HTTP verbs.</p> \n<p>When finished, I select <strong>Create service</strong>. I repeat this process for each of my microservices. For this demo, I create four Refactor Spaces Services in total.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/11/25/create-service-mockup-2.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/11/25/create-service-mockup-2.png\" /></a></p> \n<p>The last step defines the routing rules for the Refactor Spaces Application proxy. When configured, the proxy becomes the new API endpoint for my front-end application. The sole change that I have to make in my front-end application is to point it at the Refactor Spaces Application proxy URI. The proxy routes API calls to Services, according to a route definition. An Application proxy supports routing to all compute platforms with public or private visibility. At the moment, private endpoints must be referred through a public DNS name or their private IP address. Each API call is run against the set of routes configured in the proxy. When a path matches a rule, the request is sent to the target service configured for that path. Proxies have a default route that forwards requests to a default service if they don’t match any of the path rules.</p> \n<p>I select the service that I just created. Then, I enter the route <strong>Source path</strong> and the HTTP <strong>Verb</strong> to support. When my service expects subpaths (such as <code>/cart/123</code>), I make sure to select <strong>Include child paths,</strong> as well.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/11/24/2021-11-24_15-20-03.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/11/24/2021-11-24_15-20-03.png\" /></a></p> \n<p>I repeat this process for the <code>GetItem</code> and <code>RemoveItem</code> microservices. They are invoked for different HTTP verbs: <code>GET</code> and <code>DELETE</code> respectively.</p> \n<p>Based on this configuration, Refactor Spaces creates and manages the following architecture for me. The Refactor Spaces Application proxy and network fabric are deployed in a separate AWS account. I might further configure the <a href=\"http://aws.amazon.com/apigateway\">Amazon API Gateway</a> based on the needs of my monolithic application or microservices.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/11/17/Slide2-1.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/11/17/Slide2-1-1024x577.png\" /></a></p> \n<p>The ultimate change is for the application front-end. I modify its configuration to point to the Refactor Spaces Application proxy endpoint, instead of the monolith’s endpoint. From now on, Refactor Spaces routes API calls to the monolith by default. It routes the <code>/cart</code> calls for <code>GET</code>, <code>POST</code>, and <code>DELETE</code> verbs to my new microservices implemented as Lambda functions.</p> \n<p>Over time, I will repeat this process to move other capabilities out of the monolithic application, one-by-one, until the old monolith is strangled replaced by the new microservices architecture.</p> \n<p><span><strong>Pricing and Availaibility<br /> </strong></span>AWS Migration Hub Refactor Spaces is available today in the ten following AWS Regions: US East (N. Virginia), US West (Oregon), US East (Ohio), Asia Pacific (Singapore) Asia Pacific (Sydney), Asia Pacific (Tokyo), Europe (Ireland), Europe (Frankfurt), Europe (London), and Europe (Stockholm). As per usual, we’re looking forward to expanding to additional Regions in the future.</p> \n<p>This new capability is available today as an open preview, and no registration is necessary. You can start to use it today. There is no charge for using Refactor Space during the preview period. However, you may be charged for the resources that it provisions on your AWS accounts: <a href=\"http://aws.amazon.com/apigateway\">Amazon API Gateway</a>, <a href=\"https://aws.amazon.com/transit-gateway/\">AWS Transit Gateway</a>, and <a href=\"https://aws.amazon.com/elasticloadbalancing/network-load-balancer/\">Network Load Balancer</a>. <a href=\"https://aws.amazon.com/migration-hub/pricing/\">The pricing details are available on AWS Migration Hub’s pricing page</a>. Billing will start when Refactor Spaces will be generally available.</p> \n<p><a href=\"https://aws.amazon.com/migration-hub\">Go and start refactoring your applications today</a>!</p> \n<a href=\"https://twitter.com/sebsto\">-- seb</a>","author":"Sébastien Stormacq","siteTitle":"AWS News Blog","siteHash":"6093e072e4117ec22616e844cb857d03ca62c57a411a8affc77cb5e8b6b15bf6","entryHash":"8c567090fd917eb2de696bacdf8be582c555de9127c89757af0dc0ae0e959017","category":"Tech"}