{"title":"Adventure in Rewrite It in Rust","link":"https://blog.whs.in.th/node/3713","date":1722179821000,"content":"<p>ปีนี้อยากเขียน Rust เนื่องจากไม่รู้ทำอะไรดี ก็เลยคิดออกว่าอย่ามัวแต่บอกคนอื่นว่า Rewrite it in Rust เราก็ทำซะเองเลยดีกว่า</p>\n<h2>The Project</h2>\n<p>โครงการที่เลือกจะ port ตอนแรกมองว่า <a href=\"https://linux.thai.net/projects/libthai\">libthai</a> ซึ่งมันมีโครงสร้างข้อมูลด้วย <a href=\"https://linux.thai.net/projects/datrie\">libdatrie</a> ซึ่งก็ว่าจะเขียนแค่ให้มัน read file ของ libdatrie ได้ (ซึ่งทำสำเร็จแล้ว) แต่ทำไปทำมาแล้วเริ่มอยาก port libdatrie ไปเลยไม่งั้นมันคาใจ</p>\n<p>libthai เป็นไลบรารี utility ภาษาไทย ซึ่งมันควรจะป๊อปปูล่าร์มากในยุค AI, Machine Learning สมัยนี้ แต่เข้าใจว่าคนในวงการนั้นมักจะไม่ได้ใช้เพราะมันไม่มี Python binding ที่ดี (ถึงจะมีมันก็ลงยาก) อย่างไรก็ตามมันใช้ใน GTK สำหรับตัดคำไทยเป็นอย่างน้อย</p>\n<p>ส่วน libdatrie เป็นโครงสร้างข้อมูลแบบ <a href=\"https://linux.thai.net/~thep/datrie/datrie.html\">Double Array Trie</a> ซึ่งมีประโยชน์ในการเก็บคลังคำไทยเพื่อค้นหาอย่างรวดเร็ว เดิมทีเป็น C++ ก่อนที่จะถูก port เป็น C ในปี 2006</p>\n<p>ที่เลือกโครงการนี้ผมคิดว่าเหมาะสมด้วยหลายๆ เหตุผล</p>\n<ol>\n<li>มันเป็นโครงการของคนไทยสำหรับคนไทย ไม่ว่าอย่างไรเราจะไม่เห็นต่างชาติมานั่ง Port</li>\n<li>ผมเคยเห็นต่างชาติที่ compile GTK บ่นเกี่ยวกับ libthai ก็เลยคิดว่าถึงภาษาเราจะไม่ได้เป็นภาษาสำคัญในโลก แต่ library ภาษาเราก็สำคัญใน Linux desktop อย่างที่คนมองไม่เห็น</li>\n<li>เท่าที่เข้าใจคือทั้งสองไลบรารี มีคุณเทพพิทักษ์เป็น maintainer คนเดียว เรียกได้ว่า <a href=\"https://en.wikipedia.org/wiki/Bus_factor\">Bus factor</a> ต่ำมาก ทั้งๆ ที่แบกวงการภาษาไทยใน Linux Desktop อยู่ ซึ่งผมก็ไม่ได้ถนัดภาษา C และก็ไม่ได้อยาก maintain open source software แล้ว แต่ก็เผื่อว่าถ้ามันมีเวอร์ชั่น Rust ที่ใช้งานแทนกันได้ มันอาจจะมีคนอยากอาสาหยิบ Rust ไปทำต่อที่มันอ่านง่ายกว่าภาษา C</li>\n</ol>\n<p>(เท่าที่รู้คุณเทพพิทักษ์เองก็ไป<a href=\"https://thep.blogspot.com/2022/12/from-c-to-rust-so-far.html\">ศึกษา Rust มาบ้าง</a>)</p>\n<h2>Meson</h2>\n<p>ช่วงนึงผม crazy เรื่อง build system มาก ไปลองมาแล้วทั้ง CMake, Meson, Bazel แล้วก็เลย offer ว่าถ้าทาง libdatrie จะปรับ build system จาก autotools ที่เป็นซอฟต์แวร์โบราณ ให้ทันสมัยเป็น <a href=\"https://mesonbuild.com/\">Meson</a> ผมก็ยินดีนะ คุณเทพพิทักษ์เห็นด้วย ก็เลยไปนั่ง <a href=\"https://github.com/tlwg/libdatrie/pull/22\">port build system</a> ปัจจุบันก็ยังไม่ได้ merge เพราะแต่ละคนมีเวลาให้โครงการน้อยมากและไม่ตรงกัน comment ทีหนึ่งเป็นเดือนๆ กว่าจะได้แก้</p>\n<p>แต่ปรากฏว่ามันเป็น foundation ที่ดีในการ port โครงการที่เหลือเลย เพราะว่าผมขี้เกียจไปเรียน legacy software แบบ autotools ไม่รู้ว่าถ้าเพิ่มไฟล์ต้องแก้ตรงไหนบ้าง และผมใช้ CLion ในการเขียนโค้ด ซึ่งในขณะนั้นไม่รองรับ Autotools แต่พอจะอ่าน Meson ได้เล็กน้อย ทำให้อย่างน้อยๆ ผมมี IDE ที่ดีในการไล่โค้ด และรัน debugger บน test ได้ด้วย</p>\n<p>ถ้าจะ rewrite libthai ก็คงจะเขียน Meson ให้ libthai ก่อนเหมือนกัน ไม่ว่าจะได้ merge หรือไม่ เพราะ debugger สำคัญมาก</p>\n<h2>Code Archeology</h2>\n<p>ถัดมาผมก็เริ่ม rewrite ไปทีละ function ซึ่งค้นพบว่ามันเป็นโค้ดโบราณมากๆ มีแต่ท่าแปลกๆ ที่ไม่ใช้กันแ้ลว ผมโพสต์เล่าไปใน Mastodon คุณเทพพิทักษ์ก็ให้ความเห็นว่าสมัยก่อน C Compiler มันไม่ได้ optimize หรือ compatible ดีเท่าสมัยนี้ ดังนั้นการเขียนโค้ดแบบที่เห็นมันไม่ได้พึ่งว่า compiler ทุกตัวจะ optimize ได้ดีที่สุดเสมอไป แต่ยังสามารถคอมไพล์ได้ด้วยทุก compiler อยู่</p>\n<h3>Macro</h3>\n<pre><code>/**\n * @brief Test walkability in double-array structure\n *\n * @param d : the double-array structure\n * @param s : current state\n * @param c : the input character\n *\n * @return boolean indicating walkability\n *\n * Test if there is a transition from state @a s with input character @a c.\n */\n/*\nBool       da_is_walkable (DArray *d, TrieIndex s, TrieChar c);\n*/\n#define    da_is_walkable(d,s,c) \\\n    (da_get_check ((d), da_get_base ((d), (s)) + (c)) == (s))\n</code></pre>\n<p>ผมเข้าใจว่าโค้ดนี้ใช้ C Define กับโค้ดง่ายๆ เพื่อบังคับให้ compiler inline function เข้าไป</p>\n<h3>Branch Optimization Hint</h3>\n<pre><code>ds = (DString *) malloc (sizeof (DString));\nif (UNLIKELY (!ds))\n    return NULL;\n</code></pre>\n<p>โค้ดของ datrie มีการเช็ค memory allocation ไว้ทุกจุดเท่าที่เห็น ถือว่ารอบคอบมาก จะสังเกตว่าตัว if จะใช้ <code>UNLIKELY</code> ครอบเงื่อนไขไว้ ซึ่ง compiler จะ hint ให้ CPU ว่า if ตัวนี้โดยทั่วไปแล้วไม่น่าจะเกิดขึ้น ตัว branch prediction จะได้ข้ามไป ปัจจุบันคอมไพเลอร์มี <a href=\"https://en.wikipedia.org/wiki/Profile-guided_optimization\">Profile Guided Optimization</a> โดยเราคอมไพล์โปรแกรมแบบพิเศษ 1 ครั้งแล้วรันเทสทั้งหมด (ซึ่งควรจะครอบคลุมการใช้งาน) ตัวโปรแกรมจะมีการเก็บสถิติไว้ซึ่งสามารถใช้ในการคอมไพล์ตามปกติครั้งถัดไปได้ เพื่อให้ compiler ตัดสินใจได้ถูกว่าตรงไหนใช้บ่อยไม่บ่อย หรือคุ้มที่จะ unroll loop หรือไม่</p>\n<h3>Pointers</h3>\n<pre><code>/**\n * @brief Compare alphabet strings\n *\n * @param str1, str2  : the arrays of null-terminated AlphaChar strings\n *                      to compare\n *\n * @return negative if @a str1 &lt; @a str2;\n *         0 if @a str1 == @a str2;\n *         positive if @a str1 &gt; @a str2\n *\n * Available since: 0.2.7\n */\nint\nalpha_char_strcmp (const AlphaChar *str1, const AlphaChar *str2)\n{\n    while (*str1 &amp;&amp; *str1 == *str2) {\n        str1++; str2++;\n    }\n    if (*str1 &lt; *str2)\n        return -1;\n    if (*str1 &gt; *str2)\n        return 1;\n    return 0;\n}\n</code></pre>\n<p>ผมว่าที่คนบอกว่า C ไม่ปลอดภัยก็คือโค้ดแบบนี้เลย ที่อ่านแล้วหวาดเสียวมาก แต่ก็น่าจะเขียนมารัดกุมประมาณหนึ่ง</p>\n<p>ถ้าไม่เคยเขียน C ต้องบอกว่าขนาดของ Array ใน C เป็นแค่ convention ซึ่งก็ทำได้สองแบบคือระบุไว้ในโค้ดแล้วอย่าใช้เกิน หรือวาง marker ไว้ที่ท้าย array เช่น binary <code>00</code> คือสิ้นสุด ซึ่ง string ใน C มักจะทำแบบนี้เพราะเรามักจะไม่สามารถทราบความยาว string ตอนใช้งานจริงได้ในระหว่างเขียน</p>\n<p>หัว while loop ตัวแรกเลยกินความเยอะมากๆ</p>\n<ul>\n<li><code>*str1</code> มีค่าเท่ากับ <code>*str1 == 0</code> ก็คือเช็คว่าค่าของ <code>*str1</code> ยังไม่ถึงตัว marker <code>00</code> ป้องกันการอ่านเกินความยาวของ array</li>\n<li><code>*str1 == *str2</code> ก็ตามที่เขียน คือ loop นี้จะวนไปเรื่อยๆ จนกว่าจะสิ้นสุด str1 หรือเจออักษรตัวแรกที่ str1 และ str2 ต่างกัน</li>\n</ul>\n<p>ด้านในใช้ <code>str1++</code> สังเกตว่าไม่มี <code>*</code> แล้ว ท่านี้เป็น pointer arithmetic ซึ่งหวาดเสียวมากและในภาษาระดับสูงแทบจะทำไม่ได้ โดยในภาษา C นั้น array กับ pointer คือของอย่างเดียวกัน โดย <code>array[0] == *array</code> และ <code>array[1] == *(array + 1)</code> ซึ่งในโค้ด libdatrie การใช้ array จะเป็นแบบหลังเกือบทั้งหมดทำให้อ่านยากมาก คุณวีร์ให้ข้อมูลผมมาว่าการใช้ syntax array ใน C สมัยนั้นทำงานช้ากว่าการใช้ pointer</p>\n<p>โค้ดด้านบนถ้าเขียนเป็น Python คงจะกลายเป็น</p>\n<pre><code>def alpha_char_strcmp(str1: AlphaChar, str2: AlphaChar) -&gt; int:\n    while i &lt; len(str1):\n        if str1[i] != str2[i]:\n            break\n        i += 1\n    if str1[i] &lt; str2[i]:\n        return -1\n    if str1[i] &gt; str[2]:\n        return 1\n    return 0\n</code></pre>\n<p>(มันน่าจะมีบั๊ก เพราะผมไม่ได้รัน แต่น่าจะพอเห็นไอเดีย)</p>\n<p>เวอร์ชั่น Rust น่ะหรอ ผมจะไปนั่ง loop เองทำไมล่ะ</p>\n<pre><code>pub extern \"C\" fn alpha_char_strcmp(str1: *const AlphaChar, str2: *const AlphaChar) -&gt; i32 {\n    let str1 = unsafe { Nul::new_unchecked(str1) };\n    let str2 = unsafe { Nul::new_unchecked(str2) };\n    match str1.cmp(str2) {\n        Ordering::Less =&gt; -1,\n        Ordering::Equal =&gt; 0,\n        Ordering::Greater =&gt; 1,\n    }\n}\n</code></pre>\n<p>ข้อเสียของเวอร์ชั่นนี้คือ <a href=\"https://docs.rs/null-terminated/latest/null_terminated/struct.Nul.html\">Nul</a> มันใช้ slice compare ของ Rust ซึ่งมันจะรีบหาขนาดของทั้ง 2 input ก่อนเลยเพื่อป้องกัน loop ตกขอบ ดังนั้นมันจะช้ากว่าแบบเดิมแน่นอน</p>\n<p>ดังนั้นคิดว่า Rewrite it in Rust ไม่ได้ดีขึ้นเสมอไป อย่างที่เห็นว่า libdatrie มีการ optimize algorithm ไว้ดีมากๆ แล้ว at cost of safety ซึ่ง<a href=\"https://godbolt.org/z/17q5bYaqe\">ผมจะเขียนเหมือนที่ libdatrie เขียนก็ได้</a> แต่มันไม่ใช่ท่าที่คนปกติเขียน Rust กัน</p>\n<h3>Return Value Optimization</h3>\n<p>ใน libdatrie มีโค้ดนี้</p>\n<pre><code>struct _Symbols {\n    short       num_symbols;\n    TrieChar    symbols[TRIE_CHAR_MAX + 1];\n};\n\nstatic Symbols *    symbols_new (void);\n</code></pre>\n<p>ผมสังเกตว่า symbols มีความยาวตายตัวคือ 256 ซึ่งเล็กดี ในโค้ดการทำงานของ Symbols ถ้าผมจำไม่ผิดจะเป็น sorted set ของตัวอักษรที่เคยเห็นแล้ว จะได้ใช้ถามว่าเคยเห็นตัวนี้แล้วหรือยัง</p>\n<p>ตอนที่ port มาก็กลายเป็น</p>\n<pre><code>#[derive(Debug)]\npub(crate) struct Symbols {\n    symbols: ArrayVec&lt;TrieChar, { TrieChar::MAX as usize }&gt;,\n}\n\nimpl Symbols {\n    pub(crate) fn new() -&gt; Symbols {}\n}\n</code></pre>\n<p>สังเกตว่า <code>symbols_new</code> ใน C คืน pointer ของ <code>Symbols*</code> แต่ <code>Symbols::new()</code> ใน Rust คืน struct ออกไปโดยตรง บวกกับว่าผมใช้ <a href=\"https://docs.rs/arrayvec/latest/arrayvec/\">ArrayVec</a> ซึ่งเป็น vector ที่มีสมาชิกได้จำกัดจำนวนตัว และเป็น stack allocated ได้ ดังนั้นกลายเป็นว่า Symbols จะเปลี่ยนจาก heap allocated เป็น stack allocated</p>\n<p>และมากไปกว่านั้น ผม decompile code ออกมาดูก็พบว่า Symbols ไม่มีอยู่จริงในโค้ดผลลัพท์เลย เนื่องจากมันสามารถ inline code ทั้งหมดได้ซึ่งเวอร์ชั่น C แม้จะใช้ compiler ยุคปัจจุบันก็ทำไม่ได้เพราะมันเป็น heap allocated ซึ่งจะแก้ให้เวอร์ชั่น C ไม่ใช้ pointer ก็ไม่ได้เพราะ C Compiler ไม่จำเป็นต้องมี <a href=\"https://en.wikipedia.org/wiki/Copy_elision#RVO\">Return Value Optimization</a> เสมอไป ไม่เหมือน C++</p>\n<p>อันนี้ผมว้าวมาก แต่จริงๆ Rust compiler ก็มักจะ inline struct method และลบ struct ได้บ่อยครั้งอยู่แล้ว เช่น <code>Option&lt;&gt;</code> ที่มักจะไม่ได้ถูกสร้างจริงแต่กลายเป็น if-else error check ธรรมดา หรือ Iterator ที่มักจะโดนแปลงเป็น loop ธรรมดาแล้วไม่ได้ construct ตัว iterator type จริงทำให้โค้ดที่ใช้ iterator มักจะเร็วกว่าการใช้ loop เสียอีก</p>\n<h2>Waterfall</h2>\n<p>ปัญหาของการ rewrite ใน Rust ก็คือเราอยากใช้ data structure ที่แตกต่างกับ C เพราะ Rust data structure ดีกว่าในหลายๆ ด้าน และใช้งานง่ายกว่าใน Rust ด้วย แต่เนื่องจาก data structure layout ไม่เหมือนกันทำให้เราต้อง port โค้ดทั้งหมดจนไม่เหลือโค้ดที่เข้าไปอ่าน field ภายใน data structure โดยตรงอีก</p>\n<p>ซึ่งเนื่องจาก libdatrie คือ data structure library ก็เท่ากับต้อง rewrite ทั้ง library ให้เสร็จรวดเดียวถึงจะรันได้</p>\n<p>แบบนั้นก็น่าจะแย่เลย เขียนโค้ดหลายพันบรรทัดโดยไม่ได้เทสแล้วจะให้รันครั้งเดียวผ่าน ดังนั้นวิธีที่คิดไว้ว่าจะแก้ปัญหานี้คือเราต้องเขียน unit test ใน Rust เพิ่ม ซึ่งก็มีทั้งแบบที่แปลงมาจาก unit test ของ libdatrie เดิม ซึ่งรู้สึกว่าน้อย ไม่ครบถ้วน (เนื่องจากโค้ดเดิมแทบไม่มี test harness เลย ก็พอเข้าใจได้ว่าการเขียน test ยิบย่อยจะลำบาก) และก็มี test ใหม่ที่เขียนขึ้นใน Rust เองด้วย ซึ่งก็เขียนได้จำกัดเพราะไม่ได้เข้าใจตัว library ครบถ้วนโดยเฉพาะในส่วนที่มันจัดการ memory ภายในก็ไม่รู้ว่าจะต้อง assert ว่ายังไงดี</p>\n<p>ผ่านไป 4 เดือนก็แปลงโค้ดทั้งหมดเสร็จ ก็ทำการทดสอบโดย compile libdatrie test ตามปกติ แล้วรันเทสโดยใช้ <code>LD_PRELOAD</code> เรียกเวอร์ชั่น Rust ทับแทน</p>\n<p>ผลปรากฏว่า crash…</p>\n<h2>Debugging</h2>\n<p>พอ test ข้ามภาษากันแบบนี้แล้วพบว่ามัน debug อะไรไม่ได้เลย นอกจาก print ก็เลยต้องแปลง test ที่ fail เป็น Rust ด้วยถึงจะใช้ RustRover debugger ได้ แต่อาการ crash มันมาจาก data ซึ่งก็ต้องไปเปิดเวอร์ชั่น C step ไปพร้อมๆ กันเพื่อดูข้อมูลที่ถูกต้อง</p>\n<p>debug แบบนี้ยากมากๆ เพราะว่าบางทีพังที่ loop รอบที่ 4 ก็ต้อง step ไปแบบระวังว่าห้ามเกิน แล้วเทียบกัน ถ้ามันเท่ากัน ก็ต้องย้ายจุดที่น่าสงสัยไปเรื่อยๆ บั๊กอันหนึ่งใช้เวลาแก้ 2-3 ชั่วโมง กว่าจะแก้เสร็จก็หัวระเบิด จะไปแก้บั๊กถัดไปก็มีเวลาทำไม่พอ debug ไปกลางทาง ไปพัก กลับมาก็ต่อไม่ติดแล้วไม่รู้ว่า breakpoint ที่วางไว้ไว้เพื่ออะไร</p>\n<p>สุดท้ายก็เลยยอมแพ้ วิธีนี้ไม่เวิร์ค</p>\n<h2>C2Rust</h2>\n<p>หลายวันก่อนได้ยินว่ามีบาง library ใช้ <a href=\"https://github.com/immunant/c2rust\">C2Rust</a> แปลงเข้ามาแล้ว Rewrite it in Rust สำเร็จ ก็เลยคิดว่าลองดูสักหน่อย</p>\n<p>C2Rust จะรับ input เป็น compile_commands.json เหมือนกับ CLion ซึ่งโชคดีที่เราแปลงเป็น Meson ไว้เลยมีไฟล์นี้อยู่แล้ว ผมโยนเข้าไปพร้อม Flag เล็กน้อย ก็ได้โค้ด Rust ออกมาทั้ง project ไม่ว่าจะเป็น library, trietool binary, tests แถมยังมี Cargo.toml ด้วย</p>\n<p>ที่เหลือก็คือแก้ Cargo.toml ให้ output เป็น dylib (.so) ถูกต้อง แล้ว <code>cargo build</code> ก็ compile ผ่านเลย แล้วที่ทึ่งมากๆ คือพอใช้ <code>LD_PRELOAD</code> เรียก test datrie ทั้งหมดก็ผ่านฉลุย ถือว่าเป็นจุดเริ่มต้นที่ดี</p>\n<h2>Rewrite Rust in Rust</h2>\n<p>แต่โค้ดที่ C2Rust สร้างมันจะหยาบมากๆ คือ</p>\n<ul>\n<li>Macro ซับซ้อน โดน inline หมด</li>\n<li>ค่าบางอย่างที่ควรจะเป็น implementation details ของ standard library หลุดออกมาด้วย เช่น definition ของ <code>*FILE</code></li>\n<li>ทั้งโค้ดเป็น unsafe มีการใช้ pointer offset เต็มไปหมด</li>\n<li>ยังใช้ malloc/free</li>\n<li>data type ยังเป็นของ C อยู่ เช่น <code>libc::c_uint</code> แทนที่จะเป็น <code>u32</code></li>\n<li>การบวกเลขลบเลข บางทีมันแปลงเป็น <code>wrapping_add()</code> ทำให้ยุบยับมาก</li>\n<li>Comment และ spacing หายหมด</li>\n</ul>\n<p>แต่บางอย่างถือว่ามันก็ทำได้ดี</p>\n<ul>\n<li>Constant จาก <code>#define</code> กลายเป็น <code>const</code> ได้ถูกต้อง</li>\n<li>Struct, typedef แปลงมาได้ถูกต้อง</li>\n<li>โค้ดมีการใช้ <code>goto</code> ในการ cleanup ซึ่งแปลงเป็นเวอร์ชั่น Rust แล้วอ่านยาก แต่ก็ถือว่าไม่ธรรมดาเพราะมันแปลง 1-1 ไม่ได้</li>\n<li>Implicit cast กลายเป็น explicit cast ได้หมด</li>\n<li>ฟังค์ชั่นใดๆ ที่อยู่ใน .h จะกลายเป็น public ส่วนถ้าไม่อยู่ใน .h จะเป็น private</li>\n</ul>\n<p>แน่นอนว่าโค้ดที่ใช้ pointer แหลกแบบนี้ เรียกว่า Rewrite it in Rust ไม่ได้ ก็ต้องค่อยๆ cleanup ไปทีละไฟล์ เริ่มจากไฟล์ที่ไม่ค่อย depend ของในไฟล์อื่นก่อน ซึ่งวิธีการ cleanup ที่ผมใช้ก็จะหลาย pass หน่อย ประมาณนี้ และระหว่างที่แก้ก็ต้องรันเทสไปด้วยเพื่อให้รู้ว่า test ยังไม่พัง</p>\n<h3>Cleanup</h3>\n<p>ตอนที่ได้โค้ดมา มันจะมีส่วนที่ unused เยอะมากๆ ก็ต้องเริ่มจากการลบ unused ในไฟล์ออกไปก่อน เช่น</p>\n<pre><code>extern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n}\npub type __uint16_t = libc::c_ushort;\npub type __uint32_t = libc::c_uint;\npub type __uint64_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    // ...\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[inline]\nunsafe extern \"C\" fn __bswap_16(mut __bsx: __uint16_t) -&gt; __uint16_t {}\n#[inline]\nunsafe extern \"C\" fn __bswap_32(mut __bsx: __uint32_t) -&gt; __uint32_t {}\n#[inline]\nunsafe extern \"C\" fn __bswap_64(mut __bsx: __uint64_t) -&gt; __uint64_t {}\n#[inline]\nunsafe extern \"C\" fn __uint16_identity(mut __x: __uint16_t) -&gt; __uint16_t {}\n#[inline]\nunsafe extern \"C\" fn __uint32_identity(mut __x: __uint32_t) -&gt; __uint32_t {}\n#[inline]\nunsafe extern \"C\" fn __uint64_identity(mut __x: __uint64_t) -&gt; __uint64_t {}\n</code></pre>\n<p>พวกนี้เป็น unused ทั้งหมดเลย ในส่วนของไฟล์นั้นเราไม่ควรจะเอา implementation detail มาเปิดแบบนี้ ก็แปลลงเป็น</p>\n<pre><code>pub type FILE = libc::FILE;\n</code></pre>\n<p>พบว่าแทนกันได้เลย</p>\n<p>ในส่วนของ Function signature เราจะได้แบบนี้</p>\n<pre><code>#[no_mangle]\npub unsafe extern \"C\" fn da_set_check(mut d: *mut DArray, mut s: TrieIndex, mut val: TrieIndex) {}\n</code></pre>\n<p>ซึ่งก็ต้อง cleanup ได้ประมาณนี้</p>\n<ol>\n<li>แปะ <code>pub(crate)</code> ไว้ก่อน สำหรับ function ที่ไม่ได้อยู่ใน installed header ของ library (บางทีฟังค์ชั่นนี้อยู่ใน .h แต่ .h นั้นไม่ได้ถูก package ออกไป แสดงว่าใช้แค่ภายใน library)</li>\n<li>กรณีเป็น private function เราไม่จำเป็นต้องทำให้ compat กับ C ก็ได้ โดยลบ <code>#[no_mangle]</code> และ <code>extern \"C\"</code> ออกเพื่อให้มันกลายเป็น Rust function ธรรมดา บางที compiler อาจจะ inline เข้าไปตามจุดที่ใช้เลย (ตรงนี้ควรจะเทส เพราะถ้ามีคนแอบใช้ implementation detail มันจะพัง)</li>\n<li>ทุก parameter จะเป็น <code>mut</code> เราลบ <code>mut</code> ออกได้เกือบหมด ยกเว้นบางทีมี reassign ทับ</li>\n<li>ใส่ space ระหว่าง function</li>\n<li>Copy function documentation มาจาก C (อย่าลืมแปลงเป็นแบบ Rust เพราะ comment format ต่างกัน)</li>\n</ol>\n<p>ถัดมาคือเรื่อง dependency จะมีสองส่วน</p>\n<ol>\n<li>type ที่ใช้ในไฟล์จะถูกประกาศในไฟล์ ทำให้ type มันซ้ำซ้อนกันมาก เราควรจะจัดวาง type ให้เหมาะสมโดยคิดว่าไฟล์ไหนที่จะประกาศ type นี้เป็นหลัก แล้วเวลาแก้ไฟล์ไหนก็ลบการประกาศ type ที่อยู่ที่อื่นออกจากไฟล์ไปเพื่อให้ IDE แนะนำให้ import</li>\n<li>เวลาไฟล์นี้เรียกใช้ function ของไฟล์อื่น มันจะเป็นการเรียกข้ามแบบ C โดยประกาศเป็น <code>extern \"C\"</code> ด้านบนและไม่มี <code>use</code> ไปที่ไฟล์อื่น ถ้าเป็นฟังค์ชั่นที่จำได้ว่าไฟล์นั้นๆ แปลงเสร็จแล้ว ผมก็จะลบออกจาก extern “C” ด้วยเพื่อให้มัน error แล้วเราไปตาม import มาให้ครบ จะได้เป็นการเรียกข้ามแบบ Rust แทน</li>\n</ol>\n<h3>Invasive surgery</h3>\n<p>หลังจากนั้นจะเริ่มเป็นส่วนที่ยากขึ้น คือการแปลงโค้ดจาก OOP ด้วยฟังค์ชั่นเป็น OOP จริง ซึ่งเราจะต้องย้ายโค้ดจากฟังค์ชั่นที่ C2Rust สร้างให้ไปอยู่ใน <code>impl</code> แล้วทำให้ฟังค์ชั่นเดิมเป็น adapter ไปเรียกที่ใหม่แทน (ห้ามลบ) เนื่องจากโค้ด C ที่อื่นยังเรียกด้วยชื่อ C อยู่ไม่สามารถเรียกเข้าไปใน <code>impl</code> ได้</p>\n<p>นอกจากนั้นแล้วเราต้องแปลง function ข้างในให้มันเป็น idiomatic &amp; safe Rust ให้มากที่สุดด้วย แต่ในตอนนี้อย่าเพิ่งแก้ data type</p>\n<p>ยกตัวอย่างเช่น</p>\n<pre><code>pub unsafe extern \"C\" fn da_new() -&gt; *mut DArray {\n    let mut d: *mut DArray = 0 as *mut DArray;\n    d = malloc(::core::mem::size_of::&lt;DArray&gt;() as libc::c_ulong) as *mut DArray;\n    if d.is_null() {\n        return NULL as *mut DArray;\n    }\n    (*d).num_cells = DA_POOL_BEGIN;\n    (*d).cells = malloc(\n        ((*d).num_cells as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::&lt;DACell&gt;() as libc::c_ulong),\n    ) as *mut DACell;\n    if ((*d).cells).is_null() {\n        free(d as *mut libc::c_void);\n        return NULL as *mut DArray;\n    } else {\n        (*((*d).cells).offset(0 as libc::c_int as isize)).base = DA_SIGNATURE as TrieIndex;\n        (*((*d).cells).offset(0 as libc::c_int as isize)).check = (*d).num_cells;\n        (*((*d).cells).offset(1 as libc::c_int as isize)).base = -(1 as libc::c_int);\n        (*((*d).cells).offset(1 as libc::c_int as isize)).check = -(1 as libc::c_int);\n        (*((*d).cells).offset(2 as libc::c_int as isize)).base = DA_POOL_BEGIN;\n        (*((*d).cells).offset(2 as libc::c_int as isize)).check = 0 as libc::c_int;\n        return d;\n    };\n}\n</code></pre>\n<p>ฟังค์ชั่นนี้เป็นการสร้าง DArray ซึ่งมีค่าเริ่มต้น อาจจะแปลงเป็น <code>new()</code> หรือ <code>Default</code> impl ก็ได้ ดังนี้</p>\n<pre><code>impl Default for DArray {\n    fn default() -&gt; Self {\n        let num_cells = DA_POOL_BEGIN;\n        let mut out = DArray {\n            num_cells,\n            cells: unsafe { malloc(((num_cells as usize) * size_of::&lt;DACell&gt;()) as libc::c_ulong).cast() },\n        };\n        unsafe {\n            (*out.cells.offset(0)).base = DA_SIGNATURE as TrieIndex;\n            (*out.cells.offset(0)).check = num_cells;\n            (*out.cells.offset(1)).base = -1;\n            (*out.cells.offset(1)).check = -1;\n            (*out.cells.offset(2)).base = DA_POOL_BEGIN;\n            (*out.cells.offset(2)).check = 0;\n        }\n        out\n    }\n}\n</code></pre>\n<p>สังเกตว่าจุดหนึ่งที่ safety หายไปในเวอร์ชั่น Rust คือโค้ดนี้ใน C เขียนมาดี ถ้า memory allocation fail แล้ว user ที่เรียก function มีสิทธิ์ handle error ได้ตามต้องการ แต่ในเวอร์ชั่น Rust แล้ว Rust ไม่ได้คืนเป็น error ให้เรา เราเลยทำไม่ได้ มันก็จะ crash ไปเลย</p>\n<p>แต่จุดที่ได้คืนมาในเวอร์ชั่นนี้คือ DArray เป็น stack allocated แล้ว ไม่ใช่ heap allocated ซึ่งอาจจะช่วยประสิทธิภาพได้บ้าง</p>\n<p>ถัดมาคือตัวฟังค์ชั่นเดิม</p>\n<pre><code>#[deprecated(note=\"Use DArray::default()\")]\n#[no_mangle]\npub extern \"C\" fn da_new() -&gt; *mut DArray {\n    Box::into_raw(Box::new(DArray::default()))\n}\n</code></pre>\n<p>Heap allocation บน Rust ก็คือใช้ <code>Box</code> type และใน Rust หลังๆ ก็ไม่ได้ใช้ jemalloc แล้วแต่ ใช้ malloc/free ตามปกติ (+alignment) ทำให้ <code>free</code> จากใน C ก็น่าจะได้ด้วยเช่นกัน และเวอร์ชั่นนี้ไม่มี unsafe แล้ว</p>\n<p>สำหรับ deprecated ที่ใส่ไว้ ผมคิดว่าช่วยได้ดีในเวลาที่แปลง function อื่นต่อ จะได้เห็นว่า C Call นี้มีเวอร์ชั่น Rust ที่ type น่าใช้งานกว่าแล้ว ให้ย้ายไปใช้ได้เลย</p>\n<p>ในส่วนของ <code>da_free()</code> นั้นท่าที่เจอว่าเหมาะสมที่สุดคือแปลงกลับเป็น Box</p>\n<pre><code>#[no_mangle]\npub unsafe extern \"C\" fn da_free(mut d: NonNull&lt;DArray&gt;) {\n    drop(Box::from_raw(d.as_mut()))\n}\n</code></pre>\n<p>จริงๆ แล้ว <code>drop</code> ไม่ต้องใส่ก็ได้ แต่มันจะดูแปลกๆ ที่เหมือนเราสร้าง box แต่ไม่ได้ทำอะไร ซึ่งจริงๆ การสร้าง Box เป็นการโอน ownership เข้ามาใน function นี้ด้วย เมื่อจบฟังค์ชั่นนี้แล้วไม่ได้มีใช้ต่อ เลยถูก free ออกไป คำสั่ง drop ก็ทำงานด้วยหลักการนี้ (ข้างใน <code>drop</code> คือฟังค์ชั่นเปล่าๆ) แต่ใส่ไว้เพื่อให้อ่านเข้าใจง่ายขึ้น</p>\n<p>สังเกตอยู่สองจุดคือมีการใช้ NonNull แทน <code>*mut DArray</code> ซึ่งมันเท่ากัน (แต่ไม่มีเวอร์ชั่นสำหรับ <code>*const DArray</code> นะ) แต่พบผมว่าใน output type มันใช้ <code>NonNull</code> ลำบาก แต่ถ้าเป็น input type แล้วมันจะมี method ที่ให้เราอ่านเป็น <code>&amp;mut T</code> ได้เลย แต่ถ้า <code>*mut DArray</code> จะมีแต่ <code>Option&lt;&amp;mut T&gt;</code> เพราะต้อง null check (จริงๆ เราจะ deref เลยไม่สนอะไรก็ได้อยู่หรอก…)</p>\n<p>กับอีกจุดหนึ่งคือผมยังติด <code>unsafe</code> ไว้ เพราะคิดว่าฟังค์ชั่นนี้ไม่ควรเรียกใน Rust จะเจอว่าสามารถ use-after-free ได้ เลยไม่ลบป้ายออกไป</p>\n<p>โค้ดข้างใน <code>da_free</code> เดิมจะต้อง free subtype ข้างในด้วย พวกนี้ผมย้ายเข้าไปใน <code>Drop</code> implementation แทน ใครที่ใช้ <code>DArray::new()</code> จาก Rust ก็จะได้ auto free ที่ถูกต้องไปด้วย (ใน <code>Drop</code> ไม่ต้อง free ตัวเอง ตัว compiler ทำให้ แต่ต้อง recursive free pointer ด้วยตัวเอง)</p>\n<h3>Serialize</h3>\n<p>ส่วนที่ชอบมากในการ port คือ serialize</p>\n<pre><code>#[no_mangle]\npub unsafe extern \"C\" fn da_serialize(mut d: *const DArray, mut ptr: *mut *mut uint8) {\n    let mut i: TrieIndex = 0;\n    i = 0 as libc::c_int;\n    while i &lt; (*d).num_cells {\n        serialize_int32_be_incr(ptr, (*((*d).cells).offset(i as isize)).base);\n        serialize_int32_be_incr(ptr, (*((*d).cells).offset(i as isize)).check);\n        i += 1;\n        i;\n    }\n}\npub unsafe extern \"C\" fn da_fwrite(mut d: *const DArray, mut file: *mut FILE) -&gt; libc::c_int {}\n</code></pre>\n<p>ในเวอร์ชั่น C เนื่องจากไม่มี Generic เลยมีโค้ด serialize 2 จุด คือ <code>da_serialize</code> ซึ่งเขียนลงใน buffer ที่ขนาด <code>da_get_serialized_size</code> และ <code>da_fwrite</code> ซึ่งเขียนลงไฟล์ ทั้งสองโค้ดเหมือนกันแต่ไม่ใช่ duplicate code โดยตรงเพราะเมธอดในการเขียนข้อมูลต่างกัน</p>\n<p>ในเวอร์ชั่น Rust เรามี Generic แล้ว ก็น่าจะรวบรวมเป็นแบบเดียวได้เลยคือ</p>\n<pre><code>impl DArray {\n    fn slices(&amp;self) -&gt; &amp;[DACell] {\n          unsafe { slice::from_raw_parts(self.cells, self.num_cells) }\n    }\n\n    pub(crate) fn serialize&lt;T: Write&gt;(&amp;self, writer: &amp;mut T) -&gt; io::Result&lt;()&gt; {\n        for cell in &amp;self.slices() {\n            writer.write_i32::&lt;BigEndian&gt;(cell.base)?;\n            writer.write_i32::&lt;BigEndian&gt;(cell.check)?;\n        }\n        Ok(())\n    }\n}\n</code></pre>\n<p>เนื่องจาก struct ของเรา <code>self.cells</code> ยังเป็น pointer อยู่ แต่ข้างหลังมันคือ slice แน่ๆ เพราะมีขนาดตายตัว เวลาทำอะไรใน Rust เราควรจะรีบแปลงมันกลับเป็น Rust slice เสียก่อน ซึ่งไม่มี cost แต่ทำให้เราเขียนโค้ดต่อได้ง่ายมากๆ รวมถึงใช้ iterator ด้วย</p>\n<p>ตัว <code>write_i32::&lt;bigendian&gt;</code> มาจาก package <a href=\"https://docs.rs/byteorder/latest/byteorder/\">byteorder</a> เป็นอีกโค้ดหนึ่งที่ libdatrie มี <code>serialize_int32_be_incr</code> แต่ในฝั่ง Rust สามารถใช้ library สำเร็จแทนได้เลย</p>\n<p>แต่ปัญหาถัดมาก็คือ input parameter ของทั้ง <code>da_serialize</code> และ <code>da_fwrite</code> มันไม่ใช่ Rust stream เราจะใช้ไม่ได้ แถมมันยังเป็น C file ไม่ใช่ Rust file อีกด้วย ผมพยายามหาท่าแปลงแล้วก็พบว่าท่าที่ดีที่สุดที่เจอคือใช้ <a href=\"https://docs.rs/cstream/0.1.4/cstream/struct.BorrowedCStream.html\">cstream</a> ซึ่งเป็นแพคเกจที่มี adapter ครอบ <code>libc::FILE</code> แล้วไปเรียก <code>fwrite</code>, <code>ftell</code>, <code>fseek</code>, ฯลฯ อีกที ทำให้ไม่ต้องกังวลว่าเราจะ break implementation detail ของ <code>FILE*</code></p>\n<pre><code>pub(crate) fn wrap_cfile_nonnull(\n    file: NonNull&lt;libc::FILE&gt;,\n) -&gt; cstream::Io&lt;BorrowedCStream&lt;'static&gt;&gt; {\n    unsafe { cstream::Io(BorrowedCStream::borrow_raw(file)) }\n}\n\n#[deprecated(note = \"Use DArray::serialize()\")]\n#[no_mangle]\npub(crate) extern \"C\" fn da_fwrite(d: *const DArray, file: NonNull&lt;libc::FILE&gt;) -&gt; i32 {\n    let mut file = wrap_cfile_nonnull(file);\n    let da = unsafe { &amp;*d };\n\n    match da.serialize(&amp;mut file) {\n        Ok(_) =&gt; 0,\n        Err(_) =&gt; -1,\n    }\n}\n</code></pre>\n<p>ส่วนของ <code>da_serialize</code> นั้น type ที่ทำให้เรา Write ใส่ Slice ได้ก็คือ <code>std::io::Cursor</code></p>\n<pre><code>#[deprecated(note = \"Use DArray::serialize()\")]\n#[no_mangle]\npub(crate) unsafe extern \"C\" fn da_serialize(d: *const DArray, mut ptr: NonNull&lt;NonNull&lt;[u8]&gt;&gt;) {\n    let mut cursor = Cursor::new(ptr.as_mut().as_mut());\n    (*d).serialize(&amp;mut cursor).unwrap();\n    // Move ptr\n    ptr.write(ptr.as_ref().byte_offset(cursor.position() as isize));\n}\n</code></pre>\n<p>ตอนแรกเหมือน serialize จะง่ายกว่า แต่กลายเป็นว่ายากกว่าและยังไม่ถูกต้องด้วย</p>\n<ol>\n<li>ในเวอร์ชั่น C นั้น function serialize จะเลื่อนตำแหน่งของ array pointer ไปยังหลังจุดที่เขียนไปแล้ว ซึ่งเป็นการ mutate input variable ซึ่งก็ทำได้ไม่ยากคือใช้ <code>*ptr = ptr.as_ref().byte_offset()</code> เพื่อเลื่อนตำแหน่งได้</li>\n<li>แต่จุดที่ยากคือ C array ไม่มีการระบุขนาด เราอาจจะไปเรียก <code>da_get_serialized_size()</code> เพื่อหาขนาดแล้วแปลงเป็น slice (<code>slice::from_raw_parts_mut(ptr.as_mut(), da.serialized_size())</code>) ก็ได้ แต่มันจะช้าลง วิธีที่ใช้อยู่จะเห็นว่าฟังค์ชั่นนี้รับ <code>&amp;mut [u8]</code> เข้ามาเลย ซึ่งจริงๆ แล้วผิดเพราะ <code>&amp;[u8]</code> ใน Rust เรียกว่า fat pointer (ตำแหน่ง + ขนาด) ที่เป็น concept ที่ไม่มีใน C ดังนั้นถ้ามีใครใช้ขนาดของ pointer ก็คือมีโอกาสที่โปรแกรมจะพังเลย</li>\n</ol>\n<h3>Type change</h3>\n<p>ส่วนที่ยากที่สุดก็คือส่วนที่มัน operate กับตัว data structure ในที่นี่คือ <code>self.cells</code> ซึ่งพอเขียนไปเรื่อยๆ จะเริ่มเห็นว่าพฤติกรรมการทำงานมันเป็นแบบใด เท่าที่เห็นโค้ด libdatrie ก็จะมีอยู่คือ</p>\n<ol>\n<li><code>Vec&lt;t&gt;</code> หรือ Array List คือ array ที่มีขนาดไม่ตายตัว เวลา add แล้วอาจจะมีการขอเพิ่มได้บ่อยครั้ง</li>\n<li>Linked List ซึ่งเป็นโครงสร้างข้อมูลระดับมหาลัยปี 2 แต่ใน Rust กลับเขียนยากมากๆ ถึงกับมีหนังสือ <a href=\"https://rust-unofficial.github.io/too-many-lists/\">วิธีเขียน LinkedList</a> เป็นเล่มเลย</li>\n<li><code>Box&lt;[T]&gt;</code> หรือ array ที่มีขนาดตายตัว ไม่มีการขอเพิ่ม แต่ขนาดที่ตายตัวนั้นกลับไม่รู้ล่วงหน้าตอนเขียนโค้ด</li>\n<li>Null terminated array คือ array ที่ไม่ทราบขนาด แต่ตอนท้ายจะมีอักษรพิเศษบอกว่าจบแล้ว ซึ่งมักจะคือตัว <code>\\0</code> ซึ่งเป็นที่นิยมเพราะ string ในภาษา C เป็นแบบนี้ แต่ใน libdatrie มีการรองรับ array ที่ใช้ type อื่นนอกเหนือจาก <code>char</code> อีกด้วย ใน Rust มี <code>CStr</code> และ <code>CString</code> สำหรับ string อยู่แล้ว แต่ขนาดอื่นๆ ต้องใช้แพคเกจ <a href=\"https://docs.rs/null-terminated/latest/null_terminated/struct.Nul.html\">null_terminated</a> ซึ่งไม่ว่าเป็น implementation ไหน ถ้าเราขอ slice ออกมามันจะต้อง loop ทั้ง array (หรือใช้ <a href=\"https://docs.rs/memchr/latest/memchr/index.html\">CPU Instruction</a> พิเศษ) หาความยาวก่อน</li>\n</ol>\n<p>สำหรับใน DArray จากที่ใช้งานก็จะคิดว่าเป็น <code>Vec&lt;/t&gt;&lt;t&gt;</code> ธรรมดา ก็สามารถแปลงได้เลย จากโค้ดเดิม</p>\n<pre><code>#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _DArray {\n    pub num_cells: TrieIndex,\n    pub cells: *mut DACell,\n}\n</code></pre>\n<p>ที่ผมทำคือ</p>\n<ol>\n<li>แปลง field cells เป็น <code>Vec&lt;dacell&gt;</code></li>\n<li>deprecate field <code>num_cells</code> ออกด้วย <code>#[deprecate(note=\"Use self.cells.len()\")]</code></li>\n<li>แก้จุดที่ใช้ offset ต่างๆ เป็น <code>[]</code> ให้หมด</li>\n<li>ถ้ามีการ bound check ก่อนเข้าถึง สามารถแปลงเป็น <code>let Some(value) = self.cells.get() else { return }</code> ได้</li>\n<li>ตรงที่ใช้ num_checks จะติด deprecate warning ขึ้นมา ก็ตามแก้ให้หมด</li>\n<li>ใน <code>Drop</code> ลบโค้ดที่ <code>free(cells)</code> ออก เพราะพอเรามี ownership แล้ว Rust จะ recursive free ให้อัตโนมัติ และเนื่องจากเรามี ownership หมดแล้วเราสามารถลบ <code>Drop</code> ออกได้เลย</li>\n</ol>\n<p>แต่จุดที่ยากที่สุดคงจะเป็นจุดที่ allocate cells สำหรับใช้งาน ตรงนี้ก็อาจจะต้องใช้ฟังค์ชั่นเฉพาะทางของ Vec ไป เช่น <code>reserve</code>, <code>resize</code></p>\n<p>ข้อสังเกตอย่างหนึ่งของการแปลงเป็น Vec และ slice ใน Rust ก็คือ Rust มี runtime cost ของการใช้ slice โดยทุกครั้งที่เข้าถึง slice Rust จะแอบใส่ bound check มาทุกครั้ง (ถ้าเป็น C เข้าถึงเกิน slice คือ <a href=\"https://cwe.mitre.org/data/definitions/788.html\">buffer overflow</a> ซึ่งจะเกิดอะไรขึ้นก็ได้…) ถ้าเป็น loop ที่ tight มากๆ ก็อาจจะกระทบการใช้งานได้ แต่เห็นว่ามีผลประมาณ 1-15% ยกเว้นแต่ว่าถ้า bound check หายไปแล้ว compiler autovectorization ทำงานต่อได้ แปลงเป็น <a href=\"https://en.wikipedia.org/wiki/Single_instruction,_multiple_data\">SIMD instruction</a> ได้ ก็อาจจะทำให้ได้ประสิทธิภาพสูงขึ้นไปอีก ซึ่งตัว compiler ก็ฉลาดพอที่ว่าถ้าเรามีการ check โชว์แล้วว่าใช้งานไม่เกินความยาวจริงก็เชื่อ check ของเรา แต่การใช้งานจริงก็พบว่าเขียนยากมาก บางทีมันเป็น implementation detail ข้างในที่เช็คก่อนไม่ได้ หรือ type มันถูก cast ไปมาจาก <code>usize</code> เป็น type ที่ C ใช้ มันก็ไม่เชื่อ ท่าที่รู้สึกว่าเอาชัวร์ได้จริงๆ เห็นจะมีแต่ว่าใช้ Iterator</p>\n<h2>cbindgen</h2>\n<p>ตอนนี้ยังเขียนไปไม่ถึง cbindgen แต่รู้สึกว่าบล็อกยาวแล้ว เลยตัดจบไว้ที่ cbindgen ในอนาคตแล้วกัน</p>\n<p>ในเวอร์ชั่นแรกตอนที่เขียนเราใช้ <a href=\"https://github.com/mozilla/cbindgen\">cbindgen</a> ซึ่งเป็นโปรแกรมที่แปลง Rust กลับเป็น C header ช่วยตรวจสอบว่า function signature ของ Rust มันยัง compatible กับ C อยู่หรือไม่</p>\n<p>goal ที่อยากได้คือนอกจากจะ drop in replacement libdatrie ได้แล้ว ก็คิดว่าถ้าใครอยาก target libdatrie-rust เลยก็ทำได้เช่นกัน แต่เราใช้ cbindgen เพื่อ automate ในจุดนี้แทนที่จะต้องเขียน header เอง</p>\n<p>แต่คิดว่าไม่อยากให้คนใช้ Rust มาใช้ libdatrie เวอร์ชั่นนี้นะ รู้สึกว่ามันจะไม่ generic พอถูกจริตคนใช้ Rust และ type ที่เลือกใช้ก็แปลกๆ แถมบางจุดยังใช้ Null terminated array ด้วย (แก้ยาก เพราะมันอยู่ใน storage design / data format เลย) อย่างมากสุดคือใช้เพื่ออ่านไฟล์ที่สร้างจาก C แล้วเอาไปทำอย่างอื่นดีกว่า เช่น โหลดใส่ library อื่น</p>\n<h2>On license</h2>\n<p>Note ส่งท้ายว่าข้อเสียของท่าที่เขียนมานี้คือใช้ในการฟอก License ไม่ได้นะ ตัว libdatrie เป็น LGPL ก็แน่นอนว่าโค้ด libdatrie เวอร์ชั่น Rust ก็ต้องเป็น LGPL เพราะว่าถูกดัดแปลงมาจากโค้ดเดิม บางโครงการที่ Rewrite it in Rust เค้าเขียนขึ้นมาใหม่แล้วพยายามทำให้ compatible กับของเดิม (เช่น args เท่ากัน) ถ้าไม่อ่านโค้ดเดิมเลย (อาจจะอ่านแต่ documentation) ถึงจะสามารถเปลี่ยน license ได้ตามใจชอบ</p>","author":"whs","siteTitle":"Quietly Verbose","siteHash":"5f972a6fe70a917eb1b1aa165b3cb2be8a9465af33ab38bf05f34c55c0e40587","entryHash":"e4f1c3e40968ca893458522936e257e077714f49046b75be94bad0a1e29b3620","category":"Thai"}