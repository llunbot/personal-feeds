{"title":"React Children And Iteration Methods","link":"https://smashingmagazine.com/2021/08/react-children-iteration-methods/","date":1628073000000,"content":"<p>The most obvious and common prop that developers work with within React is the <code>children</code> prop. In the majority of cases, there is no need to understand how the <code>children</code> prop looks like. But in some cases, we want to inspect the <code>children</code> prop to maybe wrap each child in another element/component or to reorder or slice them. In those cases inspecting how the <code>children</code> prop looks like becomes essential.</p>\n<p>In this article, we’ll look at a React utility <code>React.Children.toArray</code> which lets us prepare the <code>children</code> prop for inspection and iteration, some of its shortcomings and how to overcome them — through a small open-source package, to keep our React code function the way it is deterministically supposed to behave, keeping performance intact. If you know the basics of React and have at least an idea about what the <code>children</code> prop in React is, this article is for you.</p>\n<p>While working with React, most of the time we do not touch the <code>children</code> prop any more than using it in React components directly.</p>\n<pre><code>function Parent({ children }) {\n  return &lt;div className=\"mt-10\"&gt;{children}&lt;/div&gt;;\n}</code></pre>\n\n<p>But sometimes we have to iterate over the <code>children</code> prop so that we can enhance or change the children without having the user of the components explicitly do it themselves. One common use case is to pass the iteration index-related information to child components of a parent like so:</p>\n<pre><code>import { Children, cloneElement } from \"react\";\n\nfunction Breadcrumbs({ children }) {\n  const arrayChildren = Children.toArray(children);\n\n  return (\n    &lt;ul\n      style={{\n        listStyle: \"none\",\n        display: \"flex\",\n      }}\n    &gt;\n      {Children.map(arrayChildren, (child, index) =&gt; {\n        const isLast = index === arrayChildren.length - 1;\n\n        if (! isLast &amp;&amp; ! child.props.link ) {\n          throw new Error(\n            `BreadcrumbItem child no. ${index + 1}\n            should be passed a 'link' prop`\n          )\n        } \n\n        return (\n          &lt;&gt;\n            {child.props.link ? (\n              &lt;a\n                href={child.props.link}\n                style={{\n                  display: \"inline-block\",\n                  textDecoration: \"none\",\n                }}\n              &gt;\n                &lt;div style={{ marginRight: \"5px\" }}&gt;\n                  {cloneElement(child, {\n                    isLast,\n                  })}\n                &lt;/div&gt;\n              &lt;/a&gt;\n            ) : (\n              &lt;div style={{ marginRight: \"5px\" }}&gt;\n                {cloneElement(child, {\n                  isLast,\n                })}\n              &lt;/div&gt;\n            )}\n            {!isLast &amp;&amp; (\n              &lt;div style={{ marginRight: \"5px\" }}&gt;\n                &gt;\n              &lt;/div&gt;\n            )}\n          &lt;/&gt;\n        );\n      })}\n    &lt;/ul&gt;\n  );\n}\n\nfunction BreadcrumbItem({ isLast, children }) {\n  return (\n    &lt;li\n      style={{\n        color: isLast ? \"black\" : \"blue\",\n      }}\n    &gt;\n      {children}\n    &lt;/li&gt;\n  );\n}\n\nexport default function App() {\n  return (\n    &lt;Breadcrumbs&gt;\n      &lt;BreadcrumbItem\n        link=\"https://goibibo.com/\"\n      &gt;\n        Goibibo\n      &lt;/BreadcrumbItem&gt;\n\n      &lt;BreadcrumbItem\n        link=\"https://goibibo.com/hotels/\"\n      &gt;\n        Hotels\n      &lt;/BreadcrumbItem&gt;\n\n      &lt;BreadcrumbItem&gt;\n       A Fancy Hotel Name\n      &lt;/BreadcrumbItem&gt;\n    &lt;/Breadcrumbs&gt;\n  );\n}\n</code></pre>\n\n<p>Take a look at the <a href=\"https://codesandbox.io/embed/sm-article-21-lt6le?fontsize=14&amp;hidenavigation=1&amp;theme=dark\">Codesandbox demo</a>. Here we’re doing the following:</p>\n<ol>\n<li>We are using the <code>React.Children.toArray</code> method to ensure that the <code>children</code> prop is always an array. If we do not do that, doing <code>children.length</code> might blow because the <code>children</code>  prop can be an object, an array, or even a function. Also, if we try to use the array <code>.map</code> method on <code>children</code> directly it might blow up.</li>\n<li>In the parent <code>Breadcrumbs</code> component we are iterating over its children by using the utility method <code>React.Children.map</code>.</li>\n<li>Because we have access to <code>index</code> inside the iterator function (second argument of callback function of <code>React.Children.map</code>) we are able to detect if the child is last-child or not.</li>\n<li>If it is the last child we clone the element and pass in the <code>isLast</code> prop to it so that the child can style itself based on it.</li>\n<li>If it is not the last child, we ensure that all those children which aren’t the last child have a <code>link</code> prop on them by throwing an error if they don’t. We clone the element as we did in step 4. and pass the <code>isLast</code> prop as we did before, but we also additionally wrap this cloned element in an anchor tag. </li>\n</ol>\n<p>The user of <code>Breadcrumbs</code> and <code>BreadcrumbItem</code> doesn’t have to worry about which children should have links and how they should be styled. Inside the <code>Breadcrumbs</code> component, it automatically gets handled.</p>\n<p>This pattern of <em>implicitly</em> passing in props and/or having <code>state</code> in the parent and passing the state and state changers down to the children as props is called the <a href=\"https://kentcdodds.com/blog/compound-components-with-react-hooks/\">compound component pattern</a>. You might be familiar with this pattern from React Router’s <code>Switch</code> component, which takes <code>Route</code> components as its children:</p>\n<pre><code>// example from react router docs\n// https://reactrouter.com/web/api/Switch\n\nimport { Route, Switch } from \"react-router\";\n\nlet routes = (\n  &lt;Switch&gt;\n    &lt;Route exact path=\"/\"&gt;\n      &lt;Home /&gt;\n    &lt;/Route&gt;\n    &lt;Route path=\"/about\"&gt;\n      &lt;About /&gt;\n    &lt;/Route&gt;\n    &lt;Route path=\"/:user\"&gt;\n      &lt;User /&gt;\n    &lt;/Route&gt;\n    &lt;Route&gt;\n      &lt;NoMatch /&gt;\n    &lt;/Route&gt;\n  &lt;/Switch&gt;\n);</code></pre>\n\n<p>Now that we have established that there are needs where we have to iterate over <code>children</code> prop sometimes, and having used two of the children utility methods <code>React.Children.map</code> and <code>React.Children.toArray</code>, let’s refresh our memory about one of them: <code>React.Children.toArray</code>.</p>\n<code>React.Children.toArray</code>\n<p>Let’s start by seeing with an example what this method does and where it might be useful.</p>\n<pre><code>import { Children } from 'react'\n\nfunction Debugger({children}) {\n  // let’s log some things\n  console.log(children);\n  console.log(\n    Children.toArray(children)\n  )\n  return children;\n}\n\nconst fruits = [\n  {name: \"apple\", id: 1},\n  {name: \"orange\", id: 2},\n  {name: \"mango\", id: 3}\n]\n\nexport default function App() {\n  return (\n    &lt;Debugger&gt;\n        &lt;a\n          href=\"https://css-tricks.com/\"\n          style={{padding: '0 10px'}}\n        &gt;\n          CSS Tricks\n        &lt;/a&gt;\n\n        &lt;a\n          href=\"https://smashingmagazine.com/\"\n          style={{padding: '0 10px'}}\n        &gt;\n          Smashing Magazine\n        &lt;/a&gt;\n\n        {\n          fruits.map(fruit =&gt; {\n            return (\n              &lt;div key={fruit.id} style={{margin: '10px'}}&gt;\n                {fruit.name}\n              &lt;/div&gt;\n            )\n          })\n        }\n    &lt;/Debugger&gt;\n  )\n}</code></pre>\n\n<p>Take a look at the <a href=\"https://codesandbox.io/embed/sm-article-22-hhuws?fontsize=14&amp;hidenavigation=1&amp;theme=dark\">Codesandbox demo</a>. We have a <code>Debugger</code> component, which does nothing much in terms of rendering — it just returns <code>children</code> as is. But it does log two values: <code>children</code> and <code>React.Children.toArray(children)</code>.</p>\n<p>If you open up the console, you’d be able to see the difference.</p>\n<ul>\n<li>The first statement which logs <code>children</code> prop, shows the following as its value’s data structure: </li>\n</ul>\n<pre><code>[\n  Object1, ----&gt; first anchor tag\n  Object2, ----&gt; second anchor tag\n  [\n    Object3, ----&gt; first fruit\n    Object4, ----&gt; second fruit\n    Object5] ----&gt; third fruit\n  ]\n]</code></pre>\n\n<ul>\n<li>The second statement which logs <code>React.Children.toArray(children)</code> logs:</li>\n</ul>\n<pre><code>[\n  Object1, ----&gt; first anchor tag\n  Object2, ----&gt; second anchor tag\n  Object3, ----&gt; first fruit\n  Object4, ----&gt; second fruit\n  Object5, ----&gt; third fruit\n]</code></pre>\n\n<p>Let’s read the method’s documentation in React docs to make sense of what is happening.</p>\n<blockquote>\n<p><code>React.Children.toArray</code> returns the <code>children</code> opaque data structure as a flat array with keys assigned to each child. Useful if you want to manipulate collections of children in your render methods, especially if you want to reorder or slice <code>children</code> before passing it down.</p>\n</blockquote>\n<p>Let’s break that down:</p>\n<ol>\n<li>Returns the <code>children</code> opaque data structure as a flat array.</li>\n<li>With keys assigned to each child.</li>\n</ol>\n<p>The first point says that that <code>children</code> (which is an opaque data structure, meaning it can be an object, array, or a function, as described earlier) is converted to a flat array. Just like we saw in the example above. Additionally, this <a href=\"https://github.com/facebook/react/issues/6889#issuecomment-221858162\">GitHub issue comment</a> also explains its behavior:</p>\n<blockquote>\n<p>It (<code>React.Children.toArray</code>) does not pull children out of elements and flatten them, that wouldn’t really make any sense. It flattens nested arrays and objects, i.e. so that <code>[['a', 'b'],['c', ['d']]]</code> becomes something similar to <code>['a', 'b', 'c', 'd']</code>.</p>\n</blockquote>\n<pre><code>React.Children.toArray(\n  [\n    [\"a\", \"b\"],\n    [\"c\", [\"d\"]]\n  ]\n).length === 4;</code></pre>\n\n<p>Let’s see what the second point (‘With keys assigned to each child.’) says, by expanding one child each from the previous logs of the example.</p>\n<h3>Expanded Child From  <code>console.log(children)</code></h3>\n<pre><code>{\n  $$typeof: Symbol(react.element),\n  key: null,\n  props: {\n    href: \"https://smashingmagazine.com\",\n    children: \"Smashing Magazine\",\n    style: {padding: \"0 10px\"}\n  },\n  ref: null,\n  type: \"a\",\n  // … other properties\n}</code></pre>\n\n\n\n<h3>Expanded Child From <code>console.log(React.Children.toArray(children))</code></h3>\n<pre><code>{\n  $$typeof: Symbol(react.element),\n  key: \".0\",\n  props: {\n    href: \"https://smashingmagazine.com\",\n    children: \"Smashing Magazine\",\n    style: {padding: \"0 10px\"}\n  },\n  ref: null,\n  type: \"a\",\n  // … other properties\n}</code></pre>\n\n<p>As you can see, besides flattening the <code>children</code> prop into a flat array, it also adds unique keys to each of its children. From the React docs:</p>\n<blockquote><code>React.Children.toArray()</code> changes keys to preserve the semantics of nested arrays when flattening lists of children. That is, <code>toArray</code> prefixes each key in the returned array so that each element’s key is scoped to the input array containing it.</blockquote>\n\n<p>Because the <code>.toArray</code> method might change the order and place of <code>children</code>, it has to make sure that it maintains unique keys for each of them for <a href=\"https://reactjs.org/docs/reconciliation.html#recursing-on-children\">reconciliation and rendering optimization</a>.</p>\n<p>Let’s give a little bit more attention to <em><code>so that each element’s key is scoped to the input array containing it.</code></em>, by looking at the keys of each element of the second array (corresponding to <code>console.log(React.Children.toArray(children))</code>).</p>\n<pre><code>import { Children } from 'react'\n\nfunction Debugger({children}) {\n  // let’s log some things\n  console.log(children);\n  console.log(\n    Children.map(Children.toArray(children), child =&gt; {\n      return child.key\n    }).join('\\n')\n  )\n  return children;\n}\n\nconst fruits = [\n  {name: \"apple\", id: 1},\n  {name: \"orange\", id: 2},\n  {name: \"mango\", id: 3}\n]\n\nexport default function App() {\n  return (\n    &lt;Debugger&gt;\n        &lt;a\n          href=\"https://css-tricks.com/\"\n          style={{padding: '0 10px'}}\n        &gt;\n          CSS Tricks\n        &lt;/a&gt;\n        &lt;a\n          href=\"https://smashingmagazine.com/\"\n          style={{padding: '0 10px'}}\n        &gt;\n          Smashing Magazine\n        &lt;/a&gt;\n        {\n          fruits.map(fruit =&gt; {\n            return (\n              &lt;div key={fruit.id} style={{margin: '10px'}}&gt;\n                {fruit.name}\n              &lt;/div&gt;\n            )\n          })\n        }\n    &lt;/Debugger&gt;\n  )\n}</code></pre>\n\n<pre><code>.0  ----&gt; first link\n.1  ----&gt; second link\n.2:0 ----&gt; first fruit\n.2:1 ----&gt; second fruit\n.2:2 ----&gt; third fruit</code></pre>\n\n<p>As you can see that the fruits, which were originally a nested array inside the original <code>children</code> array, have keys that are prefixed with <code>.2</code>. The <code>.2</code> corresponds to the fact that they were a part of an array. The suffix, namely <code>:0</code> ,<code>:1</code>, <code>:2</code> are corresponding to the React elements’ (fruits) default keys. By default, React uses the index as the key, if no key is specified for the elements of a list.</p>\n<p>So suppose you had three level of nesting inside <code>children</code> array, like so:</p>\n<pre><code>import { Children } from 'react'\n\nfunction Debugger({children}) {\n  const retVal = Children.toArray(children)\n  console.log(\n    Children.map(retVal, child =&gt; {\n      return child.key\n    }).join('\\n')\n  )\n  return retVal\n}\n\nexport default function App() {\n  const arrayOfReactElements = [\n    &lt;div key=\"1\"&gt;First&lt;/div&gt;,\n    [\n      &lt;div key=\"2\"&gt;Second&lt;/div&gt;,\n      [\n        &lt;div key=\"3\"&gt;Third&lt;/div&gt;\n      ]\n    ]\n  ];\n  return (\n    &lt;Debugger&gt;\n      {arrayOfReactElements}\n    &lt;/Debugger&gt;\n  )\n}</code></pre>\n\n<p>The keys will look like</p>\n<pre><code>.$1\n.1:$2\n.1:1:$3</code></pre>\n\n<p>Check the <a href=\"https://codesandbox.io/embed/sm-article-23-5fwrd?fontsize=14&amp;hidenavigation=1&amp;theme=dark\">Codesandbox demo</a>. The <code>$1</code>, <code>$2</code>, <code>$3</code> suffixes are because of the original keys put on the React elements in an array, otherwise React complains of lack of keys 😉 .</p>\n<p>From whatever we’ve read so far we can come to two use cases for <code>React.Children.toArray</code>.</p>\n<ol>\n<li><p>If there’s an absolute need that <code>children</code> should always be an array, you can use <code>React.Children.toArray(children)</code> instead. It’ll work perfectly even when <code>children</code> is an object or a function too.</p>\n</li>\n<li><p>If you have to sort, filter, or slice <code>children</code> prop you can rely on <code>React.Children.toArray</code> to always preserve unique keys of all the children.</p>\n</li>\n</ol>\n<p><strong>There’s a problem with <code>React.Children.toArray</code></strong> 🤔. Let’s look at this piece of code to understand what the problem is:</p>\n<pre><code>import { Children } from 'react'\n\nfunction List({children}) {\n  return (\n    &lt;ul&gt;\n      {\n        Children.toArray(\n          children\n        ).map((child, index) =&gt; {\n          return (\n            &lt;li\n              key={child.key}\n            &gt;\n              {child}\n            &lt;/li&gt;\n          )\n        })\n      }\n    &lt;/ul&gt;\n  )\n}\n\nexport default function App() {\n  return (\n    &lt;List&gt;\n      &lt;a\n        href=\"https://css-tricks.com\"\n        style={{padding: '0 10px'}}\n      &gt;\n        Google\n      &lt;/a&gt;\n      &lt;&gt;\n        &lt;a\n          href=\"https://smashingmagazine.com\"\n          style={{padding: '0 10px'}}\n        &gt;\n          Smashing Magazine\n        &lt;/a&gt;\n        &lt;a\n          href=\"https://arihantverma.com\"\n          style={{padding: '0 10px'}}\n        &gt;\n          {\"Arihant’s Website\"}\n        &lt;/a&gt;\n      &lt;/&gt;\n    &lt;/List&gt;\n  )\n}</code></pre>\n\n<p>Check the <a href=\"https://codesandbox.io/embed/sm-article-24-dqld3?fontsize=14&amp;hidenavigation=1&amp;theme=dark\">Codesandbox demo</a>. If you see what gets rendered for the children of the fragment, you’ll see that both of the links get rendered inside one <code>li</code> tag! 😱</p>\n<p>This is because <a href=\"https://github.com/facebook/react/issues/6889\"><code>React.Children.toArray</code></a> <a href=\"https://github.com/facebook/react/issues/6889\">doesn’t traverse into fragments</a>. So what can we do about it? Fortunately, nothing 😅 . We already have an open-sourced package called <a href=\"https://github.com/grrowl/react-keyed-flatten-children\"><code>react-keyed-flatten-children</code></a>. It’s a small function that does its magic. </p>\n<p>Let’s see what it does. In pseudo-code (these points are linked in the actual code below), it does this:</p>\n<ol>\n<li>It is a function that takes <code>children</code> as its only necessary argument.</li>\n<li>Iterates over <code>React.Children.toArray(children)</code> and gathers children in an accumulator array.</li>\n<li>While iterating, if a child node is a string or a number, it pushes the value as is in the accumulator array.</li>\n<li>If the child node is a valid React element, it clones it, gives it the appropriate key, and pushes it to the accumulator array.</li>\n<li>If the child node is a fragment, then the function calls itself with fragment’s children as its argument (this is how it <em>traverses through a fragment</em>) and pushes the result of calling itself in the accumulator array.</li>\n<li>While doing all this it keeps the track of the depth of traversal (of fragments), so that the children inside fragments would have correct keys, the same way as keys work with nested arrays, as we saw earlier above.</li>\n</ol>\n<pre><code>import {\n  Children,\n  isValidElement,\n  cloneElement\n} from \"react\";\n\nimport { isFragment } from \"react-is\";\n\nimport type {\n  ReactNode,\n  ReactChild,\n} from 'react'\n\n/*************** 1. ***************/\nexport default function flattenChildren(\n  // only needed argument\n  children: ReactNode,\n  // only used for debugging\n  depth: number = 0,\n  // is not required, start with default = []\n  keys: (string | number)[] = [] \n): ReactChild[] {\n  /*************** 2. ***************/\n  return Children.toArray(children).reduce(\n    (acc: ReactChild[], node, nodeIndex) =&gt; {\n      if (isFragment(node)) {\n        /*************** 5. ***************/\n        acc.push.apply(\n          acc,\n          flattenChildren(\n            node.props.children,\n            depth + 1,\n            /*************** 6. ***************/\n            keys.concat(node.key || nodeIndex)\n          )\n        );\n      } else {\n        /*************** 4. ***************/\n        if (isValidElement(node)) {\n          acc.push(\n            cloneElement(node, {\n              /*************** 6. ***************/\n              key: keys.concat(String(node.key)).join('.')\n            })\n          );\n        } else if (\n          /*************** 3. ***************/\n          typeof node === \"string\"\n          || typeof node === \"number\"\n        ) {\n          acc.push(node);\n        }\n      }\n      return acc; \n    },\n    /*************** Acculumator Array ***************/\n    []\n  );\n}</code></pre>\n\n<p>Let’s retry our previous example to use this function and see for ourselves that it fixes our problem.</p>\n<pre><code>import flattenChildren from 'react-keyed-flatten-children'\nimport { Fragment } from 'react'\n\nfunction List({children}) {\n  return (\n    &lt;ul&gt;\n      {\n        flattenChildren(\n          children\n        ).map((child, index) =&gt; {\n          return &lt;li key={child.key}&gt;{child}&lt;/li&gt;\n        })\n      }\n    &lt;/ul&gt;\n  )\n}\nexport default function App() {\n  return (\n    &lt;List&gt;\n      &lt;a\n        href=\"https://css-tricks.com\"\n        style={{padding: '0 10px'}}\n      &gt;\n        Google\n      &lt;/a&gt;\n      &lt;Fragment&gt;\n        &lt;a\n          href=\"https://smashingmagazine.com\"\n          style={{padding: '0 10px'}}&gt;\n          Smashing Magazine\n        &lt;/a&gt;\n\n        &lt;a\n          href=\"https://arihantverma.com\"\n          style={{padding: '0 10px'}}\n        &gt;\n          {\"Arihant’s Website\"}\n        &lt;/a&gt;\n      &lt;/Fragment&gt;\n    &lt;/List&gt;\n  )\n}</code></pre>\n\n<p>And <a href=\"https://codesandbox.io/embed/sm-article-25-b76gn?fontsize=14&amp;hidenavigation=1&amp;theme=dark\">here’s the final result</a> (on Codesandbox)! <em>Woooheeee!</em> It works.</p>\n<p>As an add-on, if you are new to testing — like I am at the point of this writing — you might be interested in <a href=\"https://github.com/grrowl/react-keyed-flatten-children/blob/master/index.spec.tsx\">7 tests</a> written for this utility function. It’ll be fun to read the tests to deduce the functionality of the function.</p>\nThe Long Term Problem With <code>Children</code> Utilities\n<blockquote>“<code>React.Children</code> is a leaky abstraction, and is in maintenance mode.”<br /><br />— <a href=\"https://github.com/reactjs/rfcs/pull/61#issuecomment-431247764\">Dan Abramov</a></blockquote>\n\n<p>The problem with using <code>Children</code> methods to change <code>children</code> behavior is that they only work for one level of nesting of components. If we wrap one of our <code>children</code> in another component, we lose composability. Let’s see what I mean by that, by picking up the first example that we saw — the breadcrumbs.</p>\n<pre><code>import { Children, cloneElement } from \"react\";\n\nfunction Breadcrumbs({ children }) {\n  return (\n    &lt;ul\n      style={{\n        listStyle: \"none\",\n        display: \"flex\",\n      }}\n    &gt;\n      {Children.map(children, (child, index) =&gt; {\n        const isLast = index === children.length - 1;\n        // if (! isLast &amp;&amp; ! child.props.link ) {\n        //   throw new Error(`\n        //     BreadcrumbItem child no.\n        //     ${index + 1} should be passed a 'link' prop`\n        //   )\n        // } \n        return (\n          &lt;&gt;\n            {child.props.link ? (\n              &lt;a\n                href={child.props.link}\n                style={{\n                  display: \"inline-block\",\n                  textDecoration: \"none\",\n                }}\n              &gt;\n                &lt;div style={{ marginRight: \"5px\" }}&gt;\n                  {cloneElement(child, {\n                    isLast,\n                  })}\n                &lt;/div&gt;\n              &lt;/a&gt;\n            ) : (\n              &lt;div style={{ marginRight: \"5px\" }}&gt;\n                {cloneElement(child, {\n                  isLast,\n                })}\n              &lt;/div&gt;\n            )}\n            {!isLast &amp;&amp; (\n              &lt;div style={{ marginRight: \"5px\" }}&gt;&gt;&lt;/div&gt;\n            )}\n          &lt;/&gt;\n        );\n      })}\n    &lt;/ul&gt;\n  );\n}\n\nfunction BreadcrumbItem({ isLast, children }) {\n  return (\n    &lt;li\n      style={{\n        color: isLast ? \"black\" : \"blue\",\n      }}\n    &gt;\n      {children}\n    &lt;/li&gt;\n  );\n\n}\nconst BreadcrumbItemCreator = () =&gt;\n  &lt;BreadcrumbItem\n    link=\"https://smashingmagazine.com\"\n  &gt;\n    Smashing Magazine\n  &lt;/BreadcrumbItem&gt;\n\nexport default function App() {\n  return (\n    &lt;Breadcrumbs&gt;\n      &lt;BreadcrumbItem\n        link=\"https://goibibo.com/\"\n      &gt;\n        Goibibo\n      &lt;/BreadcrumbItem&gt;\n\n      &lt;BreadcrumbItem\n        link=\"https://goibibo.com/hotels/\"\n      &gt;\n        Goibibo Hotels\n      &lt;/BreadcrumbItem&gt;\n\n      &lt;BreadcrumbItemCreator /&gt;\n\n      &lt;BreadcrumbItem&gt;\n        A Fancy Hotel Name\n      &lt;/BreadcrumbItem&gt;\n    &lt;/Breadcrumbs&gt;\n  );\n}</code></pre>\n\n<p>Take a look at the <a href=\"https://codesandbox.io/embed/sm-article-26-7067h?fontsize=14&amp;hidenavigation=1&amp;theme=dark\">Codesandbox demo</a>. Although our new component <code>&lt;BreadcrumbItemCreator /&gt;</code> rendered, our <code>Breadcrumb</code> component doesn’t have any way to extract out the <code>link</code> prop from it, because of which, it doesn’t render as link.</p>\n<p>To fix this problem React team had come with — now defunct — experimental API called <a href=\"https://www.npmjs.com/package/react-call-return\">react-call-return</a>.</p>\n<p><a href=\"https://www.youtube.com/watch?v=60MfXWyQhRE\">Ryan Florence’s Video</a> explains this problem in detail, and how <code>react-call-return</code> fixed it. Since the package was never published in any version of React, <a href=\"https://github.com/reactjs/rfcs/pull/61#issuecomment-584402735\">there are plans to take inspiration from it and make something production-ready.</a></p>\nConclusion\n<p>To conclude, we learned about:</p>\n<ol>\n<li>The <code>React.Children</code> utility methods. We saw two of them: <code>React.Children.map</code> to see how to use it to make compound components, and <code>React.Children.toArray</code> in depth.</li>\n<li>We saw how <code>React.Children.toArray</code> converts opaque <code>children</code> prop — which could be either object, array or function — into a flat array, so that one could operate over it in required manner — sort, filter, splice, etc…</li>\n<li>We learned that <code>React.Children.toArray</code> doesn’t traverse through React Fragments.</li>\n<li>We learned about an open-source package called <code>react-keyed-flatten-children</code> and understood how it solves the problem.</li>\n<li>We saw that <code>Children</code> utilities are in maintenance mode <a href=\"https://twitter.com/0xca0a/status/1371016849664704513\">because they do not compose well</a>.</li>\n</ol>\n<p>You might also be interested in reading how to use other <code>Children</code> methods to do everything you can do with <code>children</code> in Max Stoiber’s blog post <a href=\"https://mxstbr.blog/2017/02/react-children-deepdive/\">React Children Deep Dive</a>.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://kentcdodds.com/blog/compound-components-with-react-hooks/\">Compound components with react hooks</a></li>\n<li><a href=\"https://github.com/facebook/react/issues/6889#issuecomment-221858162\">React.Children.toArray array flattening github issue explanation</a></li>\n<li><a href=\"https://reactjs.org/docs/reconciliation.html#recursing-on-children\">React reconciliation: Recursing on children</a></li>\n<li><a href=\"https://github.com/facebook/react/issues/6889\"><code>React.Children.toArray</code> doesn’t traverse into fragments</a></li>\n<li><a href=\"https://github.com/grrowl/react-keyed-flatten-children\"><code>react-keyed-flatten-children</code></a></li>\n<li><a href=\"https://github.com/grrowl/react-keyed-flatten-children/blob/master/index.spec.tsx\"><code>react-keyed-flatten-children</code></a> <a href=\"https://github.com/grrowl/react-keyed-flatten-children/blob/master/index.spec.tsx\">tests</a></li>\n<li><a href=\"https://www.npmjs.com/package/react-call-return\">react-call-return</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=60MfXWyQhRE\">Ryan Florence’s Video explaining react-call-return</a></li>\n<li><a href=\"https://github.com/reactjs/rfcs/pull/61#issuecomment-584402735\">React team’s plan to replace <code>Children</code> utilities with something more composable</a></li>\n<li><a href=\"https://mxstbr.blog/2017/02/react-children-deepdive/\">Max Stoiber’s <code>React Children</code> Deep Dive</a></li>\n<li><a href=\"https://github.com/reactjs/rfcs/pull/61#issuecomment-431247764\"><code>React.Children</code> is a leaky abstraction, and is in maintenance mode</a></li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"8837393b7f0394a1ba84009561f1be6f1f2e87e82da52933962aeeb02df00928","category":"Tech"}