{"title":"Code signing with HashiCorp Vault and GitHub Actions","link":"https://www.hashicorp.com/blog/code-signing-with-hashicorp-vault-and-github-actions","date":1715616000000,"content":"<p>Code signing is an essential element of software supply chain security, enabling users of your code to verify that the code they are running is actually the code you released. This helps defend against supply chain attacks such as <a href=\"https://pbom.dev/techniques/?t_id=T0120\">dependency confusion attacks</a> by supporting end-users’ ability to verify code authorship and enforce code-integrity controls.</p>\n\n<p>At a high level, code signing workflows depend on four components:</p>\n\n<ul>\n<li>An <strong>artifact</strong> that must be signed before being distributed. Artifacts include things like container images, Windows executables and libraries, and Java .jar files.</li>\n<li>A <strong>code signing scheme</strong> that establishes how the artifact is signed and how signatures are verified. Examples of code signing schemes include:\n\n<ul>\n<li><a href=\"https://learn.microsoft.com/en-us/windows-hardware/drivers/install/authenticode\">Microsoft Authenticode</a> for Windows executables and libraries</li>\n<li><a href=\"https://docs.docker.com/engine/security/trust/\">Docker Content Trust</a> for container images</li>\n<li><a href=\"https://docs.sigstore.dev/signing/signing_with_blobs/\">Cosign</a> for generic <a href=\"https://opencontainers.org/\">OCI</a> artifacts (including container images and more).</li>\n</ul></li>\n<li>A <strong>code signing key and certificate</strong> that establish the identity of the person or system signing the artifact.</li>\n<li>A <strong>trusted certificate authority (CA)</strong> that verifies the identity of a person or system and issues a corresponding code-signing certificate attesting that identity. The end user is ultimately responsible for deciding which CAs should be trusted. Software vendors (<a href=\"https://learn.microsoft.com/en-us/security/trusted-root/program-requirements\">Microsoft</a>, <a href=\"https://www.apple.com/certificateauthority/ca_program.html\">Apple</a>, <a href=\"https://www.chromium.org/Home/chromium-security/root-ca-policy/\">Google</a>, <a href=\"https://www.mozilla.org/en-US/about/governance/policies/security-group/certs/policy/\">Mozilla</a>) provide default lists of trusted CAs, but enterprises typically tweak those lists to add and remove CAs as needed.</li>\n</ul>\n\n<p>This blog post focuses on leveraging <a href=\"https://www.vaultproject.io/use-cases/automated-pki-infrastructure\">HashiCorp Vault as a trusted CA</a> to issue short-lived code signing certificates to a GitHub Actions workflow that signs a PowerShell script using Microsoft Authenticode.</p>\n\n<h2>Workflow and PKI architecture</h2>\n\n<p>The diagram below illustrates the workflow of this solution:</p>\n<img src=\"https://www.datocms-assets.com/2885/1715812127-code-signing-workflow-edited.png\" alt=\"Code\" /><p>This workflow uses a <a href=\"https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/dn786436%28v=ws.11%29\">two-tier public key infrastructure (PKI)</a>. We’ll use OpenSSL to operate the root CA and Vault to operate the code signing issuing CA.</p>\n<img src=\"https://www.datocms-assets.com/2885/1715354319-pki-code-signing.png\" alt=\"Two-tier\" /><p>You can see an entire sample code repository of this post’s solution in the <a href=\"https://github.com/gsantos-hc/code-signing-with-vault\">code signing with Vault GitHub repository</a>.</p>\n\n<h2>Generating the root CA</h2>\n\n<p>Once you have a copy of the sample code repository linked above, navigate to the <code>root-ca</code> directory, then review and execute the <code>generate</code> script (<code>./generate</code>).</p>\n\n<p>This script will generate an Elliptic Curve P-521 key pair and issue a self-signed root certificate. You’ll find the corresponding certificate in <code>root.crt</code>, and the EC parameters and private key will be in <code>root.key</code>.</p>\n\n<h2>Configuring Vault</h2>\n\n<p>The sample code in the repository also includes a <a href=\"https://www.terraform.io/\">HashiCorp Terraform</a> module that provisions the required resources in Vault. Once you have a <a href=\"https://developer.hashicorp.com/vault/tutorials/getting-started/getting-started-deploy\">Vault cluster up and running</a>, take the following three steps (<strong>Note:</strong> the HashiCorp Cloud Platform, also called HCP, makes this step <a href=\"https://developer.hashicorp.com/vault/tutorials/cloud/get-started-vault\">much easier</a>):</p>\n\n<ol>\n<li>Review the Terraform code in the <code>terraform</code> directory.</li>\n<li>Create a Terraform variables file and populate it with values appropriate to your environment. <strong>Important:</strong> Set <code>pki_codesign_cert</code> to <code>null</code> for the time being (more on that later).</li>\n<li>Run <code>terraform apply</code>, review the plan, and deploy the changes to your Vault cluster.</li>\n</ol>\n\n<p>At this point, you’ll have these items in your Vault cluster:</p>\n\n<ul>\n<li><a href=\"https://developer.hashicorp.com/vault/docs/secrets/pki\">PKI secrets engine</a> with\n\n<ul>\n<li>The code signing CA’s EC key pair and corresponding certificate signing request (CSR)</li>\n<li>The <a href=\"https://developer.hashicorp.com/vault/api-docs/secret/pki#create-update-role\">PKI role</a> for controlling the issuance of code signing certificates</li>\n</ul></li>\n<li><a href=\"https://developer.hashicorp.com/vault/docs/auth/jwt\">JWT authentication backend</a> for authenticating GitHub Actions pipelines into Vault</li>\n<li>Sample <a href=\"https://developer.hashicorp.com/vault/tutorials/policies/policies\">ACL policy</a> to authorize access to the code signing certificate PKI role</li>\n</ul>\n\n<h2>Issuing Vault’s CA certificate</h2>\n\n<p>Since the root CA is offline under OpenSSL, the next step is to have the root CA issue a certificate for Vault’s code signing CA.</p>\n\n<p>Retrieve the Vault CA’s certificate signing request from the Terraform outputs and paste it into a file under the <code>root-ca</code> directory. Name that file <code>codesigning-ca.csr</code>. You can inspect the contents of the CSR with OpenSSL:</p>\n\n<pre><code>openssl req -in codesign-ca.csr -noout -text\n</code></pre>\n\n<p>If you’re satisfied with the parameters of the CSR, run the <code>sign</code> script (<code>./sign</code>) to have the root CA issue the certificate for Vault's CA. The certificate will be stored in <code>codesign-ca.crt</code>.</p>\n\n<p>Next, import Vault’s CA certificate by modifying your Terraform variables file to include <em>both</em> the Vault CA certificate and the root CA certificate:</p>\n\n<pre><code>pki_codesign_cert = &lt;&lt;EOF\n-----BEGIN CERTIFICATE-----\nVault CA cert here\n-----END CERTIFICATE-----\n-----BEGIN CERTIFICATE-----\nRoot CA cert here\n-----END CERTIFICATE-----\nEOF\n</code></pre>\n\n<h2>Running a GitHub pipeline</h2>\n\n<p>The repository for this post includes a <a href=\"https://github.com/gsantos-hc/code-signing-with-vault/blob/main/.github/workflows/sign-script.yml\">sample GitHub workflow</a> you can use to test this code signing pipeline concept.</p>\n\n<p>Note that this is not a production-ready workflow. At the very least, you don’t want to download the Vault CLI every time without further security checks.</p>\n\n<h2>Verifying a signed script</h2>\n\n<p>Once the <code>hello-world.ps1</code> script is signed by your pipeline, you can check its Authenticode signature by running:</p>\n\n<pre><code>Get-AuthenticodeSignature -FilePath .\\hello-world.ps1 | Format-List\n</code></pre>\n\n<p>Be sure that <a href=\"https://superuser.com/questions/463081/adding-self-signed-certificate-to-trusted-root-certificate-store-using-command-l\">your computer trusts the root CA</a> used for this exercise or signature verification will fail. If you’re not using a discardable environment, remember to remove the root CA certificate from the trust store when you’re done with signature verification.</p>\n\n<h2>Why not use a publicly trusted CA?</h2>\n\n<p>Code signing traditionally relies on certificates issued by CAs, such as DigiCert and GlobalSign, that are trusted by the major software vendors. These CAs must verify the identity of the individual or organization requesting the certificate, a process that is often manual, lengthy, and expensive.</p>\n\n<p>If you are distributing software broadly, it makes sense to go through that process: you’ll be issued a certificate that is automatically trusted by all your users by virtue of the CA being part of the major vendors’ trusted CA programs.</p>\n\n<p>But what if you’re looking to secure <em>internal</em> distribution of software, e.g. ensuring that a line-of-business application was built by an approved system and not tampered with since? In that case, ask yourself the following questions:</p>\n\n<ul>\n<li>Do you buy a certificate for your organization and allow all your developers to use it? What’s your process for authenticating and authorizing individual signing requests?</li>\n<li>Do you buy individual developer certificates and incur the expense and overhead of managing the certificates’ lifecycles?</li>\n<li>If your CA requires you to keep private keys in a hardware token, how do you integrate the signature process into automated build pipelines?</li>\n</ul>\n\n<p>The solution outlined in this post gives your business important benefits when internally distributing software:</p>\n\n<ul>\n<li><strong>Minimize the risk</strong> of compromised signing keys by adopting short-lived certificates — the key is useless an hour after it’s generated.</li>\n<li><strong>Reduce toil</strong> by automating the issuance of certificates in accordance with rules established in advance by your security team.</li>\n<li><strong>Future-proof your code signing workflow</strong> by leveraging Vault’s <a href=\"https://www.vaultproject.io/use-cases/identity-based-access#:%7E:text=Leverage%20any%20trusted%20identity%20provider%2C%20such%20as%20cloud%20IAM%20platforms%2C%20Kubernetes%2C%20and%20Active%20Directory%2C%20to%20authenticate%20into%20Vault.%20Identity%20is%20scale%20independent%2C%20unlike%20IP%20addresses%2C%20which%20require%20complex%20firewall%20rules%20and%20frequent%20updates.\">many sources of identity</a>. If tomorrow you want users to be able to manually sign code, they can authenticate to Vault with OIDC, SAML, or Kerberos and obtain certificates in the same way.</li>\n</ul>\n\n<h2>Next steps</h2>\n\n<p>Learn more about how Vault helps organizations run secure and efficient PKI from this <a href=\"https://www.hashicorp.com/resources/beyond-secrets-automating-pki-with-vault\">HashiConf talk on automating PKI with Vault</a>, and find out how to <a href=\"https://developer.hashicorp.com/vault/tutorials/secrets-management/pki-engine\">build your own certificate authority with Vault on HashiCorp Developer</a>.</p>\n","author":"Guilherme Pamplona Santos","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"38cf4b51395b922933f66791100b143dc795f0df56e02d47e0eab1aca703ae42","category":"Tech"}