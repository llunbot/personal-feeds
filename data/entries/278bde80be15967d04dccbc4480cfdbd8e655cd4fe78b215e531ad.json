{"title":"Level Up Your CSS Skills With The :has() Selector","link":"https://smashingmagazine.com/2023/01/level-up-css-skills-has-selector/","date":1674475200000,"content":"<p>Using <code>:has()</code> gives us the ability to “look ahead” with CSS and style a parent or ancestor element. Then, we can broaden the selector to target one or more siblings or children. By considering element states or positions, we can style nearly any combination of elements as unique singles or ranges.</p>\n<p><strong>Note</strong>: <em>At present, support for <code>:has()</code> is rising, with it being available as of Safari 15.4 and Chrome/Edge 105. It is also behind a flag in Firefox <a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=1771896\">as of version 103</a>. Until full support is available, check out this <a href=\"https://www.bram.us/2023/01/04/css-has-feature-detection-with-supportsselector-you-want-has-not-has/\">tip for supporting <code>:has</code> today</a> from Bramus Van Damme.</em></p>\nHow <code>:has()</code> Works With Combinators And Pseudo-Classes\n<p>To best understand how the advanced selectors we’ll be creating work, we’ll quickly review the most relevant combinators and pseudo-classes.</p>\n<p>A “combinator” is a special character that denotes the type of relationship between selector parts. Here are the core combinators to know:</p>\n<ul>\n<li>space character: the <strong>descendent combinator</strong> matches a direct or nested child;</li>\n<li><code>&gt;</code>: the <strong>direct child combinator</strong> matches only top-level, un-nested children;</li>\n<li><code>+</code>: the <strong>adjacent sibling combinator</strong> matches only the very next sibling;</li>\n<li><code>~</code>: the <strong>general sibling combinator</strong> matches one or more siblings following the base selector.</li>\n</ul>\n<p>The first stage of creating complex selectors is to append a pseudo-class to one or more parts. A “pseudo-class” defines a special state of an element, like <code>:hover</code>, and has the format of a single colon followed by the name. The <code>:has()</code> pseudo-class is considered functional since it accepts a parameter. Specifically, it accepts a list of selectors, whether they be simple like <code>img</code> or complex with combinators like <code>img + p</code>.</p>\n<p>However, <code>:has()</code> is one of four functional pseudo-classes, with the others being <code>:is()</code>, <code>:where()</code>, and <code>:not()</code>. Each of them accepts a selector list with a few other unique features.</p>\n<p>If you’ve already used <code>:is()</code> and <code>:where()</code>, it’s likely been to manage specificity. Using <code>:is()</code> means the selector in the list with the highest specificity gives the entire selector its weight. While using <code>:where()</code> lends the entire selector list zero-specificity, making it easily overruled by later rules in the cascade.</p>\n<p>Additionally, <code>:is()</code> and <code>:where()</code> have the extra special ability to be forgiving selectors. This means you may include (purposely or not) selectors the browser doesn’t understand, and it will still process the parts it does understand. Without this forgiving behavior, the browser would discard the entire rule.</p>\n<p>The other benefit of both <code>:is()</code> and <code>:where()</code> is to create succinct, complex selectors. This is especially handy when using combinators and affecting multiple siblings or descendants, for example, <code>article :is(h1, h2, h3)</code>.</p>\n<p>Our last pseudo-class, <code>:not()</code>, has been available in CSS for the longest. However, alongside Selectors Level 4 when <code>:is()</code> and <code>:where()</code> were released, <code>:not()</code> <a href=\"https://www.w3.org/TR/selectors-4/#negation\">was enhanced</a>. This happened when it was allowed to accept a list of selectors instead of a single selector. It also has the same specificity behavior noted for <code>:is()</code>.</p>\n<p>Finally, we need to know about an underused, incredibly powerful feature of <code>:is()</code>, <code>:where()</code>, and <code>:not()</code> that we’ll be using to make our advanced <code>:has()</code> selectors. Using the <code>*</code> character within these selectors — which <em>normally</em> in CSS is the “universal selector” — actually refers to the selector target. This allows checking the preceding siblings or ancestors of the selector target. So, in <code>img:not(h1 + *)</code>, we’re selecting images that <em>do not</em> directly follow an <code>h1</code>. And in <code>p:is(h2 + *)</code>, we’re selecting paragraphs <em>only if</em> they directly follow <code>h2</code>. We’ll be using this behavior for our first demo next.</p>\nPolyfill For <code>:only-of-selector</code>\n<p>While <code>:only-of-type</code> is <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/:only-of-type\">a valid pseudo-class</a>, it only works to select within elements of the same element type. Given <code>.highlight:only-of-type</code>, no matches would be made in the following HTML because the class has no effect on reducing the scope.</p>\n<pre><code>&lt;p&gt;Not highlighted&lt;/p&gt;\n&lt;p class=\"highlight\"&gt;.highlight&lt;/p&gt;\n&lt;p&gt;Not highlighted&lt;/p&gt;\n</code></pre>\n\n<p>If there was only one paragraph with the <code>highlight</code> class within a parent, it might falsely appear to be working. But in that case, it’s because the root element type the class is attached to is a paragraph, so it matches as true since there are no sibling paragraphs.</p>\n<p>By combining <code>:has()</code> and <code>:not()</code>, we can effectively create an <code>:only-of-selector</code> that will match a singleton within a range of siblings based on a class or other valid selector.</p>\n<p>We ultimately want our selector to match when there are no matching siblings that exist <em>before</em> or <em>after</em> the target.</p>\n<p>A strength of <code>:has()</code> is testing for what follows an element. Since we want to test any number of siblings that follow, we’ll use the general sibling combinator <code>~</code> to create the first condition.</p>\n<pre><code>.highlight:not(:has(~ .highlight)\n</code></pre>\n\n<p>So far, this gives us the match of “highlights that <em>do not have</em> sibling highlights following it.”</p>\n<p>Now we need to check prior siblings, and we’ll use the ability of <code>:not()</code> on its own to add that condition.</p>\n<pre><code>.highlight:not(:has(~ .highlight)):not(.highlight ~  *)\n</code></pre>\n\n<p>The second <code>:not()</code> condition is an <code>AND</code> clause to our selector that says “AND not itself a sibling of a previous highlight.”</p>\n<p>With that, we have polyfilled the non-existent <code>:only-of-selector</code> pseudo-class!</p>\n<p><img src=\"https://files.smashing.media/articles/has-selector-level-up-css-skills/out-of-range-styles.png\" /></p>\n<p>To resolve this, we need to add a complex <code>AND</code> condition using <code>:not()</code> to exclude items that are <em>not</em> between <code>[data-range=\"end\"]</code> and <code>[data-range=\"start\"]</code>, in that order.</p>\n<p>On its own, this part of the selector reads as: “<em>do not select</em> items that follow <code>[data-range=\"end\"]</code> which also have a later sibling of <code>[data-range=\"start\"]</code>.”</p>\n<div>\n<pre><code>/* Note: this needs appended on the previous selector, not used alone */\n:not([data-range=\"end\"] ~ :has(~ [data-range=\"start\"]))\n</code></pre>\n</div>\n\n<p>In total, this makes for an admittedly long but very powerful selector that wasn’t possible before <code>:has()</code> without also using JavaScript due to the previous lack of the “look ahead” and “look behind” abilities in CSS.</p>\n<div>\n<pre><code>/* Select all between a range */\n[data-range=\"start\"] ~ :has(~ [data-range=\"end\"]):not([data-range]):not([data-range=\"end\"] ~ :has(~ [data-range=\"start\"]))\n</code></pre>\n</div>\n\n<blockquote>Keep in mind that just like other selectors, you can use <code>:has()</code> when you construct a selector within JavaScript. The ability to select previous siblings, ancestors and the other features we’ve learned will also make your JS selectors more efficiently powerful!</blockquote>\n\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/VwBypzB\">Multi-range element selectors with :has() [forked]</a> by <a href=\"https://codepen.io/5t3ph\">Stephanie Eckles</a>.</p>\nLinear Range Selection Based On State\n<p>Let’s pull together some of the qualities of <code>:has()</code> selectors and combinators we’ve learned to make a star rating component.</p>\n<p>The underlying “star” will be a radio input, which will give us access to a <code>:checked</code> state to assist in developing the selectors.</p>\n<pre><code>&lt;div class=\"star-rating\"&gt;\n  &lt;fieldset&gt;\n    &lt;legend&gt;Rate this demo&lt;/legend&gt;\n    &lt;div class=\"stars\"&gt;\n      &lt;label class=\"star\"&gt;\n        &lt;input type=\"radio\" name=\"rating\" value=\"1\"&gt;\n        &lt;span&gt;1&lt;/span&gt;\n      &lt;/label&gt;\n      &lt;!-- ...4 more stars --&gt;\n    &lt;/div&gt;\n  &lt;/fieldset&gt;\n&lt;/div&gt;\n</code></pre>\n\n<p>As shown in the following video preview, when a user hovers over the outlined stars, then the range from the start (left-most) to the hovered star should fill in with color. On selection, when the star radio is checked, the star and labeling number scale up in size and keep the fill color. If the user hovers over stars after the checked star, the range should fill in the stars up to the hover. If the user hovers stars before the checked star, the range should fill in only up to the hovered star, and stars between the hover and previously checked star should have the fill color lightened.</p>\n<p>That’s a lot of ranges to keep track of, but with <code>:has()</code>, we can break them into segmented selectors real quick!</p>\n<p>The following selector series applies to all states where we want a star or range of stars to fill in for or up to the <code>:checked</code> star. The rule updates a set of custom properties that will affect the star shape, created through a combo of the <code>::before</code> and <code>::after</code> pseudo-elements on the <code>label.star</code>.</p>\n<p>Altogether, this rule selects the range of stars between the first star and the star being hovered, <em>or</em> the first star and the star with a checked radio.</p>\n<pre><code>.star:hover,\n/* Previous siblings of hovered star */\n.star:has(~ .star:hover),\n/* Star has a checked radio */\n.star:has(:checked),\n/* Previous siblings of a checked star */\n.star:has(~ .star :checked) {\n  --star-rating-bg: dodgerblue;\n}\n</code></pre>\n\n<p>Next, we want to lighten the fill color of stars in the range between the star being hovered and a later checked star, <em>and</em> checked stars that follow the hovered star.</p>\n<pre><code>/* Siblings between a hovered star and a checked star */\n.star:hover ~ .star:has(~ .star :checked),\n/* Checked star following a hovered star */\n.star:hover ~ .star:has(:checked) {\n  --star-rating-bg: lightblue;\n}\n</code></pre>\n\n<p>As far as state selectors go for our star rating component, that’s all there is to it!</p>\n<p>The CodePen demo has a few extra tricks on how the component is created using CSS grid, custom properties, and <code>clip-path</code>. For accessibility, it also ensures color isn’t the only indicator by scaling up the checked star. And it handles for <a href=\"https://blogs.windows.com/msedgedev/2020/09/17/styling-for-windows-high-contrast-with-new-standards-for-forced-colors/\">high contrast themes</a> (aka “forced colors”) by supplying values from the system colors palette to ensure the <code>:checked</code> star fill is visible. Additionally, the transitions are shortened when a user prefers reduced motion.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/ExpoWwv\">Star Rating Component with :has() [forked]</a> by <a href=\"https://codepen.io/5t3ph\">Stephanie Eckles</a>.</p>\nStateful Multi-Range Selection Groups\n<p>Whereas the star rating component showed a dynamic style change based on state, the availability of stateful elements also makes it easier to use <code>:has()</code> for creating visual boundaries.</p>\n<p>Our earlier multi-range selectors relied on manually adding “hooks” into the markup to correctly style ranges without leaking into the in-between areas. But if we have a field set containing checkboxes, we can once again use the <code>:checked</code> state to clearly identify boundaries around checked and unchecked items.</p>\n<p>In this preview video, as checkboxes are selected, they receive a border and green background to create the visual boundary. Thanks to <code>:has()</code>, that boundary grows to appear to wrap groups of checked items so that the visual box seems as though it's around the whole group. The first item (or a singleton) gets round top corners, and the last item (or a singleton) gets round bottom corners as well as a slight shadow.</p>\n<p>We need to create rules to handle the top, middle, and bottom appearance based on where the item falls within the set. Single items should receive all three styles.</p>\n<p>Our HTML is set up to wrap each checkbox input with its label, so all of our selectors will begin by matching against <code>label:has(:checked)</code> to see if the label <em>contains</em> a checked input.</p>\n<p>To determine either the first or single item in the set, we need to add the condition that it is <em>not</em> following a previous item with a checked input. This rule will style the top appearance.</p>\n<pre><code>/* First checked item in a range\n OR top of a single checked item */\nlabel:has(:checked):not(label:has(:checked) + label)\n</code></pre>\n\n<p>To determine either the last or single item in the set, we flip the previous condition to check that it is <em>not</em> followed by a checked input. This rule will style the bottom appearance.</p>\n<pre><code>/* Last checked item in a range\n OR bottom of a single checked item */\nlabel:has(:checked):not(label:has(+ label :checked))\n</code></pre>\n\n<p>For the middle appearance, we’ll create a rule that actually captures the group from start to finish since all of the items in the rule should receive a background color and side borders.</p>\n<p>We <em>could</em> simply use <code>label:has(:checked)</code> for this selector given the context. However, we’re learning how to select and style ranges, so to complete our exercise, we’ll write the expanded selectors.</p>\n<p>The logic represented in the first selector is “select labels with checked inputs that are followed by sibling labels containing checked inputs,” which captures all but the last item in the range. For that, we repeat the selector we just created for styling the last checked item in the range.</p>\n<pre><code>/* Range of checked items */\nlabel:has(:checked):has(~ label :checked),\nlabel:has(:checked):not(label:has(+ label :checked))\n</code></pre>\n\n<p>This CodePen demo also shows off <code>accent-color</code> for changing the checked input color and uses custom properties for managing the border radius. It also uses logical properties.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/RwBxpjE\">Stateful multi-range selection groups with :has() [forked]</a> by <a href=\"https://codepen.io/5t3ph\">Stephanie Eckles</a>.</p>\n<h3>More Resources On Writing <code>:has()</code> Selectors</h3>\n<p>You can <a href=\"https://codepen.io/collection/wapNEJ/327b65e9704d65901e397025ea2d51ba\">explore all of the demonstrations</a> we reviewed in my CodePen collection.</p>\n<p>Other folks have started experimenting with what’s possible using <code>:has()</code>, and I encourage you to check out these resources for even more ideas. As with all recently released features, the field of opportunity is wide-open, and we all benefit when we share our learnings!</p>\n<ul>\n<li>Bramus Van Damme has a few explorations of complex selectors using <code>:has()</code>:<ul>\n<li><a href=\"https://www.bram.us/2022/12/13/quantity-queries-for-islands-of-elements-with-the-same-class-thanks-to-css-has/\">Quantity Queries for “islands of elements” with the same class, thanks to CSS <code>:has()</code></a></li>\n<li><a href=\"https://www.bram.us/2022/12/14/a-nth-childanb-of-s-polyfill-thanks-to-css-has/\">A <code>:nth-child(An+B [of S]?)</code> polyfill thanks to CSS <code>:has()</code> and <code>:not()</code></a></li>\n<li><a href=\"https://www.bram.us/2022/11/17/style-a-parent-element-based-on-its-number-of-children-using-css-has/\">Style a parent element based on its number of children using CSS <code>:has()</code></a></li>\n</ul>\n</li>\n<li>Jhey Tompkins reviews both practical and fun use cases in “<a href=\"https://developer.chrome.com/blog/has-m105/\"><code>:has()</code>: The Family Selector</a>”</li>\n<li>Jen Simmons looks at the relationship of <code>:has()</code> to combinators and showcases more demos in “<a href=\"https://webkit.org/blog/13096/css-has-pseudo-class/\">Using <code>:has()</code> As A CSS Parent Selector And Much More</a>”</li>\n<li>Adrian Bece considers even more possibilities in “<a href=\"https://www.smashingmagazine.com/2021/06/has-native-css-parent-selector/\">Meet <code>:has</code>, A Native CSS Parent Selector (And More)</a>”</li>\n<li>Estelle Weyl demystifies more about this selector’s behavior in “<a href=\"https://12daysofweb.dev/2022/css-has-selector/\">CSS <code>:has()</code></a>”</li>\n<li>Manuel Matuzović clarifies the important difference between “<a href=\"https://www.matuzo.at/blog/2022/100daysof-day50/\"><code>:has(:not())</code> vs. <code>:not(:has())</code></a>”</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"f300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"278bde80be15967d04dccbc4480cfdbd8e655cd4fe78b215e531ad","category":"Tech"}