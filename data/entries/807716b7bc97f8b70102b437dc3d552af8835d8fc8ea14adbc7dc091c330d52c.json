{"title":"ปัญหาดิสก์ปิดครอบเล็กที่สุด","link":"https://neizod.dev/2023/07/19/smallest-enclosing-disk.html","date":1689745068000,"content":"<p>ปัญหาดิสก์ปิดครอบที่เล็กที่สุด (หรือที่รู้จักในอีกชื่อหนึ่งว่า ปัญหาวงกลมเล็กที่สุด<sup><a href=\"#fn:1\">1</a></sup>) เป็นโจทย์ปัญหาทาง<a href=\"//en.wikipedia.org/wiki/Computational_geometry\">เรขาคณิตเชิงคำนวณ</a>ที่ถามหาดิสก์ขนาดเล็กที่สุดที่สามารถครอบคลุมเซตของจุด $n$ จุดที่สนใจในระนาบสองมิติได้ทั้งหมด ซึ่งมันเป็นปัญหาที่มีงานประยุกต์ในชีวิตประจำวันอย่างมากมาย เช่น คำนวณหาตำแหน่งที่เหมาะสมสำหรับตั้งเสาสัญญาณเพื่อให้ประหยัดพลังงานที่สุด เป็นต้น</p>\n\n<blockquote>\n  <p><img src=\"/images/algorithm/minidisk/protego-disk.png\" alt /></p>\n</blockquote>\n\n<p>ดูเผินๆ แล้วปัญหานี้ก็ไม่น่ายากอะไร เราอาจลองคิดเล่นๆ ว่างั้นเราก็เลือกพิกัดที่อยู่ “กึ่งกลาง” ของข้อมูลจุดทั้งหมดมาเป็นจุดศูนย์กลางของดิสก์ แล้วประมาณค่ารัศมีมาซักค่าหนึ่งให้ดิสก์มันคลุมทุกจุดเหล่านั้นเลย ถ้าดิสก์ยังดูใหญ่ไปก็บีบขนาดรัศมีลงมา และ/หรือ ขยับตำแหน่งจุดศูนย์กลางอีกนิดหน่อย แค่นี้เราก็จะได้คำตอบแบบประมาณของปัญหาดังกล่าวแล้ว</p>\n\n<p>การแก้ปัญหาด้วยสามัญสำนึก/สัญชาตญาณที่พึ่งพาการประมาณค่าเช่นนี้ไม่ใช่เรื่องผิดอะไร เพียงแต่ว่าสำหรับปัญหานี้แล้ววิธีการดังกล่าวยังถือว่ามีประสิทธิภาพที่ไม่ดีเท่าไหร่นัก เพราะเราสามารถหาคำตอบที่ดีที่สุดได้อย่างแม่นยำโดยไม่ต้องพึ่งพาการประมาณค่าเลย</p>\n\n<p>แล้วเราจะหาคำตอบที่แม่นยำได้อย่างไร? ปรกติแล้วเมื่อเจอปัญหาที่มีข้อมูลจำนวน $n$ ชิ้นมาเกี่ยวข้อง เทคนิคหนึ่งที่เราใช้ได้บ่อยๆ ก็คือการพิจารณาปัญหาย่อยที่มีข้อมูลจำนวนน้อยก่อน หลังจากนั้นเมื่อแก้ปัญหาย่อยได้ก็ค่อยๆ ขยายขนาดของปัญหากลับมา พร้อมทั้งสังเกตหาวิธีการที่จะแปลงผลลัพธ์ให้กลับไปอยู่ในรูปทั่วไปสำหรับข้อมูลขนาด $n$ ชิ้นให้เจอ</p>\n\n<p>เช่นเมื่อเราพิจารณากรณีที่ต้องการคลุมแค่หนึ่งจุด $P=\\lbrace p_1\\rbrace$ เราก็สร้างดิสก์รัศมีเป็นศูนย์ไว้ที่ตำแหน่ง $p_1$ เท่านั้นพอ เราเรียกกรณีนี้ว่าเป็นกรณีลดรูป (degenerate case) ที่ไม่มีอะไรน่าสนใจเป็นพิเศษจึงสามารถข้ามมันไปได้เลย</p>\n\n<h2>คลุมแค่สองจุด</h2>\n\n<p>เมื่อเรามีจุดสนใจสองจุด $P=\\lbrace p_1,p_2\\rbrace$ ดิสก์ที่เล็กที่สุดคือดิสก์ที่มีจุดศูนย์กลางอยู่ระหว่าง $p_1$ กับ $p_2$ พอดี โดยมีเส้นผ่านศูนย์กลางขนาดเท่ากับ $\\abs{\\overline{p_1p_2}}/2$ ซึ่งนี่เป็นดิสก์ที่มีขนาดเล็กที่สุดแล้ว เพราะเส้นผ่านศูนย์กลางก็คือส่วนที่กว้างที่สุดของดิสก์ หากเส้นผ่านศูนย์กลางสั้นกว่านี้ก็แปลว่าดิสก์จะไม่มีทางคลุมทั้ง $p_1$ และ $p_2$ พร้อมกันได้เลย</p>\n\n<p>ข้อสังเกตสำคัญของการสร้างดิสก์ในปัญหานี้ ก็คือเราต้องการให้ทั้ง $p_1$ และ $p_2$ อยู่บนขอบดิสก์พอดีนั่นเอง เพื่อความสะดวกเราจะเรียกดิสก์ที่มีจุดสองจุดเป็นเส้นผ่านศูนย์กลางเช่นนี้ว่า $D(p_1,p_2)$</p>\n\n<h2>คลุมสามจุด</h2>\n\n<p>หลังจากได้กรณีสองจุดแล้ว กรณีสามจุดก็เปรียบได้ดังภาคต่อง่ายๆ ที่เราอาจนำเอาข้อสังเกตเดิมมาประยุกต์ใช้ได้ว่า ทั้งสามจุดใน $P=\\lbrace p_1,p_2,p_3\\rbrace$ นั้น<em>ควร</em>อยู่บนขอบของดิสก์พอดี (เราจะเรียกดิสก์ที่มีสามจุดบนขอบเช่นนี้ว่า $D(p_1,p_2,p_3)$) อย่างไรก็ตามข้อสังเกตดังกล่าวก็อาจนับได้ว่าเป็นกับดักชั้นดี เพราะการจัดเรียงจุดบางรูปแบบนั้นเราสามารถใช้ดิสก์ที่มีสองจุดบนขอบก็พอ อีกจุดที่เหลือนั้นไม่จำเป็นต้องอยู่ขอบ แต่จะอยู่ภายในดิสก์ไปเลย (เห็นได้ชัดเมื่อทั้งสามจุดนั้นอยู่ในแนวเส้นตรงเดียวกัน – หรือสรุปเป็นกรณีทั่วไปได้ว่าเมื่อลากเส้นเชื่อมจุดทั้งสามแล้ว หากได้สามเหลี่ยมมุมป้าน จุดที่อยู่บนมุมป้านจะต้องอยู่ในดิสก์) ดังนั้นสำหรับกรณีนี้เราต้องพิจารณาแยกเป็นกรณีย่อยๆ โดยไปยืมการสร้างดิสก์จากกรณีคลุมแค่สองจุดมาช่วย</p>\n\n<blockquote>\n  <p><img src=\"/images/algorithm/minidisk/three-points.svg\" alt /></p>\n\n  <p>ตัวอย่างการคลุมสามจุด ที่การสร้างดิสก์ด้วยจุดทั้งสาม (สีแดง) เปลืองกว่าการใช้แค่สองจุด (สีน้ำเงิน)</p>\n\n</blockquote>\n\n<p>ถึงแม้เราจะเจอหลุมพรางและความยุ่งยากดังกล่าว แต่เราจะได้ข้อสังเกตใหม่ที่สำคัญยิ่งยวดกลับมาแทน นั่นก็คือการจะบอกได้ว่าเมื่อจุด $p$ ไม่อยู่ภายในดิสก์ที่สนใจแล้ว แปลว่าอย่างน้อยๆ ดิสก์ที่จะครอบคลุม $p$ ต้องโดนสร้างโดยมี $p$ อยู่บนขอบแน่ๆ</p>\n\n<h2>คลุมสี่จุดขึ้นไป</h2>\n\n<p>ความดีงามของกรณีที่ผ่านมาก็คือว่าเราใช้จุดอย่างมากสุดแค่สามจุดบนขอบดิสก์ก็เพียงพอ นั่นคือ แม้ว่าเราจะมีจุดมากกว่าสามจุดบนขอบของดิสก์ เราก็สามารถเลือกหยิบแค่สามจุดใดๆ มาย้อนสร้างดิสก์นั้นได้เสมอ นี่ทำให้เราขยายการพิจารณาไปยังกรณีทั่วไปได้ ซึ่งก็คือเมื่อเราต้องการสร้างดิสก์ที่ครอบคลุมเซต $P=\\lbrace p_1,\\dots,p_n\\rbrace$ เราสามารถยืมคำตอบของปัญหาย่อยที่คลุมแค่เซต $P’=\\lbrace p_1,\\dots,p_{n-1}\\rbrace$ มาช่วยได้</p>\n\n<p>ให้ $D_{n-1}$ แทนดิสก์ที่เป็นคำตอบของการคลุมเซต $P’$ เราจะถามว่าแล้ว $p_n$ นั้นอยู่ใน $D_{n-1}$ หรือไม่ หากคำตอบคือใช่เราก็ไม่ต้องทำอะไรต่อ เพราะว่าเราจะได้ดิสก์คำตอบที่คลุม $P$ ว่าก็คือ $D_n \\gets D_{n-1}$ เลย แต่หากคำตอบคือไม่ เราจะวนลงไปทำปัญหาย่อยบน $P’$ อีกครั้ง เพียงแต่คราวนี้เราจะ<em>บังคับ</em>ให้ดิสก์คำตอบนั้นมี $p_n$ อยู่บนขอบด้วยนั่นเอง</p>\n\n<p>แนวคิดทั้งหมดสามารถแปลงเป็นโค้ดได้คร่าวๆ ดังนี้</p>\n\n<div><div><pre><code><span>def</span> <span>mini_disk</span><span>(</span><span>points</span><span>,</span> <span>borders</span><span>=</span><span>()):</span>\n    <span>if</span> <span>not</span> <span>points</span> <span>or</span> <span>len</span><span>(</span><span>borders</span><span>)</span> <span>==</span> <span>3</span><span>:</span>\n        <span>return</span> <span>disk</span><span>(</span><span>borders</span><span>)</span>\n    <span>p</span><span>,</span> <span>*</span><span>remains</span> <span>=</span> <span>points</span>\n    <span>d</span> <span>=</span> <span>mini_disk</span><span>(</span><span>remains</span><span>,</span> <span>borders</span><span>)</span>\n    <span>if</span> <span>p</span> <span>in</span> <span>d</span><span>:</span>\n        <span>return</span> <span>d</span>\n    <span>return</span> <span>mini_disk</span><span>(</span><span>remains</span><span>,</span> <span>borders</span><span>+</span><span>(</span><span>p</span><span>,))</span>\n</code></pre></div></div>\n\n<blockquote>\n  <p><img src=\"/images/algorithm/minidisk/welzl.svg\" alt /></p>\n\n  <p>ตัวอย่างการทำงานของอัลกอริทึมบนข้อมูลนำเข้า $n=7$ จุด</p>\n</blockquote>\n\n<h2>ความซับซ้อนของอัลกอริทึม</h2>\n\n<p>แล้วอัลกอริทึมข้างต้นมีความเร็วเป็นเท่าไหร่กันหละ? แม้ว่าฟังก์ชันเวียนเกิดนี้จะมีการ “แตกแขนง” ตอนเรียกตัวเองแยกเป็นสองกิ่ง (ครั้งแรกเพื่อสร้างดิสก์มาทดสอบ และครั้งที่สองเพื่อสร้างดิสก์แบบบังคับจุดหากทดสอบไม่ผ่าน) ทำให้ดูเผินๆ แล้วความซับซ้อนก็น่าจะบานปลายเป็น $O(2^n)$ แต่หากตั้งใจดูให้ดีจะเห็นฟังก์ชันนี้สามารถเกิดการแตกแขนงตามทางลึกได้เพียงแค่สามครั้งเท่านั้น ดังนั้นความเร็วของอัลกอริทึมนี้จริงๆ จึงเหลือแค่ $O(n^3)$ แทน!</p>\n\n<p>แล้วเราสามารถปรับปรุงให้มันเร็วกว่านี้ได้อีกหรือเปล่า? สังเกตว่าที่ผ่านมาเราวิเคราะห์แบบกรณีแย่สุดที่คิดให้แต่ละชั้นของการเรียกใช้ฟังก์ชัน มัน<em>ต้อง</em>แตกแขนงไปเรียกตัวเองเป็นสองกิ่งทั้งสิ้น ทั้งที่ความจริงแล้วหากเราโชคดี เราก็อาจเรียกตัวเองแค่ครั้งเดียวพอไม่ต้องแตกแขนงเลย (เช่น โชคดีเจอข้อมูลนำเข้าที่สามจุดแรกนั้นสร้างดิสก์คลุมจุดที่เหลือทั้งหมด) ดังนั้นความเร็วก็จะลดเหลือเพียงแค่ $O(n)$ ในกรณีที่ดีที่สุด</p>\n\n<p>แน่นอนว่าเราไม่มีทางโชคดีได้อย่างนี้ทุกครั้งไป (แต่ก็คงไม่มีทางโชคร้ายได้ทุกครั้ง) เช่นนั้นแล้วอัลกอริทึมดังกล่าวจะมีความเร็วโดยเฉลี่ยอยู่ที่เท่าไหร่กันหละ?</p>\n\n<p>เราจะใช้เทคนิควิเคราะห์แบบย้อนกลับ ซึ่งก็คือเริ่มจากผลลัพธ์ที่เป็นดิสก์คลุมทั้ง $n$ จุดในตอนจบฟังก์ชัน แล้วย้อนกลับไปถามว่าที่จุดเริ่มต้นของฟังก์ชันนี้ ดิสก์ดังกล่าวครอบคลุมจุด $p_n$ มาก่อนหรือไม่ ซึ่งคำตอบนั้นจะขึ้นกับจำนวนจุดบนขอบดิสก์ที่เราเลือกตรึงไว้จากฟังก์ชันเวียนเกิดในชั้นก่อนหน้า เช่น หากที่ชั้นก่อนหน้าเราตรึงจุดไว้แล้วสองจุด ก็แปลว่าในชั้นนี้จะเหลือที่ว่างที่เดียวให้ $p_n$ สามารถอยู่บนขอบดิสก์ได้ ซึ่งก็คือมีโอกาสเกิด $1/n$ กลับกันหากชั้นก่อนหน้าเรายังไม่เคยตรึงจุดใดเอาไว้ก่อนเลย จะทำให้ในชั้นนี้จุด $p_n$ มีโอกาสถึง $3/n$ ที่จะอยู่บนขอบของดิสก์ที่ต้องการนั่นเอง</p>\n\n<p>เราจะเขียนความสัมพันธ์เวียนเกิด $t_k(n)$ ที่วัดความเร็วของการเรียกฟังก์ชันด้วยข้อมูลนำเข้า $n$ จุด โดยมีจุดที่ถูกตรึงไว้บนขอบดิสก์แล้ว $3{-}k$ จุด ดังนั้นฟังก์ชันข้างต้นจึงถูกถอดความเป็นความสัมพันธ์เวียนเกิดได้ว่า</p>\n\n\\[t_k(n) \\le 1 + t_k(n-1) + \\frac{k}{n} t_{k-1}(n-1)\\]\n\n<p>แน่นอนว่า $t_0(n)\\le1$ จึงทำให้ได้ว่าเมื่อไล่แก้สมการเวียนเกิดไปเรื่อยๆ จะได้ $t_3(n)\\le10n$ หรือสรุปได้ว่า อัลกอริทึมดังกล่าวมีค่าคาดหวังว่าจะทำงานด้วยความเร็วเป็นเชิงเส้นเทียบกับขนาดของข้อมูลนำเข้านั่นเอง</p>\n\n<p>ในทางปฎิบัติ เราสามารถแก้ไขโค้ดข้างต้นเพียงเล็กน้อย ซึ่งก็คือสุ่มสลับลำดับจุดใน $P$ ทั้งหมดก่อนที่จะเรียกใช้งานฟังก์ชัน <code>mini_disk</code> เท่านี้ก็เพียงพอที่จะทำให้เราได้ความเร็วเฉลี่ยเป็น $O(n)$ แล้ว</p>\n\n<p>อัลกอริทึมข้างต้นถูกนำเสนอโดย Emo Welzl ในปี 2005 ซึ่งเขียนออกมาเป็นโค้ดได้เรียบง่ายสั้นกระชับ อย่างไรก็ตามการวิเคราะห์ความซับซ้อนอาจจะยากหน่อย เพราะมันอิงอยู่บนฟังก์ชันเวียนเกิดที่ทำงานค่อนข้างแตกต่างจากฟังก์ชันเวียนเกิดอื่นๆ ที่เคยเห็นมา ซึ่งสำหรับใครที่อ่านมาถึงจุดนี้แล้วยังไม่ค่อยเข้าใจ อาจลองไปอ่านบทที่ 4.7 จากหนังสือ Computational Geometry: Algorithms and Applications เพิ่มเติมได้ ซึ่งหัวใจของอัลกอริทึมก็ทำงานเหมือนกันเนี่ยแหละ แต่เค้าจัดรูปฟังก์ชันเวียนเกิดข้างต้นให้กลายเป็นฟังก์ชันแบบวนลูปแทน และส่งผลให้วิเคราะห์เวลาการทำงานออกมาได้เข้าใจง่ายกว่านี้(มั้ง)</p>\n\n<h2>รายละเอียดการสร้างดิสก์</h2>\n\n<p>โค้ดข้างต้นนั้นยังรันจริงไม่ได้ (แม้จะเขียนเป็น Python อย่างถูกต้องทุกอย่างก็ตาม) เพราะมันยังขาดรายละเอียดสำคัญคือการสร้างดิสก์จากจุดขอบ ซึ่งกรณีที่ยากที่สุดก็คือเมื่อมีจุดขอบอยู่บนดิสก์สามจุด $\\lbrace p_1,p_2,p_3 \\rbrace$ นั่นเอง</p>\n\n<p>มองในเชิงเรขาคณิตสังเคราะห์แล้ว นี่อาจไม่ใช่คำถามที่ยากเท่าไหร่ เพราะเราก็แค่สร้างเส้น $L_1$ ที่ตั้งฉากกับ $\\overline{p_1p_2}$ และเส้น $L_2$ ที่ตั้งฉากกับ $\\overline{p_2p_3}$ แล้วหลังจากนั้นก็แค่หาจุดตัดของ $L_1$ กับ $L_2$ ก็จะได้จุดศูนย์กลางของวงกลมแล้ว</p>\n\n<blockquote>\n  <p><img src=\"/images/algorithm/minidisk/construction.svg\" alt /></p>\n\n  <p>การสร้างดิสก์/วงกลมที่มีจุดสามจุดอยู่บนขอบ</p>\n</blockquote>\n\n<p>อย่างไรก็ตาม ในเรขาคณิตวิเคราะห์ที่มองทุกอย่างเป็นสมการผ่าน<a href=\"//en.wikipedia.org/wiki/Cartesian_coordinate_system\">พิกัด Cartesian</a> (ซึ่งง่ายต่อการนำไปเขียนโปรแกรมต่อ) การถอดคำตอบจากวิธีการข้างต้นอาจจะยังถือว่า<em>ไม่สวยงาม</em>เท่าไหร่ เพราะเราอาจเจอกรณีสุดโต่งที่ความชันของเส้นตรงเป็นอนันต์ได้ (หรือก็คือในโค้ดมีการหารด้วยศูนย์)</p>\n\n<p>เราอาจเปลี่ยนไปพิจารณาสมการวงกลมแทน โดยให้ข้อมูลนำเข้า $p_i=(x_i,y_i)$ สำหรับ $i\\in\\lbrace1,2,3\\rbrace$ และให้ตัวแปรจุดศูนย์กลางของวงกลมคือ $f=(x,y)$ พร้อมรัศมีวงกลมเท่ากับ $r$ ดังนั้นแล้วเราจะได้ชุดของสมการออกมาว่า</p>\n\n\\[(x-x_i)^2 + (y-y_i)^2 = r^2\\]\n\n<p>ซึ่งก็คือระบบสมการสามตัวแปร (ที่เราต้องการหาค่า $x,y,r$) นั่นเอง อย่างไรก็ตามเรายังทำงานกับสมการนี้ได้ยาก แต่ถ้าเรากระจายกำลังสองออกมาจะเห็นว่า</p>\n\n\\[r^2 - x^2 - y^2 + (2x_i)x + (2y_i)y = x_i^2 + y_i^2\\]\n\n<p>ดูเผินๆ แล้วเหมือนกับว่ามันจะกลายเป็นระบบสมการห้าตัวแปร แต่จุดสังเกตสำคัญคือ $x^2,y^2$ นั้นเป็นตัวแปรที่ขึ้นกับ $x,y$ ดังนั้นเราสามารถจับ $x^2,y^2$ ไปแปะอยู่กับตัวแปร $r^2$ ได้ ซึ่งจะทำให้ได้สมการเมทริกซ์ออกมาว่า</p>\n\n\\[\\begin{bmatrix}\nx_1 &amp; y_1 &amp; 1 \\\\\nx_2 &amp; y_2 &amp; 1 \\\\\nx_3 &amp; y_3 &amp; 1\n\\end{bmatrix}\n\\begin{bmatrix}\n2x \\\\ 2y \\\\ r^2-\\abs{f}^2 \n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\abs{p_1}^2 \\\\ \\abs{p_2}^2 \\\\ \\abs{p_3}^2\n\\end{bmatrix}\\]\n\n<p>ดังนั้นคำตอบตำแหน่งจุดศูนย์กลางวงกลมก็คือ</p>\n\n\\[2x = \\frac{\n\\det\\begin{bmatrix}\n\\abs{p_1}^2 &amp; y_1 &amp; 1 \\\\\n\\abs{p_2}^2 &amp; y_2 &amp; 1 \\\\\n\\abs{p_3}^2 &amp; y_3 &amp; 1\n\\end{bmatrix}\n}{\n\\det\\begin{bmatrix}\nx_1 &amp; y_1 &amp; 1 \\\\\nx_2 &amp; y_2 &amp; 1 \\\\\nx_3 &amp; y_3 &amp; 1\n\\end{bmatrix}\n},\n\\quad\\quad\\quad\n2y = \\frac{\n\\det\\begin{bmatrix}\nx_1 &amp; \\abs{p_1}^2 &amp; 1 \\\\\nx_2 &amp; \\abs{p_2}^2 &amp; 1 \\\\\nx_3 &amp; \\abs{p_3}^2 &amp; 1\n\\end{bmatrix}\n}{\n\\det\\begin{bmatrix}\nx_1 &amp; y_1 &amp; 1 \\\\\nx_2 &amp; y_2 &amp; 1 \\\\\nx_3 &amp; y_3 &amp; 1\n\\end{bmatrix}\n}\\]\n\n<p>ส่วนรัศมี $r$ นั้นจะหาผ่านดีเทอร์มิแนนต์ในทำนองเดียวกันก็ได้ แต่ใช้พีทาโกรัสน่าจะง่ายกว่าเยอะ 😉</p>\n\n<div><div><pre><code><span>from</span> <span>math</span> <span>import</span> <span>inf</span><span>,</span> <span>hypot</span>\n<span>from</span> <span>collections</span> <span>import</span> <span>namedtuple</span>\n\n<span>Point</span> <span>=</span> <span>namedtuple</span><span>(</span><span>'Point'</span><span>,</span> <span>'x y'</span><span>)</span>\n<span>Disk</span> <span>=</span> <span>namedtuple</span><span>(</span><span>'Disk'</span><span>,</span> <span>'f r'</span><span>)</span>\n<span>Disk</span><span>.</span><span>__contains__</span> <span>=</span> <span>lambda</span> <span>s</span><span>,</span> <span>p</span><span>:</span> <span>hypot</span><span>(</span><span>s</span><span>.</span><span>f</span><span>.</span><span>x</span><span>-</span><span>p</span><span>.</span><span>x</span><span>,</span> <span>s</span><span>.</span><span>f</span><span>.</span><span>y</span><span>-</span><span>p</span><span>.</span><span>y</span><span>)</span> <span>&lt;=</span> <span>s</span><span>.</span><span>r</span>\n\n<span>def</span> <span>disk_degenerate</span><span>(</span><span>p</span><span>=</span><span>Point</span><span>(</span><span>inf</span><span>,</span> <span>inf</span><span>)):</span>\n    <span>return</span> <span>Disk</span><span>(</span><span>p</span><span>,</span> <span>0</span><span>)</span>\n\n<span>def</span> <span>disk_two</span><span>(</span><span>p</span><span>,</span> <span>q</span><span>):</span>\n    <span>return</span> <span>Disk</span><span>(</span><span>Point</span><span>((</span><span>p</span><span>.</span><span>x</span><span>+</span><span>q</span><span>.</span><span>x</span><span>)</span><span>/</span><span>2</span><span>,</span> <span>(</span><span>p</span><span>.</span><span>y</span><span>+</span><span>q</span><span>.</span><span>y</span><span>)</span><span>/</span><span>2</span><span>),</span> <span>hypot</span><span>(</span><span>p</span><span>.</span><span>x</span><span>-</span><span>q</span><span>.</span><span>x</span><span>,</span> <span>p</span><span>.</span><span>y</span><span>-</span><span>q</span><span>.</span><span>y</span><span>)</span><span>/</span><span>2</span><span>)</span>\n\n<span>def</span> <span>disk_three</span><span>(</span><span>u</span><span>,</span> <span>v</span><span>,</span> <span>w</span><span>):</span>\n    <span>d</span> <span>=</span> <span>(</span><span>v</span><span>.</span><span>y</span><span>-</span><span>w</span><span>.</span><span>y</span><span>)</span><span>*</span><span>u</span><span>.</span><span>x</span> <span>+</span> <span>(</span><span>w</span><span>.</span><span>y</span><span>-</span><span>u</span><span>.</span><span>y</span><span>)</span><span>*</span><span>v</span><span>.</span><span>x</span> <span>+</span> <span>(</span><span>u</span><span>.</span><span>y</span><span>-</span><span>v</span><span>.</span><span>y</span><span>)</span><span>*</span><span>w</span><span>.</span><span>x</span>\n    <span>a</span> <span>=</span> <span>(</span><span>v</span><span>.</span><span>y</span><span>-</span><span>w</span><span>.</span><span>y</span><span>)</span><span>*</span><span>hypot</span><span>(</span><span>*</span><span>u</span><span>)</span><span>**</span><span>2</span> <span>+</span> <span>(</span><span>w</span><span>.</span><span>y</span><span>-</span><span>u</span><span>.</span><span>y</span><span>)</span><span>*</span><span>hypot</span><span>(</span><span>*</span><span>v</span><span>)</span><span>**</span><span>2</span> <span>+</span> <span>(</span><span>u</span><span>.</span><span>y</span><span>-</span><span>v</span><span>.</span><span>y</span><span>)</span><span>*</span><span>hypot</span><span>(</span><span>*</span><span>w</span><span>)</span><span>**</span><span>2</span>\n    <span>b</span> <span>=</span> <span>(</span><span>w</span><span>.</span><span>x</span><span>-</span><span>v</span><span>.</span><span>x</span><span>)</span><span>*</span><span>hypot</span><span>(</span><span>*</span><span>u</span><span>)</span><span>**</span><span>2</span> <span>+</span> <span>(</span><span>u</span><span>.</span><span>x</span><span>-</span><span>w</span><span>.</span><span>x</span><span>)</span><span>*</span><span>hypot</span><span>(</span><span>*</span><span>v</span><span>)</span><span>**</span><span>2</span> <span>+</span> <span>(</span><span>v</span><span>.</span><span>x</span><span>-</span><span>u</span><span>.</span><span>x</span><span>)</span><span>*</span><span>hypot</span><span>(</span><span>*</span><span>w</span><span>)</span><span>**</span><span>2</span>\n    <span>f</span> <span>=</span> <span>Point</span><span>(</span><span>a</span><span>/</span><span>2</span><span>/</span><span>d</span><span>,</span> <span>b</span><span>/</span><span>2</span><span>/</span><span>d</span><span>)</span>\n    <span>return</span> <span>Disk</span><span>(</span><span>f</span><span>,</span> <span>hypot</span><span>(</span><span>f</span><span>.</span><span>x</span><span>-</span><span>u</span><span>.</span><span>x</span><span>,</span> <span>f</span><span>.</span><span>y</span><span>-</span><span>u</span><span>.</span><span>y</span><span>))</span>\n\n<span>def</span> <span>disk</span><span>(</span><span>borders</span><span>):</span>\n    <span>fs</span> <span>=</span> <span>[</span><span>disk_degenerate</span><span>,</span> <span>disk_degenerate</span><span>,</span> <span>disk_two</span><span>,</span> <span>disk_three</span><span>]</span>\n    <span>return</span> <span>fs</span><span>[</span><span>len</span><span>(</span><span>borders</span><span>)](</span><span>*</span><span>borders</span><span>)</span>\n</code></pre></div></div>\n\n<h2>ปัญหาที่ใหญ่กว่านี้</h2>\n\n<p>ปัญหาดิสก์ปิดครอบนี้เป็นเพียงแค่ปัญหาขั้นพื้นฐานเริ่มต้นง่ายๆ ในเรขาคณิตเชิงคำนวณเท่านั้น โดยปัญหาในรูปทั่วไปของมันก็คือกลุ่มของ<a href=\"//en.wikipedia.org/wiki/1-center_problem\">ปัญหา 1-ศูนย์กลาง (1-center)</a> ที่เปลี่ยนวิธีการวัดระยะทาง (เช่น ใช้ระยะทางแบบ $L^1$ แทน) หรือพิจารณาให้แต่ละจุดมีน้ำหนักไม่เท่ากัน หรือพิจารณาในมิติที่สูงขึ้น</p>\n\n<p>ในอีกทางหนึ่ง เราก็สามารถขยายขนาดปัญหาโดยการยินยอมให้มีศูนย์กลางได้หลายแห่งเช่นกัน ซึ่งก็คือปัญหาการปิดครอบด้วย $k$-ศูนย์กลาง (ซึ่งมีปัญหาย่อยๆ ต่างกันไป เช่น <a href=\"//en.wikipedia.org/wiki/Facility_location_problem\">ปัญหาที่ตั้งโรงงาน (facility location problem)</a> หรือ<a href=\"//en.wikipedia.org/wiki/Cluster_analysis\">การวิเคราะห์กลุ่มก้อน (cluster analysis)</a> เป็นต้น) การเพิ่มเงื่อนไขโจทย์เช่นนี้ทำให้ปัญหายากกลายเป็น NP-hard และทำให้เราต้องหาเทคนิคในแนวทางอื่นมาช่วยหาคำตอบแทน เช่น การประมาณค่าคำตอบและวิเคราะห์ว่าผลลัพธ์จะไม่แย่เกินกี่เท่าของคำตอบที่ดีที่สุด</p>\n\n<h2>อ้างอิง</h2>\n\n<ul>\n  <li>Welzl, E. (2005, June). Smallest enclosing disks (balls and ellipsoids). In <em>New Results and New Trends in Computer Science: Graz, Austria, June 20–21, 1991 Proceedings</em> (pp. 359-370). Berlin, Heidelberg: Springer Berlin Heidelberg.</li>\n  <li>De Berg, M. (2000). <em>Computational geometry: algorithms and applications</em>. Springer Science &amp; Business Media.</li>\n</ul>\n\n<div>\n  <ol>\n    <li>\n      <p>พูดโดยรัดกุมแล้ว “วงกลม” จะหมายถึงเพียงเส้นขอบเท่านั้น ซึ่งก็คือเซตของคู่อันดับ $(x,y)$ ทุกคู่ที่สอดคล้องกับสมการ $(x{-}x_0)^2+(y{-}y_0)^2=r^2$ ส่วน “ดิสก์” จะหมายรวมถึงพื้นที่ปิดกั้นภายในด้วย นั่นก็คือ $(x{-}x_0)^2+(y{-}y_0)^2 \\le r^2$ <a href=\"#fnref:1\">↩</a></p>\n    </li>\n  </ol>\n</div>","author":"","siteTitle":"neizod's speculation","siteHash":"939338c5557b1743f2c128736c6006e145dcabc81da9970f1c0dc8ae2feb0830","entryHash":"807716b7bc97f8b70102b437dc3d552af8835d8fc8ea14adbc7dc091c330d52c","category":"Thai"}