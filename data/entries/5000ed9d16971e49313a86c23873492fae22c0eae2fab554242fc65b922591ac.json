{"title":"Optimizing WebKit & Safari for Speedometer 3.0","link":"https://webkit.org/blog/15249/optimizing-webkit-safari-for-speedometer-3-0/","date":1712768450000,"content":"<p>The <a href=\"https://webkit.org/blog/15131/speedometer-3-0-the-best-way-yet-to-measure-browser-performance/\">introduction of Speedometer 3.0</a> is a major step forward in making the web faster for all, and allowing Web developers to make websites and web apps that were not previously possible. In this article, we explore ways the WebKit team made performance optimizations in WebKit and Safari based on the Speedometer 3.0 benchmark.</p>\n<p>In order to make these improvements, we made an extensive use of our performance testing infrastructure. It’s integrated with our <a href=\"https://en.wikipedia.org/wiki/Continuous_integration\">continuous integration</a>, and provides the capability to schedule A/B tests. This allows engineers to quickly test out performance optimizations and catch new performance regressions.</p>\n<h2>Improving Tools</h2>\n<p>Proper tooling support is the key to identifying and addressing performance bottlenecks. We defined <a href=\"https://commits.webkit.org/266270@main\">new internal JSON format for JavaScriptCore sampling profiler output</a> to dump and process them offline. It includes a script which processes and generates analysis of hot functions and hot byte codes for JavaScriptCore. We also added <a href=\"https://www.brendangregg.com/flamegraphs.html\">FlameGraph</a> generation <a href=\"https://commits.webkit.org/270797@main\">tool for the dumped sampling profiler output</a> which visualizes performance bottlenecks. In addition, we added support for <a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/perf/Documentation/jitdump-specification.txt\">JITDump</a> generation on Darwin platforms to dump JIT related information during execution. And we <a href=\"https://commits.webkit.org/274632@main\">improved generated JITDump information</a> for easy use as well. These tooling improvements allowed us to quickly identify bottlenecks across Speedometer 3.0.</p>\n<h2>Improving JavaScriptCore</h2>\n<h3>Revising Megamorphic Inline Cache (IC)</h3>\n<p>Megamorphic IC offers faster property access when one property access site observes many different object types and/or property names. We observed that some frameworks such as React contain a megamorphic property access. This led us to continuously improve JavaScriptCore’s megamorphic property access optimizations: <a href=\"https://commits.webkit.org/274421@main\">expanding</a> <a href=\"https://commits.webkit.org/275510@main\">put</a> megamorphic IC, <a href=\"https://commits.webkit.org/274687@main\">adding</a> megamorphic IC for the <code>in</code> operation, and <a href=\"https://commits.webkit.org/268012@main\">adding</a> generic improvements for megamorphic IC.</p>\n<h3>Revising Call IC</h3>\n<p>Call IC offers faster function calls by caching call targets inline. We <a href=\"https://commits.webkit.org/273190@main\">redesigned</a> <a href=\"https://commits.webkit.org/273105@main\">Call</a> <a href=\"https://commits.webkit.org/272580@main\">IC</a> <a href=\"https://commits.webkit.org/271801@main\">and</a> <a href=\"https://commits.webkit.org/273947@main\">we</a> integrated two different architectures into different tiers of Just-In-Time (JIT) compilers. Lower level tiers use Call IC without any JIT code generation and the highest level tier uses JIT code generatiton with the fastest Call IC. There is a tradeoff between code generation time and code efficiency, and JavaScriptCore performs a balancing act between them to achieve the best performance across different tiers.</p>\n<h3>Optimizing JSON</h3>\n<p>Speedometer 3.0 also presented new optimization opportunities to our JSON implementations as they contain more non-ASCII characters than before. We <a href=\"https://commits.webkit.org/267481@main\">made our fast JSON stringifier work for unicode characters</a>. We also analyzed profile data carefully and made <code>JSON.parse</code> <a href=\"https://commits.webkit.org/274348@main\">faster</a> <a href=\"https://commits.webkit.org/267507@main\">than</a> <a href=\"https://commits.webkit.org/266010@main\">ever</a>.</p>\n<h3>Adjusting Inlining Heuristics</h3>\n<p>There are many tradeoffs when inlining functions in JavaScript. For example, inline functions can more aggressively increase the total bytecode size and may cause memory bandwidth to become a new bottleneck. The amount of instruction cache available in CPU can also influence how effective a given inlining strategy is. And the calculus of these tradeoffs change over time as we make more improvements to JavaScriptCore such as adding new bytecode instruction and changes to DFG’s numerous optimization phases. We took the release of the new Speedometer 3.0 benchmark as an opportunity to <a href=\"https://commits.webkit.org/272208@main\">adjust inlining heuristics</a> based on data collected in modern Apple silicon Macs with the latest JavaScriptCore.</p>\n<h3>Make JIT Code Destruction Lazy</h3>\n<p>Due to complicated conditions, JavaScriptCore eagerly destroyed CodeBlock and JIT code when GC detects they are dead. Since these destructions are costly, they should be delayed and processed while the browser is idle. We made <a href=\"https://commits.webkit.org/271184@main\">changes</a> so that they are now destroyed lazily, during idle time in most cases.</p>\n<h3>Opportunistic Sweeping and Garbage Collection</h3>\n<p>In addition, we noticed that a significant amount of time goes into performing garbage collection and incremental sweeping across all subtests in both Speedometer 2.1 and 3.0. In particular, if a subtest allocated a large number of JavaScript objects on the heap, we would often spend a significant amount of time in subsequent subtests collecting these objects. This had several effects:</p>\n<ol>\n<li>Increasing synchronous time intervals on many subtests due to on-demand sweeping and garbage collection when hitting heap size limits.</li>\n<li>Increasing asynchronous time intervals on many subtests due to asynchronous garbage collection or timer-based incremental sweeping triggering immediately after the synchronous timing interval.</li>\n<li>Increasing overall variance depending on whether timer-based incremental sweeping and garbage collection would fall in the synchronous or asynchronous timing windows of any given subtest.</li>\n</ol>\n<p>At a high level, we realized that some of this work could be performed opportunistically in between rendering updates — that is, during idle time — instead of triggering in the middle of subtests. To achieve this, we <a href=\"https://commits.webkit.org/265197@main\">introduced a new mechanism</a> in WebCore to provide hints to JavaScriptCore to opportunistically perform scheduled work after the previous rendering update has completed until a given deadline (determined by the estimated remaining time until the next rendering update). The opportunistic task scheduler also accounts for <a href=\"https://commits.webkit.org/267818@main\">imminently scheduled zero delay timers or pending <code>requestAnimationFrame</code> callbacks</a>: if it observes either, it’s less likely to schedule opportunistic work in order to avoid interference with imminent script execution. We currently perform a couple types of opportunistically scheduled tasks:</p>\n<ul>\n<li><strong>Incremental Sweeping</strong>: Prior to the opportunistic task scheduler, incremental sweeping in JavaScriptCore was automatically triggered by a periodically scheduled 100 ms timer. This had the effect of occasionally triggering incremental sweeping during asynchronous timing intervals, but also wasn’t aggressive enough to prevent on-demand sweeping in the middle of script execution. Now that JavaScriptCore is knowledgable about when to opportunistically schedule tasks, it can instead perform the majority of incremental sweeping in between rendering updates while there aren’t imminently scheduled timers. The process of sweeping is also granular to each marked block, which allows us to halt opportunistic sweeping early if we’re about to exceed the deadline for the next estimated rendering update.</li>\n<li><strong>Garbage Collection</strong>: By tracking the amount of time spent performing garbage collection in previous cycles, we’re able to roughly estimate the amount of time needed to perform the next garbage collection based on the number of bytes visited or allocated since the last cycle. If the remaining duration for performing opportunistically scheduled tasks is longer than this estimated garbage collection duration, we immediately perform either an <a href=\"https://commits.webkit.org/267893@main\">Eden collection</a> or <a href=\"https://commits.webkit.org/268039@main\">full</a> <a href=\"https://commits.webkit.org/270502@main\">garbage collection</a>. Furthermore, we <a href=\"https://commits.webkit.org/270919@main\">integrated</a> <a href=\"https://commits.webkit.org/271324@main\">activity-based</a> garbage collections into this new scheme to schedule them at appropriate timing.</li>\n</ul>\n<p>Overall, this strategy yields a <strong>6.5% total improvement in Speedometer 3.0</strong>*, decreasing the time spent in every subtest by a significant margin, and a <strong>6.9% total improvement in Speedometer 2.1</strong>*, significantly decreasing the time spent in nearly all subtests.</p>\n<p><em>* macOS 14.4, MacBook Air (M2, 2022)</em></p>\n<h3>Various Miscellaneous Optimizations for Real World Use Cases</h3>\n<p>We extensively reviewed all Speedometer 3.0 subtests and did many optimizations for realistic use cases. The examples include but are not limited to: <a href=\"https://commits.webkit.org/272794@main\">faster Object.assign with empty objects</a>, improving <a href=\"https://commits.webkit.org/267821@main\">object spread performance</a>, and so on.</p>\n<h2>Improving DOM code</h2>\n<p>Improving DOM code is Speedometer’s namesake, and that’s exactly what we did. For example, we now <a href=\"https://github.com/WebKit/WebKit/commit/871823510e94736614a4c2b1d1610648ddc1da6e\">store the NodeType in the Node object itself</a> instead of relying on a virtual function call. We also <a href=\"https://github.com/WebKit/WebKit/pull/17023\">made DOMParser use a fast parser,</a> <a href=\"https://commits.webkit.org/267207@main\">improved its support of <code>li</code> elements</a>, and made <a href=\"https://commits.webkit.org/267242@main\">DOMParser not construct a redundant DocumentFragment</a>. Together, these changes improved TodoMVC-JavaScript-ES5 by ~20%. We also <a href=\"https://commits.webkit.org/273516@main\">eliminated O(n^2) behavior in the fast parser</a> for about ~0.5% overall progression in Speedometer 3.0. We also made <code>input</code> elements <a href=\"https://commits.webkit.org/273461@main\">construct their user-agent shadow tree lazily</a> during construction and <a href=\"https://commits.webkit.org/275200@main\">cloning</a>, the latter of which is new in Speedometer 3.0 due to web components and Lit tests. We <a href=\"https://commits.webkit.org/275155@main\">devirtualized</a> <a href=\"https://commits.webkit.org/272248@main\">many functions</a> and <a href=\"https://commits.webkit.org/272802@main\">inlined more functions</a> to reduce the function call overheads. We carefully reviewed performance profile data and removed inefficiency in hot paths like <a href=\"https://commits.webkit.org/275281@main\">repeated reparsing of the same URLs</a>.</p>\n<h2>Improving Layout and Rendering</h2>\n<p>We landed a number of important optimizations in our layout and rendering code. First off, most type checks performed on <code>RenderObject</code> are now done <a href=\"https://github.com/WebKit/WebKit/pull/18352\">using an inline enum class instead of virtual function calls</a>, this alone is responsible for around ~0.7% of overall progression in Speedometer 3.0.</p>\n<h3>Improving Style Engine</h3>\n<p>We also <a href=\"https://github.com/WebKit/WebKit/pull/17897\">optimized the way we compute the properties</a> animated by Web Animations code. Previously, we were enumerating every animatable properties while resolving <code>transition: all</code>. We <a href=\"https://github.com/WebKit/WebKit/pull/18054\">optimized this code</a> to only enumerate affected properties. This was ~0.7% overall Speedometer 3.0 progression. Animating elements can now be resolved without fully recomputing their style unless necessary for correctness.</p>\n<p>Speedometer 3.0 content, like many modern web sites, uses CSS custom properties extensively. We implemented significant optimizations to improve their performance. Most custom property references are now resolved via fast cache lookups, avoiding expensive style resolution time property parsing. Custom properties are now stored in a new hierarchical data structure that reduces memory usage as well.</p>\n<p>One key component of WebKit styling performance is a cache (called “matched declarations cache”) that maps directly from a set of CSS declarations to the final element style, avoiding repeating expensive style building steps for identically styled elements. We significantly improved the hit rate of this cache.</p>\n<p>We also improved styling performance of author shadow trees, allowing trees with identical styles to share style data more effectively.</p>\n<h3>Improving Inline Layout</h3>\n<p>We fixed a number of performance bottlenecks in inline layout engine as well. <a href=\"https://github.com/WebKit/WebKit/pull/15994\">Eliminating complex text path</a> in Editor-TipTap was a major ~7% overall improvement. To understand this optimization, WebKit has two different code paths for text layout: the simple text path, which uses low level font API to access raw font data, and the complex text path, which uses CoreText for complex shaping and ligatures. The simple text path is faster but it does not cover all the edge cases. The complex text path has full coverage but is slower than the simple text path.</p>\n<p>Previously, we were taking the complex text path whenever a non-default value of <strong>font-feature</strong> or <strong>font-variant</strong> was used.  This is because historically the simple text path wouldn’t support these operations. However, we noticed that the only feature of these still missing in the simple text path was <strong>font-variant-caps</strong>. By <a href=\"https://commits.webkit.org/267095@main\">implementing font-variant-caps support for the simple text path</a>, we allowed the simple text path to handle the benchmark content. This resulted in 4.5x improvement in Editor-TipTap subtest, and ~7% overall progression in Speedometer 3.0.</p>\n<p>In addition to improving the handling of text content in WebKit, we also worked with CoreText team to avoid unnecessary work in laying out glyphs. This resulted in ~0.5% overall progression in Speedometer 3.0, and these performance gains will benefit not just WebKit but other frameworks and applications that use CoreText.</p>\n<h3>Improving SVG Layout</h3>\n<p>Another area we landed many optimizations for is SVG. Speedometer 3.0 contains a fair bit of SVG content in test cases such as React-Stockcharts-SVG. We were spending a lot of time computing the bounding box for repaint by creating GraphicsContext, applying all styles, and actually drawing strokes in CoreGraphics. Here, we <a href=\"https://commits.webkit.org/269745@main\">adopted</a> <a href=\"https://bugs.chromium.org/p/chromium/issues/detail?id=435097\">Blink</a>’s optimization to approximate bounding box and made ~6% improvement in React-Stockcharts-SVG subtest. We also <a href=\"https://github.com/WebKit/WebKit/pull/19877\">eliminated O(n^2) algorithm</a> in SVG text layout code, which <a href=\"https://bugs.webkit.org/show_bug.cgi?id=262192\">made some SVG content load a lot quicker</a>.</p>\n<h3>Improving IOSurface Cache Hit Rate</h3>\n<p>Another optimization we did involve improving the cache hit rate of IOSurface. An IOSurface is a bitmap image buffer we use to paint web contents into. Since creating this object is rather expensive, we have a cache of IOSurface objects based on their dimensions. We observed that the cache hit rate was rather low (~30%) so we <a href=\"https://commits.webkit.org/270817@main\">increased the cache size from 64MB to 256MB on macOS</a> and improved the cache hit rate by 2.7x to ~80%, improving the overall Speedometer 3.0 score by ~0.7%. In practice, this means lower latency for canvas operations and other painting operations.</p>\n<h3>Reducing Wait Time for GPU Process</h3>\n<p>Previously, we required a synchronous IPC call from the Web Process to the GPU process to determine which of the existing buffers had been released by CoreAnimation and was suitable to use for the next frame. We <a href=\"https://commits.webkit.org/271747@main\">optimized this</a> by having the GPUP just select (or allocate) an appropriate buffer, and direct all incoming drawing commands to the right destination without requiring any response. We also changed the delivery of any newly allocated <a href=\"https://commits.webkit.org/273323@main\">IOSurface handles to go via a background helper thread</a>, rather than blocking the Web Process’s main thread.</p>\n<h3>Improving Compositing</h3>\n<p><a href=\"https://commits.webkit.org/271261@main\">Updates to compositing layers are now batched</a>, and flushed during rendering updates, rather than computed during every layout. This significantly reduces the cost of script-incurred layout flushes.</p>\n<h2>Improving Safari</h2>\n<p>In addition to optimizations we made in WebKit, there were a handful of optimizations for Safari as well.</p>\n<h3>Optimizing AutoFill Code</h3>\n<p>One area we looked at was Safari’s AutoFill code. Safari uses JavaScript to implement its AutoFill logic, and this execution time was showing up in the Speedometer 3.0 profile. We made this code significantly faster by waiting for the contents of the page to settle before performing some work for AutoFill. This includes coalescing handling of newly focused fields until after the page had finished loading when possible, and moving lower-priority work out of the critical path of loading and presenting the page for long-loading pages. This was responsible for ~13% progression in TodoMVC-React-Complex-DOM and ~1% progression in numerous other tests, improving the overall Speedometer 3.0 score by ~0.9%.</p>\n<h2>Profile Guided Optimizations</h2>\n<p>In addition to making the above code changes, we also adjusted our <a href=\"https://en.wikipedia.org/wiki/Profile-guided_optimization\">profile-guided optimizations</a> to take Speedometer 3.0 into account. This allowed us to improve the overall Speedometer 3.0 score by 1~1.6%. It’s worth noting that we observed an intricate interaction between making code changes and profile-guided optimizations. We sometimes don’t observe an immediate improvement in the overall Speedometer 3.0 score when we eliminate, or reduce the runtime cost of a particular code path until the daily update of profile-guided optimizations kicks. This is because the modified or newly added code has to benefit from profile-guided optimizations before it can show a measurable difference. In some cases, we even observed that a performance optimization initially results in a performance degradation until the profile-guided optimizations are updated.</p>\n<h2>Results</h2>\n<p>With all these optimizations and dozens more, we were able to improve the overall Speedometer 3.0 score by ~60% between Safari 17.0 and Safari 17.4. Even though individual progressions were often less than 1%, over time, they all stacked up together to make a big difference. Because some of these optimizations also benefited Speedometer 2.1, Safari 17.4 is also ~13% faster than Safari 17.0 on Speedometer 2.1. We’re thrilled to deliver these performance improvements to our users allowing web developers to build websites and web apps that are more responsive and snappier than ever.</p>","author":"","siteTitle":"Blog – WebKit","siteHash":"7f8dbea0b8f53db2e11a2faa08c6dca9954c01638d09a2ce585b77a60d10f7a1","entryHash":"5000ed9d16971e49313a86c23873492fae22c0eae2fab554242fc65b922591ac","category":"Tech"}