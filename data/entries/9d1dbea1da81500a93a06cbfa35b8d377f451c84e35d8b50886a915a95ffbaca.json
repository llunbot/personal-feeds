{"title":"Gatsby Headaches And How To Cure Them: i18n (Part 2)","link":"https://smashingmagazine.com/2023/06/gatsby-headaches-i18n-part-2/","date":1687194000000,"content":"<p>In <a href=\"https://www.smashingmagazine.com/2023/06/gatsby-headaches-i18n-part-1/\">Part 1</a> of this series, we peeked at how to add i18n to a Gatsby blog using a motley set of Gatsby plugins. They are great if you know what they can do, how to use them, and how they work. Still, plugins don’t always work great together since they are often written by different developers, which can introduce compatibility issues and cause an even bigger headache. Besides, we usually use plugins for more than i18n since we also want to add features like responsive images, Markdown support, themes, CMSs, and so on, which can lead to a whole compatibility nightmare if they aren’t properly supported.</p>\n<p>How can we solve this? Well, when working with an incompatible, or even an old, plugin, the best solution often involves finding another plugin, hopefully one that provides better support for what is needed. Otherwise, you could find yourself editing the plugin’s original code to make it work (an indicator that you are in a bad place because it can introduce breaking changes), and unless you want to collaborate on the plugin’s codebase with the developers who wrote it, it likely won’t be a permanent solution.</p>\n<p>But there is another option!</p>\n<h3>Table of Contents</h3>\n<ul>\n<li><a href=\"#the-solution-make-your-own-plugin\">The Solution</a></li>\n<li><a href=\"#the-starter\">The Starter</a></li>\n<li><a href=\"#create-localized-routes\">Create localized routes</a><ul>\n<li><a href=\"#how-plugins-create-pages\">How Plugins create pages</a></li>\n<li><a href=\"#using-oncreatepage\">Using <code>onCreatePage</code></a></li>\n<li><a href=\"#creating-the-pages\">Creating the pages</a></li>\n</ul>\n</li>\n<li><a href=\"#querying-localized-content\">Querying localized content</a></li>\n<li><a href=\"#creating-localized-links\">Creating Localized Links</a><ul>\n<li><a href=\"#setting-up-a-locale-context\">Setting up a Locale Context</a></li>\n<li><a href=\"#creating-localizedlink\">Creating <code>LocalizedLink</code></a></li>\n</ul>\n</li>\n<li><a href=\"#redirecting-users\">Redirecting users</a></li>\n<li><a href=\"#changing-locales\">Changing locales</a></li>\n<li><a href=\"#localizing-static-content\">Localizing Static Content</a><ul>\n<li><a href=\"#page-body-translations\">Page Body Translations</a></li>\n<li><a href=\"#page-title-translations\">Page Title Translations</a></li>\n</ul>\n</li>\n<li><a href=\"#formatting\">Formatting</a></li>\n<li><a href=\"#conclusion\">Conclusion</a></li>\n</ul>\n<p><strong>Note</strong>: <em>Here is the <a href=\"https://gatsby-headaches-i18n-demo-no-plugins.netlify.app\">Live Demo</a>.</em></p>\nThe Solution: Make Your Own Plugin!\n<p>Sure, that might sound intimidating, but adding i18n from scratch to your blog is not so bad once you get down to it. Plus, you gain <strong>complete control over compatibility</strong> and how it is implemented. That’s exactly what we are going to do in this article, specifically by adding i18n to the starter site — a cooking blog — that we created together in <a href=\"https://www.smashingmagazine.com/2023/06/gatsby-headaches-i18n-part-1/\">Part 1</a>.</p>\nThe Starter\n<p>You can go ahead and see how we made our cooking blog starter in <a href=\"https://www.smashingmagazine.com/2023/06/gatsby-headaches-i18n-part-1/#the-starter\">Part 1</a> or <a href=\"https://github.com/Monknow/starter-gatsby-headaches-and-how-to-cure-them-i18n\">get it from GitHub</a>.</p>\n<p>This starter includes a homepage, blog post pages created from Markdown files, and blog posts authored in English and Spanish.</p>\n<p>What we will do is add the following things to the site:</p>\n<ul>\n<li>Localized routes for the home and blog posts,</li>\n<li>A locale selector,</li>\n<li>Translations,</li>\n<li>Date formatting.</li>\n</ul>\n<p>Let’s go through each one together.</p>\nCreate Localized Routes\n<p>First, we will need to create a localized route for each locale, i.e., route our English pages to paths with a <code>/en/</code> prefix and the Spanish pages to a path with a <code>/es/</code> prefix. So, for example, a path like <code>my-site.com/recipes/mac-and-cheese/</code> will be replaced with localized routes, like <code>my-site.com/en/recipes/mac-and-cheese/</code> for English and <code>my-site.com/recipes/es/mac-and-cheese/</code> for Spanish.</p>\n<p>In Part 1, we used the <a href=\"https://www.gatsbyjs.com/plugins/gatsby-theme-i18n/\"><code>gatsby-theme-i18n</code> plugin</a> to automatically add localized routes for each page, and it worked perfectly. However, to make our own version, we first must know what happens underneath the hood of that plugin.</p>\n<p>What <code>gatsby-theme-i18n</code> does is modify the <code>createPages</code> process to create a localized version of each page. However, what exactly is <code>createPages</code>?</p>\n<h3>How Plugins Create Pages</h3>\n<p>When running <code>npm run build</code> in a fresh Gatsby site, you will see in the terminal what Gatsby is doing, and it looks something like this:</p>\n<pre><code>success open and validate gatsby-configs - 0.062 s\nsuccess load plugins - 0.915 s\nsuccess onPreInit - 0.021 s\nsuccess delete html and css files from previous builds - 0.030 s\nsuccess initialize cache - 0.034 s\nsuccess copy gatsby files - 0.099 s\nsuccess onPreBootstrap - 0.034 s\nsuccess source and transform nodes - 0.121 s\nsuccess Add explicit types - 0.025 s\nsuccess Add inferred types - 0.144 s\nsuccess Processing types - 0.110 s\nsuccess building schema - 0.365 s\nsuccess createPages - 0.016 s\nsuccess createPagesStatefully - 0.079 s\nsuccess onPreExtractQueries - 0.025 s\nsuccess update schema - 0.041 s\nsuccess extract queries from components - 0.333 s\nsuccess write out requires - 0.020 s\nsuccess write out redirect data - 0.019 s\nsuccess Build manifest and related icons - 0.141 s\nsuccess onPostBootstrap - 0.164 s\n⠀\ninfo bootstrap finished - 6.932 s\n⠀\nsuccess run static queries - 0.166 s — 3/3 20.90 queries/second\nsuccess Generating image thumbnails — 6/6 - 1.059 s\nsuccess Building production JavaScript and CSS bundles - 8.050 s\nsuccess Rewriting compilation hashes - 0.021 s\nsuccess run page queries - 0.034 s — 4/4 441.23 queries/second\nsuccess Building static HTML for pages - 0.852 s — 4/4 23.89 pages/second\ninfo Done building in 16.143999152 sec\n</code></pre>\n\n<p>As you can see, Gatsby does a lot to ship your React components into static files. In short, it takes five steps:</p>\n<ol>\n<li>Source the node objects defined by your plugins on <code>gatsby-config.js</code> and the code in <code>gatsby-node.js</code>.</li>\n<li>Create a schema from the <code>nodes</code> object.</li>\n<li>Create the pages from your <code>/src/page</code> JavaScript files.</li>\n<li>Run the GraphQL queries and inject the data on your pages.</li>\n<li>Generate and bundle the static files into the public directory.</li>\n</ol>\n<p>And, as you may notice, plugins like <code>gatsby-theme-i18n</code> intervene in step three, specifically when pages are created on <code>createPages</code>:</p>\n<pre><code>success createPages - 0.016 s\n</code></pre>\n\n<p>How exactly does <code>gatsby-theme-i18n</code> access <code>createPages</code>? Well, Gatsby exposes an <code>onCreatePage</code> event handler on the <code>gatsby-node.js</code> to read and modify pages when they are being created.</p>\n<p>Learn more about <a href=\"https://www.gatsbyjs.com/docs/creating-and-modifying-pages/\">creating and modifying pages</a> and the <a href=\"https://www.gatsbyjs.com/docs/conceptual/overview-of-the-gatsby-build-process/\">Gatsby building process</a> over at Gatsby’s official documentation.</p>\n<h3>Using <code>onCreatePage</code></h3>\n<p>The <code>createPages</code> process can be modified in the <code>gatsby-node.js</code> file through the <code>onCreatePage</code> API. In short, <code>onCreatePage</code> is a function that runs each time a page is created by Gatsby. Here’s how it looks:</p>\n<pre><code>// ./gatsby-node.js\nexports.onCreatePage = ({ page, actions }) =&gt; {\n  const { createPage, deletePage } = actions;\n  // etc.\n};\n</code></pre>\n\n<p>It takes two parameters inside an object:</p>\n<ul>\n<li><strong><code>page</code></strong> holds the information of the page that’s going to be created, including its context, path, and the React component associated with it.</li>\n<li><strong><code>actions</code></strong> holds several methods for editing the site’s state. In the Gatsby docs, you can see <a href=\"https://www.gatsbyjs.com/docs/reference/config-files/actions/\">all available methods</a>. For this example we’re making, we will be using two methods: <code>createPage</code> and <code>deletePage</code>, both of which take a <code>page</code> object as the only parameter and, as you might have deduced, they create or delete the page.</li>\n</ul>\n<p>So, if we wanted to add a new context to all pages, it would translate to deleting the pages being created and replacing them with new ones that have the desired context:</p>\n<pre><code>exports.onCreatePage = ({ page, actions }) =&gt; {\n  const { createPage, deletePage } = actions;\n\n  deletePage(page);\n\n  createPage({\n    ...page,\n    context: {\n      ...page.context,\n      category: `vegan`,\n    },\n  });\n};\n</code></pre>\n\n<h3>Creating The Pages</h3>\n<p>Since we need to create English and Spanish versions of each page, it would translate to deleting every page and creating two new ones, one for each locale. And to differentiate them, we will assign them a localized route by adding the locale at the beginning of their <code>path</code>.</p>\n<p>Let’s start by creating a new <code>gatsby-node.js</code> file in the project’s root directory and adding the following code:</p>\n<pre><code>// ./gatsby-node.js\n\nconst locales = [\"en\", \"es\"];\n\nexports.onCreatePage = ({page, actions}) =&gt; {\n  const {createPage, deletePage} = actions;\n\n  deletePage(page);\n\n  locales.forEach((locale) =&gt; {\n    createPage({\n      ...page,\n      path: `${locale}${page.path}`,\n    });\n  });\n};\n</code></pre>\n\n<p><strong>Note</strong>: <em>Restarting the development server is required to see the changes.</em></p>\n<p>Now, if we go to <code>http://localhost:8000/en/</code> or <code>http://localhost:8000/es/</code>, we will see all our content there. However, there is a big caveat. Specifically, if we head back to the non-localized routes — like <code>http://localhost:8000/</code> or <code>http://localhost:8000/recipes/mac-and-cheese/</code> — Gatsby will throw a runtime error instead of the usual 404 page provided by Gatsby. This is because we deleted our 404 page in the process of deleting all of the other pages!</p>\n<p>Well, the 404 page wasn’t <em>exactly</em> deleted because we can still access it if we go to <code>http://localhost:8000/en/404</code> or <code>http://localhost:8000/es/404</code>. However, we deleted the original 404 page and created two localized versions. Now Gatsby doesn’t know they are supposed to be 404 pages.</p>\n<p>To solve it, we need to do something special to the 404 pages at <code>onCreatePage</code>.</p>\n<p>Besides a <code>path</code>, every <code>page</code> object has another property called <code>matchPath</code> that Gatsby uses to match the page on the client side, and it is normally used as a fallback when the user reaches a non-existing page. For example, a <code>page</code> with a <code>matchPath</code> property of <code>/recipes/*</code> (notice the wildcard <code>*</code>) will be displayed on each route at <code>my-site.com/recipes/</code> that doesn’t have a page. This is useful for making personalized 404 pages depending on where the user was when they reached a non-existing page. For instance, social media could display a usual 404 page on <code>my-media.com/non-existing</code> but display an empty profile page on <code>my-media.com/user/non-existing</code>. In this case, we want to display a localized 404 page depending on whether or not the user was on <code>my-site.com/en/not-found</code> or <code>my-site.com/es/not-found</code>.</p>\n<p>The good news is that we can modify the <code>matchPath</code> property on the 404 pages:</p>\n<div>\n<pre><code>// gatsby-node.js\n\nconst locales = [ \"en\", \"es\" ];\n\nexports.onCreatePage = ({ page, actions }) =&gt; {\n  const { createPage, deletePage } = actions;\n  deletePage(page);\n  locales.forEach((locale) =&gt; {\n    const matchPath = page.path.match(/^\\/404\\/$/) ? (locale === \"en\" ? <code>/&amp;#42;</code> : <code>/${locale}/&amp;#42;</code>) : page.matchPath;\n    createPage({\n      ...page,\n      path: <code>${locale}${page.path}</code>,\n      matchPath,\n    });\n  });\n};\n</code></pre>\n</div>\n\n<p>This solves the problem, but what exactly did we do in <code>matchpath</code>? The value we are assigning to the <code>matchPath</code> is asking:</p>\n<ul>\n<li>Is the page path <code>/404/</code>?<ul>\n<li>No: Leave it as-is.</li>\n<li>Yes:<ul>\n<li>Is the locale in English?<ul>\n<li>Yes: Set it to match any route.</li>\n<li>No: Set it to only match routes on that locale.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>This results in the English 404 page having a <code>matchPath</code> of <code>/*</code>, which will be our default 404 page; meanwhile, the Spanish version will have <code>matchPath</code> equal <code>/es/*</code> and will only be rendered if the user is on a route that begins with <code>/es/</code>, e.g., <code>my-site.com/es/not-found</code>. Now, if we restart the server and head to a non-existing page, we will be greeted with our usual 404 page.</p>\n<p>Besides fixing the runtime error, doing leave us with the possibility of localizing the 404 page, which we didn’t achieve in Part 1 with the <code>gatsby-theme-i18n</code> plugin. That’s already a nice improvement we get by not using a plugin!</p>\nQuerying Localized Content\n<p>Now that we have localized routes, you may notice that both <code>http://localhost:8000/en/</code> and <code>http://localhost:8000/es/</code> are querying English and Spanish blog posts. This is because we aren’t filtering our Markdown content on the page’s locale. We solved this in Part 1, thanks to <code>gatsby-theme-i18n</code> injecting the page’s locale on the context of each page, making it available to use as a query variable on the GraphQL query.</p>\n<p>In this case, we can also add the locale into the page’s context in the <code>createPage</code> method:</p>\n<div>\n<pre><code>// gatsby-node.js\n\nconst locales = [ \"en\", \"es\" ];\n\nexports.onCreatePage = ({page, actions}) =&gt; {\n  const { createPage, deletePage } = actions;\n  deletePage(page);\n  locales.forEach((locale) =&gt; {\n    const matchPath = page.path.match(/^\\/404\\/$/) ? (locale === \"en\" ? <code>/&amp;#42;</code> : <code>/${locale}/&amp;#42;</code>) : page.matchPath;\n    createPage({\n      ...page,\n      path: <code>${locale}${page.path}</code>,\n      context: {\n        ...page.context,\n        locale,\n      },\n      matchPath,\n    });\n  });\n};\n</code></pre>\n</div>\n\n<p><strong>Note</strong>: <em>Restarting the development server is required to see the changes.</em></p>\n<p>From here, we can filter the content on both the homepage and blog posts, which we explained thoroughly in Part 1. This is the <code>index</code> page query:</p>\n<pre><code>query IndexQuery($locale: String) {\n  allMarkdownRemark(filter: {frontmatter: {locale: {eq: $locale}}}) {\n    nodes {\n      frontmatter {\n        slug\n        title\n        date\n        cover_image {\n          image {\n            childImageSharp {\n              gatsbyImageData\n            }\n          }\n          alt\n        }\n      }\n    }\n  }\n}\n</code></pre>\n\n<p>And this is the <code>{markdownRemark.frontmatter__slug}.js</code> page query:</p>\n<div>\n<pre><code>query RecipeQuery($frontmatter__slug: String, $locale: String) {\n  markdownRemark(frontmatter: {slug: {eq: $frontmatter__slug}, locale: {eq: $locale}}) {\n    frontmatter {\n      slug\n      title\n      date\n      cover_image {\n        image {\n          childImageSharp {\n            gatsbyImageData\n          }\n        }\n        alt\n      }\n    }\n    html\n  }\n}\n</code></pre>\n</div>\n\n<p>Now, if we head to <code>http://localhost:8000/en/</code> or <code>http://localhost:8000/es/</code>, we will only see our English or Spanish posts, depending on which locale we are on.</p>\nCreating Localized Links\n<p>However, if we try to click on any recipe, it will take us to a 404 page since the links are still pointing to the non-localized recipes. In Part 1, <code>gatsby-theme-i18n</code> gave us a <code>LocalizedLink</code> component that worked exactly like Gatsby’s <code>Link</code> but pointed to the current locale, so we will have to create a <code>LocalizedLink</code> component from scratch. Luckily is pretty easy, but we will have to make some preparation first.</p>\n<h3>Setting Up A Locale Context</h3>\n<p>For the <code>LocalizedLink</code> to work, we will need to know the page’s locale at all times, so we will create a new context that holds the current locale, then pass it down to each component. We can implement it on <code>wrapPageElement</code> in the <code>gatsby-browser.js</code> and <code>gatsby-ssr.js</code> Gatsby files. The <code>wrapPageElement</code> is the component that wraps our entire page element. However, remember that Gatsby recommends <a href=\"https://www.gatsbyjs.com/docs/reference/config-files/gatsby-browser/#wrapPageElement\">setting context providers inside <code>wrapRootElement</code></a>, but in this case, only <code>wrapPageEement</code> can access the page’s context where the current locale can be found.</p>\n<p>Let’s create a new directory at <code>./src/context/</code> and add a <code>LocaleContext.js</code> file in it with the following code:</p>\n<pre><code>// ./src/context/LocaleContext.js\n\nimport * as React from \"react\";\nimport { createContext } from \"react\";\n\nexport const LocaleContext = createContext();\nexport const LocaleProvider = ({ locale, children }) =&gt; {\n  return &lt;LocaleContext.Provider value={locale}&gt;{children}&lt;/LocaleContext.Provider&gt;;\n};\n</code></pre>\n\n<p>Next, we will set the page’s context at <code>gatsby-browser.js</code> and <code>gatsby-ssr.js</code> and pass it down to each component:</p>\n<pre><code>// ./gatsby-browser.js &amp; ./gatsby-ssr.js\n\nimport * as React from \"react\";\nimport { LocaleProvider } from \"./src/context/LocaleContext\";\n\nexport const wrapPageElement = ({ element }) =&gt; {\n  const {locale} = element.props.pageContext;\n  return &lt;LocaleProvider locale={locale}&gt;{element}&lt;/LocaleProvider&gt;;\n};\n</code></pre>\n\n<p><strong>Note</strong>: <em>Restart the development server to load the new files.</em></p>\n<h3>Creating <code>LocalizedLink</code></h3>\n<p>Now let’s make sure that the locale is available in the <code>LocalizedLink</code> component, which we will create in the <code>./src/components/LocalizedLink.js</code> file:</p>\n<pre><code>// ./src/components/LocalizedLink.js\n\nimport * as React from \"react\";\nimport { useContext } from \"react\";\nimport { Link } from \"gatsby\";\nimport { LocaleContext } from \"../context/LocaleContext\";\n\nexport const LocalizedLink = ({ to, children }) =&gt; {\n  const locale = useContext(LocaleContext);\n  return &lt;Link to={`/${locale}${to}`}&gt;{children}&lt;/Link&gt;;\n};\n</code></pre>\n\n<p>We can use our <code>LocalizedLink</code> at <code>RecipePreview.js</code> and <code>404.js</code> just by changing the imports:</p>\n<div>\n<pre><code>// ./src/components/RecipePreview.js\n\nimport * as React from \"react\";\nimport { LocalizedLink as Link } from \"./LocalizedLink\";\nimport { GatsbyImage, getImage } from \"gatsby-plugin-image\";\n\nexport const RecipePreview = ({ data }) =&gt; {\n  const { cover_image, title, slug } = data;\n  const cover_image_data = getImage(cover_image.image.childImageSharp.gatsbyImageData);\n\n  return (\n    &lt;Link to={<code>/recipes/${slug}</code>}&gt;\n      &lt;h1&gt;{title}&lt;/h1&gt;\n      &lt;GatsbyImage image={cover_image_data} alt={cover_image.alt} /&gt;\n    &lt;/Link&gt;\n  );\n};\n</code></pre>\n</div>\n\n<div>\n<pre><code>// ./src/pages/404.js\n\nimport * as React from \"react\";\nimport { LocalizedLink as Link } from \"../components/LocalizedLink\";\n\nconst NotFoundPage = () =&gt; {\n  return (\n    &lt;main&gt;\n      &lt;h1&gt;Page not found&lt;/h1&gt;\n      &lt;p&gt;\n        Sorry 😔 We were unable to find what you were looking for.\n        &lt;br /&gt;\n        &lt;Link to=\"/\"&gt;Go Home&lt;/Link&gt;.\n      &lt;/p&gt;\n    &lt;/main&gt;\n  );\n};\n\nexport default NotFoundPage;\nexport const Head = () =&gt; &lt;title&gt;Not Found&lt;/title&gt;;\n</code></pre>\n</div>\n\nRedirecting Users\n<p>As you may have noticed, we deleted the non-localized pages and replaced them with localized ones, but by doing so, we left the non-localized routes empty with a 404 page. As we did in Part 1, we can solve this by setting up redirects at <code>gatbsy-node.js</code> to take users to the localized version. However, this time we will create a redirect for each page instead of creating a redirect that covers all pages.</p>\n<p>These are the redirects from Part 1:</p>\n<pre><code>// ./gatsby-node.js\n\nexports.createPages = async ({ actions }) =&gt; {\n  const { createRedirect } = actions;\n\n  createRedirect({\n    fromPath: `/*`,\n    toPath: `/en/*`,\n    isPermanent: true,\n  });\n\n  createRedirect({\n    fromPath: `/*`,\n    toPath: `/es/*`,\n    isPermanent: true,\n    conditions: {\n      language: [`es`],\n    },\n  });\n};\n\n// etc.\n</code></pre>\n\n<p>These are the new localized redirects:</p>\n<pre><code>// ./gatsby-node.js\n\nexports.onCreatePage = ({ page, actions }) =&gt; {\n  // Create localize version of pages...\n  const { createRedirect } = actions;\n\n  createRedirect({\n    fromPath: page.path,\n    toPath: `/en${page.path}`,\n    isPermanent: true,\n  });\n\n  createRedirect({\n    fromPath: page.path,\n    toPath: `/es${page.path}`,\n    isPermanent: true,\n    conditions: {\n      language: [`es`],\n    },\n  });\n};\n\n// etc.\n</code></pre>\n\n<p>We won’t see the difference right away since redirects don’t work in development, but if we don’t create a redirect for each page, the localized 404 pages won’t work in production. We didn’t have to do this same thing in Part 1 since <code>gatsby-theme-i18n</code> didn’t localize the 404 page the way we did.</p>\nChanging Locales\n<p>Another vital feature to add is a <strong>language selector component</strong> to toggle between the two locales. However, making a language selector isn’t completely straightforward because:</p>\n<ol>\n<li>We need to know the current page’s path, like <code>/en/recipes/pizza</code>,</li>\n<li>Then extract the <code>recipes/pizza</code> part, and</li>\n<li>Add the desired locale, getting <code>/es/recipes/pizza</code>.</li>\n</ol>\n<p>Similar to Part 1, we will have to access the page’s location information (URL, HREF, path, and so on) in all of our components, so it will be necessary to set up another context provider at the <code>wrapPageElement</code> function to pass down the <code>location</code> object through context on each page. A deeper explanation can be found in Part 1.</p>\n<h3>Setting Up A Location Context</h3>\n<p>First, we will create the location context at <code>./src/context/LocationContext.js</code>:</p>\n<pre><code>// ./src/context/LocationContext.js\n\nimport * as React from \"react\";\nimport { createContext } from \"react\";\n\nexport const LocationContext = createContext();\nexport const LocationProvider = ({ location, children }) =&gt; {\n  return &lt;LocationContext.Provider value={location}&gt;{children}&lt;/LocationContext.Provider&gt;;\n};\n</code></pre>\n\n<p>Next, let’s pass the page’s <code>location</code> object to the provider’s <code>location</code> attribute on each Gatsby file:</p>\n<pre><code>// ./gatsby-ssr.js &amp; ./gatsby-browser.js\n\nimport * as React from \"react\";\nimport { LocaleProvider } from \"./src/context/LocaleContext\";\nimport { LocationProvider } from \"./src/context/LocationContext\";\n\nexport const wrapPageElement = ({ element, props }) =&gt; {\n  const { location } = props;\n  const { locale } = element.props.pageContext;\n\n  return (\n    &lt;LocaleProvider locale={locale}&gt;\n      &lt;LocationProvider location={location}&gt;{element}&lt;/LocationProvider&gt;\n    &lt;/LocaleProvider&gt;\n  );\n};\n</code></pre>\n\n<h3>Creating An i18n Config</h3>\n<p>For the next step, it will come in handy to create a file with all our i18n details, such as the locale code or the local name. We can do it in a new <code>config.js</code> file in a new <code>i18n/</code> directory in the root directory of the project.</p>\n<pre><code>// ./i18n/config.js\n\nexport const config = [\n  {\n    code: \"en\",\n    hrefLang: \"en-US\",\n    name: \"English\",\n    localName: \"English\",\n  },\n\n  {\n    code: \"es\",\n    hrefLang: \"es-ES\",\n    name: \"Spanish\",\n    localName: \"Español\",\n  },\n];\n</code></pre>\n\n<h3>The <code>LanguageSelector</code> Component</h3>\n<p>The last thing is to remove the locale (i.e., <code>es</code> or <code>en</code>) from the path (e.g., <code>/es/recipes/pizza</code> or <code>/en/recipes/pizza</code>). Using the following simple but ugly regex, we can remove all the <code>/en/</code> and <code>/es/</code> at the beginning of the path:</p>\n<pre><code>/(\\/e(s|n)|)(\\/*|)/\n</code></pre>\n\n<p>It’s important to note that the <strong>regex pattern only works for the <code>en</code> and <code>es</code> combination of locales</strong>.</p>\n<p>Now we can create our <code>LanguageSelector</code> component at <code>./src/components/LanguageSelector.js</code>:</p>\n<pre><code>// ./src/components/LanguageSelector.js\n\nimport * as React from \"react\";\nimport { useContext } from \"react\";\n// 1\nimport { config } from \"../../i18n/config\";\nimport { Link } from \"gatsby\";\nimport { LocationContext } from \"../context/LocationContext\";\nimport { LocaleContext } from \"../context/LocaleContext\";\n\nexport const LanguageSelector = () =&gt; {\n// 2\n  const locale = useContext(LocaleContext);\n// 3\n  const { pathname } = useContext(LocationContext);\n// 4\n  const removeLocalePath = /(\\/e(s|n)|)(\\/*|)/;\n  const pathnameWithoutLocale = pathname.replace(removeLocalePath, \"\");\n// 5\n  return (\n    &lt;div&gt;\n      { config.map(({code, localName}) =&gt; {\n        return (\n          code !== locale &amp;&amp; (\n            &lt;Link key={code} to={`/${code}/${pathnameWithoutLocale}`}&gt;\n              {localName}\n            &lt;/Link&gt;\n          )\n        );\n      }) }\n    &lt;/div&gt;\n);\n};\n</code></pre>\n\n<p>Let’s break down what is happening in that code:</p>\n<ol>\n<li>We get our i18n configurations from the <code>./i18n/config.js</code> file instead of the <code>useLocalization</code> hook that was provided by the <code>gatsby-theme-i18n</code> plugin in Part 1.</li>\n<li>We get the current locale through context.</li>\n<li>We find the page’s current pathname through context, which is the part that comes after the domain (e.g., <code>/en/recipes/pizza</code>).</li>\n<li>We remove the locale part of the pathname using the regex pattern (leaving just <code>recipes/pizza</code>).</li>\n<li>We render a link for each available locale except the current one. So we check if the locale is the same as the page before rendering a common Gatsby <code>Link</code> to the desired locale.</li>\n</ol>\n<p>Now, inside our <code>gatsby-ssr.js</code> and <code>gatsby-browser.js</code> files, we can add our <code>LanguageSelector</code>, so it is available globally on the site at the top of all pages:</p>\n<pre><code>// ./gatsby-ssr.js &amp; ./gatsby-browser.js\n\nimport * as React from \"react\";\nimport { LocationProvider } from \"./src/context/LocationContext\";\nimport { LocaleProvider } from \"./src/context/LocaleContext\";\nimport { LanguageSelector } from \"./src/components/LanguageSelector\";\n\nexport const wrapPageElement = ({ element, props }) =&gt; {\n  const { location } = props;\n  const { locale } = element.props.pageContext;\n\n  return (\n    &lt;LocaleProvider locale={locale}&gt;\n      &lt;LocationProvider location={location}&gt;\n        &lt;LanguageSelector /&gt;\n        {element}\n      &lt;/LocationProvider&gt;\n    &lt;/LocaleProvider&gt;\n  );\n};\n</code></pre>\n\n\n\nLocalizing Static Content\n<p>The last thing to do would be to localize the static content on our site, like the page titles and headers. To do this, we will need to save our translations in a file and find a way to display the correct one depending on the page’s locale.</p>\n<h3>Page Body Translations</h3>\n<p>In Part 1, we used the <code>react-intl</code> package for adding our translations, but we can do the same thing from scratch. First, we will need to create a new <code>translations.js</code> file in the <code>/i18n</code> folder that holds all of our translations. </p>\n<p>We will create and export a <code>translations</code> object with two properties: <code>en</code> and <code>es</code>, which will hold the translations as strings under the same property name.</p>\n<div>\n<pre><code>// ./i18n/translations.js\n\nexport const translations = {\n  en: {\n    index_page_title: \"Welcome to my English cooking blog!\",\n    index_page_subtitle: \"Written by Juan Diego Rodríguez\",\n    not_found_page_title: \"Page not found\",\n    not_found_page_body: \"😔 Sorry, we were unable find what you were looking for.\",\n    not_found_page_back_link: \"Go Home\",\n  },\n  es: {\n    index_page_title: \"¡Bienvenidos a mi blog de cocina en español!\",\n    index_page_subtitle: \"Escrito por Juan Diego Rodríguez\",\n    not_found_page_title: \"Página no encontrada\",\n    not_found_page_body: \"😔 Lo siento, no pudimos encontrar lo que buscabas\",\n    not_found_page_back_link: \"Ir al Inicio\",\n  },\n};\n</code></pre>\n</div>\n\n<p>We know the page’s locale from the <code>LocaleContext</code> we set up earlier, so we can load the correct translation using the desired property name. </p>\n<p>The cool thing is that no matter how many translations we add, we won’t bloat our site’s bundle size since Gatsby builds the entire app into a static site.</p>\n<pre><code>// ./src/pages/index.js\n\n// etc.\n\nimport { LocaleContext } from \"../context/LocaleContext\";\nimport { useContext } from \"react\";\nimport { translations } from \"../../i18n/translations\";\n\nconst IndexPage = ({ data }) =&gt; {\n  const recipes = data.allMarkdownRemark.nodes;\n  const locale = useContext(LocaleContext);\n\n  return (\n    &lt;main&gt;\n      &lt;h1&gt;{translations[locale].index_page_title}&lt;/h1&gt;\n      &lt;h2&gt;{translations[locale].index_page_subtitle}&lt;/h2&gt;\n      {recipes.map(({frontmatter}) =&gt; {\n        return &lt;RecipePreview key={frontmatter.slug} data={frontmatter} /&gt;;\n      })}\n    &lt;/main&gt;\n  );\n};\n\n// etc.\n</code></pre>\n\n<div>\n<pre><code>// ./src/pages/404.js\n\n// etc.\n\nimport { LocaleContext } from \"../context/LocaleContext\";\nimport { useContext } from \"react\";\nimport { translations } from \"../../i18n/translations\";\n\nconst NotFoundPage = () =&gt; {\n  const locale = useContext(LocaleContext);\n\n  return (\n    &lt;main&gt;\n      &lt;h1&gt;{translations[locale].not_found_page_title}&lt;/h1&gt;\n      &lt;p&gt;\n        {translations[locale].not_found_page_body} &lt;br /&gt;\n        &lt;Link to=\"/\"&gt;{translations[locale].not_found_page_back_link}&lt;/Link&gt;.\n      &lt;/p&gt;\n    &lt;/main&gt;\n  );\n};\n\n// etc.\n</code></pre>\n</div>\n\n<p><strong>Note</strong>: <em>Another way we can access the <code>locale</code> property is by using <code>pageContext</code> in the page <code>props</code>.</em></p>\n<h3>Page Title Translations</h3>\n<p>We ought to localize the site’s page titles the same way we localized our page content. However, in <a href=\"https://www.smashingmagazine.com/2023/06/gatsby-headaches-i18n-part-1/#gatsby-theme-i18n\">Part 1</a>, we used <code>react-helmet</code> for the task since the <code>LocaleContext</code> isn’t available at the <a href=\"https://www.gatsbyjs.com/docs/reference/built-in-components/gatsby-head/\">Gatsby Head API</a>. So, to complete this task without resorting to a third-party plugin, we will take a different path. We’re unable to access the locale through the <code>LocaleContext</code>, but as I noted above, we can still get it with the <code>pageContext</code> property in the page <code>props</code>.</p>\n<pre><code>// ./src/page/index.js\n\n// etc.\n\nexport const Head = ({pageContext}) =&gt; {\n  const {locale} = pageContext;\n  return &lt;title&gt;{translations[locale].index_page_title}&lt;/title&gt;;\n};\n\n// etc.\n</code></pre>\n\n<pre><code>// ./src/page/404.js\n\n// etc.\n\nexport const Head = ({pageContext}) =&gt; {\n  const {locale} = pageContext;\n  return &lt;title&gt;{translations[locale].not_found_page_title}&lt;/title&gt;;\n};\n\n// etc.\n</code></pre>\n\nFormatting\n<p>Remember that i18n also covers formatting numbers and dates depending on the current locale. We can use the <code>Intl</code> object from the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl\">JavaScript Internationalization API</a>. The <code>Intl</code> object holds several constructors for formatting numbers, dates, times, plurals, and so on, and it’s globally available in JavaScript.</p>\n<p>In this case, we will use the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat\"><code>Intl.DateTimeFormat</code> constructor</a> to localize dates in blog posts. It works by creating a new <code>Intl.DateTimeFormat</code> object with the locale as its parameter:</p>\n<pre><code>const DateTimeFormat = new Intl.DateTimeFormat(\"en\");\n</code></pre>\n\n<p>The new <code>Intl.DateTimeFormat</code> and other <code>Intl</code> instances have several methods, but the main one is the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/format\"><code>format</code> method</a>, which takes a <code>Date</code> object as a parameter.</p>\n<pre><code>const date = new Date();\nconsole.log(new Intl.DateTimeFormat(\"en\").format(date)); // 4/20/2023\nconsole.log(new Intl.DateTimeFormat(\"es\").format(date)); // 20/4/2023\n</code></pre>\n\n<p>The <code>format</code> method takes an <code>options</code> object as its second parameter, which is used to customize how the date is displayed. In this case, the <code>options</code> object has a <code>dateStyle</code> property to which we can assign <code>\"full\"</code>, <code>\"long\"</code>, <code>\"medium\"</code>, or <code>\"short\"</code> values depending on our needs:</p>\n<pre><code>const date = new Date();\n\nconsole.log(new Intl.DateTimeFormat(\"en\", {dateStyle: \"short\"}).format(date)); // 4/20/23\nconsole.log(new Intl.DateTimeFormat(\"en\", {dateStyle: \"medium\"}).format(date)); // Apr 20, 2023\nconsole.log(new Intl.DateTimeFormat(\"en\", {dateStyle: \"long\"}).format(date)); // April 20, 2023\nconsole.log(new Intl.DateTimeFormat(\"en\", {dateStyle: \"full\"}).format(date)); // Thursday, April 20, 2023\n</code></pre>\n\n<p>In the case of our blog posts publishing date, we will set the <code>dateStyle</code> to <code>\"long\"</code>.</p>\n<div>\n<pre><code>// ./src/pages/recipes/{markdownRemark.frontmatter__slug}.js\n\n// etc.\n\nconst RecipePage = ({ data, pageContext }) =&gt; {\n  const { html, frontmatter } = data.markdownRemark;\n  const { title, cover_image, date } = frontmatter;\n  const { locale } = pageContext;\n  const cover_image_data = getImage(cover_image.image.childImageSharp.gatsbyImageData);\n\n  return (\n    &lt;main&gt;\n      &lt;h1&gt;{title}&lt;/h1&gt;\n      &lt;p&gt;{new Intl.DateTimeFormat(locale, { dateStyle: \"long\" }).format(new Date(date))}&lt;/p&gt;\n      &lt;GatsbyImage image={cover_image_data} alt={cover_image.alt} /&gt;\n      &lt;p dangerouslySetInnerHTML={{__html: html}}&gt;&lt;/p&gt;\n    &lt;/main&gt;\n  );\n};\n\n// etc.\n</code></pre>\n</div>\n\nConclusion\n<p>And just like that, we reduced the need for several i18n plugins to a grand total of zero. And we didn’t even lose any functionality in the process! If anything, our hand-rolled solution is actually more robust than the system of plugins we cobbled together in <a href=\"https://www.smashingmagazine.com/2023/06/gatsby-headaches-i18n-part-1/\">Part 1</a> because we now have localized 404 pages.</p>\n<p>That said, both approaches are equally valid, but in times when Gatsby plugins are unsupported in some way or conflict with other plugins, it is sometimes better to create your own i18n solution. That way, you don’t have to worry about plugins that are outdated or left unmaintained. And if there is a conflict with another plugin, you control the code and can fix it. I’d say these sorts of benefits greatly outweigh the obvious convenience of installing a ready-made, third-party solution.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"9d1dbea1da81500a93a06cbfa35b8d377f451c84e35d8b50886a915a95ffbaca","category":"Tech"}