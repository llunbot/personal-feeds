{"title":"Building A Drupal To Storyblok Migration Tool: An Engineering Perspective","link":"https://smashingmagazine.com/2025/04/building-drupal-storyblok-migration-tool-engineering-perspective/","date":1743595200000,"content":"<p>This article is a sponsored by <a href=\"https://www.storyblok.com/?utm_source=smashing&amp;utm_medium=sponsor&amp;utm_campaign=DGM_DEV_SMA_TRA&amp;utm_content=smashing-OSS\">Storyblok</a></p>\n<p>Content management is evolving. The traditional monolithic CMS approach is giving way to headless architectures, where content management and presentation are decoupled. This shift brings new challenges, particularly when organizations need to migrate from legacy systems to modern headless platforms.</p>\n<p>Our team encountered this scenario when creating a migration path from Drupal to Storyblok. These systems handle content architecture quite differently — Drupal uses an entity-field model integrated with PHP, while Storyblok employs a flexible Stories and Blocks structure designed for headless delivery.</p>\n<p>If you just need to use a script to do a simple — yet extensible — content migration from Drupal to Storyblok, I already shared <a href=\"https://www.storyblok.com/tp/migrating-drupal-articles-to-storyblok\">step-by-step instructions</a> on how to download and use it. If you’re interested in the process of creating such a script so that you can write your own (possibly) better version, stay here!</p>\n<p>We observed that developers sometimes struggle with manual content transfers and custom scripts when migrating between CMSs. This led us to develop and share our migration approach, which we implemented as an open-source tool that others could use as a reference for their migration needs.</p>\n<p>Our solution combines two main components: a custom Drush command that handles content mapping and transformation and a new PHP client for Storyblok’s Management API that leverages modern language features for improved developer experience.</p>\n<p>We’ll explore the engineering decisions behind this tool’s development, examining our architectural choices and how we addressed real-world migration challenges using modern PHP practices.</p>\n<blockquote><p><strong>Note</strong>: You can find the complete source code of the migration tool <a href=\"https://github.com/storyblok/drupal-exporter\">in the Drupal exporter repo</a>.</p></blockquote>\n\nPlanning The Migration Architecture\n<p>The journey from Drupal to Storyblok presents unique architectural challenges. The fundamental difference lies in how these systems conceptualize content: Drupal structures content as entities with fields, while Storyblok uses a component-based approach with Stories and Blocks.</p>\n<h3>Initial Requirements Analysis</h3>\n<p>A successful migration tool needs to understand both systems intimately. Drupal’s content model relies heavily on its Entity API, storing content as structured field collections within entities. A typical Drupal article might contain fields for the title, body content, images, and taxonomies. <a href=\"https://www.storyblok.com/?utm_source=smashing&amp;utm_medium=sponsor&amp;utm_campaign=DGM_DEV_SMA_TRA&amp;utm_content=smashing-OSS\">Storyblok</a>, on the other hand, structures content as stories that contain blocks, reusable components that can be nested and arranged in a flexible way. It’s a subtle difference that shaped our technical requirements, particularly around content mapping and data transformation, but ultimately, it’s easy to see the relationships between the two content models.</p>\n<h3>Technical Constraints</h3>\n<p>Early in development, we identified several key constraints. <a href=\"https://www.storyblok.com/docs/api/management/getting-started/?utm_source=smashing&amp;utm_medium=sponsor&amp;utm_campaign=DGM_DEV_SMA_TRA&amp;utm_content=smashing-OSS\">Storyblok’s Management API</a> enforces rate limits that affect how quickly we can transfer content. Media assets must first be uploaded and then linked. Error recovery becomes essential when migrating hundreds of pieces of content.</p>\n<p>The brand-new<a href=\"https://github.com/storyblok/php-management-api-client\"> Management API PHP client</a> handles these constraints through built-in retry mechanisms and response validation, so in writing a migration script, we don’t need to worry about them.</p>\n<h3>Tool Selection</h3>\n<p>We chose Drush as our command-line interface for several reasons. First, it’s deeply integrated with Drupal’s bootstrap process, providing direct access to the Entity API and field data. Second, Drupal developers are already familiar with its conventions, making our tool more accessible.</p>\n<p>The decision to develop a new <strong>Management API client</strong> came from our experience with the evolution of PHP since we developed the first PHP client, and our goal to provide developers with a dedicated tool for this specific API that offered an improved DX and a tailored set of features.</p>\n<p>This groundwork shaped how we approached the migration workflow.</p>\nThe Building Blocks: A New Management API Client\n<p>A content migration tool interacts heavily with Storyblok’s Management API &amp;mdash, creating stories, uploading assets, and managing tags. Each operation needs to be reliable and predictable. Our brand-new client simplifies these interactions through intuitive method calls: The client handles authentication, request formatting, and response parsing behind the scenes, letting devs focus on content operations rather than API mechanics.</p>\n<h3>Design For Reliability</h3>\n<p>Content migrations often involve hundreds of API calls. Our client includes built-in mechanisms for handling common scenarios like rate limiting and failed requests. The response handling pattern provides clear feedback about operation success: A logger can be injected into the client class, as we did using the Drush logger in our migration script from Drupal.</p>\n<h3>Improving The Development Experience</h3>\n<p>Beyond basic API operations, the client reduces cognitive load through predictable patterns. Data objects provide a structured way to prepare content for Storyblok: This pattern validates data early in the process, catching potential issues before they reach the API.</p>\nDesigning The Migration Workflow\n<p>Moving from Drupal’s entity-based structure to Storyblok’s <strong>component model</strong> required careful planning of the migration workflow. Our goal was to create a process that would be both reliable and adaptable to different content structures.</p>\n<h3>Command Structure</h3>\n<p>The migration leverages Drupal’s <em>entity query</em> system to extract content systematically. By default, <strong>access checks were disabled</strong> (a reversible business decision) to focus solely on migrating <strong>published nodes</strong>.</p>\n<h3>Key Steps And Insights</h3>\n<ul>\n<li><p><strong>Text Fields</strong>  </p>\n<ul>\n<li>Required minimal effort: values like <code>value()</code> mapped directly to Storyblok fields.  </li>\n<li>Rich text posed no encoding challenges, enabling straightforward 1:1 transfers.</li>\n</ul>\n</li>\n<li><p><strong>Handling Images</strong>  </p>\n<ol>\n<li><strong>Upload</strong>: Assets were sent to an AWS S3 bucket.</li>\n<li><strong>Link</strong>: Storyblok’s <strong>Asset API</strong> <code>upload()</code> method returned an <code>object_id</code>, simplifying field mapping.</li>\n<li><strong>Assign</strong>: The asset ID and filename were attached to the story.</li>\n</ol>\n</li>\n<li><p><strong>Managing Tags</strong></p>\n<ul>\n<li>Tags extracted from Drupal were pre-created via Storyblok’s <strong>Tag API</strong> (optional but ensures consistency).</li>\n<li>When assigning tags to stories, Storyblok automatically creates missing ones, streamlining the process.</li>\n</ul>\n</li>\n</ul>\n<h3>Why Staged Workflows Matter</h3>\n<p>The migration avoids broken references by prioritizing dependencies (assets first, tags next, content last). While pre-creating tags add control, teams can adapt this logic—for example, letting Storyblok auto-generate tags to save time.</p>\n<blockquote><p>Flexibility is key: every decision (access checks, tag workflows) can be adjusted to align with project goals.</p></blockquote>\n\nReal-World Implementation Challenges\n<p>Migrating content between Drupal and Storyblok presents challenges that you, as the implementer, may encounter.</p>\n<p>For example, when dealing with large datasets, you may find that Drupal sites with thousands of nodes can quickly hit the rate limits enforced by Storyblok’s management API. In such cases, a batching mechanism for your requests is worth considering. Instead of processing every node at once, you can process a subset of records, wait for a short period of time, and then continue.</p>\n<p>Alternatively, you could use the <code>createBulk</code> method of the Story API in the Management API, which allows you to handle multiple story creations with built-in rate limit handling and retries. Another potential hurdle is the conversion of complex field types, especially when Drupal’s nested structures or Paragraph fields need to be mapped to Storyblok’s more flexible block-based model.</p>\n<p>One approach is first to analyze the nesting depth and structure of the Drupal content, then flatten deeply nested elements into reusable Storyblok components while maintaining the correct hierarchy. For example, a <code>paragraph</code> field with embedded media and text can be split into blocks within Storyblok, with each component representing a logical section of content. By structuring data this way before migration, you ensure that content remains editable and properly structured in the new system.</p>\n<p>Data consistency is another aspect that you need to manage carefully. When migrating hundreds of records, partial failures are always risky. One approach to managing this is to log detailed information for each migration operation and implement a retry mechanism for failed operations.</p>\n<p>For example, wrapping API calls in a <code>try-catch</code> block and logging errors can be a practical way to ensure that no records are silently dropped. When dealing with fields such as taxonomy terms or tags created on the fly in Storyblok, you may run into duplication issues. A good practice is to perform a check before creating a new tag. This could involve maintaining a local cache of previously created tags and checking against them before sending a create request to the API.</p>\n<p>The same goes for images; a check could ensure you don’t upload the same asset twice.</p>\nLessons Learned And Looking Forward\n<p>A <strong>dedicated API client</strong> for Storyblok streamlined interactions, abstracting backend complexity while improving code maintainability. Early use of <strong>structured data objects</strong> to prepare content proved critical, enabling pre-emptive error detection and reducing API failures.</p>\n<p>We also ran into some challenges and see room for improvement:</p>\n<ul>\n<li><strong>Encoding issues</strong> in rich text (e.g., HTML entities) were resolved with a pre-processing step</li>\n<li><strong>Performance bottlenecks</strong> with large text/images required memory optimization and refined request handling</li>\n</ul>\n<p>Enhancements could include support for <em>Drupal Layout Builder</em>, advanced validation layers, or dynamic asset management systems.</p>\n<blockquote><p>💡 For deeper dives into our Management API client or migration strategies, reach out via <a href=\"https://discord.gg/jKrbAMz\">Discord</a>, explore the <a href=\"https://github.com/storyblok/php-management-api-client\">PHP Client repo</a>, or connect with me on <a href=\"https://hachyderm.io/@edodusi\">Mastodon</a>. Feedback and contributions are welcome!</p></blockquote>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"f53bd90013c5090c5bc1a5e0ab713572814361a38d70a362093375a1f992b1f1","category":"Tech"}