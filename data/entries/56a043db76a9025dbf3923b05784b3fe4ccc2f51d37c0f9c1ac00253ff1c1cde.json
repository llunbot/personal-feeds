{"title":"Wall of Text #15: Who compile the compiler","link":"https://blog.whs.in.th/node/3683","date":1697274004000,"content":"<p>เป็นคำถามที่สงสัยตั้งแต่เด็กๆ ว่าโปรแกรมเราเขียนใน Python แล้วเวลารันต้องใช้ Python interpreter ที่โหลดในเน็ตมา ตัวไฟล์ Python interpreter มันสร้างขึ้นมาได้ยังไง</p>\n<p>คำตอบก็ไปดูง่ายๆ คือ <a href=\"https://github.com/python/cpython\">CPython</a> ที่โหลดในเว็บมันเขียนด้วยภาษา C ก็เลยใช้ C compiler สร้างไฟล์นั้นขึ้นมา แล้วใครสร้างไฟล์ของ C compiler?</p>\n<h2>Linux from Scratch</h2>\n<p>ตอนประมาณ ม. ต้นเคยทำ <a href=\"https://www.linuxfromscratch.org\">Linux from Scratch</a> ซึ่งเป็นหนังสือที่สอนวิธีสร้าง Linux ตั้งแต่ต้นด้วยตนเอง ไม่ได้สร้างมาจาก Linux อื่นๆ ที่มีอยู่แล้ว เขาจะมีแผ่นซีดีมาให้ซึ่งมีโปรแกรมพื้นฐานให้ประมาณหนึ่ง (Linux จอดำ) จากนั้นให้เรา compile โปรแกรมต่างๆ</p>\n<p>ในเล่มบอกว่าตัว C compiler ที่ใช้คือโปรแกรม GCC ซึ่งเขียนด้วยภาษา C โดยให้เราเอา C compiler ในแผ่นซีดี compile GCC source code ก็แปลว่าต้องมี C compiler ก่อน จึงจะคอมไพล์ C compiler ได้ ก็เลยเป็นปัญหาไก่กับไข่ แต่มันตอบคำถามหนึ่งคือถ้าเราสร้างคอมพิวเตอร์สถาปัตยกรรมใหม่ (new computer architecture) ขึ้นมาเราจะเอา C compiler มาจากไหน <a href=\"https://www.linuxfromscratch.org/lfs/view/development/partintro/toolchaintechnotes.html\">โดยวิธีที่เขาเขียน</a> สมมุติว่าผมสร้างเครื่องสถาปัตยกรรม whs32 ขึ้นมา และใช้เครื่อง amd64 เป็นเครื่อง desktop ให้ทำดังนี้</p>\n<ol>\n<li>แก้ไขโค้ด gcc เพิ่มให้สามารถ generate machine code ของ whs32 ได้</li>\n<li>เอา compiler ในเครื่อง amd64 ที่ generate machine code ของ amd64 มา compile gcc ตัวใหม่ เรียกว่า <strong>stage1</strong> ซึ่งยังรันบน amd64 แต่ให้ผลลัพท์เป็นโค้ดที่รันใน whs32 (gcc สามารถเลือกให้ output machine code เป็นสถาปัตยกรรมเครื่องใดๆ ก็ได้ ไม่จำเป็นต้องเป็นเครื่องที่รันอยู่)</li>\n<li>เอา <strong>stage1</strong> ที่รันในเครื่อง amd64 มา compile ตัวเอง จะได้ gcc อีกตัวเรียกว่า <strong>stage2</strong> ซึ่งรันบน whs32 และให้ผลลัพท์เป็นโค้ดที่รันใน whs32</li>\n<li>เอา <strong>stage2</strong> รันบนเครื่อง whs32 มา compile ตัวเองใหม่ จะได้ stage3 เป็นอันเสร็จ\n<ul>\n<li>ที่ต้องทำ stage3 เพราะว่า stage2 อาจจะมีการอ้างอิง library, path ต่างๆ บนเครื่อง amd64 ทำให้ไปใช้งานจริงบนเครื่องอื่นไม่ได้ วิธีแก้ไขคือปิดฟีเจอร์ที่ไม่จำเป็นใน stage2 ออกไปก่อนเพื่อให้ compiler จบในตัว แล้วค่อย compile stage3 ที่มีฟีเจอร์ครบถ้วนในระบบจริง</li>\n<li>เวลา <a href=\"https://gcc.gnu.org/install/build.html\">gcc compile ตัวเอง</a> แบบไม่ข้ามสถาปัตยกรรม มันจะ compile 3 ครั้ง\n<ol>\n<li>ใช้ stage2 compile ตัวเองจาก source code เรียกว่า stage3.1</li>\n<li>ใช้ stage3.1 compile ตัวเองอีก 2 ครั้ง เรียกว่า stage3.2 และ stage3.3</li>\n<li>ตรวจสอบว่า stage3.2 = stage3.3 เพื่อทดสอบว่า compiler ทำงานได้ถูกต้อง</li>\n<li>ใช้ stage3.3 เป็นผลลัพท์ stage3</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<p>สรุปแล้วเราก็พอเข้าใจว่าถ้าสร้างชิพใหม่ขึ้นมาเราจะเอา compiler มาจากไหน แต่ compiler ตัวแรกมาจากไหน…? ก่อนจะเล่าต่อไป ขอไปเล่าเรื่องอื่นก่อนแล้วกัน</p>\n<h2>Why does this matter</h2>\n<p>Ken Thompson ผู้สร้างระบบปฏิบัติการ Unix และภาษา Go เคยตีพิมพ์ paper เรื่อง <a href=\"https://dl.acm.org/doi/10.1145/358198.358210\">Reflection on trusting trust (1984)</a> ว่าคุณจะรู้ได้อย่างไรว่า compiler ที่คุณใช้ไม่มี backdoor จริง</p>\n<p>สมมุติว่ามี compiler ตัวหนึ่งซึ่งมันจะ detect source code pattern อย่างหนึ่งแล้วแทรก backdoor ลงไป และ detect source code ตัวเองเพื่อแทรกโค้ดตัวมันเองเข้าไป ถ้าเรา compile compiler ตัวนี้แล้วก็จะทำให้ backdoor ฝังอยู่ใน compiler ซึ่ง compile compiler ใหม่ก็ไม่หาย แต่ตรวจสอบหา backdoor ใน source code ไม่พบ ถ้าอย่างนั้นแล้วคุณจะแน่ใจได้อย่างไร ว่าระบบที่ใช้งานอยู่ไม่มี backdoor</p>\n<p>ปรากฏว่า<a href=\"https://niconiconi.neocities.org/posts/ken-thompson-really-did-launch-his-trusting-trust-trojan-attack-in-real-life/\">มีผู้พบว่า Ken Thompson เคยโจมตีด้วยท่านี้จริง</a> โดยเขาเล่าในปี 1995 ว่าหลายสิบปีก่อนเขาสร้าง compiler แบบนี้จริงแล้วส่งให้แผนก UNIX support ติดตั้ง binary เข้าไปในระบบโดยอ้างว่ามีฟีเจอร์ใหม่ที่ไม่สามารถใช้ compiler เก่า compile source code ใหม่ได้ ใน compiler ใหม่นี้มีการฝัง backdoor ของโปรแกรม <code>login</code> ไว้</p>\n<p>ต่อมามีผู้พบว่า symbol table (function list) ของ compiler มันแปลกๆ ก็เลยสั่งให้ compiler print assembly ออกมาซึ่งระบบแทรก backdoor ไม่ได้เขียนไว้รองรับคำสั่งนี้ แล้วเอา assembly ไปแปลงเป็น machine code ทำให้ backdoor หายไป</p>\n<p>ในปัจจุบันจึงเป็นคำถามว่าถ้าหากเรามี backdoor ที่ซับซ้อนกว่าที่ Ken เคยสร้างไว้จริง เราจะมั่นใจได้อย่างไรว่าระบบคอมพิวเตอร์มีความปลอดภัยเพราะถึงแม้จะอ่านโค้ดทุกบรรทัดก็ไม่ได้แปลว่าจะเป็นโค้ดทั้งหมดของโปรแกรม</p>\n<h2>Go</h2>\n<p>Compiler ของภาษา Go เขียนขึ้นด้วยภาษา C ในตอนแรก <a href=\"https://go.dev/doc/go1.5#c\">จากนั้นถูกใช้เครื่องมือแปลงภาษา C เป็น Go ภายหลัง</a> ทำให้ Go compiler ในปัจจุบันเขียนด้วยภาษา Go ดังนั้นทีมงาน Go จึงแนะนำ<a href=\"https://go.dev/doc/install/source\">วิธีสร้าง Go compiler ดังนี้</a></p>\n<ol>\n<li>ดาวน์โหลดซอร์สโค้ด Go 1.4 ซึ่งเป็นรุ่นสุดท้ายที่เขียนด้วยภาษา C</li>\n<li>Compile Go 1.4</li>\n<li><a href=\"https://go.dev/doc/go1.20#bootstrap\">Compile Go 1.17.13 ด้วย Go 1.4</a></li>\n<li>Compile Go 1.20</li>\n<li>Compile Go รุ่นต่อๆ ไป โดยทีมงาน Go กำหนดว่า minimum compiler version ที่ใช้ compile รุ่นล่าสุดได้คือ version ที่ออกเมื่อประมาณ 1 ปีที่แล้ว</li>\n</ol>\n<p>อีกวิธีหนึ่งที่ทำได้คือมีอีกโปรแกรมที่ compile ภาษา Go ได้นั่นคือ <a href=\"https://go.dev/doc/install/gccgo\">gccgo</a> ซึ่งเขียนด้วยภาษา C และรองรับโค้ด Go ในระดับหนึ่ง สามารถใช้ gccgo compile Go รุ่นใหม่ได้เลย</p>\n<h2>Reproducible builds</h2>\n<p>ในปัจจุบัน <a href=\"https://reproducible-builds.org/who/projects/\">Linux distribution หลายตัว</a>เข้าร่วมโครงการ <a href=\"https://reproducible-builds.org/\">Reproducible builds</a> ซึ่งเป็นอีกวิธีหนึ่งที่พอจะแก้ปัญหาความปลอดภัยด้านบนได้บ้าง โดย Linux distro จะทำให้ผลลัพท์ของการสร้าง package นั้นสามารถทำซ้ำได้ไฟล์เดียวกัน 100% ซึ่งใครก็สามารถทำซ้ำ ตรวจสอบได้ตลอดเวลาเพื่อยืนยันว่า package นั้นเกิดจาก source code จริงๆ เพราะ Linux บางตัวไม่มีระบบ CI/CD กลางเนื่องจากเป็นค่าใช้จ่าย แต่ให้ผู้สร้างแพคเกจ compile บนเครื่องตัวเอง เซ็นแล้วอัพโหลดไปแจกจ่าย</p>\n<p>ขณะที่เขียนนี้ Package ทั้งหมดของ Linux ต่อไปนี้สามารถทำซ้ำ ตรวจสอบได้ด้วยตนเอง</p>\n<ul>\n<li>Arch Linux 78.5%</li>\n<li>Debian amd64 90.8%</li>\n<li>openSUSE 94%</li>\n</ul>\n<p>รวมถึง <a href=\"https://go.dev/blog/rebuild\">Go compiler 1.21</a> ด้วยที่ตัวที่ให้โหลดในหน้าเว็บ สามารถทำซ้ำได้ด้วยตนเอง</p>\n<p>ฟังดูเหมือนว่าง่ายๆ ว่าโค้ดเดิมก็ควรจะได้ผลลัพท์เดิมเสมอ แต่ในความเป็นจริงแล้วอาจจะมีปัจจัยต่างๆ ที่ทำให้ได้ผลลัพท์ต่างกันไป เช่น</p>\n<ul>\n<li>File metadata ไม่ตรงกัน ทำให้เวลาสร้าง/แตก zip แล้วไม่ตรง เช่น ชื่อเจ้าของไฟล์ สิทธิ์ หรือเวลาสร้างไฟล์</li>\n<li>สถาปัตยกรรมไม่ตรงกัน เช่น compile ครั้งแรกใช้เครื่อง 32 bit ต่อมาใช้เครื่อง 64 bit แต่ compile เป็นโปรแกรม 32 bit ทั้งคู่ อาจจะได้ผลลัพท์ต่างกันเพราะมีการบันทึกค่าไว้</li>\n<li>มีการฝังวันเวลาที่ compile เข้าไปในโปรแกรม (เช่นคำสั่ง version/about) ทำให้ได้ผลลัพท์ไม่ตรงกัน ซึ่งต้องลบโค้ดออกหรือกำหนดเป็นวันเวลาที่ fix ไว้</li>\n<li>มีการฝัง path ที่ compile เข้าไปในโปรแกรม (เช่นใน stack trace เวลา crash) เวลาทำซ้ำอาจจะทำที่ path อื่น หรือระบุ path คนละแบบกัน (absolute/relative) ซึ่งจะต้องบันทึก path ไว้หรือให้ compiler normalize path ได้</li>\n<li>มีการฝังข้อมูลเครื่องที่ compile เข้าไปในโปรแกรม เช่น username, hostname, timezone, language</li>\n<li>Library ที่ใช้ไม่ตรงกัน เช่น มีการใช้ library ในเครื่องที่ไม่แจ้งไว้ พอคนอื่นไป compile แล้วหาไม่เจอ, ใช้ version ไม่ตรงกัน, compiler คนละตัวกัน</li>\n<li>ในโค้ดมีการสุ่ม เช่นอ่านข้อมูลจาก filesystem หรือ HashMap มาแล้วไม่ได้ sort แต่ละครั้งจึงได้ลำดับสลับกัน</li>\n</ul>\n<p>ดังนั้นผู้สร้างแพคเกจจะต้องตรวจหาปัญหาเหล่านี้และแก้ไขให้เรียบร้อย ซึ่งบางครั้ง compiler เองก็อาจจะเป็นที่มาของปัญหาเหล่านี้ได้เช่นกัน ไม่ใช่เฉพาะแค่ใน source code</p>\n<p>เนื่องจาก Linux หลายตัวสามารถสร้างได้จาก source code อยู่แล้ว (ถึงอาจจะไม่ได้เท่ากันทุก bytes) ดังนั้นบริษัทใหญ่ๆ หลายที่จึงสร้าง Linux ของตัวเองซึ่งโปรแกรมส่วนมากก็เอามาจาก Linux อื่นๆ แต่ compile เองจะได้ไม่ต้องไว้ใจคนอื่น และอาจจะ modify ตามที่ตัวเองสนใจได้ด้วย เช่น</p>\n<ul>\n<li><a href=\"https://github.com/microsoft/CBL-Mariner\">Microsoft CBL Mariner</a> ซึ่งใช้ใน WSL มาจาก VMware Photon, Fedora, Openmamba</li>\n<li><a href=\"https://aws.amazon.com/linux/amazon-linux-2023/\">Amazon Linux</a> ซึ่งมาจาก <a href=\"https://docs.aws.amazon.com/linux/al2023/ug/relationship-to-fedora.html\">Fedora คละรุ่น</a></li>\n<li><a href=\"https://www.tencentcloud.com/document/product/213/46183#in-what-editions-is-tencentos-server-available.3F\">TencentOS</a> มาจาก CentOS/Red Hat Enterprise Linux</li>\n</ul>\n<h2>Guix Bootstrap</h2>\n<p>ที่เล่าไปด้านบนก็คือวิธีบริหารความเสี่ยงที่ใช้กันทั่วไปว่า Linux ที่ใช้งานอยู่นั้นเชื่อถือได้ แต่ยังอยู่บนข้อจำกัดว่าระบบที่ใช้งานอยู่เชื่อถือได้ และ C compiler ปัจจุบันเชื่อถือได้ ถ้าเราต้องการ C compiler ที่เชื่อถือได้จะทำอย่างไรดี</p>\n<p>Guix เป็น Linux distribution ของโครงการ GNU ซึ่งมองว่าระบบ Linux นั้นสามารถ reproducible ได้จาก source code โดยขั้นตอนการ reproduce ก็เป็น source code เช่นเดียวกันซึ่งเขียนด้วยภาษา Scheme การติดตั้งแพคเกจต่างๆ ก็คือให้มัน reproduce build ของโปรแกรมนั้นๆ ขึ้นมา</p>\n<p>ในขณะนี้ <a href=\"https://guix.gnu.org/en/blog/2023/the-full-source-bootstrap-building-from-source-all-the-way-down/\">Guix ใช้โครงการ bootstrap-seeds เป็นจุดเริ่มต้น</a> โดย bootstrap-seed ทำงานดังนี้</p>\n<ol>\n<li>กำหนดไฟล์ <a href=\"https://esolangs.org/wiki/Hex0\">hex0</a> เป็นการแสดงเลขฐาน 2 ในรูปแบบเลขฐาน 16 (เช่นในไฟล์เขียนว่าว่า <code>F0</code> ให้ output <code>11110000</code>) และรองรับการใส่ comment</li>\n<li>สร้างโปรแกรมสำหรับแปลงไฟล์ <a href=\"https://raw.githubusercontent.com/oriansj/bootstrap-seeds/42c20ae1f1cf4fa895bcc2c8edd6429bdb24cf6a/POSIX/x86/hex0_x86.hex0\">hex0</a> ซึ่งเขียนด้วย machine code ของเครื่อง x86 ในรูปแบบไฟล์ hex0 โดย Guix จะใช้ไฟล์ <a href=\"https://github.com/oriansj/bootstrap-seeds/blob/42c20ae1f1cf4fa895bcc2c8edd6429bdb24cf6a/POSIX/x86/hex0-seed\">hex0-seed</a> ขนาด 357 bytes ที่แปลงมาสำเร็จรูปแล้ว แต่เราจะแปลงเองด้วยมือก็ได้</li>\n<li>Compile โปรแกรม <a href=\"https://github.com/oriansj/stage0-posix-x86/blob/e86bf7d304bae5ce5ccc88454bb60cf0837e941f/hex1_x86.hex0\">hex1</a> ซึ่งเขียนด้วย hex0 โดย hex1 เป็นภาษาที่ปรับปรุงขึ้นมาจาก hex0 สามารถใช้ label สำหรับ jump ได้ (ก็คือต้องสามารถแทรก relative offset ของจุดที่แปะ label ไว้ในไฟล์จากจุดปัจจุบันได้)</li>\n<li>Compile โปรแกรม <a href=\"https://github.com/oriansj/stage0-posix-x86/blob/e86bf7d304bae5ce5ccc88454bb60cf0837e941f/hex2_x86.hex1\">hex2</a> ซึ่งเขียนด้วย hex1 โดย hex2 จะเพิ่มความสามารถที่ label มีหลายตัวอักษรได้และสามารถหาตำแหน่งแบบ absolute ของ label ได้</li>\n<li>Compile โปรแกรม <a href=\"https://github.com/oriansj/stage0-posix-x86/blob/e86bf7d304bae5ce5ccc88454bb60cf0837e941f/M0_x86.hex2\">M0</a> ซึ่งเขียนด้วย hex2 ซึ่งสามารถกำหนด macro ได้ (ชุดคำสั่งที่ให้พิมพ์ซ้ำ)</li>\n<li>Compile โปรแกรม <a href=\"https://github.com/oriansj/stage0-posix-x86/blob/e86bf7d304bae5ce5ccc88454bb60cf0837e941f/cc_x86.M1\">cc</a> ซึ่งเขียนด้วย M0 เป็น C compiler แบบง่ายๆ ที่ใช้ชุดคำสั่งได้จำกัด</li>\n<li>Compile โปรแกรม <a href=\"https://github.com/oriansj/M2-Planet\">M2-Planet</a> ซึ่งเขียนด้วยภาษา C เท่าที่โปรแกรม cc รองรับ เป็น C compiler ที่รองรับชุดคำสั่งได้มากขึ้น</li>\n<li>Compile โปรแกรม <a href=\"https://www.gnu.org/software/mes/\">GNU Mes</a> ซึ่งเป็น C compiler และ interpreter ของภาษา Scheme (ที่ Guix ใช้) โดยสามารถคอมไพล์ได้จาก M2-Planet</li>\n<li>Compile โปรแกรม <a href=\"https://gitlab.com/janneke/tinycc\">TinyCC (fork)</a> ซึ่งสามารถใช้ compile GCC และไลบรารีอื่นๆ ที่ใช้งานใน Linux ปกติได้</li>\n</ol>\n<p>(ในนี้ไม่รวมถึง tool อื่นๆ ที่ใช้ประกอบการรัน tool ข้างบน เช่น <code>cat</code>, shell, debug tool, linker, C standard library เป็นต้น)</p>\n<p>หลังจากเรามี GCC และ library อื่นๆ แล้วก็สามารถ compile โปรแกรมอื่นๆ ไปเรื่อยๆ จนถึงโปรแกรมที่เราต้องการได้ เช่น Python interpreter โดยถ้าเราเชื่อว่า source code ทั้งหมดที่ใช้น่าเชื่อถือ ไม่มี backdoor แล้วกระบวนการนี้ก็ทำให้เรามั่นใจได้ว่าสามารถสร้างระบบ Linux ขึ้นมาได้โดยไม่ต้องใช้ compiler ตั้งต้น</p>\n<p>ในปัจจุบันข้อจำกัดของระบบนี้คือต้องเชื่อได้ว่า Kernel ที่รันอยู่น่าเชื่อถือ เพราะเรารัน hex0 บน Kernel ปัจจุบัน ในอนาคตทีมงาน bootstrappable.org มีความคิดที่จะพัฒนา CPU architecture “Knight” ซึ่งสามารถออกแบบเป็นวงจร FPGA ได้เพื่อใช้สร้าง hex0 โดยไม่ต้องใช้คอมพิวเตอร์ และ <a href=\"https://github.com/ironmeld/builder-hex0\">builder-hex0</a> ที่เป็น OS พื้นฐานสามารถรัน hex0 ได้ในตัว</p>\n<h2>The original C compiler</h2>\n<p>แล้ว C compiler ตัวแรกสร้างมาจากไหน?</p>\n<p><a href=\"https://www.bell-labs.com/usr/dmr/www/chist.html\">Dennis Richie</a> (RIP) เขียนบันทึกไว้ว่า UNIX ตัวแรกถูกสร้างขึ้นโดย Ken Thompson (จำชื่อนี้ได้ไหม) ในปี 1968 โดยใช้โปรแกรม assembler (คล้ายๆ M0) ของเครื่อง <a href=\"https://en.wikipedia.org/wiki/GE-600_series\">GE-635</a> สร้างแถบกระดาษสำหรับเครื่อง PDP-7 จนมีโปรแกรมพื้นฐานพร้อมใช้งาน ได้แก่ Kernel, editor, shell, คำสั่ง rm, cat, cp และ assembler จากนั้นก็เริ่มพัฒนาบนเครื่อง PDP-7 ต่อ</p>\n<p>ในปีต่อมา Doug McIlroy สร้างภาษา TMG (TransMoGrifiers) สำหรับ UNIX บน PDP-7 ขึ้นมาเป็นภาษาโปรแกรมระดับสูงตัวแรก แล้ว Ken ก็สร้างภาษา B ขึ้นโดยเขียนในภาษา TMG โดยอ้างอิงแบบมาจากภาษา BCPL ของ Martin Richards หลังจากสร้างขึ้นสำเร็จก็ได้เขียนภาษา B ใหม่อีกครั้งหนึ่งในภาษา B เอง</p>\n<p>ในปี 1971 Dennis Richie พบว่าภาษา B เริ่มตามไม่ทันเครื่องคอมพิวเตอร์ที่อัพเกรดเป็นรุ่น PDP-11 จึงปรับปรุงภาษาขึ้นเป็นภาษา NB (New B) พร้อมกับคอมไพเลอร์ตัวใหม่ ซึ่งต่อมาก็ได้เปลี่ยนชื่อเป็น C</p>\n<p>สำหรับ GCC ผมยังไม่เห็นประวัติว่าใช้ compiler ใดสร้างขึ้น แต่โปรแกรมส่วนมากของโครงการ GNU ถูกสร้างขึ้นบนเครื่อง UNIX ก็เป็นไปได้ว่าอาจจะใช้ C compiler ของ Dennis Richie</p>","author":"whs","siteTitle":"Quietly Verbose","siteHash":"5f972a6fe70a917eb1b1aa165b3cb2be8a9465af33ab38bf05f34c55c0e40587","entryHash":"56a043db76a9025dbf3923b05784b3fe4ccc2f51d37c0f9c1ac00253ff1c1cde","category":"Thai"}