{"title":"Handling Mounting And Unmounting Of Navigation Routes In React Native","link":"https://smashingmagazine.com/2021/08/mounting-unmounting-navigation-routes-react-native/","date":1628682000000,"content":"<p>In this article, we are going to walk through <strong>mounting and unmounting of navigation routes</strong> in React Native. An expected behavior of your app is that once the authentication condition is met, a new set of navigation routes are available only to logged-in users, while the other screens which were displayed before authentication is removed and can’t be returned to unless the user signs out of the application.</p>\n<p>For security in your app, protected routes provide you with a way to only display certain information/content on your app to specific users, while restricting access from unauthorized persons.</p>\n<p>We will be working with <a href=\"https://expo.io/\">Expo</a> for this project because it’ll help us focus on the problem at hand instead of worrying about a lot of setups. The exact same steps in this article could be followed for a bare React Native application.</p>\n<p>You need some familiarity with <strong>JavaScript and React Native</strong> to follow through with this tutorial. Here are a few important things you should already be familiar with:</p>\n<ul>\n<li>Custom components in React Native (how to create components, receive, pass, and use props in a component). <a href=\"https://www.fastfwd.com/custom-component-in-react-native/\">Read more</a>.</li>\n<li>React Navigation. <a href=\"https://reactjs.org/docs/context.html\">Read more</a>.</li>\n<li>Stack Navigator in React Native. <a href=\"https://reactnavigation.org/docs/stack-navigator/\">Read more</a>.</li>\n<li>Basic Knowledge of React Native Core components (<code>&lt;View/&gt;</code>, <code>&lt;Text/&gt;</code>, etc.). <a href=\"https://reactnative.dev/docs/components-and-apis\">Read more</a>.</li>\n<li>React Native <code>AsyncStorage</code>. <a href=\"https://reactnative.dev/docs/asyncstorage\">Read more</a>.</li>\n<li>Context API. <a href=\"https://reactjs.org/docs/context.html\">Read more</a>.</li>\n</ul>\nProject Setup And Base Authentication\n<p>If you're new to using expo and don’t know how to install expo, <a href=\"https://docs.expo.io/get-started/installation/\">visit the official documentation</a>. Once the installation is complete, go ahead to initialize a new React Native project with expo from our command prompt:</p>\n<pre><code>expo init navigation-project</code></pre>\n\n<p>You will be presented with some options to choose how you want the base setup to be:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/cf792489-413d-48a1-9f0d-2343e662ab7d/1-mounting-unmounting-navigation-routes-authentication-react-native.PNG\" /></p>\n<p>In our case, let’s select the first option to set up our project as a blank document. Now, wait until the installation of the JavaScript dependencies is complete.</p>\n<p>Once our app is set up, we can change our directory to our new project directory and open it in your favorite code editor. We need to install the library we will be using for <code>AsyncStorage</code> and our navigation libraries. Inside your folder directory in your terminal, paste the command above and choose a template (<code>blank</code> would work) to install our project dependencies.</p>\n<p>Let's look at what each of these dependencies is for:</p>\n<ul>\n<li><strong>@react-native-community/async-storage</strong><br />Like localStorage on the web, it is a React Native API for persisting data on a device in key-value pairs. </li>\n<li><strong>@react-native-community/masked-view, react-native-screens, react-native-gesture-handle</strong><br />These dependencies are core utilities that are used by most navigators to create the navigation structure in the app. (Read more in <a href=\"https://reactnavigation.org/docs/getting-started/\">Getting started with React Native navigation</a>.)</li>\n<li><strong>@react-navigation/native</strong><br />This is the dependency for React Native navigation.</li>\n<li><strong>@react-navigation/stack</strong><br />This is the dependency for stack navigation in React Native.</li>\n</ul>\n<div>\n<pre><code>npm install @react-native-community/async-storage @react-native-community/masked-view @react-navigation/native @react-navigation/stack react-native-screens react-native-gesture-handle</code></pre>\n</div>\n\n<p>To start the application use <code>expo start</code> from the app directory in your terminal. Once the app is started, you can use the expo app from your mobile phone to scan the bar code and view the application, or if you have an android emulator/IOS simulator, you can open the app through them from the expo developer tool that opens up in your browser when you start an expo application. For the images examples in this article, we will be using <a href=\"https://www.genymotion.com/\">Genymotions</a> to see our result. Here’s what our final result will look like in Genymotions:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a271a5a6-2d28-4334-a57e-8aff24818578/2-mounting-unmounting-navigation-routes-authentication-react-native.PNG\" /></p>\n<h3>Folder Structures</h3>\n<p>Let us create our folder structure from the start so that it's easier for us to work with it as we proceed:</p>\n<p>We need two folders first:</p>\n<ul>\n<li><strong>context</strong><br />This folder will hold the context for our entire application as we will be working with Context API for global state management.</li>\n<li><strong>views</strong><br />This folder will hold both the navigation folder and the views for different screens.</li>\n</ul>\n<p>Go ahead and create the two folders in your project directory.</p>\n<p>Inside the context folder, create a folder called <strong>authContext</strong> and create two file inside of the <strong>authContext</strong> folder:</p>\n<ul>\n<li><strong>AuthContext.js</strong>,</li>\n<li><strong>AuthState.js</strong>.</li>\n</ul>\n<p>We will need these files when we start working with Context API.</p>\n<p>Now go to the <strong>views</strong> folder we created and create two more folders inside of it, namely:</p>\n<ul>\n<li><strong>navigation</strong>,</li>\n<li><strong>screens</strong>.</li>\n</ul>\n<p>Now, we are not yet finished, inside the <strong>screens</strong> folder, create these two more folders:</p>\n<ul>\n<li><strong>postAuthScreens</strong>,</li>\n<li><strong>preAuthScreens</strong>.</li>\n</ul>\n<p>If you followed the folder setup correctly, this is how your folder structure should look like at the moment:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/5ffaf659-afec-4555-9224-de273d1d10c2/3-mounting-unmounting-navigation-routes-authentication-react-native.PNG\" /></p>\n<h3>Creating Our First Screen</h3>\n<p>Now let's create our first screen and call it the <strong>welcomeScreen.js</strong> inside the <strong>preAuthScreens</strong> folder.</p>\n<p><strong>preAuthScreens   &gt;   welcomeScreen.js</strong></p>\n<p>Here’s the content of our <strong>welcomeScreen.js</strong> file:</p>\n<div>\n<pre><code>import React from 'react';\nimport { View, Text, Button, StyleSheet, TextInput } from 'react-native';\n\nconst WelcomeScreen = () =&gt; {\n\n  const onUserAuthentication = () =&gt; {\n    console.log(\"User authentication button clicked\")\n  }\n\n  return (\n    &lt;View style={styles.container}&gt;\n      &lt;Text style={styles.header}&gt;Welcome to our App!&lt;/Text&gt;\n      &lt;View&gt;\n        &lt;TextInput style={styles.inputs} placeholder=\"Enter your email here..\" /&gt;\n        &lt;TextInput style={styles.inputs} secureTextEntry={true} placeholder=\"Enter your password here..\" /&gt;\n&lt;Button  title=\"AUTHENTICATE\" onPress={onUserAuthentication} /&gt;\n      &lt;/View&gt;\n    &lt;/View&gt;\n  )\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: '#fff',\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  header: {\n    fontSize: 25,\n    fontWeight: 'bold',\n    marginBottom: 30\n  },\n  inputs: {\n    width: 300,\n    height: 40,\n    marginBottom: 10,\n    borderWidth: 1,\n  }\n})\n\nexport default WelcomeScreen\n</code></pre>\n</div>\n\n<p>Here's what we did in the code block above:</p>\n<p>First, we imported the things we need from the React Native library, namely, <code>View</code>, <code>Text</code>, <code>Button</code>, <code>TextInput</code>. Next, we created our functional component <code>WelcomeScreen</code>. </p>\n<p>You’ll notice that we imported the <code>StyleSheet</code> from React Native and used it to define styles for our header and also our <code>&lt;TextInput /&gt;</code>.</p>\n<p>Lastly, we export the <code>WelcomeScreen</code> component at the bottom of the code.</p>\n<p>Now that we are done with this, let's get this component to function as expected by using the <code>useState</code> hook to store the values of the inputs and update their states anytime a change happens in the input fields. We will also bring import the <code>useCallback</code> hook from React as we will be needing it later to hold a function.</p>\n<p>First, while we are still in the <code>WelcomeScreen</code> component, we need to import the <code>useState</code> and <code>useCallback</code> from React.</p>\n<pre><code>import React, { useState, useCallback } from 'react';</code></pre>\n\n<p>Now inside the <code>WelcomeScreen</code> functional component, let's create the two states for the email and password respectively:</p>\n<pre><code>...\nconst WelcomeScreen = () =&gt; {\n  const [email, setEmail] = useState('')\n  const [password, setPassword] = useState('')\n  return (\n    ...\n  )\n}\n...</code></pre>\n\n<p>Next, we need to modify our <code>&lt;TextInput /&gt;</code> fields so that the get their value from their respective states and update their state when the value of the input is updated:</p>\n<div>\n<pre><code>import React, { useState, useCallback } from 'react';\nimport { View, Text, Button, StyleSheet, TextInput } from 'react-native';\n\nconst WelcomeScreen = () =&gt; {\n  const [email, setEmail] = useState('')\n  const [password, setPassword] = useState('')\n\n  const onInputChange = (value, setState) =&gt; {\n    setState(value);\n  }\n  return (\n    &lt;View&gt;\n      ...<br />      &lt;View&gt;\n        &lt;TextInput\n          style={styles.inputs}\n          placeholder=\"Enter your email here..\"\n          value={email}\n          onChangeText={(value) =&gt; onInputChange(value, setEmail)}\n        /&gt;\n        &lt;TextInput\n          style={styles.inputs}\n          secureTextEntry={true}\n          placeholder=\"Enter your password here..\"\n          value={password}\n          onChangeText={(value) =&gt; onInputChange(value, setPassword)}\n        /&gt;\n        ...\n      &lt;/View&gt;\n    &lt;/View&gt;\n  )\n}\n...\n</code></pre>\n</div>\n\n<p>In the code above, here is what we did:</p>\n<ul>\n<li>We made the <code>value</code> of each of the text inputs to point to their respective states.</li>\n<li>We added the <code>onChangeText</code> handler to our text inputs. This fires up anytime a new value is entered or deleted from the input fields.</li>\n<li>We called our <code>onInputChange</code> function which accepts two arguments:<ul>\n<li>The current <code>value</code> is supplied by the <code>onChangeText</code> handler.</li>\n<li>The setter of the state that should be updated (for the first input field we pass <code>setEmail</code> and the second we pass <code>setPassword</code>.</li>\n<li>Finally, we write our <code>onInputChange</code> function, and our function does only one thing: It updates the respective states with the new value.</li>\n</ul>\n</li>\n</ul>\n<p>The next thing we need to work on is the <code>onUserAuthentication()</code> function with is called whenever the button for the form submission is clicked.</p>\n<p>Ideally, the user must have already created an account and login will involve some backend logic of some sort to check that the user exists and then assign a token to the user. In our case, since we are not using any backend, we will create an object holding the correct user login detail, and then only authenticate a user when the values they enter matches our fixed values from the login object of <code>email</code> and <code>password</code> that we will create.</p>\n<p>Here’s the code we need to do this:</p>\n<div>\n<pre><code>...\n\nconst correctAuthenticationDetails = {\n  email: <a href=\"mailto:'demouser@gmail.com\">'demouser@gmail.com</a>',\n  password: 'password'\n}\nconst WelcomeScreen = () =&gt; {\n  ...\n\n  // This function gets called when the <code>AUTHENTICATE</code> button is clicked\n  const onUserAuthentication = () =&gt; {\n    if (\n      email !== correctAuthenticationDetails.email ||\n      password !== correctAuthenticationDetails.password\n    ) {\n      alert('The email or password is incorrect')\n      return\n    }\n      // In here, we will handle what happens if the login details are       // correct\n  }\n\n  ...\n  return (\n    ...\n  )\n}\n...\n</code></pre>\n</div>\n\n<p>One of the first things you’ll notice in the code above is that we defined a <code>correctAuthenticationDetails</code> (which is an object that holds the correct login details we expect a user to supply)  outside of the <code>WelcomeScreen()</code> functional component.</p>\n<p>Next, we wrote the content of the <code>onUserAuthentication()</code> function and used a conditional statement to check if the <code>email</code> or <code>password</code> held in the respective states does not match the one we supplied in our object.</p>\n<p>If you would like to see what we have done so far, import the <strong>WelcomeScreen</strong> component into your <strong>App.js</strong> like this:</p>\n<p>Open the <strong>App.js</strong> file and put this replace the entire code with this:</p>\n<div>\n<pre><code>import { StatusBar } from 'expo-status-bar';\nimport React from 'react';\nimport { View } from 'react-native';\nimport WelcomeScreen from './views/screens/preAuthScreens/welcomeScreen';\nexport default function App() {\n  return (\n    &lt;View&gt;\n      &lt;StatusBar style=\"auto\" /&gt;\n      &lt;WelcomeScreen /&gt;\n    &lt;/View&gt;\n  );\n}\n</code></pre>\n</div> \n\n<p>Looking closely at the code above, you’ll see that what we did was import the <strong>WelcomeScreen</strong> component and then used it in the <code>App()</code> function.</p>\n<p>Here’s what the result looks like of our <code>WelcomeScreen</code> looks like:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8ecde0ee-f05f-4a93-91e1-371f5d3fa834/4-mounting-unmounting-navigation-routes-authentication-react-native.PNG\" /></p>\n<p>Now that we are done building the <strong>WelcomeScreen</strong> component, let’s move ahead and start working with Context API for managing our global state.</p>\n<h3>Why Context API?</h3>\n<p>Using Context API, we do not need to install any additional library into ReactJS, it is less stressful to set up, and is one of the most popular ways of handling global state in ReactJS. For lightweight state management, it is a good choice.</p>\n<h3>Creating Our Context</h3>\n<p>If you recall, we created a <strong>context</strong> folder earlier and created a subfolder inside of it called the <strong>authContext</strong>.</p>\n<p>Now let’s navigate to the <strong>AuthContext.js</strong> file in the <strong>authContext</strong> folder and create our context:</p>\n<p><em>context &gt; authContext &gt; AuthContext.js</em></p>\n<pre><code>\nimport React, { createContext } from 'react';\nconst AuthContext = createContext();\nexport default AuthContext;\n</code></pre>\n\n<p>The <code>AuthContext</code> we just created holds the <code>loading</code> state value and the <code>userToken</code> state values. Currently, in the <code>createContext</code> we declared in the code-block above, we didn’t initialize any default values here so our context is currently <code>undefined</code>.  An example value of the auth context could be <code>{loading: false, userToken: 'abcd}</code></p>\n<p>The <strong>AuthState.js</strong> file holds our Context API logic and their state values. Functions written here can be called from anywhere in our app and when they update values in state, it is updated globally also.</p>\n<p>First, let’s bring in all the imports we will need in this file:</p>\n<p><em>context &gt; AuthContext &gt; AuthState.js</em></p>\n<div>\n<pre><code>import React, { useState } from 'react';\nimport AuthContext from './AuthContext';\nimport AsyncStorage from '@react-native-community/async-storage';</code></pre>\n</div>\n\n<p>We imported the <code>useState()</code> hook from ReactJS to hold our states, we imported the <strong>AuthContext</strong> file we created above because this is where our empty context for authentication is initialized and we will need to use it as you’ll see later on while we progress, finally we import the <code>AsyncStorage</code> package (similar to localStorage for the web). </p>\n<p><code>AsyncStorage</code> is a React Native API that allows you to persist data offline over the device in a React Native application.</p>\n<pre><code>...\n\nconst AuthState = (props) =&gt; {\n    const [userToken, setUserToken] = useState(null);\n    const [isLoading, setIsLoading] = useState(true);\n\n    const onAuthentication = async() =&gt; {\n        const USER_TOKEN = \"drix1123q2\"\n        await AsyncStorage.setItem('user-token', USER_TOKEN);\n        setUserToken(USER_TOKEN);\n        console.warn(\"user has been authenticated!\")\n    }\n\n    return (\n        &lt;AuthContext.Provider\n            value={{\n                onAuthentication,\n            }}\n        &gt;\n            {props.children}\n        &lt;/AuthContext.Provider&gt;\n    )\n}\nexport default AuthState;\n</code></pre>  \n\n<p>In the code block above here's what we did:</p>\n<ul>\n<li><p>We declared two states for the <code>userToken</code> and <code>isLoading</code>. The <code>userToken</code> state will be used to store the token saved to <code>AsyncStorage</code>, while the <code>isLoading</code> state will be used to track the loading status (initially it is set to <code>true</code>). We will find out more about the use of these two states as we proceed.</p>\n</li>\n<li><p>Next, we wrote our <code>onAuthentication()</code> function. This function is an <code>async</code> function that gets called when the login button is clicked from the <code>welcomeScreen.jsx</code> file. This function will only get called if the email and password the user has supplied matches the correct user detail object we provided. Usually what happens during authentication is that a token is generated for the user after the user is authenticated on the backend using a package like <a href=\"https://jwt.io/introduction\">JWT</a>, and this token is sent to the frontend. Since we are not going into all of that for this tutorial, we created a static token and kept it in a variable called <code>USER_TOKEN</code>.</p>\n</li>\n<li><p>Next, we use the <code>await</code> keyword to set our user token to AsyncStorage with the name <code>user-token</code>. The <code>console.warn()</code> statement is just used to check that everything went right, you can take it off whenever you like.</p>\n</li>\n<li><p>Finally, we pass our <code>onAuthenticated</code> function as a value inside our <code>&lt;AuthContext.Provider&gt;</code> so that we can access and call the function from anywhere in our app.</p>\n</li>\n</ul>\n<p><em>screens &gt; preAuth &gt; welcomeScreen.js</em></p>\n<p>First, import <code>useContext</code> from ReactJS and import the <code>AuthContext</code> from the <code>AuthContext.js</code> file.</p>\n<div>\n<pre><code>import React, { useState, useContext } from 'react';\nimport AuthContext from '../../../context/authContext/AuthContext'\n...</code></pre>\n</div>\n\n<p>Now, inside the <code>welcomeScreen()</code> functional component, let’s use the context which we have created:</p>\n<pre><code>...\nconst WelcomeScreen = () =&gt; {\n  const { onAuthentication } = useContext(AuthContext)\n  const onUserAuthentication = () =&gt; {\n    if (\n      email !== correctAuthenticationDetails.email ||\n      password !== correctAuthenticationDetails.password\n    ) {\n      alert('The email or password is incorrect')\n      return\n    }\n    onAuthentication()\n  }\n  return (\n    ...\n  )\n}\n...\n</code></pre>\n\n<p>In the above code block, we destructured the <code>onAuthentication</code> function from our <code>AuthContext</code> and then we called it inside our <code>onUserAuthentication()</code> function and removed the <code>console.log()</code> statement which was there before now.</p>\n<p>Right now, this will throw an error because we don’t yet have access to the <code>AuthContext</code>. To use the <code>AuthContext</code> anywhere in your application, we need to wrap the top-level file in our app with the <code>AuthState</code> (in our case, it is the <strong>App.js</strong> file).</p>\n<p>Go to the <strong>App.js</strong> file and replace the code there with this:</p>\n<div>\n<pre><code>import React from 'react';\nimport WelcomeScreen from './views/screens/preAuthScreens/welcomeScreen';\nimport AuthState from './context/authContext/AuthState'\n\nexport default function App() {\n  return (\n    &lt;AuthState&gt;\n      &lt;WelcomeScreen /&gt;\n    &lt;/AuthState&gt;\n  );\n}\n</code></pre>\n</div>\n\n<p>We've come so far and we're done with this section. Before we move into the next section where we set up our routing, let's create a new screen. The screen we are about to create will be the <strong>HomeScreen.js</strong> file which is supposed to show up only after successful authentication.</p>\n<p>Go to: <em>screens &gt; postAuth</em>.</p>\n<p>Create a new file called <strong>HomeScreen.js</strong>. Here's the code for the <strong>HomeScreen.js</strong> file:</p>\n<p><em>screens &gt; postAuth &gt;</em> <strong><em>HomeScreen.js</em></strong></p>\n<pre><code>import React from 'react';\nimport { View, Text, Button, StyleSheet } from 'react-native';\n\nconst HomeScreen = () =&gt; {\n\n  const onLogout = () =&gt; {\n    console.warn(\"Logout button cliked\")\n  }\n\n  return (\n    &lt;View style={styles.container}&gt;\n      &lt;Text&gt;Now you're authenticated! Welcome!&lt;/Text&gt;\n      &lt;Button title=\"LOG OUT\" onPress={onLogout} /&gt;\n    &lt;/View&gt;\n  )\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: '#fff',\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n})\n\nexport default HomeScreen\n</code></pre>\n\n<p>For now, the logout button has a dummy <code>console.log()</code> statement. Later on, we will create the logout functionality and pass it to the screen from our context.</p>\nSetting Up Our Routes\n<p>We need to create three (3) files inside our navigation folder:</p>\n<ul>\n<li><strong>postAuthNavigator.js</strong>,</li>\n<li><strong>preAuthNavigator.js</strong>,</li>\n<li><strong>AppNavigator.js</strong>.</li>\n</ul>\n<p>Once you’ve created these three files, navigate to the <strong>preAuthNaviagtor.js</strong> file you just created and write this:</p>\n<p><em>navigation &gt; preAuthNavigator.js</em></p>\n<div>\n<pre><code>import React from \"react\";\nimport { createStackNavigator } from \"@react-navigation/stack\";\nimport WelcomeScreen from \"../screens/preAuthScreens/welcomeScreen\";\n\nconst PreAuthNavigator = () =&gt; {\n    const { Navigator, Screen } = createStackNavigator();\n\n    return (\n        &lt;Navigator initialRouteName=\"Welcome\"&gt;\n            &lt;Screen\n                name=\"Welcome\"\n                component={WelcomeScreen}\n            /&gt;\n        &lt;/Navigator&gt;\n    )\n}\nexport default PreAuthNavigator;\n</code></pre>\n</div>\n\n<p>In the file above, here's what we did:</p>\n<ul>\n<li>We imported the <code>createStackNavigator</code> from the <code>@react-navigation/stack</code> which we are using for our stack navigation. The <code>createStackNavigator</code>Provides a way for your app to transition between screens where each new screen is placed on top of a stack. By default the stack navigator is configured to have the familiar iOS and Android look &amp; feel: new screens slide in from the right on iOS, fade in from the bottom on Android. Click <a href=\"https://reactnavigation.org/docs/stack-navigator/\">here</a> if you want to learn more about the <a href=\"https://reactnavigation.org/docs/stack-navigator/\">stack navigator in React Native</a>.</li>\n<li>We destructured <code>Navigator</code> and <code>Screen</code> from the <code>createStackNavigator()</code>.</li>\n<li>In our return statement, we created our navigation with the <code>&lt;Navigator/&gt;</code> and created our screen with the <code>&lt;Screen/&gt;</code>. this means that if we had multiple screens that can be accessed before authentication, we will have multiple <code>&lt;Screen/&gt;</code> tags here representing them.</li>\n<li>Finally, we export our <code>PreAuthNavigator</code> component.</li>\n</ul>\n<p>Let us do a similar thing for the <code>postAuthNavigator.js</code> file.</p>\n<p><em>navigation &gt; postAuthNavigator.js</em></p>\n<div>\n<pre><code>import React from \"react\";\nimport { createStackNavigator } from \"@react-navigation/stack\";\nimport HomeScreen from \"../screens/postAuthScreens/HomeScreen\";\nconst PostAuthNavigator = () =&gt; {\n  const { Navigator, Screen} = createStackNavigator();\n  return (\n    &lt;Navigator initialRouteName=\"Home\"&gt;\n      &lt;Screen\n        name=\"Home\"\n        component={HomeScreen}\n      /&gt;\n    &lt;/Navigator&gt; \n  )\n}\nexport default PostAuthNavigator;\n</code></pre>\n</div>\n\n<p>As we see in the code above, the only difference between the <strong>preAuthNavigator.js</strong> and the <strong>postAuthNavigator.js</strong> is the screen being rendered. While the first one takes the <code>WelcomeScreen</code>, the <strong>postAuthNavigator.js</strong> takes the <code>HomeScreen</code>.</p>\n<p>To create our <strong>AppNavigator.js</strong> we need to create a few things.</p>\n<p>Since the <strong>AppNavigator.js</strong> is where we will be switching and checking which route will be available for access by the user, we need several screens in place for this to work properly, let’s outline the things we need to create first:</p>\n<ol>\n<li><strong>TransitionScreen.js</strong><br />While the app decides which navigation it is going to mount, we want a transition screen to show up. Typically, the transition screen will be a loading spinner or any other custom animation chosen for the app, but in our case, we will use a basic <code>&lt;Text/&gt;</code> tag to display <em><code>loading…</code></em>.</li>\n<li><code>checkAuthenticationStatus()</code><br />This function is what we will be calling to check the authentication status which will determine which navigation stack is going to be mounted. We will create this function in our context and use it in the <strong>Appnavigator.js</strong>.</li>\n</ol>\n<p>Now, let's go ahead and create our <strong>TransitionScreen.js</strong> file.</p>\n<p><em>screens &gt;</em> <strong><em>TransitionScreen.js</em></strong></p>\n<pre><code>import React from 'react';\nimport { Text, View } from 'react-native';\n\nconst TransitionScreen = () =&gt; {\n  return (\n    &lt;View&gt;\n      &lt;Text&gt;Loading...&lt;/Text&gt;\n    &lt;/View&gt;\n  )\n}\n\nexport default TransitionScreen\n</code></pre>\n\n<p>Our transition screen is just a simple screen that shows loading text. We will see where to use this as we proceed in this article.</p>\n<p>Next, let us go to our <strong>AuthState.js</strong> and write our <code>checkAuthenticationStatus()</code>:</p>\n<p><em>context &gt; authContext &gt;</em> <strong><em>AuthState.js</em></strong></p>\n<div>\n<pre><code>import React, { useState, useEffect } from 'react';\nimport AuthContext from './AuthContext';\nimport AsyncStorage from '@react-native-community/async-storage';\n\nconst AuthState = (props) =&gt; {\n    const [userToken, setUserToken] = useState(null);\n    const [isLoading, setIsLoading] = useState(true);\n\n    ...\n    useEffect(() =&gt; {\n        checkAuthenticationStatus()\n    }, [])\n\n    const checkAuthenticationStatus = async () =&gt; {\n        try {\n            const returnedToken = await AsyncStorage.getItem('user-toke             n');\n            setUserToken(returnedToken);\n            console.warn('User token set to the state value)\n        } catch(err){\n            console.warn(<code>Here's the error that occured while retrievin             g token: ${err}</code>) \n        }\n        setIsLoading(false)\n    }\n\n\n    const onAuthentication = async() =&gt; {\n        ...\n    }\n\n    return (\n        &lt;AuthContext.Provider\n            value={{\n                onAuthentication,\n                userToken,\n                isLoading,\n            }}\n        &gt;\n            {props.children}\n        &lt;/AuthContext.Provider&gt;\n    )\n}\nexport default AuthState;\n</code></pre>\n</div>\n\n<p>In the code block above, we wrote the function <code>checkAuthenticationStatus()</code>. In our function, here's what we are doing:</p>\n<ul>\n<li>We used the <code>await</code> keyword to get our token from <code>AsyncStorage</code>. With <code>AsyncStorage</code>, if there’s no token supplied, it returns <code>null</code>. Our initial <code>userToken</code> state is set to <code>null</code> also.</li>\n<li>We use the <code>setUserToken</code> to set our returned value from <code>AsyncStorage</code> as our new <code>userToken</code>. If the returned value is <code>null</code>, it means our <code>userToken</code> remains <code>null</code>.</li>\n<li>After the <code>try{}…catch(){}</code> block, we set <code>isLoading</code> to false because the function to check authentication status is complete. We’ll need the value of <code>isLoading</code> to know if we should still be displaying the <code>TransitionScreen</code> or not. It’s worth considering setting an error if there is an error retrieving the token so that we can show the user a “Retry” or “Try Again” button when the error is encountered.</li>\n<li>Whenever <code>AuthState</code> mounts we want to check the authentication status, so we use the <code>useEffect()</code> ReactJS hook to do this. We call our <code>checkAuthenticationStatus()</code> function inside the <code>useEffect()</code> hook and set the value of <code>isLoading</code> to <code>false</code> when it is done.</li>\n<li>Finally, we add our states to our <code>&lt;AuthContext.Provider/&gt;</code> values so that we can access them from anywhere in our app covered by the Context API.</li>\n</ul>\n<p>Now that we have our function, it is time to go back to our <strong>AppNavigator.js</strong> and write the code for mounting a particular stack navigator based on the authentication status:</p>\n<p><em>navigation &gt; AppNavigator.js</em></p>\n<p>First, we will import all we need for our <strong>AppNavigator.js</strong>.</p>\n<div>\n<pre><code>import React, { useEffect, useContext } from \"react\";\nimport PreAuthNavigator from \"./preAuthNavigator\";\nimport PostAuthNavigator from \"./postAuthNavigator\";\nimport { NavigationContainer } from \"@react-navigation/native\"\nimport { createStackNavigator } from \"@react-navigation/stack\";\nimport AuthContext from \"../../context/authContext/AuthContext\";\nimport TransitionScreen from \"../screens/TransitionScreen\";\n</code></pre>\n</div>\n\n<p>Now that we have all our imports, let’s create the <code>AppNavigator()</code> function.</p>\n<pre><code>...\nconst AppNavigator = () =&gt; {\n\n}\n\nexport default AppNavigator\n</code></pre>\n\n<p>Next, we will now go ahead to write the content of our <code>AppNavigator()</code> function:</p>\n<div>\n<pre><code>import React, { useState, useEffect, useContext } from \"react\";\nimport PreAuthNavigator from \"./preAuthNavigator\";\nimport PostAuthNavigator from \"./postAuthNavigator\";\nimport { NavigationContainer } from \"@react-navigation/native\"\nimport { createStackNavigator } from \"@react-navigation/stack\";\nimport AuthContext from \"../../context/authContext/AuthContext\";\nimport TransitionScreen from \"../screens/transition\";\n\nconst AppNavigator = () =&gt; {\n    const { Navigator, Screen } = createStackNavigator();\n    const authContext = useContext(AuthContext);\n    const { userToken, isLoading } = authContext;\n    if(isLoading) {\n      return &lt;TransitionScreen /&gt;\n    }\n    return (\n    &lt;NavigationContainer&gt;\n      &lt;Navigator&gt;\n        { \n          userToken == null ? (\n            &lt;Screen\n              name=\"PreAuth\"\n              component={PreAuthNavigator}\n              options={{ header: () =&gt; null }}\n            /&gt;\n          ) : (\n            &lt;Screen \n              name=\"PostAuth\"\n              component={PostAuthNavigator}\n              options={{ header: () =&gt; null }}\n            /&gt;\n          )\n        }\n      &lt;/Navigator&gt;\n    &lt;/NavigationContainer&gt;\n  )\n}\n\nexport default AppNavigator\n</code></pre>\n</div>\n\n<p>In the above block of code, here's an outline of what we did:</p>\n<ul>\n<li>We created a stack navigator and destructured the <code>Navigator</code> and <code>Screen</code> from it.</li>\n<li>We imported the <code>userToken</code> and the <code>isLoading</code> from our <code>AuthContext</code></li>\n<li>When the <code>AuthState</code> mounts, the <code>checkAuthenticationStatus()</code> is called in the <code>useEffecct</code> hook there. We use the <code>if</code> statement to check if  <code>isLoading</code> is <code>true</code>, if it is <code>true</code> the screen we return is our <code>&lt;TransitionScreen /&gt;</code> which we created earlier because the <code>checkAuthenticationStatus()</code> function is not yet complete.</li>\n<li>Once our <code>checkAuthenticationStatus()</code> is complete, <code>isLoading</code> is set to <code>false</code> and we return our main Navigation components.</li>\n<li>The <code>NavigationContainer</code> was imported from the <code>@react-navigation/native</code>. It is only used once in the main top-level navigator. Notice that we are not using this in the <strong>preAuthNavigator.js</strong> or the <strong>postAuthNavigator.js.</strong></li>\n<li>In our <code>AppNavigator()</code>, we still create a stack navigator. If the <code>userToken</code> gotten from our Context API is <code>null</code>, we mount the <code>PreAuthNavigator</code>, if its value is something else (meaning that the <code>AsyncStorage.getItem()</code> in the <code>checkAuthenticationStatus()</code> returned an actual value), then we mount the <code>PostAuthNavigator</code>. Our conditional rendering is done using the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator\">ternary operator</a>.</li>\n</ul>\n<p>Now we’ve set up our <strong>AppNavigator.js</strong>. Next, we need to pass our <code>AppNavigator</code> into our <strong>App.js</strong> file.</p>\n<p>Let’s pass our <code>AppNavigator</code> into the <strong>App.js</strong> file:</p>\n<p><em>App.js</em></p>\n<pre><code> ...\nimport AppNavigator from './views/navigation/AppNavigator';\n\n...\nreturn (\n    &lt;AuthState&gt;\n      &lt;AppNavigator /&gt;\n    &lt;/AuthState&gt;\n  );\n</code></pre>\n\n<p>Let's now see what our app looks like at the moment:</p>\n<p>Here’s what happens when you supply an incorrect credential while trying to log in:</p>\n<h3>Adding The Logout Functionality</h3>\n<p>At this point, our authentication and route selection process is complete. The only thing left for our app is to add the logout functionality.</p>\n<p>The logout button is in the <strong>HomeScreen.js</strong> file. We passed an <code>onLogout()</code> function to the <code>onPress</code> attribute of the button. For now, we have a simple <code>console.log()</code> statement in our function, but in a little while that will change.</p>\n<p>Now, let’s go to our <strong>AuthState.js</strong> and write the function for logout. This function simply clears the <code>AsyncStorage</code> where the user token is saved.</p>\n<p><em>context &gt; authContext &gt; AuthState.js</em></p>\n<pre><code>...\nconst AuthState = (props) =&gt; {\n    ...\n\n    const userSignout = async() =&gt; {\n        await AsyncStorage.removeItem('user-token');\n        setUserToken(null);\n    }\n\n\n    return (\n      ...\n    )\n}\n\nexport default AuthState;\n</code></pre>\n\n<p>The <code>userSignout()</code> is an asynchronous function that removes the <code>user-token</code> from our <code>AsyncStorage</code>.</p>\n<p>Now we need to call the <code>userSignout()</code> function in our <strong>HomeScreen.js</strong> any time the logout button is clicked on.</p>\n<p>Let’s go to our <strong>HomeScreen.js</strong> and use ther <code>userSignout()</code> from our <code>AuthContext</code>.</p>\n<p><em>screens &gt; postAuthScreens &gt;</em> <strong><em>HomeScreen.js</em></strong></p>\n<div>\n<pre><code>import React, { useContext } from 'react';\nimport { View, Text, Button, StyleSheet } from 'react-native';\nimport AuthContext from '../../../context/authContext/AuthContext'\n\nconst HomeScreen = () =&gt; {\n  const { userSignout } = useContext(AuthContext)\n\n  const onLogout = () =&gt; {\n    userSignout()\n  }\n  return (\n    &lt;View style={styles.container}&gt;\n      &lt;Text&gt;Now you're authenticated! Welcome!&lt;/Text&gt;\n &lt;Button title=\"LOG OUT\" onPress={onLogout} /&gt;\n    &lt;/View&gt;\n  )\n}\n...\n</code></pre>\n</div>\n\n<p>In the above code block we imported thee <code>useContext</code> hook from ReactJS, then we imported our AuthContext. Next, we destructured the <code>userSignout</code> function from our <code>AuthContext</code> and this <code>userSignout()</code> function is called in our <code>onLogout()</code> function.</p>\n<p>Now whenever our logout button is clicked, the user token in our <code>AsyncStorage</code> is cleared.</p>\n<p>Voila! our entire process is finished.</p>\n<p>Here’s what happens when you press the back button after you’re logged in:</p>\n<p>Here’s what happens when you press the back button after logging out:</p>\n<p>Here are some  different behaviors we notice when using this pattern in our navigation stack switching:</p>\n<ol>\n<li>You’ll notice that there was nowhere we needed to make use of <code>navigation.navigate()</code> or <code>navigation.push()</code> to go to another route after login. Once our state is updated with the user token, the navigation stack rendered is automatically changed.</li>\n<li>Pressing the back button on your device after login is successful cannot take you back to the login page, instead, it closes the app entirely. This behavior is important because you don’t want the user to be able to return back to the login page except they log out of the app. The same thing applies to logging out — once the user logs out, they cannot use the back button to return to the <code>HomeScreen</code> screen, but instead, the app closes.</li>\n</ol>\nConclusion\n<p>In many Apps, authentication is one of the most important parts because it confirms that the person trying to gain access to protected content has the right to access the information. Learning how to do it right is an important step in building a great, intuitive, and easy to use/navigate the application.</p>\n<p>Building on top of this code, here are a few things you might consider adding:</p>\n<ul>\n<li>Form validation for validating input fields. Check out <a href=\"https://blog.logrocket.com/react-native-form-validations-with-formik-and-yup/\">React Native form validation with Formik and Yup</a>.</li>\n<li>Firebase authentication for integrating authentication with Gmail, Github, Facebook, Twitter, or your custom interface. Check out <a href=\"https://rnfirebase.io/auth/usage\">React Native Firebase</a>.</li>\n<li><a href=\"https://uxdesign.cc/code-concepts-for-designers-authentication-authorization-24b72ab33a62\">Code concepts for designers: Authentication and Authorization.</a></li>\n</ul>\n<p>Here are also some important resources I found that will enlighten you more about authentication, security and how to do it right:</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://rossbulat.medium.com/react-native-user-authentication-flow-explained-d988905ba106\">React Native: User Authentication Flow Explained</a></li>\n<li><a href=\"https://snyk.io/blog/10-react-security-best-practices/\">10 React Security Best Practices</a></li>\n<li><a href=\"https://www.idrnd.ai/5-authentication-methods-that-can-prevent-the-next-breach/\">Authentication Methods That Can Prevent The Next Breach</a></li>\n<li>View a live build/preview of our application <a href=\"https://snack.expo.io/@danieldon/github.com-chiagozielam-reactnative_authentication_navigation_pattern\">here</a>;</li>\n<li>View the project on <a href=\"https://github.com/Chiagozielam/ReactNative_authentication_navigation_pattern\">GitHub</a>.</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"31a4c93c98e3c72891e58936cd46f35637009a15e460111997b7674ff0cee497","category":"Tech"}