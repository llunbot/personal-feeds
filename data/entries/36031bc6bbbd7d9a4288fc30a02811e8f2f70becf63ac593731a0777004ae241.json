{"title":"Secure Kubernetes ingress with HashiCorp Boundary","link":"https://www.hashicorp.com/blog/secure-kubernetes-ingress-with-hashicorp-boundary","date":1699549200000,"content":"<p>How could you enable secure and auditable access from outside a Kubernetes platform without using a traditional <a href=\"https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/\">Kubernetes Ingress Controller</a>? Can this be achieved in a way that improves the security posture of both application content and components while leveraging a strong notion of identity to authenticate and authorize access?</p>\n\n<p>Consider a scenario. You are part of a product team, delivering an application or service that’s hosted in a Kubernetes environment — perhaps a cloud-hosted xKS solution, maybe K3s, or a more opinionated offering such as Red Hat’s OpenShift Container Platform. The components of your application may exist in one namespace, or indeed be spread across multiple namespaces. You want to enable secure external access to the content and components of your application for debugging and maintenance purposes without compromising the security of either the platform or the application.</p>\n\n<p>This post considers an alternative take on traditional Kubernetes Ingress Controllers, using <a href=\"https://www.boundaryproject.io/\">HashiCorp Boundary</a> to enable secure, controlled ingress to workloads hosted on Kubernetes. For this proof of concept, you will need to deploy and configure your own Kubernetes and HashiCorp Cloud Platform (HCP) Boundary clusters (documentation links provided). In addition, you’ll need administrative access with the appropriate tooling for both <a href=\"https://developer.hashicorp.com/boundary/docs/commands\">Boundary</a> and <a href=\"https://kubernetes.io/docs/reference/kubectl/\">Kubernetes</a>. Later on in the blog, references will also be made to the <a href=\"https://developer.hashicorp.com/boundary/docs/api-clients/desktop\">Boundary desktop client</a>.</p>\n\n<p>HCP Boundary is HashiCorp’s fully managed, cloud-hosted Boundary offering (the first 50 sessions per month are free). The concepts in this blog are also applicable to Boundary Enterprise.</p>\n\n<h2>What is an ingress controller?</h2>\n\n<p>Typically, when working with a Kubernetes platform there will come a point in time when you want to expose the workloads that you’re hosting on your Kubernetes platform to a wider audience. This may be to an audience within a department, an organization, or even to public consumers. Broadly speaking, this is achieved through the use of the <a href=\"https://kubernetes.io/docs/concepts/services-networking/ingress/\">ingress controller</a> configured within your Kubernetes platform. </p>\n\n<p>There are a <a href=\"https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/\">vast number of ingress controllers available</a>, both commercially and community-supported. Some Kubernetes distributions will even ship with an ingress solution pre-configured and ready to go.</p>\n\n<p>For this proof of concept, a self-managed deployment of Red Hat’s <a href=\"https://www.redhat.com/en/technologies/cloud-computing/openshift/container-platform\">OpenShift Container Platform</a> was used as the Kubernetes platform, which ships with an ingress implementation based on <a href=\"https://www.haproxy.org/\">HAProxy</a>. However, it should be noted that the specifics of the Kubernetes platform and its ingress controller are largely irrelevant, as this workflow relies on core Kubernetes resources that will be available irrespective of the platform provider.</p>\n\n<h2>What is HashiCorp Boundary?</h2>\n\n<p>Fundamentally, <a href=\"https://www.hashicorp.com/products/boundary\">Boundary</a> is not an ingress controller. It doesn’t even pretend to be one. Boundary is an identity-aware proxy aimed at simplifying and securing least-privileged access to cloud infrastructure. </p>\n\n<p>From an administrator’s point of view, Boundary provides a simple way for authenticated users to have secure, authorized access to cloud and self-managed infrastructure without exposing the target networks to the end user, or (depending on the use case) requiring the use of managed credentials.</p>\n\n<p>From an end user’s point of view, Boundary offers a standardized workflow for connecting to infrastructure resources, wherever they reside. Through the use of Boundary’s consistent access workflow, end users no longer need to be concerned about managing a list of target resources they require access to, nor do they need to manage the myriad of credentials such use cases usually require.</p>\n\n<h2>Architecture</h2>\n\n<p>At a high level, the architecture for our proof of concept looks like the following diagram:</p>\n<img src=\"https://www.datocms-assets.com/2885/1699481484-boundary-kubernetes-poc-arch.png\" alt=\"High-level\" /><p>The approach above requires the configuration of a <a href=\"https://developer.hashicorp.com/boundary/tutorials/hcp-administration/hcp-manage-workers\">self-managed Boundary worker</a> within a target Kubernetes namespace, authenticating itself and establishing trust with the HCP Boundary control plane.</p>\n\n<p>This pattern works without the explicit use of an ingress method because the Boundary worker handles establishing connectivity back to the HCP Boundary control plane. The worker uses its HCP cluster ID to discover the implicit HCP Boundary workers associated with its Boundary cluster, and proxies its connection through these back to the control plane. There’s no inbound traffic that needs to reach into the Kubernetes namespace from outside the Kubernetes cluster in order to establish the connection.</p>\n\n<p>Once Boundary is configured in the manner described in this post, a client can establish a connection with private resources adjacent to the self-managed Boundary worker using what Boundary refers to as a <a href=\"https://developer.hashicorp.com/boundary/tutorials/hcp-administration/hcp-manage-multi-hop\">multi-hop session</a>. A multi-hop session is when two or more workers — in this case, an implicitly configured HCP Boundary worker and the self-managed Boundary worker — are chained together creating multiple ‘hops’ from the client to the target. Once this multi-hop session is established, it can be used to access Kubernetes-hosted resources listening on a standard Kubernetes service IP/port  — no ingress solution required!</p>\n\n<h2>Building the Boundary worker container image</h2>\n\n<p>For this walkthrough, you will need an HCP Boundary cluster. You can follow our <a href=\"https://developer.hashicorp.com/boundary/docs/hcp/get-started/deploy-and-login\">Deploy HCP Boundary and log in</a> tutorial if you don’t have an existing cluster set up. </p>\n\n<p>Once your initial environment is set up, you will start by building a Boundary worker image. In order to do this, use Red Hat’s Minimal <a href=\"https://catalog.redhat.com/software/base-images\">Universal Base Image</a> (UBI) for <a href=\"https://catalog.redhat.com/software/containers/ubi9/ubi-minimal/615bd9b4075b022acc111bf5\">Red Hat Enterprise Linux 9</a> as the base image along with the HashiCorp-provided RPM packages installed and configured on top of that.</p>\n\n<p>This small form-factor base image provides everything required to run the Boundary worker.</p>\n<pre><code>FROM registry.access.redhat.com/ubi9-minimal:latest\n\nUSER root\n\nRUN microdnf -y install yum-utils &amp;&amp; \\\n   yum-config-manager --add-repo https://rpm.releases.hashicorp.com/RHEL/hashicorp.repo &amp;&amp; \\\n   microdnf -y install boundary-enterprise &amp;&amp; \\\n   mkdir -p /opt/boundary/{data,config} &amp;&amp; \\\n   cp /etc/boundary.d/worker.hcl /opt/boundary/config/ \n        \nRUN chgrp -R 0 /usr/bin/boundary &amp;&amp; \\                   \n   chmod -R g=u /usr/bin/boundary &amp;&amp; \\\n   chgrp -R 0 /opt/boundary &amp;&amp; \\\n   chmod -R g=u /opt/boundary\n\nUSER boundary\n\nENTRYPOINT [\"boundary\"]\nCMD [\"server\", \"-config=/opt/boundary/config/worker.hcl\"]\n</code></pre><p>Let’s break down this Containerfile a little bit.</p>\n<pre><code>FROM registry.access.redhat.com/ubi9-minimal:latest\n\n...\n\nRUN microdnf -y install yum-utils ...</code></pre><p>This UBI image is a freely distributable, minimal footprint container image that ships with a lightweight version of the DNF package manager called <em>microdnf</em>. This is used to install the package needed to add the HashiCorp RPM repository, and then install the Boundary Enterprise package.</p>\n<pre><code>cp /etc/boundary.d/worker.hcl /opt/boundary/config/</code></pre><p>Once this is done, the default template Boundary configuration (provided by the installer) can be moved to where it needs to be on the filesystem. This represents the bare minimum configuration required to run a Boundary worker to completion — nothing more.</p>\n<pre><code>RUN chgrp -R 0 /usr/bin/boundary ...</code></pre><p>Given that this image will need to conform to the security requirements of the platform on which it runs — in this case, Red Hat OpenShift Container Platform — the container image needs to support execution as an arbitrary UID. These updates simply ensure that when the Boundary process is run, it has access to the filesystem resources that it requires.</p>\n<pre><code>ENTRYPOINT [\"boundary\"]\nCMD [\"server\", \"-config=/opt/boundary/config/worker.hcl\"</code></pre><p>Once the basic image is defined, the <code>ENTRYPOINT</code> and command (<code>CMD</code>) to run the Container image can be configured. This also establishes a fixed path for the Boundary worker configuration that can be overridden at runtime.</p>\n\n<h2>Boundary worker configuration</h2>\n\n<p>Once the image has been built and pushed to a container registry location that’s resolvable from the Kubernetes cluster, the Boundary worker itself can be configured. This is done via a file written in the HashiCorp Configuration Language (HCL: a common DSL used across HashiCorp’s products) which will then be presented to the running container in its Pod as a Kubernetes ConfigMap.</p>\n<pre><code>disable_mlock = true\n\nhcp_boundary_cluster_id = \"env://HCP_BOUNDARY_CLUSTER_ID\" \n\nlistener \"tcp\" {\n address = \"0.0.0.0:9202\"                             \n purpose = \"proxy\"\n}\n\nlistener \"tcp\" {\n address = \"0.0.0.0:9203\"                             \n purpose = \"ops\"\n tls_disable = true\n}\n\nworker {\n controller_generated_activation_token = \"env://CONTROLLER_GENERATED_ACTIVATION_TOKEN\"\n\n\n auth_storage_path = \"/opt/boundary/data\"\n tags {\n   type = [\"openshift\", \"kubernetes\"]\n   namespace = \"application\"\n }\n}</code></pre><p>As with the Containerfile, it helps to examine the configuration file in a bit more detail. In this example there are six particular elements that will be of interest.</p>\n<pre><code>hcp_boundary_cluster_id = \"env://HCP_BOUNDARY_CLUSTER_ID\"</code></pre><p>The HCP Boundary cluster ID is a unique identifier that allows the Boundary worker you’ve built to discover the HCP Boundary cluster it is aligned with. As this is passed in as an environment variable, it allows the Boundary worker configuration to be configured completely agnostic of the HCP Boundary cluster it is supposed to be registering with.</p>\n<pre><code>listener \"tcp\" {\n  address = \"0.0.0.0:9202\"        \n  purpose = \"proxy\"\n}</code></pre><p>The listener block defines the address and port combination on which the Boundary worker serves traffic. Each Boundary worker will have this single mandatory listener labeled proxy. The default port for the listener is 9202, but this is configurable.</p>\n<pre><code>listener \"tcp\" {\n  address = \"0.0.0.0:9203\"                             \n  purpose = \"ops\"\n  tls_disable = true\n}</code></pre><p>A second, optional listener block called ops allows access to the operational endpoints of the Boundary worker. In this case, these are used to expose Prometheus-format metrics to observability components within the Kubernetes cluster. The default port for this is 9203, but again, this is configurable.</p>\n<pre><code>controller_generated_activation_token = \"env://CONTROLLER_GENERATED_ACTIVATION_TOKEN\"</code></pre><p>The <code>CONTROLLER_GENERATED_ACTIVATION_TOKEN</code> is a single-use credential initially provided by the system administrator to the Boundary worker as a means of authenticating and authorizing the worker with the HCP Boundary control plane. This is Boundary’s <a href=\"https://developer.hashicorp.com/boundary/docs/configuration/worker/pki-worker#controller-led-authorization-flow\">controller-led authorization workflow</a> in action, one of two methods that can be used to register a worker with a cluster. In this example, the token is configured as an environment variable. </p>\n\n<p>The second method that could be used to register the Boundary worker is the <a href=\"https://developer.hashicorp.com/boundary/docs/configuration/worker/pki-worker#worker-led-authorization-flow\">worker-led authorization workflow</a>. This just isn’t practical in the containerization use case as it requires user intervention at runtime, which is not ideal in a Kubernetes cluster. See the following link for <a href=\"https://developer.hashicorp.com/boundary/docs/configuration/worker/pki-worker#authorization-methods\">more information on authorization methods in Boundary</a>.</p>\n<pre><code>auth_storage_path = \"/opt/boundary/data\"</code></pre><p>It should be noted that the <code>auth_storage_path</code> aligns with one of the file paths created and managed as part of the initial container image creation. This is more important when it comes to configuring how the Boundary worker is deployed within the Kubernetes platform. A persistent volume resource will be mounted at this location.</p>\n<pre><code> tags {\n   type = [\"openshift\", \"kubernetes\"]\n   namespace = \"application\"\n }\n</code></pre><p>Tags are a very useful, arbitrary, metadata construct within Boundary. At the time of writing, they allow traffic for a given set of Boundary targets to be proxied through through a specific worker or group of workers. In this instance, there are a pair of tags that define the type of platform the Boundary worker is deployed on (OpenShift/Kubernetes), as well as a namespace tag that matches the Kubernetes namespace into which the Boundary worker is deployed. In this setup, Boundary sessions destined for Boundary targets within this Kubernetes namespace can be routed explicitly through this Boundary worker.</p>\n\n<p>A broad overview of the configuration file and its syntax can be found in the <a href=\"https://developer.hashicorp.com/boundary/docs/configuration\">HashiCorp Boundary documentation</a>.</p>\n\n<h2>Registering the Boundary worker</h2>\n\n<p>Because the method being used to register the Boundary worker in Kubernetes with the HCP Boundary cluster is the controller-led authorization workflow, this initial configuration to retrieve the one-time activation token must be carried out by an human operator. This token can subsequently be used by the Boundary worker to authenticate and authorize itself with the HCP Boundary control plane.</p>\n\n<p>It sounds complex, but the process is very simple and can be undertaken from the Boundary CLI once authenticated with the HCP Boundary cluster:</p>\n<pre><code>% boundary workers create controller-led -name=kubernetes-applications-worker\nWorker information:\n  Active Connection Count:                 0\n  Controller-Generated Activation Token:   neslat_...\n  Created Time:                            Tue, 19 Sep 2023 13:46:55 BST\n  ID:                                      w_HmpjVGqXyj\n  Name:                                    kubernetes-applications-worker\n  Type:                                    pki\n  Updated Time:                            Tue, 19 Sep 2023 13:46:55 BST\n  Version:                                 1\n  Scope:\n    ID:                                    global\n    Name:                                  global\n    Type:                                  global\n  Authorized Actions:\n    no-op\n    read\n    update\n    delete\n    add-worker-tags\n    set-worker-tags\n    remove-worker-tags</code></pre><p>See? Done.</p>\n\n<p>Contained within the registration response is the field containing the controller generated activation token. It is this value that should be presented as the <code>CONTROLLER_GENERATED_ACTIVATION_TOKEN</code> environment variable in the Boundary worker configuration so that it can complete the registration process with the HCP Boundary control plane.</p>\n\n<p>It is worth noting that once the Boundary worker starts, it is safe to keep this token in the environment variable even after the worker has successfully authorized and authenticated because it will be unusable after that point.</p>\n\n<h2>Deploying the Boundary worker</h2>\n\n<p>Now that the Boundary worker container image is built and the activation token has been acquired from HCP Boundary, the Boundary worker can be deployed.</p>\n\n<p>In this instance, the Boundary worker will be deployed on Kubernetes as a StatefulSet. While the Boundary worker is not an inherently stateful application, the use of the controller-led authorization workflow means that it does need persistent storage in order to hold onto the registration data it receives from the HCP Boundary control plane. This could be achieved with a standard Kubernetes deployment but it is conceptually beneficial to enforce a one-to-one mapping between the Boundary worker Pod and its persistent volume. </p>\n\n<p>This mapping is helpful because scaling up a Kubernetes deployment to provision multiple replicas of the Boundary worker will cause a registration race condition; each replica continuously attempts to register, will be successful, and then will lose contact when the next replica successfully registers using the same registration data sourced from the same Persistent Volume. The end result is that none of the replicas stay available long enough to be usable.</p>\n\n<p>By using a StatefulSet, the architecture is still bound to a single Boundary worker per StatefulSet — there’s no getting away from that — but there’s no shared storage and therefore no shared registration data to handle. Any instance other than the original will simply fail to authenticate to the HCP Boundary control plane without interrupting the operations of the original instance, all while retaining the self-healing attributes naturally present in Kubernetes Pods.</p>\n<img src=\"https://www.datocms-assets.com/2885/1699481445-k8s-resources-statefulset.png\" alt=\"Kubernetes\" /><p>Figure 2 describes the Kubernetes resources that will be created and utilized. Both the PersistentVolume and ConfigMap will be mounted into the resulting Pod at the paths explicitly stated in the Containerfile: <em>/opt/boundary/data</em> and <em>/opt/boundary/config</em> respectively.</p>\n\n<p>Once the resources have been applied, the Boundary worker should use its configuration, consumed from the ConfigMap, to register itself with its HCP Boundary cluster. Looking at the Pod logs should yield a ‘server started’ message similar to the one below:</p>\n<pre><code>==&gt; Boundary server configuration:\nCgo: disabled\nListener 1: tcp (addr: \"0.0.0.0:9202\", max_request_duration: \"1m30s\", purpose: \"proxy\")\nListener 2: tcp (addr: \"0.0.0.0:9203\", max_request_duration: \"1m30s\", purpose: \"ops\")\nLog Level: info\nMlock: supported: true, enabled: false\nVersion: Boundary v0.13.2+ent\nVersion Sha: b1f75f5c731c843f5c987feae310d86e635806c7\nWorker Auth Storage Path: /opt/boundary/data\nWorker Public Proxy Addr: 0.0.0.0:9202\n==&gt; Boundary server started! Log data will stream in below:</code></pre><p>A successful registration can subsequently be confirmed by examining the <em>Workers</em> tab in the HCP Boundary admin UI.</p>\n<img src=\"https://www.datocms-assets.com/2885/1699481604-boundary-worker-reg-ui.png\" alt=\"Worker\" /><p>The name of the Boundary worker should align with the name provided when initiating the controller-led authorization workflow. The tags configured for the Boundary worker should also be visible if they have been successfully read from the Boundary worker configuration. In this example, the namespace tag has been propagated to the HCP Boundary control plane, which will enable filtering of Boundary targets by Boundary worker.</p>\n\n<h2>Setting a Boundary target</h2>\n\n<p>One of the reasons that Red Hat OpenShift Container Platform was chosen as the target operating environment for this proof of concept, is that it is supplied with a plethora of example applications and services ready to be deployed out of the box. Given that any Boundary target demonstration doesn’t need to be particularly sophisticated, two examples have been selected from OpenShift’s catalog to demonstrate Boundary’s capabilities: a basic Node.js application, and a PostgreSQL database.</p>\n<img src=\"https://www.datocms-assets.com/2885/1699482961-example-node-js-page-edited.png\" alt=\"Example\" /><p>This example application is clearly being resolved via its Fully Qualified Domain Name (FQDN) and is therefore an ingress solution. For this walkthrough, you will remove the FQDN when the time comes to use Boundary as the method of communicating with these workloads.</p>\n\n<p>What actually matters here, from a networking perspective, is the actual Kubernetes services that will be used as the Boundary targets. We can examine those with a simple <code>kubectl</code> command.</p>\n<pre><code>% kubectl get services -n application\nNAME                  TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)   ...\nboundary-worker       ClusterIP  None                     9202/TCP,9203/TCP \nnodejs-basic          ClusterIP  172.30.38.208            3001/TCP\npostgresql            ClusterIP  172.30.199.135           5432/TCP \n</code></pre><p>Some of this output has been omitted for brevity, but it clearly shows the IP address and the port(s) provisioned for the Node.js application and the PostgreSQL database respectively. </p>\n\n<p>This information can be used to configure a Boundary target within the HCP Boundary cluster. This is accomplished using the <em>Targets</em> tab within the Boundary admin UI.</p>\n<img src=\"https://www.datocms-assets.com/2885/1699482200-generic-tcp-target-boundary.png\" alt=\"Configuring\" /><p>In Figure 5, the IP address and port combination of the Kubernetes service will be used to complete the <em>Target Address</em> and <em>Default Port</em> fields within the HCP Boundary admin UI.</p>\n\n<p>The next element of the Boundary target configuration is presented further down the same page — the section titled <em>Workers</em>. In this section, the egress worker can be defined using the same set of tags in the Boundary worker configuration shown previously. This enables the multi-hop behavior alluded to earlier.</p>\n<img src=\"https://www.datocms-assets.com/2885/1699482266-egress-worker-filter-boundary.png\" alt=\"Configuring\" /><p>The steps above are required to configure the Node.js application as a Boundary target. The process is repeated for the PostgreSQL database, with the result being that there are now two Boundary targets configured within the HCP Boundary admin UI that can be used to access resources embedded within the Kubernetes cluster.</p>\n<img src=\"https://www.datocms-assets.com/2885/1699482319-boudary-targets-figure.png\" alt=\"Boundary\" /><h2>Connecting to the Boundary targets</h2>\n\n<p>Now that the Boundary targets are configured, they are usable from within Boundary itself. Using either the <a href=\"https://developer.hashicorp.com/boundary/tutorials/oss-getting-started/oss-getting-started-desktop-app\">Boundary Desktop client</a> or the Boundary command line interface (CLI), an end user  —  once authenticated and authorized with Boundary using one of the provided authentication methods  —  can simply connect to the Boundary target and start working with it. The end user doesn’t need to know anything about the target addresses or ports required to access the target.</p>\n\n<p>From the UI, this is as simple as clicking on the Connect button, which displays a pop-up confirming the status of that action and, if successful, the proxy information required to access the Boundary target.</p>\n<img src=\"https://www.datocms-assets.com/2885/1699482387-success-connection-boundary.png\" alt=\"A\" /><p>Opening a web browser to this proxy address yields the same content displayed in Figure 4.</p>\n<img src=\"https://www.datocms-assets.com/2885/1699482720-example-node-js-app-boundary-success-edited.png\" alt=\"Example\" /><p>The same Boundary Desktop client workflow can be used to initiate a further connection to the PostgreSQL database running in the Kubernetes cluster. The end user may then connect using the presented proxy information from the <em>psql</em> CLI tooling.</p>\n<pre><code>% psql -h 127.0.0.1 -p 55376 -U myapp -d boundary-example\nPassword for user myapp:\npsql (16.0, server 10.23)\nType \"help\" for help.\n\nboundary-example=&gt;</code></pre><p>In the CLI extract presented above, the presence of a credential is clearly requested  —  and provided  —  as part of the authentication exchange. However, allowing end user visibility on specific credentials is not always desirable, as it can lead to credential management issues further on.  Generally, you don’t want credentials written on a note, captured in a file on the user’s machine, or accidentally committed to source control.</p>\n\n<p>To prevent these kinds of credential mishandling issues, Boundary can make use of its <a href=\"https://developer.hashicorp.com/boundary/docs/concepts/credential-management#credential-management\">credential management capabilities </a> —  in this case <a href=\"https://developer.hashicorp.com/boundary/docs/concepts/credential-management#credential-brokering\">brokered credentials</a>  —  to <a href=\"https://developer.hashicorp.com/boundary/docs/getting-started/dev-mode/connect-to-dev-target#postgresql-connect-helper\">implicitly supply the credentials for that PostgreSQL database into the Boundary session</a> when the session is established. This removes the need for the end user to ever know what those credentials actually are. In this workflow, Boundary is simply providing access to a system that the authenticated end user is permitted to access based on Boundary’s access rules.</p>\n<pre><code>% boundary connect postgres -target-name=postgresql -target-scope-name=kubernetes -dbname=boundary-example\npsql (16.0, server 10.23)\nType \"help\" for help.\n\nboundary-example=&gt;</code></pre><p>Although brokered and injected credentials will not be covered in detail here, credential management is an incredibly powerful aspect of Boundary that can help to enforce a zero trust posture around human-to-machine access, irrespective of where the machine  —  or the human  —  is located.</p>\n\n<h2>Boundary Worker Operator</h2>\n\n<p>In an effort to make the configuration and deployment of a Boundary worker on Kubernetes as easy to undertake as possible, a companion <a href=\"https://kubernetes.io/docs/concepts/extend-kubernetes/operator/\">Kubernetes Operator</a> is available. This project includes the Kubernetes setup elements described in this blog post, and can be found in the <a href=\"https://github.com/benemon/boundary-worker-operator\">boundary-worker-operator</a> GitHub project.</p>\n\n<p>The Boundary Worker Operator requires the creation of a small custom resource that provides — at a very basic level — the ability to inform the Boundary worker of its HCP cluster ID and its controller-generated activation token.</p>\n<pre><code>apiVersion: workers.boundaryproject.io/v1alpha1\nkind: BoundaryPKIWorker\nmetadata:\n  name: my-boundary-worker\n  Namespace: my-application\nspec:\n  registration:\n    controllerGeneratedActivationToken: neslat_...\n    hcpBoundaryClusterID: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</code></pre><p>Options exist for modifying the storage configuration for the worker, as well as its resource requests and limits. Furthermore, the custom resource also provides a way to preconfigure tags on the Boundary worker. Changes to any of these elements forces a reconciliation of the deployed worker’s state and the configuration will update as necessary.</p>\n\n<p>This community-centric operator is the sole work of the author, and is not affiliated, supported or endorsed by HashiCorp in any capacity.</p>\n\n<h2>Summary</h2>\n\n<p>In an effort to answer the original question, you can now hopefully see how the use of Boundary in this manner can help improve the security of application content and components hosted within Kubernetes. In this post, this was demonstrated in four key ways:</p>\n\n<ol>\n<li><p>By removing an explicit ingress path to the Kubernetes workload(s) in question, we remove a potentially long-lived attack vector — the FQDN of that workload.</p></li>\n<li><p>Despite being able to access Kubernetes-hosted resources, the end-user is not on the Kubernetes network. There’s no VPN or similar solution at play here that would allow direct traversal to other targets within the Kubernetes namespace or the wider cluster.</p></li>\n<li><p>Boundary operates under the principle that every action is authenticated and authorized. A user must have established their identity with Boundary in order to access their configured Boundary targets. If no access rules exist for an authenticated user, then no Boundary targets are presented; a deny-by-default stance. This is in contrast to an application or component accessible over an FQDN which would have to solely rely on its own — or platform provided — security measures to secure itself.</p></li>\n<li><p>The Boundary workflow presented here for accessing the PostgreSQL database was secured through the use of Boundary’s brokered credential capability. To expand on this concept: <a href=\"https://developer.hashicorp.com/boundary/tutorials/hcp-administration/hcp-ssh-cred-injection\">When Boundary is integrated with HashiCorp Vault</a>, credentials for the Boundary targets can be vended on a just-in-time basis, with the credential lifecycle tightly bound to that of the Boundary session.</p></li>\n</ol>\n\n<p>Finally, the artifacts used to build, deploy, and configure the Boundary worker used in this post have been published to <a href=\"https://github.com/benemon/boundary-ingress-blog/tree/0.14\">this companion GitHub repository</a> for the article.</p>\n\n<p>The use of Boundary in this manner starts to open up some really exciting possibilities for human-to-machine access to resources hosted in a Kubernetes cluster. What kind of use cases would you be able to address using Boundary workers on Kubernetes?</p>\n\n<p><a href=\"https://www.hashicorp.com/products/boundary\">Register on the HashiCorp Cloud Platform if you’d like to test drive HCP Boundary</a> with 50 free sessions per month.</p>\n","author":"Ben Holmes","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"36031bc6bbbd7d9a4288fc30a02811e8f2f70becf63ac593731a0777004ae241","category":"Tech"}