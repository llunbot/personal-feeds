{"title":"รูปแบบที่น่าสนใจ สำหรับจัดการปัญหาการติดต่อสื่อสารระหว่าง service","link":"https://www.somkiat.cc/problems-from-service-to-service/","date":1627797966000,"content":"<p><img src=\"https://www.somkiat.cc/wp-content/uploads/2021/08/communication-fail-150x150.jpg\" /></p>\n<figure><img src=\"https://www.somkiat.cc/wp-content/uploads/2021/08/communication-fail.jpg\" /></figure>\n\n\n\n<p>ในระบบงานมักจะมีการติดต่อสื่อสารระหว่างระบบหรือ service<br /><strong><em>ผ่านระบบ network ที่ขึ้นชื่อว่า พร้อมพัง ได้เสมอ</em></strong><br />ดังนั้นในการออกแบบ พัฒนา และ ทดสอบระบบ<br />ต้องทำให้มั่นใจว่าการติดต่อสื่อสารจะต้องทำงานตามที่เราต้องการเสมอ<br />ทั้งการทำงานให้เสร็จ <br />ทั้งการทำงานอย่างไรเมื่อเกิดปัญหาขึ้นมา<br />เพื่อให้ระบบงานมีความน่าเชื่อถือมากยิ่งขึ้น</p>\n\n\n\n<span></span>\n\n\n\n<p><strong>โดยรูปแบบยอดนิยมของการจัดการ ​​มีดังนี้​</strong></p>\n\n\n\n<ul><li>Timeout</li><li>Retry</li><li>Circuit braker</li><li>Bulkhead</li></ul>\n\n\n\n<p><strong>แบบที่ 1 Timeout</strong></p>\n\n\n\n<p>เป็นรูปแบบที่ถูกใช้งานมากที่สุด<br />เพราะว่า service หรือ ระบบปลายทาง อาจจะเกิดปัญหาขึ้นมา<br />ส่งผลให้ตอบกลับได้ช้ากว่าปกติ<br />ดังนั้นเพื่อป้องกันการทำงานที่นาน หรือใช้ resource มากจนเกินไป<br />จึงทำการกำหนด timeout ของการใช้งานไว้<br />เมื่อถึง timeout ก็จะตัดการเชื่อมต่อ หรือ คืน resource ให้ระบบกลับไป</p>\n\n\n\n<p>ยกตัวอย่างการใช้งาน Database connection pool<br />หรืออาจจะเป็น network connection <br /><br />ดังนั้นทางผู้เรียกใช้งานจะได้ระบบผลกลับมาว่า Connection timeout<br />จากนั้นก็ต้องจัดการว่าจะทำอย่างไรต่อไป<br /><br />คำถามที่น่าสนใจคือ <br />ระบบปลายทางยังมีปัญหาแล้ว request อื่น ๆ ยังจะเรียกอีกหรือ ?</p>\n\n\n\n<p><strong>แบบที่ 2 Retry</strong></p>\n\n\n\n<p>เป็นอีกรูปแบบที่ถูกใช้งาน เพื่อแก้ไขปัญหาที่เกิดจากความผิดพลาด<br />อาจจะไม่เรียกว่าเป็นการแก้ไขปัญหา<br />แต่เป็นวิธีการที่จะทำต่อ หลังจากการทำงานมีปัญหา<br /><br />ยกตัวอย่างเช่น เกิด timeout หรือ ระบบล่ม ขึ้นมา<br />ดังนั้นทางฝั่งคนเรียกใช้ ก็ต้องจัดการต่อไป<br /><strong>การ retry</strong> คือการทำซ้ำไปเรื่อย ๆ ตามจำนวนครั้ง และ interval ที่กำหนด<br />ทำไปจนกว่าจะทำงานสำเร็จ !!<br />มักจะเจอบ่อยกับงานที่เป็น batch job<br />หรือเป็นพวกระบบ messaging นั่นเอง<br /><br />คำถามที่น่าสนใจคือ <br />ระบบปลายทางยังมีปัญหายังจะ retry อีกหรือ ?<br />หรื retry กันตอนไหน ?</p>\n\n\n\n<p><strong>แบบที่ 3 Circuit breaker</strong></p>\n\n\n\n<p>เป็นอีกวิธีที่ได้รับความนิยมในปัจจุบัน<br />แต่หลาย ๆ คนไม่รู้จัก ไม่เข้าใจส่งผลให้ไม่ได้ใช้งานกัน<br /><br /><strong>โดยใช้หลักการเหมือนการตัดไฟเมื่อเกิดการช๊อตขึ้นมา</strong><br />ถ้าเทียบกับระบบคือ <br />ผู้เรียกใช้งานจะไม่เรียก service หรือ ระบบปลายทาง<br />เมื่อมีปัญหาตามรูปแบบที่ตกลงร่วมกันไว้ยกตัวอย่างเช่น</p>\n\n\n\n<ul><li>มีจำนวน concurrent user มากกว่า 1,000 คนในช่วง 1 นาที</li><li>มีจำนวนความผิดพลาด เช่น timeout มากกว่า 3 ครั้งในช่วง 1 นาที หรือ 10% ของ request ในช่วงเวลาหนึ่ง ๆ เป็นต้น</li></ul>\n\n\n\n<p><strong>โดยทางผู้เรียกใช้งานจะรู้ทันทีว่าปลายทางมีปัญหา</strong><br />ทำให้สามารถจัดการได้ว่า<br />เมื่อมี request เข้ามาหลังจากนี้จะจัดการอย่างไร<br />วิธีการที่ได้รับความนิยมคือ<strong> fail fast</strong><br />นั่นคือ ส่งผลการทำงานที่ fail กลับไปทันที <br />ไม่ต้องส่ง request ไปยังปลายทาง<br />เป็นการลดภาระไปในตัว<br />พร้อมทั้งช่วยให้ service ปลายทาง สามารถ recovery กลับมาได้ง่ายขึ้น<br />หรืออาจจะใช้วิธีการอื่น ๆ นอกเหนือจาก fail fast เช่น</p>\n\n\n\n<ul><li>ส่งค่าล่าสุดที่เก็บไว้จาก database หรือ caching</li><li>ไปเรียก service อื่น ๆ ที่วางแผนไว้แล้ว</li></ul>\n\n\n\n<p><strong>แบบที่ 4 Bulkhead</strong></p>\n\n\n\n<p>เป็นหลักการที่ใช้สำหรับป้องกันปัญหาที่เกิดจากระบบหนึ่งทำงานผิดพลาด<br />แล้วอาจจะส่งผลให้ทั้งระบบพังได้<br />จึงมักจะทำแผนสำรองไว้<br />ยกตัวอย่างเช่น Active-stand by หรือเป็น Muti-data center เป็นต้น<br />เมื่อเกิดปัญหาขึ้นมาที่หนึ่ง แล้วจะทำการเปลี่ยนไปใช้อีกที่โดยอัตโนมัติ<br />อย่าลือซ้อมบ่อย ๆ ละ !!</p>\n\n\n\n<p><strong>ยังมีแนวทางอื่น ๆ ช่วยจัดการปัญหาที่เกิดขึ้นอีก</strong></p>\n\n\n\n<p>ยกตัวอย่างเช่น Feature toggle <br />ทำการเปิดหรือปิด feature ของระบบได้ทันที<br />เพื่อลดความผิดพลาดและปัญหาอื่น ๆ ที่จะตามมา</p>\n\n\n\n<p>หรือจะเป็นพวก</p>\n\n\n\n<ul><li>Rate limit</li><li>Redundancy</li><li>Caching</li><li>Boundary validation</li><li>Rollback</li><li></li></ul>\n\n\n\n<p>วิธีการต่าง ๆ ไม่ได้ทำให้ความผิดพลาดหายไป<br />แต่เป็นการลดผลที่เกิดจากความผิดพลาด<br />ไม่ให้มันกระทบไปทั้งระบบ<br />ไม่ให้กระทบกับผู้ใช้งานโดยรวม<br /><br /><strong><em>ความผิดพลาดเกิดขึ้นได้ <br />แต่เราต้องเรียนรู้ที่จะปรับปรุงและจัดการมันเช่นกัน</em></strong></p>\n\n\n\n<p><strong>Reference websites</strong></p>\n\n\n\n<p><a href=\"https://levelup.gitconnected.com/10-robustness-and-resiliency-design-patterns-to-learn-today-c03776f73936\">https://levelup.gitconnected.com/10-robustness-and-resiliency-design-patterns-to-learn-today-c03776f73936</a></p>\n","author":"somkiat","siteTitle":"cc :: somkiat","siteHash":"3a23a5a4389e1e40c6fbb16520a8cc20df5b3591c25145ce72aaa18b19e48201","entryHash":"59ad8b0674e0151a988d7b46f491a12b1d8554bc92834101b3e01870555c723b","category":"Thai"}