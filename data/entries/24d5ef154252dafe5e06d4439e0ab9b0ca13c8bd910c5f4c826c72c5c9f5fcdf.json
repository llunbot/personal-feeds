{"title":"How To Build An E-Commerce Site With Angular 11, Commerce Layer And Paypal","link":"https://smashingmagazine.com/2021/07/ecommerce-angular11-headless-paypal/","date":1627642800000,"content":"<p>Nowadays it’s essential to have an online presence when running a business. A lot more shopping is done online than in previous years. Having an e-commerce store allows shop owners to open up other streams of revenue they couldn't take advantage of with just a brick and mortar store. Other shop owners however, run their businesses online entirely without a physical presence. This makes having an online store crucial. </p>\n<p>Sites such as Etsy, Shopify and Amazon make it easy to set up a store pretty quickly without having to worry about developing a site. However, there may be instances where shop owners may want a personalized experience or maybe save on the cost of owning a store on some of these platforms. </p>\n<p>Headless e-commerce API platforms provide backends that store sites can interface with. They manage all processes and data related to the store like customer, orders,  shipments, payments, and so on. All that’s needed is a frontend to interact with this information. This gives owners a lot of flexibility when it comes to deciding how their customers will experience their online store and how they choose to run it.  </p>\n<p>In this article, we will cover how to build an e-commerce store using Angular 11. We shall use <a href=\"https://commercelayer.io/\">Commerce Layer</a> as our headless e-commerce API. Although there may be tonnes of ways to process payments, we’ll demonstrate how to use just one, <a href=\"https://paypal.com\">Paypal</a>.  </p>\n<ul>\n<li><a href=\"https://github.com/zaracooper/lime-app\">View source code on GitHub →</a></li>\n</ul>\nPrerequisites\n<p>Before building the app, you need to have Angular CLI installed. We shall use it to initialize and scaffold the app. If you don’t have it installed yet, you can get it through <a href=\"https://www.npmjs.com/\">npm</a>.  </p>\n<pre><code>npm install -g @angular/cli</code></pre>\n\n<p>You’ll also need a Commerce Layer developer account. Using the developer account, you will need to create a test organization and seed it with test data. Seeding makes it easier to develop the app first without worrying about what data you’ll have to use. You can create an account at this <a href=\"https://core.commercelayer.io/users/sign_up\">link</a> and an organization <a href=\"https://core.commercelayer.io/admin/account/organizations/new\">here</a>.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f242a4e3-fa42-4400-8a44-0aea63771a30/7-jamstack-e-commerce-site-angular-11-scull.png\" /></p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/072c5747-6d1d-4cb3-9690-db2f5741d76e/11-jamstack-e-commerce-site-angular-11-scull.png\" /></p>\n<p>Lastly, you will need a Paypal Sandbox account. Having this type of account will allow us to test transactions between businesses and users without risking actual money. You can create one <a href=\"https://developer.paypal.com/developer/accounts/\">here</a>. A sandbox account has a test business and test personal account already created for it. </p>\nCommerce Layer And Paypal Config\n<p>To make Paypal Sandbox payments possible on Commerce Layer, you’ll need to set up API keys. Head on over to the <a href=\"https://developer.paypal.com/developer/accounts/\">accounts overview</a> of your Paypal developer account. Select a business account and under the API credentials tab of the account details, you will find the <strong>Default Application</strong> under <strong>REST Apps</strong>. </p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/bfecf28c-ff68-4c7c-8703-d87b1c91657e/12-jamstack-e-commerce-site-angular-11-scull.png\" /></p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f276596c-cc2c-4757-bbdd-52f6134f66c4/14-jamstack-e-commerce-site-angular-11-scull.png\" /></p>\n<p>To associate your Paypal business account with your Commerce Layer organization, go to your organization’s dashboard. Here you will add a Paypal payment gateway and a Paypal payment method for your various markets. Under <strong>Settings &gt; Payments</strong>, select <strong>Payment Gateways &gt; Paypal</strong> and add your Paypal client Id and secret. </p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/0270ffe3-2ede-4045-acc5-4065af3245b4/8-jamstack-e-commerce-site-angular-11-scull.png\" /></p>\n<p>After creating the gateway, you will need to create a Paypal payment method for each market you are targeting to make Paypal available as an option. You’ll do this under <strong>Settings &gt; Payments &gt; Payment Methods &gt; New Payment Method</strong>.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a7e7b7d8-d6de-4927-9726-6ecb3e4cce14/22-jamstack-e-commerce-site-angular-11-scull.png\" /></p>\nA Note About Routes Used\n<p>Commerce Layer provides a route for authentication and another different set of routes for their API. Their <code>/oauth/token</code> authentication route exchanges credentials for a token. This token is required to access their API. The rest of the API routes take the pattern <code>/api/:resource</code>.  </p>\n<p>The scope of this article only covers the frontend portion of this app. I opted to store the tokens server side, use sessions to track ownership, and provide http-only cookies with a session id to the client. This will not be covered here as it is outside the scope of this article. However, the routes remain the same and exactly correspond to the Commerce Layer API. Although, there are a couple of custom routes not available from the Commerce Layer API that we’ll use. These mainly deal with session management. I’ll point these out as we get to them and describe how you can achieve a similar result.</p>\n<p>Another inconsistency you may notice is that the request bodies differ from what the Commerce Layer API requires. Since the requests are passed on to another server to get populated with a token, I structured the bodies differently. This was to make it easier to send requests. Whenever there are any inconsistencies in the request bodies, these will be pointed out in the services.  </p>\n<p>Since this is out of scope, you will have to decide how to store tokens securely. You’ll also need to slightly modify request bodies to match exactly what the Commerce Layer API requires. When there is an inconsistency, I will link to the <a href=\"https://docs.commercelayer.io/api/\">API reference</a> and <a href=\"https://docs.commercelayer.io/guides/\">guides</a> detailing how to correctly structure the body.</p>\nApp Structure\n<p>To organize the app, we will break it down into four main parts. A better description of what each of the modules does is given under their corresponding sections:</p>\n<ol>\n<li>the core module,</li>\n<li>the data module,</li>\n<li>the shared module,</li>\n<li>the feature modules.</li>\n</ol>\n<p>The feature modules will group related pages and components together. There will be four feature modules: </p>\n<ol>\n<li>the auth module,</li>\n<li>the product module,</li>\n<li>the cart module,</li>\n<li>the checkout module.</li>\n</ol>\n<p>As we get to each module, I’ll explain what its purpose is and break down its contents. </p>\n<p>Below is a tree of the <code>src/app</code> folder and where each module resides.   </p>\n<pre><code>src\n├── app\n│   ├── core\n│   ├── data\n│   ├── features\n│   │   ├── auth\n│   │   ├── cart\n│   │   ├── checkout\n│   │   └── products\n└── shared</code></pre>\n\nGenerating The App And Adding Dependencies\n<p>We’ll begin by generating the app. Our organization will be called <strong>The LIme Brand</strong> and will have test data already seeded by Commerce Layer. </p>\n<pre><code>ng new lime-app</code></pre>\n\n<p>We’ll need a couple of dependencies. Mainly <a href=\"https://material.angular.io/\">Angular Material</a> and <a href=\"https://material.angular.io/\">Until Destroy</a>. Angular Material will provide components and styling. Until Destroy automatically unsubscribes from observables when components are destroyed. To install them run:</p>\n<pre><code>npm install @ngneat/until-destroy\nng add @angular/material</code></pre>\n\nAssets\n<p>When adding addresses to Commerce Layer, an alpha-2 country code needs to be used. We’ll add a json file containing these codes to the <code>assets</code> folder at <code>assets/json/country-codes.json</code>. You can find this file <a href=\"https://github.com/zaracooper/lime-app/blob/main/src/assets/json/country-codes.json\">linked here</a>. </p>\nStyles\n<p>The components we’ll create share some global styling. We shall place them in <code>styles.css</code> which can be found at <a href=\"https://github.com/zaracooper/lime-app/blob/main/src/styles.css\">this link</a>.</p>\nEnvironment\n<p>Our configuration will consist of two fields. The <code>apiUrl</code> which should point to the Commerce Layer API. <code>apiUrl</code> is used by the services we will create to fetch data. The <code>clientUrl</code> should be the domain the app is running on. We use this when setting redirect URLs for Paypal. You can find this file at <a href=\"https://github.com/zaracooper/lime-app/blob/main/src/environments/environment.ts\">this link</a>.</p>\nShared Module\n<p>The shared module will contain services, pipes, and components shared across the other modules. </p>\n<pre><code>ng g m shared</code></pre>\n\n<p>It consists of three components, one pipe, and two services. Here’s what that will look like. </p>\n<pre><code>src/app/shared\n├── components\n│   ├── item-quantity\n│   │   ├── item-quantity.component.css\n│   │   ├── item-quantity.component.html\n│   │   └── item-quantity.component.ts\n│   ├── simple-page\n│   │   ├── simple-page.component.css\n│   │   ├── simple-page.component.html\n│   │   └── simple-page.component.ts\n│   └── title\n│       ├── title.component.css\n│       ├── title.component.html\n│       └── title.component.ts\n├── pipes\n│   └── word-wrap.pipe.ts\n├── services\n│   ├── http-error-handler.service.ts\n│   └── local-storage.service.ts\n└── shared.module.ts</code></pre>\n\n<p>We shall also use the shared module to export some commonly used Angular Material components. This makes it easier to use them out of the box instead of importing each component across various modules. Here’s what <a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/shared/shared.module.ts\"><code>shared.module.ts</code></a> will contain. </p>\n<div>\n<pre><code>@NgModule({\n  declarations: [SimplePageComponent, TitleComponent, WordWrapPipe, ItemQuantityComponent],\n  imports: [CommonModule, MatIconModule, MatButtonModule, MatTooltipModule, MatMenuModule, RouterModule],\n  exports: [\n    CommonModule,\n    ItemQuantityComponent,\n    MatButtonModule,\n    MatIconModule,\n    MatSnackBarModule,\n    MatTooltipModule,\n    SimplePageComponent,\n    TitleComponent,\n    WordWrapPipe\n  ]\n})\nexport class SharedModule { }</code></pre>\n</div>\n\n<h3>Components</h3>\n<h4>Item Quantity Component</h4>\n<p>This component sets the quantity of items when adding them to the cart. It will be used in the cart and products modules. A material selector would have been an easy choice for this purpose. However, the style of the material select didn’t match the material inputs used in all the other forms. A material menu looked very similar to the material inputs used. So I decided to create a select component with it instead.  </p>\n<pre><code>ng g c shared/components/item-quantity</code></pre>\n\n<p>The component will have three input properties and one output property. <code>quantity</code> sets the initial quantity of items, <code>maxValue</code> indicates the maximum number of items that can be selected in one go, and <code>disabled</code> indicates whether the component should be disabled or not. The <code>setQuantityEvent</code> is triggered when a quantity is selected. </p>\n<p>When the component is initialized, we’ll set the values that appear on the material menu. There also exists a method called <code>setQuantity</code> that will emit <code>setQuantityEvent</code> events. </p>\n<p><a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/shared/components/item-quantity/item-quantity.component.ts\">This</a> is the component file.</p>\n<pre><code>@Component({\n  selector: 'app-item-quantity',\n  templateUrl: './item-quantity.component.html',\n  styleUrls: ['./item-quantity.component.css']\n})\nexport class ItemQuantityComponent implements OnInit {\n  @Input() quantity: number = 0;\n  @Input() maxValue?: number = 0;\n  @Input() disabled?: boolean = false;\n  @Output() setQuantityEvent = new EventEmitter&lt;number&gt;();\n\n  values: number[] = [];\n\n  constructor() { }\n\n  ngOnInit() {\n    if (this.maxValue) {\n      for (let i = 1; i &lt;= this.maxValue; i++) {\n        this.values.push(i);\n      }\n    }\n  }\n\n  setQuantity(value: number) {\n    this.setQuantityEvent.emit(value);\n  }\n}</code></pre>\n\n<p>This is its template.</p>\n<div>\n<pre><code>&lt;button mat-stroked-button [matMenuTriggerFor]=\"menu\" [disabled]=\"disabled\"&gt;\n    {{quantity}}\n    &lt;mat-icon <em>ngIf=\"!disabled\"&gt;expand_more&lt;/mat-icon&gt;\n&lt;/button&gt;\n&lt;mat-menu #menu=\"matMenu\"&gt;\n    &lt;button </em>ngFor=\"let no of values\" (click)=\"setQuantity(no)\" mat-menu-item&gt;{{no}}&lt;/button&gt;\n&lt;/mat-menu&gt;</code></pre>\n</div>\n\n<p>Here is its styling.</p>\n<pre><code>button {\n    margin: 3px;\n}</code></pre>\n\n<h4>Title Component</h4>\n<p>This component doubles as a stepper title as well as a plain title on some simpler pages. Although Angular Material provides a stepper component, it wasn’t the best fit for a rather long checkout process, wasn’t as responsive on smaller displays, and required a lot more time to implement. A simpler title however could be repurposed as a stepper indicator and be useful across multiple pages.</p>\n<pre><code>ng g c shared/components/title</code></pre>\n\n<p>The component has four input properties: a <code>title</code>, a <code>subtitle</code>, a number (<code>no</code>), and <code>centerText</code>, to indicate whether to center the text of the component.</p>\n<pre><code>@Component({\n  selector: 'app-title',\n  templateUrl: './title.component.html',\n  styleUrls: ['./title.component.css']\n})\nexport class TitleComponent {\n  @Input() title: string = '';\n  @Input() subtitle: string = '';\n  @Input() no?: string;\n  @Input() centerText?: boolean = false;\n}</code></pre>\n\n<p>Below is its template. You can find its styling linked <a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/shared/components/title/title.component.css\">here</a>.</p>\n<pre><code>&lt;div id=\"header\"&gt;\n    &lt;h1 *ngIf=\"no\" class=\"mat-display-1\" id=\"no\"&gt;{{no}}&lt;/h1&gt;\n    &lt;div [ngClass]=\"{ 'centered-section': centerText}\"&gt;\n        &lt;h1 class=\"mat-display-2\"&gt;{{title}}&lt;/h1&gt;\n        &lt;p id=\"subheading\"&gt;{{subtitle}}&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/div&gt;</code></pre>\n\n<h4>Simple Page Component</h4>\n<p>There are multiple instances where a title, an icon, and a button were all that were needed for a page. These include a 404 page, an empty cart page, an error page, a payment page, and an order placement page. That’s the purpose the simple page component will serve. When the button on the page is clicked, it will either redirect to a route or perform some action in response to a <code>buttonEvent</code>. </p>\n<p>To make it:</p>\n<pre><code>ng g c shared/components/simple-page</code></pre>\n\n<p><a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/shared/components/simple-page/simple-page.component.ts\">This</a> is its component file.</p>\n<pre><code>@Component({\n  selector: 'app-simple-page',\n  templateUrl: './simple-page.component.html',\n  styleUrls: ['./simple-page.component.css']\n})\nexport class SimplePageComponent {\n  @Input() title: string = '';\n  @Input() subtitle?: string;\n  @Input() number?: string;\n  @Input() icon?: string;\n  @Input() buttonText: string = '';\n  @Input() centerText?: boolean = false;\n  @Input() buttonDisabled?: boolean = false;\n  @Input() route?: string | undefined;\n  @Output() buttonEvent = new EventEmitter();\n\n  constructor(private router: Router) { }\n\n  buttonClicked() {\n    if (this.route) {\n      this.router.navigateByUrl(this.route);\n    } else {\n      this.buttonEvent.emit();\n    }\n  }\n}</code></pre>\n\n<p>And its template contains:</p>\n<div>\n<pre><code>&lt;div id=\"container\"&gt;\n    &lt;app-title no=\"{{number}}\" title=\"{{title}}\" subtitle=\"{{subtitle}}\" [centerText]=\"centerText\"&gt;&lt;/app-title&gt;\n    &lt;div *ngIf=\"icon\" id=\"icon-container\"&gt;\n        &lt;mat-icon color=\"primary\" class=\"icon\"&gt;{{icon}}&lt;/mat-icon&gt;\n    &lt;/div&gt;\n    &lt;button mat-flat-button color=\"primary\" (click)=\"buttonClicked()\" [disabled]=\"buttonDisabled\"&gt;\n        {{buttonText}}\n    &lt;/button&gt;\n&lt;/div&gt;</code></pre>\n</div>\n\n<p>It’s styling can be found <a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/shared/components/simple-page/simple-page.component.css\">here</a>.</p>\n<h3>Pipes</h3>\n<h4>Word Wrap Pipe</h4>\n<p>Some products' names and other types of information displayed on the site are really long. In some instances, getting these long sentences to wrap in material components is challenging. So we’ll use this pipe to cut the sentences down to a specified length and add ellipses to the end of the result. </p>\n<p>To create it run:</p>\n<pre><code>ng g pipe shared/pipes/word-wrap</code></pre>\n\n<p>It will contain:</p>\n<pre><code>import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'wordWrap'\n})\nexport class WordWrapPipe implements PipeTransform {\n  transform(value: string, length: number): string {\n    return `${value.substring(0, length)}...`;\n  }\n}</code></pre>\n\n<h3>Services</h3>\n<h4>HTTP Error Handler Service</h4>\n<p>There are quite a number of http services in this project. Creating an error handler for each method is repetitive. So creating one single handler that can be used by all methods makes sense. The error handler can be used to format an error and also pass on the errors to other external logging platforms.</p>\n<p>Generate it by running:</p>\n<pre><code>ng g s shared/services/http-error-handler</code></pre>\n\n<p>This service will contain only one method. The method will format the error message to be displayed depending on whether it’s a client or server error. However, there is room to improve it further.</p>\n<div>\n<pre><code>@Injectable({\n  providedIn: 'root'\n})\nexport class HttpErrorHandler {\n\n  constructor() { }\n\n  handleError(err: HttpErrorResponse): Observable {\n    let displayMessage = '';\n\n    if (err.error instanceof ErrorEvent) {\n      displayMessage = <code>Client-side error: ${err.error.message}</code>;\n    } else {\n      displayMessage = <code>Server-side error: ${err.message}</code>;\n    }\n\n    return throwError(displayMessage);\n  }\n}</code></pre>\n</div>\n\n<h4>Local Storage Service</h4>\n<p>We shall use local storage to keep track of the number of items in a cart. It’s also useful to store the Id of an order here. An order corresponds to a cart on Commerce Layer. </p>\n<p>To generate the local storage service run:</p>\n<pre><code>ng g s shared/services/local-storage</code></pre>\n\n<p>The service will contain four methods to add, delete, and get items from local storage and another to clear it. </p>\n<pre><code>import { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class LocalStorageService {\n\n  constructor() { }\n\n  addItem(key: string, value: string) {\n    localStorage.setItem(key, value);\n  }\n\n  deleteItem(key: string) {\n    localStorage.removeItem(key);\n  }\n\n  getItem(key: string): string | null {\n    return localStorage.getItem(key);\n  }\n\n  clear() {\n    localStorage.clear();\n  }\n}</code></pre>\n\nData Module\n<p>This module is responsible for data retrieval and management. It’s what we’ll use to get the data our app consumes. Below is its structure:</p>\n<pre><code>src/app/data\n├── data.module.ts\n├── models\n└── services</code></pre>\n\n<p>To generate the module run:</p>\n<pre><code>ng g m data</code></pre>\n\n<h3>Models</h3>\n<p>The models define how the data we consume from the API is structured. We’ll have 16 interface declarations. To create them run:</p>\n<pre><code>for model in \\\naddress cart country customer-address \\\ncustomer delivery-lead-time line-item order \\\npayment-method payment-source paypal-payment \\\nprice shipment shipping-method sku stock-location; \\\ndo ng g interface \"data/models/${model}\"; done</code></pre>\n\n<p>The following table links to each file and gives a description of what each interface is.</p>\n<table>\n    <thead>\n        <tr>\n            <th>Interface</th>\n            <th>Description</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td><a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/data/models/address.ts\">Address</a></td>\n            <td>Represents a general address.</td>\n        </tr>\n        <tr>\n            <td><a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/data/models/cart.ts\">Cart</a></td>\n            <td>Client side version of an order tracking the number of products a customer intends to purchase.</td>\n        </tr>\n        <tr>\n            <td><a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/data/models/country.ts\">Country</a></td>\n            <td>Alpha-2 country code.</td>\n        </tr>\n    <tr>\n            <td><a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/data/models/customer-address.ts\">Customer Address</a></td>\n            <td>An address associated with a customer.</td>\n        </tr>\n    <tr>\n            <td><a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/data/models/customer.ts\">Customer</a></td>\n            <td>A registered user.</td>\n        </tr>\n    <tr>\n            <td><a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/data/models/delivery-lead-time.ts\">Delivery Lead Time</a></td>\n            <td>Represents the amount of time it will take to delivery a shipment.</td>\n        </tr>\n    <tr>\n            <td><a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/data/models/line-item.ts\">Line Item</a></td>\n            <td>An itemized product added to the cart.</td>\n        </tr>\n    <tr>\n            <td><a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/data/models/order.ts\">Order</a></td>\n            <td>A shopping cart or collection of line items.</td>\n        </tr>\n    <tr>\n            <td><a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/data/models/payment-method.ts\">Payment Method</a></td>\n            <td>A payment type made available to an order.</td>\n        </tr>\n    <tr>\n            <td><a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/data/models/payment-source.ts\">Payment Source</a></td>\n            <td>A payment associated with an order.</td>\n        </tr>\n    <tr>\n            <td><a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/data/models/paypal-payment.ts\">Paypal Payment</a></td>\n            <td>A payment made through Paypal</td>\n        </tr>\n    <tr>\n            <td><a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/data/models/price.ts\">Price</a></td>\n            <td>Price associated with an SKU.</td>\n        </tr>\n    <tr>\n            <td><a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/data/models/shipment.ts\">Shipment</a></td>\n            <td>Collection of items shipped together.</td>\n        </tr>\n    <tr>\n            <td><a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/data/models/shipping-method.ts\">Shipping Method</a></td>\n            <td>Method through which a package is shipped.</td>\n        </tr>\n    <tr>\n            <td><a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/data/models/sku.ts\">SKU</a></td>\n            <td>A unique stock-keeping unit.</td>\n        </tr>\n    <tr>\n            <td><a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/data/models/stock-location.ts\">Stock Location</a></td>\n            <td>Location that contains SKU inventory.</td>\n        </tr>\n    </tbody>\n</table>\n\n<h3>Services</h3>\n<p>This folder contains the services that create, retrieve, and manipulate app data. We’ll create 11 services here. </p>\n<pre><code>for service in \\\naddress cart country customer-address \\\ncustomer delivery-lead-time line-item \\\norder paypal-payment shipment sku; \\\ndo ng g s \"data/services/${service}\"; done</code></pre>\n\n<h4>Address Service</h4>\n<p>This service creates and retrieves addresses. It’s important when creating and assigning shipping and billing addresses to orders. It has two methods. One to create an address and another to retrieve one.  </p>\n<p>The route used here is <code>/api/addresses</code>. If you’re going to use the Commerce Layer API directly, make sure to structure the data as demonstrated in <a href=\"https://docs.commercelayer.io/api/resources/addresses/create_address#example\">this example</a>.</p>\n<div>\n<pre><code>@Injectable({\n  providedIn: 'root'\n})\nexport class AddressService {\n  private url: string = <code>${environment.apiUrl}/api/addresses</code>;\n\n  constructor(private http: HttpClient, private eh: HttpErrorHandler) { }\n\n  createAddress(address: Address): Observable&lt;Address&gt; {\n    return this.http.post&lt;Address&gt;(this.url, address)\n      .pipe(catchError(this.eh.handleError));\n  }\n\n  getAddress(id: string): Observable&lt;Address&gt; {\n    return this.http.get&lt;Address&gt;(<code>${this.url}/${id}</code>)\n      .pipe(catchError(this.eh.handleError));\n  }\n}</code></pre>\n</div>\n\n<h3>Cart Service</h3>\n<p>The cart is responsible for maintaining the quantity of items added and the order Id. Making API calls to get the number of items in an order everytime a new line item is created can be expensive. Instead, we could just use local storage to maintain the count on the client. This eliminates the need to make unnecessary order fetches every time an item is added to the cart. </p>\n<p>We also use this service to store the order Id. A cart corresponds to an order on Commerce Layer. Once the first item is added to the cart, an order is created. We need to preserve this order Id so we can fetch it during the checkout process. </p>\n<p>Additionally, we need a way to communicate to the header that an item has been added to the cart. The header contains the cart button and displays the amount of items in it. We’ll use an observable of a <code>BehaviorSubject</code> with the current value of the cart. The header can subscribe to this and track changes in the cart value. </p>\n<p>Lastly, once an order has been completed the cart value needs to be cleared. This ensures that there’s no confusion when creating subsequent newer orders. The values that were stored are cleared once the current order is marked as placed. </p>\n<p>We’ll accomplish all this using the local storage service created earlier.</p>\n<div>\n<pre><code>@Injectable({\n  providedIn: 'root'\n})\nexport class CartService {\n  private cart = new BehaviorSubject({\n    orderId: this.orderId,\n    itemCount: this.itemCount\n  });\n\n  cartValue$ = this.cart.asObservable();\n\n  constructor(private storage: LocalStorageService) { }\n\n  get orderId(): string {\n    const id = this.storage.getItem('order-id');\n    return id ? id : '';\n  }\n\n  set orderId(id: string) {\n    this.storage.addItem('order-id', id);\n    this.cart.next({ orderId: id, itemCount: this.itemCount });\n  }\n\n  get itemCount(): number {\n    const itemCount = this.storage.getItem('item-count');\n\n    return itemCount ? parseInt(itemCount) : 0;\n  }\n\n  set itemCount(amount: number) {\n    this.storage.addItem('item-count', amount.toString());\n    this.cart.next({ orderId: this.orderId, itemCount: amount });\n  }\n\n  incrementItemCount(amount: number) {\n    this.itemCount = this.itemCount + amount;\n  }\n\n  decrementItemCount(amount: number) {\n    this.itemCount = this.itemCount - amount;\n  }\n\n  clearCart() {\n    this.storage.deleteItem('item-count');\n    this.cart.next({ orderId: '', itemCount: 0 });\n  }\n}</code></pre>\n</div>\n\n<h4>Country Service</h4>\n<p>When adding addresses on Commerce Layer, the country code has to be an <a href=\"https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\">alpha 2 code</a>. This service reads a json file containing these codes for every country and returns it in its <code>getCountries</code> method.</p>\n<div>\n<pre><code>@Injectable({\n  providedIn: 'root'\n})\nexport class CountryService {\n\n  constructor(private http: HttpClient) { }\n\n  getCountries(): Observable&lt;Country[]&gt; {\n    return this.http.get&lt;Country[]&gt;('./../../../assets/json/country-codes.json');\n  }\n}</code></pre>\n</div>\n\n<h4>Customer Address Service</h4>\n<p>This service is used to associate addresses with customers. It also fetches a specific or all addresses related to a customer. It is used when the customer adds their shipping and billing addresses to their order. The <code>createCustomer</code> method creates a customer, <code>getCustomerAddresses</code> gets all of a customer’s addresses, and <code>getCustomerAddress</code> gets a specific one. </p>\n<p>When creating a customer address, be sure to structure the post body according to <a href=\"https://docs.commercelayer.io/api/resources/customer_addresses/create_customer_address#example\">this example</a>.</p>\n<div>\n<pre><code>@Injectable({\n  providedIn: 'root'\n})\nexport class CustomerAddressService {\n  private url: string = <code>${environment.apiUrl}/api/customer_addresses</code>;\n\n  constructor(private http: HttpClient, private eh: HttpErrorHandler) { }\n\n  createCustomerAddress(addressId: string, customerId: string): Observable&lt;CustomerAddress&gt; {\n    return this.http.post&lt;CustomerAddress&gt;(this.url, {\n      addressId: addressId, customerId: customerId\n    })\n      .pipe(catchError(this.eh.handleError));\n  }\n\n  getCustomerAddresses(): Observable&lt;CustomerAddress[]&gt; {\n    return this.http.get&lt;CustomerAddress[]&gt;(<code>${this.url}</code>)\n      .pipe(catchError(this.eh.handleError));\n  }\n\n  getCustomerAddress(id: string): Observable&lt;CustomerAddress&gt; {\n    return this.http.get&lt;CustomerAddress&gt;(<code>${this.url}/${id}</code>)\n      .pipe(catchError(this.eh.handleError));\n  }\n}</code></pre>\n</div>\n\n<h4>Customer Service</h4>\n<p>Customers are created and their information retrieved using this service. When a user signs up, they become a customer and are created using the <code>createCustomerMethod</code>. <code>getCustomer</code> returns the customer associated with a specific Id. <code>getCurrentCustomer</code> returns the customer currently logged in. </p>\n<p>When creating a customer, structure the data like <a href=\"https://docs.commercelayer.io/api/resources/customers/create_customer#example\">this</a>. You can add their first and last names to the metadata, as shown in its <a href=\"https://docs.commercelayer.io/api/resources/customers/create_customer#arguments\">attributes</a>.</p>\n<p>The route <code>/api/customers/current</code> is not available on Commerce Layer. So you’ll need to figure out how to get the currently logged in customer.</p>\n<div>\n<pre><code>@Injectable({\n  providedIn: 'root'\n})\nexport class CustomerService {\n  private url: string = <code>${environment.apiUrl}/api/customers</code>;\n\n  constructor(private http: HttpClient, private eh: HttpErrorHandler) { }\n\n  createCustomer(email: string, password: string, firstName: string, lastName: string): Observable&lt;Customer&gt; {\n    return this.http.post&lt;Customer&gt;(this.url, {\n      email: email,\n      password: password,\n      firstName: firstName,\n      lastName: lastName\n    })\n      .pipe(catchError(this.eh.handleError));\n  }\n\n  getCurrentCustomer(): Observable&lt;Customer&gt; {\n    return this.http.get&lt;Customer&gt;(<code>${this.url}/current</code>)\n      .pipe(catchError(this.eh.handleError));\n  }\n\n  getCustomer(id: string): Observable&lt;Customer&gt; {\n    return this.http.get&lt;Customer&gt;(<code>${this.url}/${id}</code>)\n      .pipe(catchError(this.eh.handleError));\n  }\n}</code></pre>\n</div>\n\n<h4>Delivery Lead Time Service</h4>\n<p>This service returns information about shipping timelines from various stock locations.</p>\n<div>\n<pre><code>@Injectable({\n  providedIn: 'root'\n})\nexport class DeliveryLeadTimeService {\n  private url: string = <code>${environment.apiUrl}/api/delivery_lead_times</code>;\n\n  constructor(private http: HttpClient, private eh: HttpErrorHandler) { }\n\n  getDeliveryLeadTimes(): Observable&lt;DeliveryLeadTime[]&gt; {\n    return this.http.get&lt;DeliveryLeadTime[]&gt;(this.url)\n      .pipe(catchError(this.eh.handleError));\n  }\n}</code></pre>\n</div>\n\n<h4>Line Item Service</h4>\n<p>Items added to the cart are managed by this service. With it, you can create an item the moment it is added to the cart. An item’s information can also be fetched. The item may also be updated when its quantity changes or deleted when removed from the cart. </p>\n<p>When creating items or updating them, structure the request body as shown in this <a href=\"https://docs.commercelayer.io/api/resources/line_items/create_line_item#example\">example</a>.</p>\n<div>\n<pre><code>@Injectable({\n  providedIn: 'root'\n})\nexport class LineItemService {\n  private url: string = <code>${environment.apiUrl}/api/line_items</code>;\n\n  constructor(private http: HttpClient, private eh: HttpErrorHandler) { }\n\n  createLineItem(lineItem: LineItem): Observable&lt;LineItem&gt; {\n    return this.http.post&lt;LineItem&gt;(this.url, lineItem)\n      .pipe(catchError(this.eh.handleError));\n  }\n\n  getLineItem(id: string): Observable&lt;LineItem&gt; {\n    return this.http.get&lt;LineItem&gt;(<code>${this.url}/${id}</code>)\n      .pipe(catchError(this.eh.handleError));\n  }\n\n  updateLineItem(id: string, quantity: number): Observable&lt;LineItem&gt; {\n    return this.http.patch&lt;LineItem&gt;(<code>${this.url}/${id}</code>, { quantity: quantity })\n      .pipe(catchError(this.eh.handleError));\n  }\n\n  deleteLineItem(id: string): Observable&lt;LineItem&gt; {\n    return this.http.delete&lt;LineItem&gt;(<code>${this.url}/${id}</code>)\n      .pipe(catchError(this.eh.handleError));\n  }\n}</code></pre>\n</div>\n\n<h4>Order Service</h4>\n<p>Similar to the line item service, the order service allows you to create, update, delete, or get an order. Additionally, you may choose to get the shipments associated with an order separately using the <code>getOrderShipments</code> method. This service is used heavily throughout the checkout process. </p>\n<p>There are different kinds of information about an order that are required throughout checkout. Since it may be expensive to fetch a whole order and its relations, we specify what we want to get from an order using <code>GetOrderParams</code>. The equivalent of this on the CL API is the <a href=\"https://docs.commercelayer.io/api/including-associations\">include query parameter</a> where you list the <a href=\"https://docs.commercelayer.io/api/resources/orders#the-order-object\">order relationships</a> to be included. You can check what fields need to be included for the cart summary <a href=\"https://docs.commercelayer.io/guides/shopping-cart/displaying-the-cart-summary#example\">here</a> and for the various checkout stages <a href=\"https://docs.commercelayer.io/guides/checkout\">here</a>. </p>\n<p>In the same manner, when updating an order, we use <code>UpdateOrderParams</code> to specify update fields. This is because in the server that populates the token, some extra operations are performed depending on what field is being updated. However, if you’re making direct requests to the CL API, you do not need to specify this. You can do away with it since the CL API doesn’t require you to specify them. Although, the request body should resemble <a href=\"https://docs.commercelayer.io/api/resources/orders/update_order#example\">this example</a>.</p>\n<div>\n<pre><code>@Injectable({\n  providedIn: 'root'\n})\nexport class OrderService {\n  private url: string = <code>${environment.apiUrl}/api/orders</code>;\n\n  constructor(\n    private http: HttpClient,\n    private eh: HttpErrorHandler) { }\n\n  createOrder(): Observable&lt;Order&gt; {\n    return this.http.post&lt;Order&gt;(this.url, {})\n      .pipe(catchError(this.eh.handleError));\n  }\n\n  getOrder(id: string, orderParam: GetOrderParams): Observable&lt;Order&gt; {\n    let params = {};\n    if (orderParam != GetOrderParams.none) {\n      params = { [orderParam]: 'true' };\n    }\n\n    return this.http.get&lt;Order&gt;(<code>${this.url}/${id}</code>, { params: params })\n      .pipe(catchError(this.eh.handleError));\n  }\n\n  updateOrder(order: Order, params: UpdateOrderParams[]): Observable&lt;Order&gt; {\n    let updateParams = [];\n    for (const param of params) {\n      updateParams.push(param.toString());\n    }\n\n    return this.http.patch&lt;Order&gt;(\n      <code>${this.url}/${order.id}</code>,\n      order,\n      { params: { 'field': updateParams } }\n    )\n      .pipe(catchError(this.eh.handleError));\n  }\n\n  getOrderShipments(id: string): Observable&lt;Shipment[]&gt; {\n    return this.http.get&lt;Shipment[]&gt;(<code>${this.url}/${id}/shipments</code>)\n      .pipe(catchError(this.eh.handleError));\n  }\n}</code></pre>\n</div>\n\n<h4>Paypal Payment Service</h4>\n<p>This service is responsible for creating and updating Paypal payments for orders. Additionally, we can get a Paypal payment given its id. The post body should have a structure similar to <a href=\"https://docs.commercelayer.io/api/resources/paypal_payments/create_paypal_payment#example\">this example</a> when creating a Paypal payment.</p>\n<div>\n<pre><code>@Injectable({\n  providedIn: 'root'\n})\nexport class PaypalPaymentService {\n  private url: string = <code>${environment.apiUrl}/api/paypal_payments</code>;\n\n  constructor(private http: HttpClient, private eh: HttpErrorHandler) { }\n\n  createPaypalPayment(payment: PaypalPayment): Observable&lt;PaypalPayment&gt; {\n    return this.http.post&lt;PaypalPayment&gt;(this.url, payment)\n      .pipe(catchError(this.eh.handleError));\n  }\n\n  getPaypalPayment(id: string): Observable&lt;PaypalPayment&gt; {\n    return this.http.get&lt;PaypalPayment&gt;(<code>${this.url}/${id}</code>)\n      .pipe(catchError(this.eh.handleError));\n  }\n\n  updatePaypalPayment(id: string, paypalPayerId: string): Observable&lt;PaypalPayment&gt; {\n    return this.http.patch&lt;PaypalPayment&gt;(\n      <code>${this.url}/${id}</code>,\n      { paypalPayerId: paypalPayerId }\n    )\n      .pipe(catchError(this.eh.handleError));\n  }\n}</code></pre>\n</div>\n\n<h4>Shipment Service</h4>\n<p>This service gets a shipment or updates it given its id. The request body of a shipment update should look similar to <a href=\"https://docs.commercelayer.io/api/resources/shipments/update_shipment#example\">this example</a>.</p>\n<div>\n<pre><code>@Injectable({\n  providedIn: 'root'\n})\nexport class ShipmentService {\n  private url: string = <code>${environment.apiUrl}/api/shipments</code>;\n\n  constructor(private http: HttpClient, private eh: HttpErrorHandler) { }\n\n  getShipment(id: string): Observable&lt;Shipment&gt; {\n    return this.http.get&lt;Shipment&gt;(<code>${this.url}/${id}</code>)\n      .pipe(catchError(this.eh.handleError));\n  }\n\n  updateShipment(id: string, shippingMethodId: string): Observable&lt;Shipment&gt; {\n    return this.http.patch&lt;Shipment&gt;(\n      <code>${this.url}/${id}</code>,\n      { shippingMethodId: shippingMethodId }\n    )\n      .pipe(catchError(this.eh.handleError));\n  }\n}</code></pre>\n</div>\n\n<h4>SKU Service</h4>\n<p>The SKU service gets products from the store.  If multiple products are being retrieved, they can be paginated and have a page size set. Page size and page number should be set as query params like in <a href=\"https://docs.commercelayer.io/api/pagination#example\">this example</a> if you’re making direct requests to the API. A single product can also be retrieved given its id.</p>\n<div>\n<pre><code>@Injectable({\n  providedIn: 'root'\n})\nexport class SkuService {\n  private url: string = <code>${environment.apiUrl}/api/skus</code>;\n\n  constructor(private http: HttpClient, private eh: HttpErrorHandler) { }\n\n  getSku(id: string): Observable&lt;Sku&gt; {\n    return this.http.get&lt;Sku&gt;(<code>${this.url}/${id}</code>)\n      .pipe(catchError(this.eh.handleError));\n  }\n\n  getSkus(page: number, pageSize: number): Observable&lt;Sku[]&gt; {\n    return this.http.get&lt;Sku[]&gt;(\n      this.url,\n      {\n        params: {\n          'page': page.toString(),\n          'pageSize': pageSize.toString()\n        }\n      })\n      .pipe(catchError(this.eh.handleError));\n  }\n}</code></pre>\n</div>\n\n\n\nCore Module\n<p>The core module contains everything central to and common across the application. These include components like the header and pages like the 404 page. Services responsible for authentication and session management also fall here, as well as app-wide interceptors and guards. </p>\n<p>The core module tree will look like this.</p>\n<pre><code>src/app/core\n├── components\n│   ├── error\n│   │   ├── error.component.css\n│   │   ├── error.component.html\n│   │   └── error.component.ts\n│   ├── header\n│   │   ├── header.component.css\n│   │   ├── header.component.html\n│   │   └── header.component.ts\n│   └── not-found\n│       ├── not-found.component.css\n│       ├── not-found.component.html\n│       └── not-found.component.ts\n├── core.module.ts\n├── guards\n│   └── empty-cart.guard.ts\n├── interceptors\n│   └── options.interceptor.ts\n└── services\n    ├── authentication.service.ts\n    ├── header.service.ts\n    └── session.service.ts</code></pre>\n\n<p>To generate the module and its contents run:</p>\n<div>\n<pre><code>ng g m core\nng g g core/guards/empty-cart\nng g s core/header/header\nng g interceptor core/interceptors/options\nfor comp in header error not-found; do ng g c \"core/${comp}\"; done\nfor serv in authentication session; do ng g s \"core/authentication/${serv}\"; done</code></pre>\n</div>\n\n<p>The core module file should like this. Note that routes have been registered for the <code>NotFoundComponent</code> and <code>ErrorComponent</code>.</p>\n<div>\n<pre><code>@NgModule({\n  declarations: [HeaderComponent, NotFoundComponent, ErrorComponent],\n  imports: [\n    RouterModule.forChild([\n      { path: '404', component: NotFoundComponent },\n      { path: 'error', component: ErrorComponent },\n      { path: '**', redirectTo: '/404' }\n    ]),\n    MatBadgeModule,\n    SharedModule\n  ],\n  exports: [HeaderComponent]\n})\nexport class CoreModule { }</code></pre>\n</div>\n\n<h3>Services</h3>\n<p>The services folder holds the authentication, session, and header services. </p>\n<h4>Authentication Service</h4>\n<p>The <code>AuthenticationService</code> allows you to acquire <a href=\"https://docs.commercelayer.io/api/authentication/client-credentials\">client</a> and <a href=\"https://docs.commercelayer.io/api/authentication/password\">customer tokens</a>. These tokens are used to access the rest of the API’s routes. Customer tokens are returned when a user exchanges an email and password for it and have a wider range of permissions. Client tokens are issued without needing credentials and have narrower permissions. </p>\n<p><code>getClientSession</code> gets a client token. <code>login</code> gets a customer token. Both methods also create a session. The body of a client token request should look <a href=\"https://docs.commercelayer.io/api/authentication/client-credentials#examples\">like this</a> and that of a customer token <a href=\"https://docs.commercelayer.io/api/authentication/password#example\">like this</a>.</p>\n<div>\n<pre><code>@Injectable({\n  providedIn: 'root'\n})\nexport class AuthenticationService {\n  private url: string = <code>${environment.apiUrl}/oauth/token</code>;\n\n  constructor(private http: HttpClient, private eh: HttpErrorHandler) { }\n\n  getClientSession(): Observable&lt;object&gt; {\n    return this.http.post&lt;object&gt;(\n      this.url,\n      { grantType: 'client_credentials' })\n      .pipe(catchError(this.eh.handleError));\n  }\n\n  login(email: string, password: string): Observable&lt;object&gt; {\n    return this.http.post&lt;object&gt;(\n      this.url,\n      { username: email, password: password, grantType: 'password' })\n      .pipe(catchError(this.eh.handleError));\n  }\n}</code></pre>\n</div>\n\n<h4>Session Service</h4>\n<p>The <code>SessionService</code> is responsible for session management. The service will contain an observable from a <code>BehaviorSubject</code> called <code>loggedInStatus</code> to communicate whether a user is logged in. <code>setLoggedInStatus</code> sets the value of this subject, <code>true</code> for logged in, and <code>false</code> for not logged in. <code>isCustomerLoggedIn</code> makes a request to the server to check if the user has an existing session. <code>logout</code> destroys the session on the server. The last two methods access routes that are unique to the server that populates the request with a token. They are not available from Commerce Layer. You’ll have to figure out how to implement them. </p>\n<div>\n<pre><code>@Injectable({\n  providedIn: 'root'\n})\nexport class SessionService {\n  private url: string = <code>${environment.apiUrl}/session</code>;\n  private isLoggedIn = new BehaviorSubject(false);\n\n  loggedInStatus = this.isLoggedIn.asObservable();\n\n  constructor(private http: HttpClient, private eh: HttpErrorHandler) { }\n\n  setLoggedInStatus(status: boolean) {\n    this.isLoggedIn.next(status);\n  }\n\n  isCustomerLoggedIn(): Observable&lt;{ message: string }&gt; {\n    return this.http.get&lt;{ message: string }&gt;(<code>${this.url}/customer/status</code>)\n      .pipe(catchError(this.eh.handleError));\n  }\n\n  logout(): Observable&lt;{ message: string }&gt; {\n    return this.http.get&lt;{ message: string }&gt;(<code>${this.url}/destroy</code>)\n      .pipe(catchError(this.eh.handleError));\n  }\n}</code></pre>\n</div>\n\n<h4>Header Service</h4>\n<p>The <code>HeaderService</code> is used to communicate whether the cart, login, and logout buttons should be shown in the header. These buttons are hidden on the login and signup pages but present on all other pages to prevent confusion. We’ll use an observable from a <code>BehaviourSubject</code> called <code>showHeaderButtons</code> that shares this. We’ll also have a <code>setHeaderButtonsVisibility</code> method to set this value.</p>\n<div>\n<pre><code>@Injectable({\n  providedIn: 'root'\n})\nexport class HeaderService {\n  private headerButtonsVisibility = new BehaviorSubject(true);\n\n  showHeaderButtons = this.headerButtonsVisibility.asObservable();\n\n  constructor() { }\n\n  setHeaderButtonsVisibility(visible: boolean) {\n    this.headerButtonsVisibility.next(visible);\n  }\n}</code></pre>\n</div>\n\n<h3>Components</h3>\n<h4>Error Component</h4>\n<p>This component is used as an error page. It is useful in instances when server requests fail and absolutely no data is displayed on a page. Instead of showing a blank page, we let the user know that a problem occurred. Below is it’s template.</p>\n<div>\n<pre><code>&lt;app-simple-page title=\"An error occurred\" subtitle=\"There was a problem fetching your page\" buttonText=\"GO TO HOME\" icon=\"report\" [centerText]=\"true\" route=\"/\"&gt;\n&lt;/app-simple-page&gt;</code></pre>\n</div>\n\n<p>This is what the component will look like.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/cfaae995-ac3a-482b-a9fe-803253d20ced/6-jamstack-e-commerce-site-angular-11-scull.png\" /></p>\n<h4>Not Found Component</h4>\n<p>This is a 404 page that the user gets redirected to when they request a route not available on the router. Only its template is modified. </p>\n<div>\n<pre><code>&lt;app-simple-page title=\"404: Page not found\" buttonText=\"GO TO HOME\" icon=\"search\" subtitle=\"The requested page could not be found\" [centerText]=\"true\" route=\"/\"&gt;&lt;/app-simple-page&gt;</code></pre>\n</div>\n\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d4d18e10-3de2-4a65-aecf-a539c10c1846/2-jamstack-e-commerce-site-angular-11-scull.png\" /></p>\n<h4>Header Component</h4>\n<p>The HeaderComponent is basically the header displayed at the top of a page. It will contain the app title, the cart, login, and logout buttons. </p>\n<p>When this component is initialized, a request is made to check whether the user has a current session. This happens when subscribing to <code>this.session.isCustomerLoggedIn()</code>. We subscribe to <code>this.session.loggedInStatus</code> to check if the user logs out throughout the life of the app. The <code>this.header.showHeaderButtons</code> subscription decides whether to show all the buttons on the header or hide them. <code>this.cart.cartValue$</code> gets the count of items in the cart. </p>\n<p>There exists a <code>logout</code> method that destroys a user’s session and assigns them a client token. A client token is assigned because the session maintaining their customer token is destroyed and a token is still required for each API request. A material snackbar communicates to the user whether their session was successfully destroyed or not.</p>\n<p>We use the <code>@UntilDestroy({ checkProperties: true })</code> decorator to indicate that all subscriptions should be automatically unsubscribed from when the component is destroyed.</p>\n<div>\n<pre><code>@UntilDestroy({ checkProperties: true })\n@Component({\n  selector: 'app-header',\n  templateUrl: './header.component.html',\n  styleUrls: ['./header.component.css']\n})\nexport class HeaderComponent implements OnInit {\n  cartAmount: number = 0;\n  isLoggedIn: boolean = false;\n  showButtons: boolean = true;\n\n  constructor(\n    private session: SessionService,\n    private snackBar: MatSnackBar,\n    private cart: CartService,\n    private header: HeaderService,\n    private auth: AuthenticationService\n  ) { }\n\n  ngOnInit() {\n    this.session.isCustomerLoggedIn()\n      .subscribe(\n        () =&gt; {\n          this.isLoggedIn = true;\n          this.session.setLoggedInStatus(true);\n        }\n      );\n\n    this.session.loggedInStatus.subscribe(status =&gt; this.isLoggedIn = status);\n\n    this.header.showHeaderButtons.subscribe(visible =&gt; this.showButtons = visible);\n\n    this.cart.cartValue$.subscribe(cart =&gt; this.cartAmount = cart.itemCount);\n  }\n\n  logout() {\n    concat(\n      this.session.logout(),\n      this.auth.getClientSession()\n    ).subscribe(\n      () =&gt; {\n        this.snackBar.open('You have been logged out.', 'Close', { duration: 4000 });\n        this.session.setLoggedInStatus(false);\n      },\n      err =&gt; this.snackBar.open('There was a problem logging you out.', 'Close', { duration: 4000 })\n    );\n  }\n}</code></pre>\n</div>\n\n<p>Below is the header template and <a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/core/components/header/header.component.css\">linked here</a> is its styling.</p>\n<div>\n<pre><code>&lt;div id=\"header-container\"&gt;\n    &lt;div id=\"left-half\" routerLink=\"/\"&gt;\n        &lt;h1&gt;&lt;span id=\"lime-text\"&gt;Lime&lt;/span&gt;&lt;span id=\"store-text\"&gt;Store&lt;/span&gt;&lt;/h1&gt;\n    &lt;/div&gt;\n    &lt;div id=\"right-half\"&gt;\n        &lt;div id=\"button-container\" <em>ngIf=\"showButtons\"&gt;\n            &lt;button mat-icon-button color=\"primary\" aria-label=\"shopping cart\"&gt;\n                &lt;mat-icon [matBadge]=\"cartAmount\" matBadgeColor=\"accent\" aria-label=\"shopping cart\" routerLink=\"/cart\"&gt;shopping_cart&lt;/mat-icon&gt;\n            &lt;/button&gt;\n            &lt;button mat-icon-button color=\"primary\" aria-label=\"login\" </em>ngIf=\"!isLoggedIn\"&gt;\n                &lt;mat-icon aria-label=\"login\" matTooltip=\"login\" routerLink=\"/login\"&gt;login&lt;/mat-icon&gt;\n            &lt;/button&gt;\n            &lt;button mat-icon-button color=\"primary\" aria-label=\"logout\" *ngIf=\"isLoggedIn\" (click)=\"logout()\"&gt;\n                &lt;mat-icon aria-label=\"logout\" matTooltip=\"logout\"&gt;logout&lt;/mat-icon&gt;\n            &lt;/button&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;</code></pre>\n</div>\n\n<h3>Guards</h3>\n<h4>Empty Cart Guard</h4>\n<p>This guard prevents users from accessing routes relating to checkout and billing if their cart is empty. This is because to proceed with checkout, there needs to be a valid order. An order corresponds to a cart with items in it. If there are items in the cart, the user can proceed to a guarded page. However, if the cart is empty, the user is redirected to an empty-cart page.</p>\n<div>\n<pre><code>@Injectable({\n  providedIn: 'root'\n})\nexport class EmptyCartGuard implements CanActivate {\n  constructor(private cart: CartService, private router: Router) { }\n\n  canActivate(\n    route: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot): Observable&lt;boolean | UrlTree&gt; | Promise&lt;boolean | UrlTree&gt; | boolean | UrlTree {\n    if (this.cart.orderId) {\n      if (this.cart.itemCount &gt; 0) {\n        return true;\n      }\n    }\n\n    return this.router.parseUrl('/empty');\n  }\n}</code></pre>\n</div>\n\n<h3>Interceptors</h3>\n<h4>Options Interceptor</h4>\n<p>This interceptor intercepts all outgoing HTTP requests and adds two options to the request. These are a <code>Content-Type</code> header and a <code>withCredentials</code> property. <code>withCredentials</code> specifies whether a request should be sent with outgoing credentials like the http-only cookies that we use. We use <code>Content-Type</code> to indicate that we are sending json resources to the server.</p>\n<div>\n<pre><code>@Injectable()\nexport class OptionsInterceptor implements HttpInterceptor {\n\n  constructor() { }\n\n  intercept(request: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {\n    request = request.clone({\n      headers: request.headers.set('Content-Type', 'application/json'),\n      withCredentials: true\n    });\n\n    return next.handle(request);\n  }\n}</code></pre>\n</div>\n\nFeature Modules\n<p>This section contains the main features of the app. As mentioned earlier, the features are grouped in four modules: auth, product, cart, and checkout modules. </p>\n<h3>Products Module</h3>\n<p>The products module contains pages that display products on sale. These include the product page and the product list page. It’s structured as shown below. </p>\n<pre><code>src/app/features/products\n├── pages\n│   ├── product\n│   │   ├── product.component.css\n│   │   ├── product.component.html\n│   │   └── product.component.ts\n│   └── product-list\n│       ├── product-list.component.css\n│       ├── product-list.component.html\n│       └── product-list.component.ts\n└── products.module.ts</code></pre>\n\n<p>To generate it and its components:</p>\n<pre><code>ng g m features/products\nng g c features/products/pages/product\nng g c features/products/pages/product-list</code></pre>\n\n<p>This is the module file:</p>\n<pre><code>@NgModule({\n  declarations: [ProductListComponent, ProductComponent],\n  imports: [\n    RouterModule.forChild([\n      { path: 'product/:id', component: ProductComponent },\n      { path: '', component: ProductListComponent }\n    ]),\n    LayoutModule,\n    MatCardModule,\n    MatGridListModule,\n    MatPaginatorModule,\n    SharedModule\n  ]\n})\nexport class ProductsModule { }</code></pre>\n\n<h4>Product List Component</h4>\n<p>This component displays a paginated list of available products for sale. It is the first page that is loaded when the app starts. </p>\n<p>The products are displayed in a grid. Material grid list is the best component for this. To make the grid responsive, the number of grid columns will change depending on the screen size. The <code>BreakpointObserver</code> service allows us to determine the size of the screen and assign the columns during initialization.</p>\n<p>To get the products, we call the <code>getProducts</code> method of the <code>SkuService</code>. It returns the products if successful and assigns them to the grid. If not, we route the user to the error page. </p>\n<p>Since the products displayed are paginated, we will have a <code>getNextPage</code> method to get the additional products.</p>\n<div>\n<pre><code>@UntilDestroy({ checkProperties: true })\n@Component({\n  selector: 'app-product-list',\n  templateUrl: './product-list.component.html',\n  styleUrls: ['./product-list.component.css']\n})\nexport class ProductListComponent implements OnInit {\n  cols = 4;\n  length = 0;\n  pageIndex = 0;\n  pageSize = 20;\n  pageSizeOptions: number[] = [5, 10, 20];\n\n  pageEvent!: PageEvent | void;\n\n  products: Sku[] = [];\n\n  constructor(\n    private breakpointObserver: BreakpointObserver,\n    private skus: SkuService,\n    private router: Router,\n    private header: HeaderService) { }\n\n  ngOnInit() {\n    this.getProducts(1, 20);\n    this.header.setHeaderButtonsVisibility(true);\n\n    this.breakpointObserver.observe([\n      Breakpoints.Handset,\n      Breakpoints.Tablet,\n      Breakpoints.Web\n    ]).subscribe(result =&gt; {\n      if (result.matches) {\n        if (result.breakpoints['(max-width: 599.98px) and (orientation: portrait)'] || result.breakpoints['(max-width: 599.98px) and (orientation: landscape)']) {\n          this.cols = 1;\n        }\n        else if (result.breakpoints['(min-width: 1280px) and (orientation: portrait)'] || result.breakpoints['(min-width: 1280px) and (orientation: landscape)']) {\n          this.cols = 4;\n        } else {\n          this.cols = 3;\n        }\n      }\n    });\n  }\n\n  private getProducts(page: number, pageSize: number) {\n    this.skus.getSkus(page, pageSize)\n      .subscribe(\n        skus =&gt; {\n          this.products = skus;\n          this.length = skus[0].__collectionMeta.recordCount;\n        },\n        err =&gt; this.router.navigateByUrl('/error')\n      );\n  }\n\n  getNextPage(event: PageEvent) {\n    this.getProducts(event.pageIndex + 1, event.pageSize);\n  }\n\n  trackSkus(index: number, item: Sku) {\n    return <code>${item.id}-${index}</code>;\n  }\n}</code></pre>\n</div>\n\n<p>The template is shown below and its styling can be found <a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/features/products/pages/product-list/product-list.component.css\">here</a>.</p>\n<div>\n<pre><code>&lt;mat-grid-list cols=\"{{cols}}\" rowHeight=\"400px\" gutterSize=\"20px\" class=\"grid-layout\"&gt;\n    &lt;mat-grid-tile *ngFor=\"let product of products; trackBy: trackSkus\"&gt;\n        &lt;mat-card&gt;\n            &lt;img id=\"card-image\" mat-card-image src=\"{{product.imageUrl}}\" alt=\"product photo\"&gt;\n            &lt;mat-card-content&gt;\n                &lt;mat-card-title matTooltip=\"{{product.name}}\"&gt;{{product.name |wordWrap:35}}&lt;/mat-card-title&gt;\n                &lt;mat-card-subtitle&gt;{{product.prices[0].compareAtAmountFloat | currency:'EUR'}}&lt;/mat-card-subtitle&gt;\n            &lt;/mat-card-content&gt;\n            &lt;mat-card-actions&gt;\n                &lt;button mat-flat-button color=\"primary\" [routerLink]=\"['/product', product.id]\"&gt;\n                    View\n                &lt;/button&gt;\n            &lt;/mat-card-actions&gt;\n        &lt;/mat-card&gt;\n    &lt;/mat-grid-tile&gt;\n&lt;/mat-grid-list&gt;\n&lt;mat-paginator [length]=\"length\" [pageIndex]=\"pageIndex\" [pageSize]=\"pageSize\" [pageSizeOptions]=\"pageSizeOptions\" (page)=\"pageEvent = getNextPage($event)\"&gt;\n&lt;/mat-paginator&gt;</code></pre>\n</div>\n\n<p>The page will look like this.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/144e5ec3-9474-4395-a968-c0e70c8503a2/16-jamstack-e-commerce-site-angular-11-scull.png\" /></p>\n<h4>Product Component</h4>\n<p>Once a product is selected from the product list page, this component displays its details. These include the product’s full name, price, and description. There’s also a button to add the item to the product cart. </p>\n<p>On initialization, we get the id of the product from the route parameters. Using the id, we fetch the product from the <code>SkuService</code>.</p>\n<p>When the user adds an item to the cart, the <code>addItemToCart</code> method is called. In it, we check if an order has already been created for the cart. If not, a new one is made using the <code>OrderService</code>. Afterwhich, a line item is created in the order that corresponds to the product. If an order already exists for the cart, just the line item is created. Depending on the status of the requests, a snackbar message is displayed to the user. </p>\n<div>\n<pre><code>@UntilDestroy({ checkProperties: true })\n@Component({\n  selector: 'app-product',\n  templateUrl: './product.component.html',\n  styleUrls: ['./product.component.css']\n})\nexport class ProductComponent implements OnInit {\n  id: string = '';\n  product!: Sku;\n  quantity: number = 0;\n\n  constructor(\n    private route: ActivatedRoute,\n    private skus: SkuService,\n    private location: Location,\n    private router: Router,\n    private header: HeaderService,\n    private orders: OrderService,\n    private lineItems: LineItemService,\n    private cart: CartService,\n    private snackBar: MatSnackBar\n  ) { }\n\n  ngOnInit() {\n    this.route.paramMap\n      .pipe(\n        mergeMap(params =&gt; {\n          const id = params.get('id')\n          this.id = id ? id : '';\n\n          return this.skus.getSku(this.id);\n        }),\n        tap((sku) =&gt; {\n          this.product = sku;\n        })\n      ).subscribe({\n        error: (err) =&gt; this.router.navigateByUrl('/error')\n      });\n\n    this.header.setHeaderButtonsVisibility(true);\n  }\n\n  addItemToCart() {\n    if (this.quantity &gt; 0) {\n      if (this.cart.orderId == '') {\n        this.orders.createOrder()\n          .pipe(\n            mergeMap((order: Order) =&gt; {\n              this.cart.orderId = order.id || '';\n\n              return this.lineItems.createLineItem({\n                orderId: order.id,\n                name: this.product.name,\n                imageUrl: this.product.imageUrl,\n                quantity: this.quantity,\n                skuCode: this.product.code\n              });\n            })\n          )\n          .subscribe(\n            () =&gt; {\n              this.cart.incrementItemCount(this.quantity);\n              this.showSuccessSnackBar();\n            },\n            err =&gt; this.showErrorSnackBar()\n          );\n      } else {\n        this.lineItems.createLineItem({\n          orderId: this.cart.orderId,\n          name: this.product.name,\n          imageUrl: this.product.imageUrl,\n          quantity: this.quantity,\n          skuCode: this.product.code\n        }).subscribe(\n          () =&gt; {\n            this.cart.incrementItemCount(this.quantity);\n            this.showSuccessSnackBar();\n          },\n          err =&gt; this.showErrorSnackBar()\n        );\n      }\n    } else {\n      this.snackBar.open('Select a quantity greater than 0.', 'Close', { duration: 8000 });\n    }\n  }\n\n  setQuantity(no: number) {\n    this.quantity = no;\n  }\n\n  goBack() {\n    this.location.back();\n  }\n\n  private showSuccessSnackBar() {\n    this.snackBar.open('Item successfully added to cart.', 'Close', { duration: 8000 });\n  }\n\n  private showErrorSnackBar() {\n    this.snackBar.open('Failed to add your item to the cart.', 'Close', { duration: 8000 });\n  }\n}</code></pre>\n</div>\n\n<p>The <code>ProductComponent</code> template is as follows and its styling is linked <a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/features/products/pages/product/product.component.css\">here</a>.</p>\n<div>\n<pre><code>&lt;div id=\"container\"&gt;\n    &lt;mat-card *ngIf=\"product\" class=\"product-card\"&gt;\n        &lt;img mat-card-image src=\"{{product.imageUrl}}\" alt=\"Photo of a product\"&gt;\n        &lt;mat-card-content&gt;\n            &lt;mat-card-title&gt;{{product.name}}&lt;/mat-card-title&gt;\n            &lt;mat-card-subtitle&gt;{{product.prices[0].compareAtAmountFloat | currency:'EUR'}}&lt;/mat-card-subtitle&gt;\n            &lt;p&gt;\n                {{product.description}}\n            &lt;/p&gt;\n        &lt;/mat-card-content&gt;\n        &lt;mat-card-actions&gt;\n            &lt;app-item-quantity [quantity]=\"quantity\" [maxValue]=\"10\" (setQuantityEvent)=\"setQuantity($event)\"&gt;&lt;/app-item-quantity&gt;\n            &lt;button mat-raised-button color=\"accent\" (click)=\"addItemToCart()\"&gt;\n                &lt;mat-icon&gt;add_shopping_cart&lt;/mat-icon&gt;\n                Add to cart\n            &lt;/button&gt;\n            &lt;button mat-raised-button color=\"primary\" (click)=\"goBack()\"&gt;\n                &lt;mat-icon&gt;storefront&lt;/mat-icon&gt;\n                Continue shopping\n            &lt;/button&gt;\n        &lt;/mat-card-actions&gt;\n    &lt;/mat-card&gt;\n&lt;/div&gt;</code></pre>\n</div>\n\n<p>The page will look like this. </p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/cbf71049-a4d6-4bf6-9d25-09c3e640dde5/9-jamstack-e-commerce-site-angular-11-scull.png\" /></p>\n<h3>Auth Module</h3>\n<p>The Auth module contains pages responsible for authentication. These include the login and signup pages. It‘s structured as follows. </p>\n<pre><code>src/app/features/auth/\n├── auth.module.ts\n└── pages\n    ├── login\n    │   ├── login.component.css\n    │   ├── login.component.html\n    │   └── login.component.ts\n    └── signup\n        ├── signup.component.css\n        ├── signup.component.html\n        └── signup.component.ts</code></pre>\n\n<p>To generate it and its components:</p>\n<pre><code>ng g m features/auth\nng g c features/auth/pages/signup\nng g c features/auth/pages/login</code></pre>\n\n<p>This is its module file.</p>\n<pre><code>@NgModule({\n  declarations: [LoginComponent, SignupComponent],\n  imports: [\n    RouterModule.forChild([\n      { path: 'login', component: LoginComponent },\n      { path: 'signup', component: SignupComponent }\n    ]),\n    MatFormFieldModule,\n    MatInputModule,\n    ReactiveFormsModule,\n    SharedModule\n  ]\n})\nexport class AuthModule { }</code></pre>\n\n<h4>Signup Component</h4>\n<p>A user signs up for an account using this component. A first name, last name, email, and password are required for the process. The user also needs to confirm their password. The input fields will be created with the <code>FormBuilder</code> service. Validation is added to require that all the inputs have values. Additional validation is added to the password field to ensure a minimum length of eight characters. A custom <code>matchPasswords</code> validator ensures that the confirmed password matches the initial password. </p>\n<p>When the component is initialized, the cart, login, and logout buttons in the header are hidden.This is communicated to the header using the <code>HeaderService</code>. </p>\n<p>After all the fields are marked as valid, the user can then sign up. In the <code>signup</code> method, the <code>createCustomer</code> method of the <code>CustomerService</code> receives this input. If the signup is successful, the user is informed that their account was successfully created using a snackbar. They are then rerouted to the home page.</p>\n<div>\n<pre><code>@UntilDestroy({ checkProperties: true })\n@Component({\n  selector: 'app-signup',\n  templateUrl: './signup.component.html',\n  styleUrls: ['./signup.component.css']\n})\nexport class SignupComponent implements OnInit {\n  signupForm = this.fb.group({\n    firstName: ['', Validators.required],\n    lastName: ['', Validators.required],\n    email: ['', [Validators.required, Validators.email]],\n    password: ['', [Validators.required, Validators.minLength(8)]],\n    confirmedPassword: ['', [Validators.required]]\n  }, { validators: this.matchPasswords });\n\n  @ViewChild(FormGroupDirective) sufDirective: FormGroupDirective | undefined;\n\n  constructor(\n    private customer: CustomerService,\n    private fb: FormBuilder,\n    private snackBar: MatSnackBar,\n    private router: Router,\n    private header: HeaderService\n  ) { }\n\n  ngOnInit() {\n    this.header.setHeaderButtonsVisibility(false);\n  }\n\n  matchPasswords(signupGroup: AbstractControl): ValidationErrors | null {\n    const password = signupGroup.get('password')?.value;\n    const confirmedPassword = signupGroup.get('confirmedPassword')?.value;\n\n    return password == confirmedPassword ? null : { differentPasswords: true };\n  }\n\n  get password() { return this.signupForm.get('password'); }\n\n  get confirmedPassword() { return this.signupForm.get('confirmedPassword'); }\n\n  signup() {\n    const customer = this.signupForm.value;\n\n    this.customer.createCustomer(\n      customer.email,\n      customer.password,\n      customer.firstName,\n      customer.lastName\n    ).subscribe(\n      () =&gt; {\n        this.signupForm.reset();\n        this.sufDirective?.resetForm();\n\n        this.snackBar.open('Account successfully created. You will be redirected in 5 seconds.', 'Close', { duration: 5000 });\n\n        setTimeout(() =&gt; this.router.navigateByUrl('/'), 6000);\n      },\n      err =&gt; this.snackBar.open('There was a problem creating your account.', 'Close', { duration: 5000 })\n    );\n  }\n}</code></pre>\n</div>\n\n<p>Below is the template for the <code>SignupComponent</code>.</p>\n<div>\n<pre><code>&lt;form id=\"container\" [formGroup]=\"signupForm\" (ngSubmit)=\"signup()\"&gt;\n    &lt;h1 class=\"mat-display-3\"&gt;Create Account&lt;/h1&gt;\n    &lt;mat-form-field appearance=\"outline\"&gt;\n        &lt;mat-label&gt;First Name&lt;/mat-label&gt;\n        &lt;input matInput formControlName=\"firstName\"&gt;\n        &lt;mat-icon matPrefix&gt;portrait&lt;/mat-icon&gt;\n    &lt;/mat-form-field&gt;\n    &lt;mat-form-field appearance=\"outline\"&gt;\n        &lt;mat-label&gt;Last Name&lt;/mat-label&gt;\n        &lt;input matInput formControlName=\"lastName\"&gt;\n        &lt;mat-icon matPrefix&gt;portrait&lt;/mat-icon&gt;\n    &lt;/mat-form-field&gt;\n    &lt;mat-form-field appearance=\"outline\"&gt;\n        &lt;mat-label&gt;Email&lt;/mat-label&gt;\n        &lt;input matInput formControlName=\"email\" type=\"email\"&gt;\n        &lt;mat-icon matPrefix&gt;alternate_email&lt;/mat-icon&gt;\n    &lt;/mat-form-field&gt;\n    &lt;mat-form-field appearance=\"outline\"&gt;\n        &lt;mat-label&gt;Password&lt;/mat-label&gt;\n        &lt;input matInput formControlName=\"password\" type=\"password\"&gt;\n        &lt;mat-icon matPrefix&gt;vpn_key&lt;/mat-icon&gt;\n    &lt;/mat-form-field&gt;\n    &lt;mat-form-field appearance=\"outline\"&gt;\n        &lt;mat-label&gt;Confirm Password&lt;/mat-label&gt;\n        &lt;input matInput formControlName=\"confirmedPassword\" type=\"password\"&gt;\n        &lt;mat-icon matPrefix&gt;vpn_key&lt;/mat-icon&gt;\n    &lt;/mat-form-field&gt;\n    &lt;div <em>ngIf=\"confirmedPassword?.invalid &amp;&amp; (confirmedPassword?.dirty || confirmedPassword?.touched)\"&gt;\n        &lt;mat-error </em>ngIf=\"signupForm.hasError('differentPasswords')\"&gt;\n            Your passwords do not match.\n        &lt;/mat-error&gt;\n    &lt;/div&gt;\n    &lt;div <em>ngIf=\"password?.invalid &amp;&amp; (password?.dirty || password?.touched)\"&gt;\n        &lt;mat-error </em>ngIf=\"password?.hasError('minlength')\"&gt;\n            Your password should be at least 8 characters.\n        &lt;/mat-error&gt;\n    &lt;/div&gt;\n    &lt;button mat-flat-button color=\"primary\" [disabled]=\"!signupForm.valid\"&gt;Sign Up&lt;/button&gt;\n&lt;/form&gt;</code></pre>\n</div>\n\n<p>The component will turn out as follows.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8b5eee5d-98ef-4e0e-a57a-a2c1b61b3b78/13-jamstack-e-commerce-site-angular-11-scull.png\" /></p>\n<h4>Login Component</h4>\n<p>A registered user logs into their account with this component. An email and password need to be entered. Their corresponding input fields would have validation that makes them required. </p>\n<p>Similar to the <code>SignupComponent</code>, the cart, login, and logout buttons in the header are hidden. Their visibility is set using the <code>HeaderService</code> during component initialization.</p>\n<p>To login, the credentials are passed to the <code>AuthenticationService</code>. If successful, the login status of the user is set using the <code>SessionService</code>. The user is then routed back to the page they were on. If unsuccessful, a snackbar is displayed with an error and the password field is reset.  </p>\n<pre><code>@UntilDestroy({ checkProperties: true })\n@Component({\n  selector: 'app-login',\n  templateUrl: './login.component.html',\n  styleUrls: ['./login.component.css']\n})\nexport class LoginComponent implements OnInit {\n  loginForm = this.fb.group({\n    email: ['', Validators.required],\n    password: ['', Validators.required]\n  });\n\n  constructor(\n    private authService: AuthenticationService,\n    private session: SessionService,\n    private snackBar: MatSnackBar,\n    private fb: FormBuilder,\n    private header: HeaderService,\n    private location: Location\n  ) { }\n\n  ngOnInit() {\n    this.header.setHeaderButtonsVisibility(false);\n  }\n\n  login() {\n    const credentials = this.loginForm.value;\n\n    this.authService.login(\n      credentials.email,\n      credentials.password\n    ).subscribe(\n      () =&gt; {\n        this.session.setLoggedInStatus(true);\n        this.location.back();\n      },\n      err =&gt; {\n        this.snackBar.open(\n          'Login failed. Check your login credentials.',\n          'Close',\n          { duration: 6000 });\n\n        this.loginForm.patchValue({ password: '' });\n      }\n    );\n  }\n}</code></pre>\n\n<p>Below is the <code>LoginComponent</code> template.</p>\n<div>\n<pre><code>&lt;form id=\"container\" [formGroup]=\"loginForm\" (ngSubmit)=\"login()\"&gt;\n    &lt;h1 class=\"mat-display-3\"&gt;Login&lt;/h1&gt;\n    &lt;mat-form-field appearance=\"outline\"&gt;\n        &lt;mat-label&gt;Email&lt;/mat-label&gt;\n        &lt;input matInput type=\"email\" formControlName=\"email\" required&gt;\n        &lt;mat-icon matPrefix&gt;alternate_email&lt;/mat-icon&gt;\n    &lt;/mat-form-field&gt;\n    &lt;mat-form-field appearance=\"outline\"&gt;\n        &lt;mat-label&gt;Password&lt;/mat-label&gt;\n        &lt;input matInput type=\"password\" formControlName=\"password\" required&gt;\n        &lt;mat-icon matPrefix&gt;vpn_key&lt;/mat-icon&gt;\n    &lt;/mat-form-field&gt;\n    &lt;button mat-flat-button color=\"primary\" [disabled]=\"!loginForm.valid\"&gt;Login&lt;/button&gt;\n    &lt;p id=\"newAccount\" class=\"mat-h3\"&gt;Not registered yet? &lt;a id=\"newAccountLink\" routerLink=\"/signup\"&gt;Create an account.&lt;/a&gt;&lt;/p&gt;\n&lt;/form&gt;</code></pre>\n</div>\n\n<p>Here is a screenshot of the page. </p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/60f04e9d-0f99-4adc-8ceb-7f817566b5fd/5-jamstack-e-commerce-site-angular-11-scull.png\" /></p>\n<h3>Cart Module</h3>\n<p>The cart module contains all pages related to the cart. These include the order summary page, a coupon and gift card code page, and an empty cart page. It's structured as follows.</p>\n<pre><code>src/app/features/cart/\n├── cart.module.ts\n└── pages\n    ├── codes\n    │   ├── codes.component.css\n    │   ├── codes.component.html\n    │   └── codes.component.ts\n    ├── empty\n    │   ├── empty.component.css\n    │   ├── empty.component.html\n    │   └── empty.component.ts\n    └── summary\n        ├── summary.component.css\n        ├── summary.component.html\n        └── summary.component.ts</code></pre>\n\n<p>To generate it, run:</p>\n<pre><code>ng g m features/cart\nng g c features/cart/codes\nng g c features/cart/empty\nng g c features/cart/summary</code></pre>\n\n<p>This is the module file.</p>\n<div>\n<pre><code>@NgModule({\n  declarations: [SummaryComponent, CodesComponent, EmptyComponent],\n  imports: [\n    RouterModule.forChild([\n      {\n        path: '', canActivate: [EmptyCartGuard], children: [\n          { path: 'cart', component: SummaryComponent },\n          { path: 'codes', component: CodesComponent }\n        ]\n      },\n      { path: 'empty', component: EmptyComponent }\n    ]),\n    MatDividerModule,\n    MatFormFieldModule,\n    MatInputModule,\n    MatMenuModule,\n    ReactiveFormsModule,\n    SharedModule\n  ]\n})\nexport class CartModule { }</code></pre>\n</div>\n\n<h4>Codes Component</h4>\n<p>As mentioned earlier, this component is used to add any coupon or gift card codes to an order. This allows the user to apply discounts to the total of their order before proceeding to checkout. </p>\n<p>There will be two input fields. One for coupons and another for gift card codes. </p>\n<p>The codes are added by updating the order.  The <code>updateOrder</code> method of the <code>OrderService</code> updates the order with the codes. Afterwhich, both fields are reset and the user is informed of the success of the operation with a snackbar. A snackbar is also shown when an error occurs. Both the <code>addCoupon</code> and <code>addGiftCard</code> methods call the <code>updateOrder</code> method. </p>\n<div>\n<pre><code>@UntilDestroy({ checkProperties: true })\n@Component({\n  selector: 'app-codes',\n  templateUrl: './codes.component.html',\n  styleUrls: ['./codes.component.css']\n})\nexport class CodesComponent {\n  couponCode = new FormControl('');\n  giftCardCode = new FormControl('');\n\n  @ViewChild(FormControlDirective) codesDirective: FormControlDirective | undefined;\n\n  constructor(\n    private cart: CartService,\n    private order: OrderService,\n    private snackBar: MatSnackBar\n  ) { }\n\n  private updateOrder(order: Order, params: UpdateOrderParams[], codeType: string) {\n    this.order.updateOrder(order, params)\n      .subscribe(\n        () =&gt; {\n          this.snackBar.open(<code>Successfully added ${codeType} code.</code>, 'Close', { duration: 8000 });\n          this.couponCode.reset();\n          this.giftCardCode.reset();\n          this.codesDirective?.reset();\n        },\n        err =&gt; this.snackBar.open(<code>There was a problem adding your ${codeType} code.</code>, 'Close', { duration: 8000 })\n      );\n  }\n\n  addCoupon() {\n    this.updateOrder({ id: this.cart.orderId, couponCode: this.couponCode.value }, [UpdateOrderParams.couponCode], 'coupon');\n  }\n\n  addGiftCard() {\n    this.updateOrder({ id: this.cart.orderId, giftCardCode: this.giftCardCode.value }, [UpdateOrderParams.giftCardCode], 'gift card');\n  }\n\n}</code></pre>\n</div>\n\n<p>The template is shown below and its styling can be found at <a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/features/cart/pages/codes/codes.component.css\">this link</a>.</p>\n<div>\n<pre><code>&lt;div id=\"container\"&gt;\n    &lt;app-title title=\"Redeem a code\" subtitle=\"Enter a coupon code or gift card\" [centerText]=\"true\"&gt;&lt;/app-title&gt;\n    &lt;div class=\"input-row\"&gt;\n        &lt;mat-form-field appearance=\"outline\"&gt;\n            &lt;mat-label&gt;Coupon Code&lt;/mat-label&gt;\n            &lt;input matInput [formControl]=\"couponCode\" required&gt;\n            &lt;mat-icon matPrefix&gt;card_giftcard&lt;/mat-icon&gt;\n        &lt;/mat-form-field&gt;\n        &lt;button class=\"redeem\" mat-flat-button color=\"accent\" [disabled]=\"couponCode.invalid\" (click)=\"addCoupon()\"&gt;Redeem&lt;/button&gt;\n    &lt;/div&gt;\n    &lt;div class=\"input-row\"&gt;\n        &lt;mat-form-field appearance=\"outline\"&gt;\n            &lt;mat-label&gt;Gift Card Code&lt;/mat-label&gt;\n            &lt;input matInput [formControl]=\"giftCardCode\" required&gt;\n            &lt;mat-icon matPrefix&gt;redeem&lt;/mat-icon&gt;\n        &lt;/mat-form-field&gt;\n        &lt;button class=\"redeem\" mat-flat-button color=\"accent\" [disabled]=\"giftCardCode.invalid\" (click)=\"addGiftCard()\"&gt;Redeem&lt;/button&gt;\n    &lt;/div&gt;\n    &lt;button color=\"primary\" mat-flat-button routerLink=\"/cart\"&gt;\n        &lt;mat-icon&gt;shopping_cart&lt;/mat-icon&gt;\n        CONTINUE TO CART\n    &lt;/button&gt;\n&lt;/div&gt;</code></pre>\n</div>\n\n<p>Here is a screenshot of the page. </p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/261453ef-4ebb-456f-a348-d6d26782302b/17-jamstack-e-commerce-site-angular-11-scull.png\" /></p>\n<h4>Empty Component</h4>\n<p>It should not be possible to check out with an empty cart. There needs to be a guard that prevents users from accessing checkout module pages with empty carts. This has already been covered as part of the <code>CoreModule</code>. The guard redirects requests to checkout pages with an empty cart to the <code>EmptyCartComponent</code>. </p>\n<p>It's a very simple component that has some text indicating to the user that their cart is empty. It also has a button that the user can click to go to the homepage to add things to their cart. So we’ll use the <code>SimplePageComponent</code> to display it. Here is the template.</p>\n<div>\n<pre><code>&lt;app-simple-page title=\"Your cart is empty\" subtitle=\"There is currently nothing in your cart. Head to the home page to add items.\" buttonText=\"GO TO HOME PAGE\" icon=\"shopping_basket\" [centerText]=\"true\" route=\"/\"&gt;\n&lt;/app-simple-page&gt;</code></pre>\n</div>\n\n<p>Here is a screenshot of the page. </p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/70ea3c01-0485-4496-b5a1-aafe12e843d7/20-jamstack-e-commerce-site-angular-11-scull.png\" /></p>\n<h4>Summary Component</h4>\n<p>This component summarizes the cart/order. It lists all the items in the cart, their names, quantities, and pictures. It additionally breaks down the cost of the order including taxes, shipping, and discounts. The user should be able to view this and decide whether they are satisfied with the items and cost before proceeding to checkout. </p>\n<p>On initialization, the order and its line items are fetched using the <code>OrderService</code>. A user should be able to modify the line items or even remove them from the order. Items are removed when the <code>deleteLineItem</code> method is called. In it the <code>deleteLineItem</code> method of the <code>LineItemService</code> receives the id of the line item to be deleted. If a deletion is successful, we update the item count in the cart using the <code>CartService</code>. </p>\n<p>The user is then routed to the customer page where they begin the process of checking out. The <code>checkout</code> method does the routing. </p>\n<div>\n<pre><code>@UntilDestroy({ checkProperties: true })\n@Component({\n  selector: 'app-summary',\n  templateUrl: './summary.component.html',\n  styleUrls: ['./summary.component.css']\n})\nexport class SummaryComponent implements OnInit {\n  order: Order = {};\n\n  summary: { name: string, amount: string | undefined, id: string }[] = [];\n\n  constructor(\n    private orders: OrderService,\n    private lineItems: LineItemService,\n    private cart: CartService,\n    private snackBar: MatSnackBar,\n    private router: Router\n  ) { }\n\n  ngOnInit() {\n    this.orders.getOrder(this.cart.orderId, GetOrderParams.cart)\n      .subscribe(\n        order =&gt; this.processOrder(order),\n        err =&gt; this.showOrderError('retrieving your cart')\n      );\n  }\n\n  private processOrder(order: Order) {\n    this.order = order;\n\n    this.summary = [\n      { name: 'Subtotal', amount: order.formattedSubtotalAmount, id: 'subtotal' },\n      { name: 'Discount', amount: order.formattedDiscountAmount, id: 'discount' },\n      { name: 'Taxes (included)', amount: order.formattedTotalTaxAmount, id: 'taxes' },\n      { name: 'Shipping', amount: order.formattedShippingAmount, id: 'shipping' },\n      { name: 'Gift Card', amount: order.formattedGiftCardAmount, id: 'gift-card' }\n    ];\n  }\n\n  private showOrderError(msg: string) {\n    this.snackBar.open(<code>There was a problem ${msg}.</code>, 'Close', { duration: 8000 });\n  }\n\n  checkout() {\n    this.router.navigateByUrl('/customer');\n  }\n\n  deleteLineItem(id: string) {\n    this.lineItems.deleteLineItem(id)\n      .pipe(\n        mergeMap(() =&gt; this.orders.getOrder(this.cart.orderId, GetOrderParams.cart))\n      ).subscribe(\n        order =&gt; {\n          this.processOrder(order);\n          this.cart.itemCount = order.skusCount || this.cart.itemCount;\n          this.snackBar.open(<code>Item successfully removed from cart.</code>, 'Close', { duration: 8000 })\n        },\n        err =&gt; this.showOrderError('deleting your order')\n      );\n  }\n}</code></pre>\n</div>\n\n<p>Below is the template and its styling is <a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/features/cart/pages/summary/summary.component.css\">linked here</a>. </p>\n<div>\n<pre><code>&lt;div class=\"container\" <em>ngIf=\"order\"&gt;\n    &lt;h3 id=\"order-id\"&gt;Order #{{order.number}} ({{order.skusCount}} items)&lt;/h3&gt;\n    &lt;div class=\"line-item\" </em>ngFor=\"let item of order.lineItems\"&gt;\n        &lt;div id=\"product-details\"&gt;\n            &lt;img <em>ngIf=\"item.imageUrl\" class=\"image-xs\" src=\"{{item.imageUrl}}\" alt=\"product photo\"&gt;\n            &lt;div </em>ngIf=\"!item.imageUrl\" class=\"image-xs no-image\"&gt;&lt;/div&gt;\n            &lt;div id=\"line-details\"&gt;\n                &lt;div&gt;{{item.name}}&lt;/div&gt;\n                &lt;div&gt; {{item.formattedUnitAmount }} &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div id=\"product-config\"&gt;\n            &lt;app-item-quantity [quantity]=\"item.quantity || 0\" [disabled]=\"true\"&gt;&lt;/app-item-quantity&gt;\n            &lt;div class=\"itemTotal\"&gt; {{item.formattedTotalAmount }} &lt;/div&gt;\n            &lt;button mat-icon-button color=\"warn\" (click)=\"deleteLineItem(item.id || '')\"&gt;\n                &lt;mat-icon&gt;clear&lt;/mat-icon&gt;\n        &lt;/button&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;mat-divider&gt;&lt;/mat-divider&gt;\n    &lt;div class=\"costSummary\"&gt;\n        &lt;div class=\"costItem\" *ngFor=\"let item of summary\" [id]=\"item.id\"&gt;\n            &lt;h3 class=\"costLabel\"&gt;{{item.name}}&lt;/h3&gt;\n            &lt;p&gt; {{item.amount }} &lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;mat-divider&gt;&lt;/mat-divider&gt;\n    &lt;div class=\"costSummary\"&gt;\n        &lt;div class=\"costItem\" id=\"total\"&gt;\n            &lt;h2 id=\"totalLabel\"&gt;Total&lt;/h2&gt;\n            &lt;h2&gt; {{order.formattedTotalAmountWithTaxes}} &lt;/h2&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div id=\"checkout-button\"&gt;\n        &lt;button color=\"accent\" mat-flat-button routerLink=\"/codes\"&gt;\n        &lt;mat-icon&gt;redeem&lt;/mat-icon&gt;\n        ADD GIFT CARD/COUPON\n    &lt;/button&gt;\n        &lt;button color=\"primary\" mat-flat-button (click)=\"checkout()\"&gt;\n        &lt;mat-icon&gt;point_of_sale&lt;/mat-icon&gt;\n        CHECKOUT\n    &lt;/button&gt;\n    &lt;/div&gt;\n&lt;/div&gt;</code></pre>\n</div>\n\n<p>Here is a screenshot of the page.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/18ac066f-8765-4bd1-9ebe-5a418177e41f/18-jamstack-e-commerce-site-angular-11-scull.png\" /></p>\n<h3>Checkout Module</h3>\n<p>This module is responsible for the checkout process. Checkout involves providing a billing and shipping address, a customer email, and selecting a shipping and payment method. The last step of this process is placement and confirmation of the order. The structure of the module is as follows.</p>\n<pre><code>src/app/features/checkout/\n├── components\n│   ├── address\n│   ├── address-list\n│   └── country-select\n└── pages\n    ├── billing-address\n    ├── cancel-payment\n    ├── customer\n    ├── payment\n    ├── place-order\n    ├── shipping-address\n    └── shipping-methods</code></pre>\n\n<p>This module is the biggest by far and contains 3 components and 7 pages. To generate it and its components run:</p>\n<pre><code>ng g m features/checkout\nfor comp in \\\naddress address-list country-select; do \\\nng g c \"features/checkout/components/${comp}\" \\\n; done\nfor page in \\\nbilling-address cancel-payment customer \\\npayment place-order shipping-address \\\nshipping-methods; do \\\nng g c \"features/checkout/pages/${page}\"; done</code></pre>\n\n<p>This is the module file.</p>\n<div>\n<pre><code>@NgModule({\n  declarations: [\n    CustomerComponent,\n    AddressComponent,\n    BillingAddressComponent,\n    ShippingAddressComponent,\n    ShippingMethodsComponent,\n    PaymentComponent,\n    PlaceOrderComponent,\n    AddressListComponent,\n    CountrySelectComponent,\n    CancelPaymentComponent\n  ],\n  imports: [\n    RouterModule.forChild([\n      {\n        path: '', canActivate: [EmptyCartGuard], children: [\n          { path: 'billing-address', component: BillingAddressComponent },\n          { path: 'cancel-payment', component: CancelPaymentComponent },\n          { path: 'customer', component: CustomerComponent },\n          { path: 'payment', component: PaymentComponent },\n          { path: 'place-order', component: PlaceOrderComponent },\n          { path: 'shipping-address', component: ShippingAddressComponent },\n          { path: 'shipping-methods', component: ShippingMethodsComponent }\n        ]\n      }\n    ]),\n    MatCardModule,\n    MatCheckboxModule,\n    MatDividerModule,\n    MatInputModule,\n    MatMenuModule,\n    MatRadioModule,\n    ReactiveFormsModule,\n    SharedModule\n  ]\n})\nexport class CheckoutModule { }</code></pre>\n</div>\n\n<h4>Components</h4>\n<p><strong>Country Select Component</strong></p>\n<p>This component lets a user select a country as part of an address. The material select component has a pretty different appearance when compared to the input fields in the address form. So for the sake of uniformity, a material menu component is used instead. </p>\n<p>When the component is initialized, the country code data is fetched using the <code>CountryService</code>. The <code>countries</code> property holds the values returned by the service. These values will be added to the menu in the template. </p>\n<p>The component has one output property, <code>setCountryEvent</code>. When a country is selected, this event emits the alpha-2 code of the country.</p>\n<pre><code>@UntilDestroy({ checkProperties: true })\n@Component({\n  selector: 'app-country-select',\n  templateUrl: './country-select.component.html',\n  styleUrls: ['./country-select.component.css']\n})\nexport class CountrySelectComponent implements OnInit {\n  country: string = 'Country';\n  countries: Country[] = [];\n  @Output() setCountryEvent = new EventEmitter&lt;string&gt;();\n\n  constructor(private countries: CountryService) { }\n\n  ngOnInit() {\n    this.countries.getCountries()\n      .subscribe(\n        countries =&gt; {\n          this.countries = countries;\n        }\n      );\n  }\n\n  setCountry(value: Country) {\n    this.country = value.name || '';\n    this.setCountryEvent.emit(value.code);\n  }}</code></pre>\n\n<p>Below is its template and linked <a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/features/checkout/components/country-select/country-select.component.css\">here</a> is its styling.</p>\n<div>\n<pre><code>&lt;button id=\"country-select\" mat-stroked-button [matMenuTriggerFor]=\"countryMenu\"&gt;\n    {{country}}\n    &lt;mat-icon&gt;expand_more&lt;/mat-icon&gt;\n&lt;/button&gt;\n&lt;mat-menu #countryMenu=\"matMenu\"&gt;\n    &lt;button *ngFor=\"let cnt of countries\" (click)=\"setCountry(cnt)\" mat-menu-item&gt;{{cnt.name}}&lt;/button&gt;\n&lt;/mat-menu&gt;</code></pre>\n</div>\n\n<p><strong>Address Component</strong></p>\n<p>This is a form for capturing addresses. It is used by both the shipping and billing address pages. A valid Commerce Layer address should contain a first and last name, an address line, a city, zip code, state code, country code, and phone number.  </p>\n<p>The <code>FormBuilder</code> service will create the form group. Since this component is used by multiple pages, it has a number of input and output properties. The input properties include the button text, title displayed, and text for a checkbox. The output properties will be event emitters for when the button is clicked to create the address and another for when the checkbox value changes. </p>\n<p>When the button is clicked, the <code>addAddress</code> method is called and the <code>createAddress</code> event emits the complete address. Similarly, when the checkbox is checked, the <code>isCheckboxChecked</code> event emits the checkbox value.</p>\n<div>\n<pre><code>@Component({\n  selector: 'app-address',\n  templateUrl: './address.component.html',\n  styleUrls: ['./address.component.css']\n})\nexport class AddressComponent {\n  @Input() buttonText: string = '';\n  @Input() showTitle?: boolean = false;\n\n  @Output() createAddress = new EventEmitter&lt;Address&gt;();\n\n  @Input() checkboxText: string = '';\n  @Output() isCheckboxChecked = new EventEmitter&lt;boolean&gt;();\n\n  countryCode: string = '';\n\n  addressForm = this.fb.group({\n    firstName: [''],\n    lastName: [''],\n    line1: [''],\n    city: [''],\n    zipCode: [''],\n    stateCode: [''],\n    phone: ['']\n  });\n\n  @ViewChild(FormGroupDirective) afDirective: FormGroupDirective | undefined;\n\n  constructor(private fb: FormBuilder) { }\n\n  setCountryCode(code: string) {\n    this.countryCode = code;\n  }\n\n  addAddress() {\n    this.createAddress.emit({\n      firstName: this.addressForm.get('firstName')?.value,\n      lastName: this.addressForm.get('lastName')?.value,\n      line1: this.addressForm.get('line1')?.value,\n      city: this.addressForm.get('city')?.value,\n      zipCode: this.addressForm.get('zipCode')?.value,\n      stateCode: this.addressForm.get('stateCode')?.value || 'N/A',\n      countryCode: this.countryCode,\n      phone: this.addressForm.get('phone')?.value\n    });\n  }\n\n  setCheckboxValue(change: MatCheckboxChange) {\n    if (this.isCheckboxChecked) {\n      this.isCheckboxChecked.emit(change.checked);\n    }\n  }\n}</code></pre>\n</div>\n\n<p>This is its template and its styling is linked <a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/features/checkout/components/address/address.component.css\">here</a>.</p>\n<div>\n<pre><code>&lt;form id=\"container\" [formGroup]=\"addressForm\"&gt;\n    &lt;p class=\"mat-headline\" *ngIf=\"showTitle\"&gt;Or add a new address&lt;/p&gt;\n    &lt;div class=\"row\"&gt;\n        &lt;mat-form-field appearance=\"outline\"&gt;\n            &lt;mat-label&gt;First Name&lt;/mat-label&gt;\n            &lt;input matInput formControlName=\"firstName\"&gt;\n        &lt;/mat-form-field&gt;\n        &lt;mat-form-field appearance=\"outline\"&gt;\n            &lt;mat-label&gt;Last Name&lt;/mat-label&gt;\n            &lt;input matInput formControlName=\"lastName\"&gt;\n        &lt;/mat-form-field&gt;\n    &lt;/div&gt;\n    &lt;div class=\"row\"&gt;\n        &lt;mat-form-field appearance=\"outline\"&gt;\n            &lt;mat-label&gt;Address&lt;/mat-label&gt;\n            &lt;input matInput formControlName=\"line1\"&gt;\n        &lt;/mat-form-field&gt;\n        &lt;mat-form-field appearance=\"outline\"&gt;\n            &lt;mat-label&gt;City&lt;/mat-label&gt;\n            &lt;input matInput formControlName=\"city\"&gt;\n        &lt;/mat-form-field&gt;\n    &lt;/div&gt;\n    &lt;div class=\"row\"&gt;\n        &lt;mat-form-field appearance=\"outline\"&gt;\n            &lt;mat-label&gt;State Code&lt;/mat-label&gt;\n            &lt;input matInput formControlName=\"stateCode\"&gt;\n        &lt;/mat-form-field&gt;\n        &lt;mat-form-field appearance=\"outline\"&gt;\n            &lt;mat-label&gt;Zip Code&lt;/mat-label&gt;\n            &lt;input matInput formControlName=\"zipCode\"&gt;\n        &lt;/mat-form-field&gt;\n    &lt;/div&gt;\n    &lt;div class=\"row\"&gt;\n        &lt;mat-form-field appearance=\"outline\"&gt;\n            &lt;mat-label&gt;Phone&lt;/mat-label&gt;\n            &lt;input matInput formControlName=\"phone\"&gt;\n        &lt;/mat-form-field&gt;\n        &lt;app-country-select (setCountryEvent)=\"setCountryCode($event)\"&gt;&lt;/app-country-select&gt;\n    &lt;/div&gt;\n    &lt;mat-checkbox color=\"accent\" (change)=\"setCheckboxValue($event)\"&gt;\n        {{checkboxText}}\n    &lt;/mat-checkbox&gt;\n    &lt;button id=\"submit-button\" mat-flat-button color=\"primary\" (click)=\"addAddress()\"&gt;\n        {{buttonText}}\n    &lt;/button&gt;\n&lt;/form&gt;</code></pre>\n</div>\n\n<p><strong>Address List Component</strong></p>\n<p>When a customer logs in, they can access their existing addresses. Instead of having them re-enter an address, they can pick from an address list. This is the purpose of this component. On initialization, all the customer's addresses are fetched using the <code>CustomerAddressService</code> if they are logged in. We will check their login status using the <code>SessionService</code>. </p>\n<p>This component has a <code>setAddressEvent</code> output property. When an address is selected, <code>setAddressEvent</code> emits its id to the parent component.</p>\n<div>\n<pre><code>@Component({\n  selector: 'app-address-list',\n  templateUrl: './address-list.component.html',\n  styleUrls: ['./address-list.component.css']\n})\nexport class AddressListComponent implements OnInit {\n  addresses: CustomerAddress[] = [];\n\n  @Output() setAddressEvent = new EventEmitter&lt;string&gt;();\n\n  constructor(\n    private session: SessionService,\n    private customerAddresses: CustomerAddressService,\n    private snackBar: MatSnackBar\n  ) { }\n\n  ngOnInit() {\n    this.session.loggedInStatus\n      .pipe(\n        mergeMap(\n          status =&gt; iif(() =&gt; status, this.customerAddresses.getCustomerAddresses())\n        ))\n      .subscribe(\n        addresses =&gt; {\n          if (addresses.length) {\n            this.addresses = addresses\n          }\n        },\n        err =&gt; this.snackBar.open('There was a problem getting your existing addresses.', 'Close', { duration: 8000 })\n      );\n  }\n\n  setAddress(change: MatRadioChange) {\n    this.setAddressEvent.emit(change.value);\n  }\n}</code></pre>\n</div>\n\n<p>Here is its template. You can find its styling <a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/features/checkout/components/address-list/address-list.component.css\">here</a>.</p>\n<div>\n<pre><code>&lt;div id=\"container\"&gt;\n    &lt;p class=\"mat-headline\"&gt;Pick an existing address&lt;/p&gt;\n    &lt;mat-error <em>ngIf=\"!addresses.length\"&gt;You have no existing addresses&lt;/mat-error&gt;\n    &lt;mat-radio-group </em>ngIf=\"addresses.length\" class=\"addresses\" (change)=\"setAddress($event)\"&gt;\n        &lt;mat-card class=\"address\" *ngFor=\"let address of addresses\"&gt;\n            &lt;mat-radio-button [value]=\"address.address?.id\" color=\"primary\"&gt;\n                &lt;p&gt;{{address.address?.firstName}} {{address.address?.lastName}},&lt;/p&gt;\n                &lt;p&gt;{{address.address?.line1}},&lt;/p&gt;\n                &lt;p&gt;{{address.address?.city}},&lt;/p&gt;\n                &lt;p&gt;{{address.address?.zipCode}},&lt;/p&gt;\n                &lt;p&gt;{{address.address?.stateCode}}, {{address.address?.countryCode}}&lt;/p&gt;\n                &lt;p&gt;{{address.address?.phone}}&lt;/p&gt;\n            &lt;/mat-radio-button&gt;\n        &lt;/mat-card&gt;\n    &lt;/mat-radio-group&gt;\n&lt;/div&gt;</code></pre>\n</div>\n\n<h4>Pages</h4>\n<p><strong>Customer Component</strong></p>\n<p>An order needs to be associated with an email address. This component is a form that captures the customer email address. When the component is initialized, the current customer's email address is fetched if they are logged in. We get the customer from the <code>CustomerService</code>. If they do not wish to change their email address, this email will be the default value. </p>\n<p>If the email is changed or a customer is not logged in, the order is updated with the inputted email. We use the <code>OrderService</code> to update the order with the new email address. If successful, we route the customer to the billing address page.</p>\n<div>\n<pre><code>@UntilDestroy({ checkProperties: true })\n@Component({\n  selector: 'app-customer',\n  templateUrl: './customer.component.html',\n  styleUrls: ['./customer.component.css']\n})\nexport class CustomerComponent implements OnInit {\n  email = new FormControl('', [Validators.required, Validators.email]);\n\n  constructor(\n    private orders: OrderService,\n    private customers: CustomerService,\n    private cart: CartService,\n    private router: Router,\n    private snackBar: MatSnackBar\n  ) { }\n\n  ngOnInit() {\n    this.customers.getCurrentCustomer()\n      .subscribe(\n        customer =&gt; this.email.setValue(customer.email)\n      );\n  }\n\n  addCustomerEmail() {\n    this.orders.updateOrder(\n      { id: this.cart.orderId, customerEmail: this.email.value },\n      [UpdateOrderParams.customerEmail])\n      .subscribe(\n        () =&gt; this.router.navigateByUrl('/billing-address'),\n        err =&gt; this.snackBar.open('There was a problem adding your email to the order.', 'Close', { duration: 8000 })\n      );\n  }\n}</code></pre>\n</div>\n\n<p>Here is the component template and linked <a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/features/checkout/pages/customer/customer.component.css\">here</a> is its styling. </p>\n<div>\n<pre><code>&lt;div id=\"container\"&gt;\n    &lt;app-title no=\"1\" title=\"Customer\" subtitle=\"Billing information and shipping address\"&gt;&lt;/app-title&gt;\n    &lt;mat-form-field appearance=\"outline\"&gt;\n        &lt;mat-label&gt;Email&lt;/mat-label&gt;\n        &lt;input matInput [formControl]=\"email\" required&gt;\n        &lt;mat-icon matPrefix&gt;alternate_email&lt;/mat-icon&gt;\n    &lt;/mat-form-field&gt;\n    &lt;button mat-flat-button color=\"primary\" [disabled]=\"email.invalid\" (click)=\"addCustomerEmail()\"&gt;\n        PROCEED TO BILLING ADDRESS\n    &lt;/button&gt;\n&lt;/div&gt;</code></pre>\n</div>\n\n<p>Here is a screenshot of the customer page. </p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6f77bbb2-9fde-4c31-b50b-333c5101604a/10-jamstack-e-commerce-site-angular-11-scull.png\" /></p>\n<p><strong>Billing Address Component</strong></p>\n<p>The billing address component lets a customer either add a new billing address or pick from their existing addresses. Users who are not logged in have to input a new address. Those who have logged in get an option to pick between new or existing addresses. </p>\n<p>The <code>showAddress</code> property indicates whether existing addresses should be shown on the component. <code>sameShippingAddressAsBilling</code> indicates whether the shipping address should be the same as what the billing address is set. When a customer selects an existing address, then its id is assigned to <code>selectedCustomerAddressId</code>. </p>\n<p>When the component is initialized, we use the <code>SessionService</code> to check if the current user is logged in. If they are logged in, we will display their existing addresses if they have any. </p>\n<p>As mentioned earlier, if a user is logged in, they can pick an existing address as their billing address. In the <code>updateBillingAddress</code> method, if they are logged in, the address they select is cloned and set as the order's billing address. We do this by updating the order using the <code>updateOrder</code> method of the <code>OrderService</code> and supplying the address Id. </p>\n<p>If they are not logged in, the user has to provide an address. Once provided, the address is created using the <code>createAddress</code> method. In it, the <code>AddressService</code> takes the input and makes the new address. After which, the order is updated using the id of the newly created address. If there is an error or either operation is successful, we show a snackbar.</p>\n<p>If the same address is selected as a shipping address, the user is routed to the shipping methods page. If they'd like to provide an alternate shipping address, they are directed to the shipping address page.</p>\n<div>\n<pre><code>@UntilDestroy({ checkProperties: true })\n@Component({\n  selector: 'app-billing-address',\n  templateUrl: './billing-address.component.html',\n  styleUrls: ['./billing-address.component.css']\n})\nexport class BillingAddressComponent implements OnInit {\n  showAddresses: boolean = false;\n  sameShippingAddressAsBilling: boolean = false;\n  selectedCustomerAddressId: string = '';\n\n  constructor(\n    private addresses: AddressService,\n    private snackBar: MatSnackBar,\n    private session: SessionService,\n    private orders: OrderService,\n    private cart: CartService,\n    private router: Router,\n    private customerAddresses: CustomerAddressService) { }\n\n  ngOnInit() {\n    this.session.loggedInStatus\n      .subscribe(\n        status =&gt; this.showAddresses = status\n      );\n  }\n\n  updateBillingAddress(address: Address) {\n    if (this.showAddresses &amp;&amp; this.selectedCustomerAddressId) {\n      this.cloneAddress();\n    } else if (address.firstName &amp;&amp; address.lastName &amp;&amp; address.line1 &amp;&amp; address.city &amp;&amp; address.zipCode &amp;&amp; address.stateCode &amp;&amp; address.countryCode &amp;&amp; address.phone) {\n      this.createAddress(address);\n    }\n    else {\n      this.snackBar.open('Check your address. Some fields are missing.', 'Close');\n    }\n  }\n\n  setCustomerAddress(customerAddressId: string) {\n    this.selectedCustomerAddressId = customerAddressId;\n  }\n\n  setSameShippingAddressAsBilling(change: boolean) {\n    this.sameShippingAddressAsBilling = change;\n  }\n\n  private createAddress(address: Address) {\n    this.addresses.createAddress(address)\n      .pipe(\n        concatMap(\n          address =&gt; {\n            const update = this.updateOrderObservable({\n              id: this.cart.orderId,\n              billingAddressId: address.id\n            }, [UpdateOrderParams.billingAddress]);\n\n            if (this.showAddresses) {\n              return combineLatest([update, this.customerAddresses.createCustomerAddress(address.id || '', '')]);\n            } else {\n              return update;\n            }\n          }))\n      .subscribe(\n        () =&gt; this.showSuccessSnackBar(),\n        err =&gt; this.showErrorSnackBar()\n      );\n  }\n\n  private cloneAddress() {\n    this.updateOrderObservable({\n      id: this.cart.orderId,\n      billingAddressCloneId: this.selectedCustomerAddressId\n    }, [UpdateOrderParams.billingAddressClone])\n      .subscribe(\n        () =&gt; this.showSuccessSnackBar(),\n        err =&gt; this.showErrorSnackBar()\n      );\n  }\n\n  private updateOrderObservable(order: Order, updateParams: UpdateOrderParams[]): Observable&lt;any&gt; {\n    return iif(() =&gt; this.sameShippingAddressAsBilling,\n      concat([\n        this.orders.updateOrder(order, updateParams),\n        this.orders.updateOrder(order, [UpdateOrderParams.shippingAddressSameAsBilling])\n      ]),\n      this.orders.updateOrder(order, updateParams)\n    );\n  }\n\n  private showErrorSnackBar() {\n    this.snackBar.open('There was a problem creating your address.', 'Close', { duration: 8000 });\n  }\n\n  private navigateTo(path: string) {\n    setTimeout(() =&gt; this.router.navigateByUrl(path), 4000);\n  }\n\n  private showSuccessSnackBar() {\n    this.snackBar.open('Billing address successfully added. Redirecting...', 'Close', { duration: 3000 });\n    if (this.sameShippingAddressAsBilling) {\n      this.navigateTo('/shipping-methods');\n    } else {\n      this.navigateTo('/shipping-address');\n    }\n  }\n}</code></pre>\n</div>\n\n<p>Here is the template. <a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/features/checkout/pages/billing-address/billing-address.component.css\">This link</a> points to its styling.</p>\n<div>\n<pre><code>&lt;app-title no=\"2\" title=\"Billing Address\" subtitle=\"Address to bill charges to\"&gt;&lt;/app-title&gt;\n&lt;app-address-list <em>ngIf=\"showAddresses\" (setAddressEvent)=\"setCustomerAddress($event)\"&gt;&lt;/app-address-list&gt;\n&lt;mat-divider </em>ngIf=\"showAddresses\"&gt;&lt;/mat-divider&gt;\n&lt;app-address [showTitle]=\"showAddresses\" buttonText=\"PROCEED TO NEXT STEP\" checkboxText=\"Ship to the same address\" (isCheckboxChecked)=\"setSameShippingAddressAsBilling($event)\" (createAddress)=\"updateBillingAddress($event)\"&gt;&lt;/app-address&gt;</code></pre>\n</div>\n\n<p>This is what the billing address page will look like.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/9bc621e9-a6a3-4796-a1bd-cfaaf8f6615e/1-jamstack-e-commerce-site-angular-11-scull.png\" /></p>\n<p><strong>Shipping Address Component</strong></p>\n<p>The shipping address component behaves a lot like the billing address component. However, there are a couple of differences. For one, the text displayed on the template is different. The other key differences are in how the order is updated using the <code>OrderService</code> once an address is created or selected. The fields that the order updates are <code>shippingAddressCloneId</code> for selected addresses and <code>shippingAddress</code> for new addresses. If a user chooses to change the billing address, to be the same as the shipping address, the <code>billingAddressSameAsShipping</code> field is updated. </p>\n<p>After a shipping address is selected and the order is updated, the user is routed to the shipping methods page.</p>\n<div>\n<pre><code>@UntilDestroy({ checkProperties: true })\n@Component({\n  selector: 'app-shipping-address',\n  templateUrl: './shipping-address.component.html',\n  styleUrls: ['./shipping-address.component.css']\n})\nexport class ShippingAddressComponent implements OnInit {\n  showAddresses: boolean = false;\n  sameBillingAddressAsShipping: boolean = false;\n  selectedCustomerAddressId: string = '';\n\n  constructor(\n    private addresses: AddressService,\n    private snackBar: MatSnackBar,\n    private session: SessionService,\n    private orders: OrderService,\n    private cart: CartService,\n    private router: Router,\n    private customerAddresses: CustomerAddressService) { }\n\n  ngOnInit() {\n    this.session.loggedInStatus\n      .subscribe(\n        status =&gt; this.showAddresses = status\n      );\n  }\n\n  updateShippingAddress(address: Address) {\n    if (this.showAddresses &amp;&amp; this.selectedCustomerAddressId) {\n      this.cloneAddress();\n    } else if (address.firstName &amp;&amp; address.lastName &amp;&amp; address.line1 &amp;&amp; address.city &amp;&amp; address.zipCode &amp;&amp; address.stateCode &amp;&amp; address.countryCode &amp;&amp; address.phone) {\n      this.createAddress(address);\n    }\n    else {\n      this.snackBar.open('Check your address. Some fields are missing.', 'Close');\n    }\n  }\n\n  setCustomerAddress(customerAddressId: string) {\n    this.selectedCustomerAddressId = customerAddressId;\n  }\n\n  setSameBillingAddressAsShipping(change: boolean) {\n    this.sameBillingAddressAsShipping = change;\n  }\n\n  private createAddress(address: Address) {\n    this.addresses.createAddress(address)\n      .pipe(\n        concatMap(\n          address =&gt; {\n            const update = this.updateOrderObservable({\n              id: this.cart.orderId,\n              shippingAddressId: address.id\n            }, [UpdateOrderParams.shippingAddress]);\n\n            if (this.showAddresses) {\n              return combineLatest([update, this.customerAddresses.createCustomerAddress(address.id || '', '')]);\n            } else {\n              return update;\n            }\n          }))\n      .subscribe(\n        () =&gt; this.showSuccessSnackBar(),\n        err =&gt; this.showErrorSnackBar()\n      );\n  }\n\n  private cloneAddress() {\n    this.updateOrderObservable({\n      id: this.cart.orderId,\n      shippingAddressCloneId: this.selectedCustomerAddressId\n    }, [UpdateOrderParams.shippingAddressClone])\n      .subscribe(\n        () =&gt; this.showSuccessSnackBar(),\n        err =&gt; this.showErrorSnackBar()\n      );\n  }\n\n  private updateOrderObservable(order: Order, updateParams: UpdateOrderParams[]): Observable&lt;any&gt; {\n    return iif(() =&gt; this.sameBillingAddressAsShipping,\n      concat([\n        this.orders.updateOrder(order, updateParams),\n        this.orders.updateOrder(order, [UpdateOrderParams.billingAddressSameAsShipping])\n      ]),\n      this.orders.updateOrder(order, updateParams)\n    );\n  }\n\n  private showErrorSnackBar() {\n    this.snackBar.open('There was a problem creating your address.', 'Close', { duration: 8000 });\n  }\n\n  private showSuccessSnackBar() {\n    this.snackBar.open('Shipping address successfully added. Redirecting...', 'Close', { duration: 3000 });\n\n    setTimeout(() =&gt; this.router.navigateByUrl('/shipping-methods'), 4000);\n  }\n}</code></pre>\n</div>\n\n<p>Here is the template and its styling can be found <a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/features/checkout/pages/shipping-address/shipping-address.component.css\">here</a>.</p>\n<div>\n<pre><code>&lt;app-title no=\"3\" title=\"Shipping Address\" subtitle=\"Address to ship package to\"&gt;&lt;/app-title&gt;\n&lt;app-address-list <em>ngIf=\"showAddresses\" (setAddressEvent)=\"setCustomerAddress($event)\"&gt;&lt;/app-address-list&gt;\n&lt;mat-divider </em>ngIf=\"showAddresses\"&gt;&lt;/mat-divider&gt;\n&lt;app-address [showTitle]=\"showAddresses\" buttonText=\"PROCEED TO SHIPPING METHODS\" checkboxText=\"Bill to the same address\" (isCheckboxChecked)=\"setSameBillingAddressAsShipping($event)\" (createAddress)=\"updateShippingAddress($event)\"&gt;&lt;/app-address&gt;</code></pre>\n</div>\n\n<p>The shipping address page will look like this. </p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/80952fbf-9294-4da7-8ec1-1e5968718eac/21-jamstack-e-commerce-site-angular-11-scull.png\" /></p>\n<p><strong>Shipping Methods Component</strong></p>\n<p>This component displays the number of shipments required for an order to be fulfilled, the available shipping methods, and their associated costs. The customer can then select a shipping method they prefer for each shipment. </p>\n<p>The <code>shipments</code> property contains all the shipments of the order. The <code>shipmentsForm</code> is the form within which the shipping method selections will be made. </p>\n<p>When the component is initialized, the order is fetched and will contain both its line items and shipments. At the same time, we get the delivery lead times for the various shipping methods. We use the <code>OrderService</code> to get the order and the <code>DeliveryLeadTimeService</code> for the lead times. Once both sets of information are returned, they are combined into an array of shipments and assigned to the <code>shipments</code> property. Each shipment will contain its items, the shipping methods available, and the corresponding cost. </p>\n<p>After the user has selected a shipping method for each shipment, the selected shipping method is updated for each in <code>setShipmentMethods</code>. If successful, the user is routed to the payments page.</p>\n<div>\n<pre><code>@UntilDestroy({ checkProperties: true })\n@Component({\n  selector: 'app-shipping-methods',\n  templateUrl: './shipping-methods.component.html',\n  styleUrls: ['./shipping-methods.component.css']\n})\nexport class ShippingMethodsComponent implements OnInit {\n  shipments: Shipment[] | undefined = [];\n  shipmentsForm: FormGroup = this.fb.group({});\n\n  constructor(\n    private orders: OrderService,\n    private dlts: DeliveryLeadTimeService,\n    private cart: CartService,\n    private router: Router,\n    private fb: FormBuilder,\n    private shipments: ShipmentService,\n    private snackBar: MatSnackBar\n  ) { }\n\n  ngOnInit() {\n    combineLatest([\n      this.orders.getOrder(this.cart.orderId, GetOrderParams.shipments),\n      this.dlts.getDeliveryLeadTimes()\n    ]).subscribe(\n      ([lineItems, deliveryLeadTimes]) =&gt; {\n        let li: LineItem;\n        let lt: DeliveryLeadTime[];\n\n        this.shipments = lineItems.shipments?.map((shipment) =&gt; {\n          if (shipment.id) {\n            this.shipmentsForm.addControl(shipment.id, new FormControl('', Validators.required));\n          }\n\n          if (shipment.lineItems) {\n            shipment.lineItems = shipment.lineItems.map(item =&gt; {\n              li = this.findItem(lineItems, item.skuCode || '');\n              item.imageUrl = li.imageUrl;\n              item.name = li.name;\n              return item;\n            });\n          }\n\n          if (shipment.availableShippingMethods) {\n            lt = this.findLocationLeadTime(deliveryLeadTimes, shipment);\n            shipment.availableShippingMethods = shipment.availableShippingMethods?.map(\n              method =&gt; {\n                method.deliveryLeadTime = this.findMethodLeadTime(lt, method);\n                return method;\n              });\n          }\n\n          return shipment;\n        });\n      },\n      err =&gt; this.router.navigateByUrl('/error')\n    );\n  }\n\n  setShipmentMethods() {\n    const shipmentsFormValue = this.shipmentsForm.value;\n\n    combineLatest(Object.keys(shipmentsFormValue).map(\n      key =&gt; this.shipments.updateShipment(key, shipmentsFormValue[key])\n    )).subscribe(\n      () =&gt; {\n        this.snackBar.open('Your shipments have been updated with a shipping method.', 'Close', { duration: 3000 });\n        setTimeout(() =&gt; this.router.navigateByUrl('/payment'), 4000);\n      },\n      err =&gt; this.snackBar.open('There was a problem adding shipping methods to your shipments.', 'Close', { duration: 5000 })\n    );\n  }\n\n\n  private findItem(lineItems: LineItem[], skuCode: string): LineItem {\n    return lineItems.filter((item) =&gt; item.skuCode == skuCode)[0];\n  }\n\n  private findLocationLeadTime(times: DeliveryLeadTime[], shipment: Shipment): DeliveryLeadTime[] {\n    return times.filter((dlTime) =&gt; dlTime?.stockLocation?.id == shipment?.stockLocation?.id);\n  }\n\n  private findMethodLeadTime(times: DeliveryLeadTime[], method: ShippingMethod): DeliveryLeadTime {\n    return times.filter((dlTime) =&gt; dlTime?.shippingMethod?.id == method?.id)[0];\n  }\n}</code></pre>\n</div>\n\n<p>Here is the template and you can find the styling at <a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/features/checkout/pages/shipping-methods/shipping-methods.component.css\">this link</a>.</p>\n<div>\n<pre><code>&lt;form id=\"container\" [formGroup]=\"shipmentsForm\"&gt;\n    &lt;app-title no=\"4\" title=\"Shipping Methods\" subtitle=\"How to ship your packages\"&gt;&lt;/app-title&gt;\n    &lt;div class=\"shipment-container\" <em>ngFor=\"let shipment of shipments; let j = index; let isLast = last\"&gt;\n        &lt;h1&gt;Shipment {{j+1}} of {{shipments?.length}}&lt;/h1&gt;\n        &lt;div class=\"row\" </em>ngFor=\"let item of shipment.lineItems\"&gt;\n            &lt;img class=\"image-xs\" [src]=\"item.imageUrl\" alt=\"product photo\"&gt;\n            &lt;div id=\"shipment-details\"&gt;\n                &lt;h4 id=\"item-name\"&gt;{{item.name}}&lt;/h4&gt;\n                &lt;p&gt;{{item.skuCode}}&lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div id=\"quantity-section\"&gt;\n                &lt;p id=\"quantity-label\"&gt;Quantity: &lt;/p&gt;{{item.quantity}}\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;mat-radio-group [formControlName]=\"shipment?.id || j\"&gt;\n            &lt;mat-radio-button <em>ngFor=\"let method of shipment.availableShippingMethods\" [value]=\"method.id\"&gt;\n                &lt;div class=\"radio-button\"&gt;\n                    &lt;p&gt;{{method.name}}&lt;/p&gt;\n                    &lt;div&gt;\n                        &lt;p class=\"radio-label\"&gt;Cost:&lt;/p&gt;\n                        &lt;p&gt; {{method.formattedPriceAmount}}&lt;/p&gt;\n                    &lt;/div&gt;\n                    &lt;div&gt;\n                        &lt;p class=\"radio-label\"&gt;Timeline:&lt;/p&gt;\n                        &lt;p&gt; Available in {{method.deliveryLeadTime?.minDays}}-{{method.deliveryLeadTime?.maxDays}} days&lt;/p&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/mat-radio-button&gt;\n        &lt;/mat-radio-group&gt;\n        &lt;mat-divider </em>ngIf=\"!isLast\"&gt;&lt;/mat-divider&gt;\n    &lt;/div&gt;\n    &lt;button mat-flat-button color=\"primary\" [disabled]=\"shipmentsForm.invalid\" (click)=\"setShipmentMethods()\"&gt;PROCEED TO PAYMENT&lt;/button&gt;\n&lt;/form&gt;</code></pre>\n</div>\n\n<p>This is a screenshot of the shipping methods page.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/88e82833-062d-4f85-9fcd-8173f28458bd/4-jamstack-e-commerce-site-angular-11-scull.png\" /></p>\n<p><strong>Payments Component</strong></p>\n<p>In this component, the user clicks the payment button if they wish to proceed to pay for their order with Paypal. The <code>approvalUrl</code> is the Paypal link that the user is directed to when they click the button. </p>\n<p>During initialization, we get the order with the payment source included using the <code>OrderService</code>. If a payment source is set, we get its id and retrieve the corresponding Paypal payment from the <code>PaypalPaymentService</code>. The Paypal payment will contain the approval url. If no payment source has been set, we update the order with Paypal as the preferred payment method. We then proceed to create a new Paypal payment for the order using the <code>PaypalPaymentService</code>. From here, we can get the approval url from the newly created order. </p>\n<p>Lastly, when the user clicks the button, they are redirected to Paypal where they can approve the purchase. </p>\n<div>\n<pre><code>@UntilDestroy({ checkProperties: true })\n@Component({\n  selector: 'app-payment',\n  templateUrl: './payment.component.html',\n  styleUrls: ['./payment.component.css']\n})\nexport class PaymentComponent implements OnInit {\n  approvalUrl: string = '';\n\n  constructor(\n    private orders: OrderService,\n    private cart: CartService,\n    private router: Router,\n    private payments: PaypalPaymentService\n  ) { }\n\n  ngOnInit() {\n    const orderId = this.cart.orderId;\n\n    this.orders.getOrder(orderId, GetOrderParams.paymentSource)\n      .pipe(\n        concatMap((order: Order) =&gt; {\n          const paymentSourceId = order.paymentSource?.id;\n\n          const paymentMethod = order.availablePaymentMethods?.filter(\n            (method) =&gt; method.paymentSourceType == 'paypal_payments'\n          )[0];\n\n          return iif(\n            () =&gt; paymentSourceId ? true : false,\n            this.payments.getPaypalPayment(paymentSourceId || ''),\n            this.orders.updateOrder({\n              id: orderId,\n              paymentMethodId: paymentMethod?.id\n            }, [UpdateOrderParams.paymentMethod])\n              .pipe(concatMap(\n                order =&gt; this.payments.createPaypalPayment({\n                  orderId: orderId,\n                  cancelUrl: <code>${environment.clientUrl}/cancel-payment</code>,\n                  returnUrl: <code>${environment.clientUrl}/place-order</code>\n                })\n              ))\n          );\n        }))\n      .subscribe(\n        paypalPayment =&gt; this.approvalUrl = paypalPayment?.approvalUrl || '',\n        err =&gt; this.router.navigateByUrl('/error')\n      );\n  }\n\n  navigateToPaypal() {\n    window.location.href = this.approvalUrl;\n  }\n}</code></pre>\n</div>\n\n<p>Here is its template.</p>\n<div>\n<pre><code>&lt;app-simple-page number=\"5\" title=\"Payment\" subtitle=\"Pay for your order\" buttonText=\"PROCEED TO PAY WITH PAYPAL\" icon=\"point_of_sale\" (buttonEvent)=\"navigateToPaypal()\" [buttonDisabled]=\"approvalUrl.length ? false : true\"&gt;&lt;/app-simple-page&gt;</code></pre>\n</div>\n\n<p>Here’s what the payments page will look like.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/e95b6832-2acf-422c-88a9-35d1f22bbd4d/19-jamstack-e-commerce-site-angular-11-scull.png\" /></p>\n<p><strong>Cancel Payment Component</strong></p>\n<p>Paypal requires a cancel payment page. This component serves this purpose. This is its template.</p>\n<div>\n<pre><code>&lt;app-simple-page title=\"Payment cancelled\" subtitle=\"Your Paypal payment has been cancelled\" icon=\"money_off\" buttonText=\"GO TO HOME\" [centerText]=\"true\" route=\"/\"&gt;&lt;/app-simple-page&gt;</code></pre>\n</div>\n\n<p>Here’s a screenshot of the page.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8549e6ca-a031-4094-8c56-162f6d5efc8f/15-jamstack-e-commerce-site-angular-11-scull.png\" /></p>\n<p><strong>Place Order Component</strong></p>\n<p>This is the last step in the checkout process. Here the user confirms that they indeed want to place the order and begin its processing. When the user approves the Paypal payment, this is the page they are redirected to. Paypal adds a payer id query parameter to the url. This is the user's Paypal Id. </p>\n<p>When the component is initialized, we get the <code>payerId</code> query parameter from the url. The order is then retrieved using the <code>OrderService</code> with the payment source included. The id of the included payment source is used to update the Paypal payment with the payer id, using the <code>PaypalPayment</code> service. If any of these fail, the user is redirected to the error page. We use the <code>disableButton</code> property to prevent the user from placing the order until the payer Id is set. </p>\n<p>When they click the place-order button, the order is updated with a <code>placed</code> status. Afterwhich the cart is cleared, a successful snack bar is displayed, and the user is redirected to the home page.</p>\n<div>\n<pre><code>@UntilDestroy({ checkProperties: true })\n@Component({\n  selector: 'app-place-order',\n  templateUrl: './place-order.component.html',\n  styleUrls: ['./place-order.component.css']\n})\nexport class PlaceOrderComponent implements OnInit {\n  disableButton = true;\n\n  constructor(\n    private route: ActivatedRoute,\n    private router: Router,\n    private payments: PaypalPaymentService,\n    private orders: OrderService,\n    private cart: CartService,\n    private snackBar: MatSnackBar\n  ) { }\n\n  ngOnInit() {\n    this.route.queryParams\n      .pipe(\n        concatMap(params =&gt; {\n          const payerId = params['PayerID'];\n          const orderId = this.cart.orderId;\n\n          return iif(\n            () =&gt; payerId.length &gt; 0,\n            this.orders.getOrder(orderId, GetOrderParams.paymentSource)\n              .pipe(\n                concatMap(order =&gt; {\n                  const paymentSourceId = order.paymentSource?.id || '';\n\n                  return iif(\n                    () =&gt; paymentSourceId ? paymentSourceId.length &gt; 0 : false,\n                    this.payments.updatePaypalPayment(paymentSourceId, payerId)\n                  );\n                })\n              )\n          );\n        }))\n      .subscribe(\n        () =&gt; this.disableButton = false,\n        () =&gt; this.router.navigateByUrl('/error')\n      );\n  }\n\n  placeOrder() {\n    this.disableButton = true;\n\n    this.orders.updateOrder({\n      id: this.cart.orderId,\n      place: true\n    }, [UpdateOrderParams.place])\n      .subscribe(\n        () =&gt; {\n          this.snackBar.open('Your order has been successfully placed.', 'Close', { duration: 3000 });\n          this.cart.clearCart();\n          setTimeout(() =&gt; this.router.navigateByUrl('/'), 4000);\n        },\n        () =&gt; {\n          this.snackBar.open('There was a problem placing your order.', 'Close', { duration: 8000 });\n          this.disableButton = false;\n        }\n      );\n  }\n}</code></pre>\n</div>\n\n<p>Here is the template and its <a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/features/checkout/pages/place-order/place-order.component.css\">associated styling</a>. </p>\n<div>\n<pre><code>&lt;app-simple-page title=\"Finalize Order\" subtitle=\"Complete your order\" [number]=\"'6'\" icon=\"shopping_bag\" buttonText=\"PLACE YOUR ORDER\" (buttonEvent)=\"placeOrder()\" [buttonDisabled]=\"disableButton\"&gt;&lt;/app-simple-page&gt;</code></pre>\n</div>\n\n<p>Here is a screenshot of the page. </p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/cb0f69f6-d5d6-4683-a59e-5f5cb1edf965/3-jamstack-e-commerce-site-angular-11-scull.png\" /></p>\nApp Module\n<p>All requests made to Commerce Layer, other than for authentication, need to contain a token. So the moment the app is initialized, a token is fetched from the <code>/oauth/token</code> route on the server and a session is initialized. We’ll use the <code>APP_INITIALIZER</code> token to provide an initialization function in which the token is retrieved. Additionally, we’ll use the <code>HTTP_INTERCEPTORS</code> token to provide the <code>OptionsInterceptor</code> we created earlier. Once all the modules are added the app module file should look something like this.</p>\n<div>\n<pre><code>@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    HttpClientModule,\n    BrowserAnimationsModule,\n    AuthModule,\n    ProductsModule,\n    CartModule,\n    CheckoutModule,\n    CoreModule\n  ],\n  providers: [\n    {\n      provide: HTTP_INTERCEPTORS,\n      useClass: OptionsInterceptor,\n      multi: true\n    },\n    {\n      provide: APP_INITIALIZER,\n      useFactory: (http: HttpClient) =&gt; () =&gt; http.post&lt;object&gt;(\n        <code>${environment.apiUrl}/oauth/token</code>,\n        { 'grantType': 'client_credentials' },\n        { withCredentials: true }),\n      multi: true,\n      deps: [HttpClient]\n    }\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }</code></pre>\n</div>\n\n<h3>App Component</h3>\n<p>We’ll modify the app component template and its styling which you can find <a href=\"https://github.com/zaracooper/lime-app/blob/main/src/app/app.component.css\">here</a>.</p>\n<pre><code>&lt;div id=\"page\"&gt;\n    &lt;app-header&gt;&lt;/app-header&gt;\n    &lt;div id=\"content\"&gt;\n        &lt;router-outlet&gt;&lt;/router-outlet&gt;\n    &lt;/div&gt;\n&lt;/div&gt;</code></pre>\n\nConclusion\n<p>In this article, we’ve covered how you could create an e-commerce Angular 11 app with Commerce Layer and Paypal. We’ve also touched on how to structure the app and how you could interface with an e-commerce API. </p>\n<p>Although this app allows a customer to make a complete order, it is not by any means finished. There is so much you could add to improve it. For one, you may choose to enable item quantity changes in the cart, link cart items to their product pages, optimize the address components, add additional guards for checkout pages like the place-order page, and so on. This is just the starting point. </p>\n<p>If you’d like to understand more about the process of making an order from start to finish, you could check out the Commerce Layer <a href=\"https://docs.commercelayer.io/guides\">guides</a> and <a href=\"https://docs.commercelayer.io/api/\">API</a>. You can view the code for this project at this <a href=\"https://github.com/zaracooper/lime-app\">repository</a>.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"24d5ef154252dafe5e06d4439e0ab9b0ca13c8bd910c5f4c826c72c5c9f5fcdf","category":"Tech"}