{"title":"เร็วขึ้นอีกสิเจ้าแฟกทอเรียล!","link":"https://neizod.dev/2021/12/12/smarter-better-faster-factorial.html","date":1639327850000,"content":"<p>นิยาม<a href=\"//en.wikipedia.org/wiki/Factorial\">แฟกทอเรียล</a>นั้นเรียบง่ายจนใครๆ ก็สามารถ implement ตามได้ สมมติต้องการ $20!$ เราก็แค่คำนวณ</p>\n\n\\[20! = 1 \\times 2 \\times 3 \\times \\cdots \\times 20\\]\n\n<p>วิเคราะห์แบบหยาบๆ อัลกอริทึมนี้จับตัวเลขมาคูณกันมากที่สุด $n$ ครั้ง คำถามคือเราจะทำได้เร็วกว่านี้อีกมั้ย?</p>\n\n<p>สังเกตว่าถ้าเราแบ่งลำดับการคูณของตัวเลขจำนวณคู่และจำนวณคี่ออกจากกัน เราจะเห็นแพทเทิร์นที่คุ้นหน้าคุ้นตาขึ้นมาทันที</p>\n\n\\[\\begin{align}\n20! &amp;= (1 \\times 3 \\times 5 \\times 7 \\times 9 \\times 11 \\times 13 \\times 15 \\times 17 \\times 19) \\;\\times \\\\\n    &amp;\\phantom{=\\;\\;} (2 \\times 4 \\times 6 \\times 8 \\times 10 \\times 12 \\times 14 \\times 16 \\times 18 \\times 20) \\\\\n    &amp;= (1 \\times 3 \\times 5 \\times 7 \\times 9 \\times 11 \\times 13 \\times 15 \\times 17 \\times 19) \\;\\times \\\\\n    &amp;\\phantom{=\\;\\;} (1 \\times 2 \\times 3 \\times 4 \\times 5 \\times 6 \\times 7 \\times 8 \\times 9 \\times 10) \\times {\\color{red}2^{10}} \\\\\n\\end{align}\\]\n\n<p>ซึ่งหมายความว่า เราอาจใช้เทคนิคแนว<a href=\"//en.wikipedia.org/wiki/Divide-and-conquer_algorithm\">แบ่งแยกและเอาชนะ</a>ไปคำนวณปัญหาเดียวกันในเคสที่เล็กลง หลังจากนั้นก็เอาผลลัพธ์มาช่วยแก้ปัญหากับเคสที่ใหญ่กว่าได้</p>\n\n<p>แล้วเราจะหยุดทำไมแค่ตรงนี้หละ? ในเมื่อเราสามารถแตกปัญหาย่อยลงไปได้อีก</p>\n\n\\[\\begin{align}\n20! &amp;= (1 \\times 3 \\times 5 \\times 7 \\times 9 \\times 11 \\times 13 \\times 15 \\times 17 \\times 19) \\;\\times \\\\\n    &amp;\\phantom{=\\;\\;} (2 \\times 4 \\times 6 \\times 8 \\times 10 \\times 12 \\times 14 \\times 16 \\times 18 \\times 20) \\\\\n    &amp;= (1 \\times 3 \\times 5 \\times 7 \\times 9 \\times 11 \\times 13 \\times 15 \\times 17 \\times 19) \\;\\times \\\\\n    &amp;\\phantom{=\\;\\;} (2 \\times 6 \\times 10 \\times 14 \\times 18) \\;\\times \\\\\n    &amp;\\phantom{=\\;\\;} (4 \\times 8 \\times 12 \\times 16 \\times 20) \\\\\n    &amp;= (1 \\times 3 \\times 5 \\times 7 \\times 9 \\times 11 \\times 13 \\times 15 \\times 17 \\times 19) \\;\\times \\\\\n    &amp;\\phantom{=\\;\\;} (2 \\times 6 \\times 10 \\times 14 \\times 18) \\;\\times \\\\\n    &amp;\\phantom{=\\;\\;} (4 \\times 12 \\times 20) \\;\\times \\\\\n    &amp;\\phantom{=\\;\\;} (8 \\times 16) \\\\\n    &amp;= (1 \\times 3 \\times 5 \\times 7 \\times 9 \\times 11 \\times 13 \\times 15 \\times 17 \\times 19) \\;\\times \\\\\n    &amp;\\phantom{=\\;\\;} (2 \\times 6 \\times 10 \\times 14 \\times 18) \\;\\times \\\\\n    &amp;\\phantom{=\\;\\;} (4 \\times 12 \\times 20) \\;\\times \\\\\n    &amp;\\phantom{=\\;\\;} (8) \\;\\times \\\\\n    &amp;\\phantom{=\\;\\;} (16) \\\\\n    &amp;= (1 \\times 3 \\times 5 \\times 7 \\times 9 \\times 11 \\times 13 \\times 15 \\times 17 \\times 19) \\;\\times &amp; {\\color{red}1^{10}}\\times \\\\\n    &amp;\\phantom{=\\;\\;} (1 \\times 3 \\times 5 \\times 7 \\times 9) \\;\\times &amp; {\\color{red}2^{5\\phantom0}}\\times \\\\\n    &amp;\\phantom{=\\;\\;} (1 \\times 3 \\times 5) \\;\\times &amp; {\\color{red}4^{3\\phantom0}}\\times \\\\\n    &amp;\\phantom{=\\;\\;} (1) \\;\\times &amp; {\\color{red}8^{1\\phantom0}}\\times \\\\\n    &amp;\\phantom{=\\;\\;} (1) \\;\\times &amp; {\\color{red}16^{1\\phantom0}}\\phantom{\\times}\n\\end{align}\\]\n\n<p>หรือก็คือเราสามารถลดรูปปัญหาเป็นการหาผลคูณของเลขจำนวนคี่ในโครงสร้างเช่นนี้แทน แล้วจึงค่อยเอาไปคูณกับเลขคู่ที่จับแยกไว้ … มองผ่านๆ อาจจะเหมือนไม่ได้ช่วยเร่งความเร็วเลย เพราะในส่วนเลขคี่เราก็ยังต้องคูณเป็นจำนวน $n$ ครั้งเท่าเดิม เพิ่มเติมขึ้นมาก็คือต้องเอาไปคูณกับเลขคู่อีกหลายตัวทางด้านขวาเสียอีก</p>\n\n<p>แต่ระลึกไว้ว่าเราทำงานบนเลขฐานสอง ที่การคูณเลขใดๆ ด้วย $2^k$ นั้นเป็นเพียงการเลื่อนบิตไปทางซ้าย $k$ บิต อนึ่งการคูณเพียงเลขคี่นั้นก็ยังเร็วกว่าการคูณเลขทั้งหมด เพราะผลลัพธ์ระหว่างทางของการคูณเลขคี่นั้นมีขนาดบิตของตัวเลขที่สั้นกว่านั่นเอง ถึงตรงนี้ที่เราคูณเพียงเลขคี่และค่อยๆ เลื่อนบิตก็เร็วกว่าเดิมแล้ว</p>\n\n<p>แต่มาสังเกตว่าค่า $k$ ก็มีโครงสร้างที่รวบรัดเรียบง่ายเช่นกัน ซึ่งในกรณีนี้คำนวณได้จาก</p>\n\n\\[\\begin{align}\nk &amp;= \\log_2( 1^{10} \\times 2^5 \\times 4^3 \\times 8^1 \\times 16^1 ) \\\\\n  &amp;= 0{\\times}10 + 1{\\times}5 + 2{\\times}3 + 3{\\times}1 + 4{\\times}1 \\\\\n  &amp;= 18\n\\end{align}\\]\n\n<p>หรือเทียบเท่ากับการนับจำนวนบิต <code>1</code> ในเลขฐานสองของค่า $n$ ตั้งต้น เรียบร้อยแล้วก็เอา $n$ ไปลบทิ้งนั่นเอง หมายความว่าเราสามารถรู้ได้อย่างเร็วเลยว่าต้องเลื่อนกี่บิต ไม่ต้องค่อยๆ เลื่อนบิตหลายครั้งด้วย</p>\n\n<p>เรายังทำได้ดีกว่านี้อีก ย้อนกลับไปสังเกตส่วนการคูณเลขคี่ จะเห็นการคูณเลขซ้ำๆ กันเป็นจำนวนมาก เช่นนี้</p>\n\n\\[\\begin{align}\n20! &amp;= ({\\color{lightgray}1 \\times 3 \\times 5 \\times 7 \\times 9} \\times 11 \\times 13 \\times 15 \\times 17 \\times 19) \\;\\times &amp; {\\color{red}1^{10}}\\times \\\\\n    &amp;\\phantom{=\\;\\;} ({\\color{lightgray}1 \\times 3 \\times 5} \\times 7 \\times 9) \\;\\times &amp; {\\color{red}2^{5\\phantom0}}\\times \\\\\n    &amp;\\phantom{=\\;\\;} ({\\color{lightgray}1} \\times 3 \\times 5) \\;\\times &amp; {\\color{red}4^{3\\phantom0}}\\times \\\\\n    &amp;\\phantom{=\\;\\;} ({\\color{lightgray}1}) \\;\\times &amp; {\\color{red}8^{1\\phantom0}}\\times \\\\\n    &amp;\\phantom{=\\;\\;} (1) \\;\\times &amp; {\\color{red}16^{1\\phantom0}}\\phantom{\\times} \\\\\n    &amp;= (1)^5 (3 \\times 5)^3 (7 \\times 9)^2 (11 \\times 13 \\times 15 \\times 17 \\times 19)^1 \\;\\times &amp; {\\color{red}2^{18}\\phantom{\\times}}\n\\end{align}\\]\n\n<p>ซึ่งในส่วนการยกกำลังเราสามารถใช้เทคนิค<a href=\"//en.wikipedia.org/wiki/Exponentiation_by_squaring\">การสร้างจัตุรัส</a> ที่มีรายละเอียดเป็นการเลื่อนบิตของเลขยกกำลังไปทางขวาแทนการหารสองมาช่วยได้อีก จึงทำให้เราประหยัดการคูณ/หาร และเก็บมันไว้ใช้เฉพาะกับการคำนวณตัวเลขในแฟกทอเรียลเท่านั้นได้</p>\n\n<p>นอกจากนี้ ลำดับการคูณเลขเรียงกันก็มีผล จากตัวอย่าง $11{\\times}13{\\times}15{\\times}17{\\times}19$ หากเราคำนวณไล่จากซ้ายไปขวาเรื่อยๆ ซึ่งก็คือ $((((11{\\times}13){\\times}15){\\times}17){\\times}19)$ ผลลัพธ์ยิบย่อยระหว่างทางจะมีบิตเพิ่มขึ้นเรื่อยๆ จนมีจำนวนบิตเข้าใกล้จำนวนบิตของผลลัพธ์สุดท้าย แต่หากเราพยายามแบ่งชุดการคูณออกเป็นสองข้างที่มีจำนวนการคูณใกล้เคียงกัน เช่นอาจแบ่งเป็น $((11{\\times}13){\\times}15){\\times}(17{\\times}19)$ จะเห็นว่าผลลัพธ์ระหว่างทางนั้นใช้จำนวนบิตเก็บข้อมูลน้อยกว่า โดยน้อยลงเหลือประมาณครึ่งหนึ่งของจำนวนบิตของผลลัพธ์สุดท้ายเท่านั้น</p>\n\n<p>ดังนั้นสรุปแล้ว อัลกอริทึมนี้จะใช้การคูณลดเหลือ $\\frac{n}2$ ครั้งสำหรับการคูณเลขคี่ทุกตัวที่น้อยกว่า $n$ ส่วนการคูณที่แฝงอยู่ในการยกกำลังก็ใช้รวมกันอีกไม่เกิน $\\frac{n}2$ ครั้ง แม้ว่ารวมกันแล้วจะกลายเป็นใช้การคูณไม่เกิน $n$ ครั้งเหมือนเดิม แต่ก็เห็นได้ชัดว่ามันทำงานเร็วกว่าด้วยหลายสาเหตุ ตั้งแต่ใช้บิตเก็บข้อมูลเล็กกว่า จำนวนการคูณที่เรียกใช้ก็ไม่มากครั้งกว่า ไปจนถึงการใช้เทคนิคบนเลขฐานสองมาช่วยคำนวณได้อีกหลายจุดอีกด้วย</p>\n\n<p>อัลกอริทึมในแนวคิดนี้ถูกนำไปใช้งานจริงบน Python 3.2+ (<a href=\"//bugs.python.org/issue8692\">กระดานพูดคุยนักพัฒนา</a>, <a href=\"//hg.python.org/cpython/file/7937aa6b7e92/Modules/mathmodule.c#l1218\">โค้ด C บรรทัดที่ 1218-1460</a>) ซึ่งผู้ใช้ Stack Overflow <a href=\"//stackoverflow.com/questions/9815252/\">รายงาน</a>ว่าฟังก์ชันดังกล่าวเร็วขึ้นประมาณห้าเท่าเมื่อคำนวณ $10000!$ และจะเร็วห่างกันมากยิ่งขึ้นกว่านี้เมื่อตัวเลขมีขนาดใหญ่ยิ่งขึ้นไปอีกด้วย</p>","author":"","siteTitle":"neizod's speculation","siteHash":"939338c5557b1743f2c128736c6006e145dcabc81da9970f1c0dc8ae2feb0830","entryHash":"2807c4f6ae706a6b4edda4e82abcbf3002720f48614d435f54dcfea18e0c3d43","category":"Thai"}