{"title":"รูปแบบที่น่าสนใจ สำหรับจัดการปัญหาการติดต่อสื่อสารระหว่าง service","link":"https://www.somkiat.cc/problems-from-service-to-service/","date":1627797966000,"content":"<div id=\"readability-page-1\" class=\"page\"><div id=\"page\"><article><div id=\"content_box\"><header><div><p><time>August 1, 2021</time> <span><a href=\"https://www.somkiat.cc/category/architecture-2/\" rel=\"category tag\">Architecture</a></span></p></div></header><div><figure><img src=\"https://www.somkiat.cc/wp-content/uploads/2021/08/communication-fail.jpg\" alt=\"\" srcset=\"https://www.somkiat.cc/wp-content/uploads/2021/08/communication-fail.jpg 586w, https://www.somkiat.cc/wp-content/uploads/2021/08/communication-fail-300x174.jpg 300w\" sizes=\"(max-width: 586px) 100vw, 586px\"></figure><p>ในระบบงานมักจะมีการติดต่อสื่อสารระหว่างระบบหรือ service<br><strong><em>ผ่านระบบ network ที่ขึ้นชื่อว่า พร้อมพัง ได้เสมอ</em></strong><br>ดังนั้นในการออกแบบ พัฒนา และ ทดสอบระบบ<br>ต้องทำให้มั่นใจว่าการติดต่อสื่อสารจะต้องทำงานตามที่เราต้องการเสมอ<br>ทั้งการทำงานให้เสร็จ<br>ทั้งการทำงานอย่างไรเมื่อเกิดปัญหาขึ้นมา<br>เพื่อให้ระบบงานมีความน่าเชื่อถือมากยิ่งขึ้น</p><p><strong>โดยรูปแบบยอดนิยมของการจัดการ ​​มีดังนี้​</strong></p><ul><li>Timeout</li><li>Retry</li><li>Circuit braker</li><li>Bulkhead</li></ul><p><strong>แบบที่ 1 Timeout</strong></p><p>เป็นรูปแบบที่ถูกใช้งานมากที่สุด<br>เพราะว่า service หรือ ระบบปลายทาง อาจจะเกิดปัญหาขึ้นมา<br>ส่งผลให้ตอบกลับได้ช้ากว่าปกติ<br>ดังนั้นเพื่อป้องกันการทำงานที่นาน หรือใช้ resource มากจนเกินไป<br>จึงทำการกำหนด timeout ของการใช้งานไว้<br>เมื่อถึง timeout ก็จะตัดการเชื่อมต่อ หรือ คืน resource ให้ระบบกลับไป</p><div><p>ยกตัวอย่างการใช้งาน Database connection pool<br>หรืออาจจะเป็น network connection</p><p>ดังนั้นทางผู้เรียกใช้งานจะได้ระบบผลกลับมาว่า Connection timeout<br>จากนั้นก็ต้องจัดการว่าจะทำอย่างไรต่อไป</p><p>คำถามที่น่าสนใจคือ<br>ระบบปลายทางยังมีปัญหาแล้ว request อื่น ๆ ยังจะเรียกอีกหรือ ?</p></div><p><strong>แบบที่ 2 Retry</strong></p><div><p>เป็นอีกรูปแบบที่ถูกใช้งาน เพื่อแก้ไขปัญหาที่เกิดจากความผิดพลาด<br>อาจจะไม่เรียกว่าเป็นการแก้ไขปัญหา<br>แต่เป็นวิธีการที่จะทำต่อ หลังจากการทำงานมีปัญหา</p><p>ยกตัวอย่างเช่น เกิด timeout หรือ ระบบล่ม ขึ้นมา<br>ดังนั้นทางฝั่งคนเรียกใช้ ก็ต้องจัดการต่อไป<br><strong>การ retry</strong> คือการทำซ้ำไปเรื่อย ๆ ตามจำนวนครั้ง และ interval ที่กำหนด<br>ทำไปจนกว่าจะทำงานสำเร็จ !!<br>มักจะเจอบ่อยกับงานที่เป็น batch job<br>หรือเป็นพวกระบบ messaging นั่นเอง</p><p>คำถามที่น่าสนใจคือ<br>ระบบปลายทางยังมีปัญหายังจะ retry อีกหรือ ?<br>หรื retry กันตอนไหน ?</p></div><p><strong>แบบที่ 3 Circuit breaker</strong></p><div><p>เป็นอีกวิธีที่ได้รับความนิยมในปัจจุบัน<br>แต่หลาย ๆ คนไม่รู้จัก ไม่เข้าใจส่งผลให้ไม่ได้ใช้งานกัน</p><p><strong>โดยใช้หลักการเหมือนการตัดไฟเมื่อเกิดการช๊อตขึ้นมา</strong><br>ถ้าเทียบกับระบบคือ<br>ผู้เรียกใช้งานจะไม่เรียก service หรือ ระบบปลายทาง<br>เมื่อมีปัญหาตามรูปแบบที่ตกลงร่วมกันไว้ยกตัวอย่างเช่น</p></div><ul><li>มีจำนวน concurrent user มากกว่า 1,000 คนในช่วง 1 นาที</li><li>มีจำนวนความผิดพลาด เช่น timeout มากกว่า 3 ครั้งในช่วง 1 นาที หรือ 10% ของ request ในช่วงเวลาหนึ่ง ๆ เป็นต้น</li></ul><p><strong>โดยทางผู้เรียกใช้งานจะรู้ทันทีว่าปลายทางมีปัญหา</strong><br>ทำให้สามารถจัดการได้ว่า<br>เมื่อมี request เข้ามาหลังจากนี้จะจัดการอย่างไร<br>วิธีการที่ได้รับความนิยมคือ<strong> fail fast</strong><br>นั่นคือ ส่งผลการทำงานที่ fail กลับไปทันที<br>ไม่ต้องส่ง request ไปยังปลายทาง<br>เป็นการลดภาระไปในตัว<br>พร้อมทั้งช่วยให้ service ปลายทาง สามารถ recovery กลับมาได้ง่ายขึ้น<br>หรืออาจจะใช้วิธีการอื่น ๆ นอกเหนือจาก fail fast เช่น</p><ul><li>ส่งค่าล่าสุดที่เก็บไว้จาก database หรือ caching</li><li>ไปเรียก service อื่น ๆ ที่วางแผนไว้แล้ว</li></ul><p><strong>แบบที่ 4 Bulkhead</strong></p><p>เป็นหลักการที่ใช้สำหรับป้องกันปัญหาที่เกิดจากระบบหนึ่งทำงานผิดพลาด<br>แล้วอาจจะส่งผลให้ทั้งระบบพังได้<br>จึงมักจะทำแผนสำรองไว้<br>ยกตัวอย่างเช่น Active-stand by หรือเป็น Muti-data center เป็นต้น<br>เมื่อเกิดปัญหาขึ้นมาที่หนึ่ง แล้วจะทำการเปลี่ยนไปใช้อีกที่โดยอัตโนมัติ<br>อย่าลือซ้อมบ่อย ๆ ละ !!</p><p><strong>ยังมีแนวทางอื่น ๆ ช่วยจัดการปัญหาที่เกิดขึ้นอีก</strong></p><p>ยกตัวอย่างเช่น Feature toggle<br>ทำการเปิดหรือปิด feature ของระบบได้ทันที<br>เพื่อลดความผิดพลาดและปัญหาอื่น ๆ ที่จะตามมา</p><div><p>วิธีการต่าง ๆ ไม่ได้ทำให้ความผิดพลาดหายไป<br>แต่เป็นการลดผลที่เกิดจากความผิดพลาด<br>ไม่ให้มันกระทบไปทั้งระบบ<br>ไม่ให้กระทบกับผู้ใช้งานโดยรวม</p><p><strong><em>ความผิดพลาดเกิดขึ้นได้<br>แต่เราต้องเรียนรู้ที่จะปรับปรุงและจัดการมันเช่นกัน</em></strong></p></div></div><div><p><img alt=\"\" src=\"https://secure.gravatar.com/avatar/e5cb9aad7bf4f0e43462bd51d6ff7021?s=90&amp;d=mm&amp;r=g\" srcset=\"https://secure.gravatar.com/avatar/e5cb9aad7bf4f0e43462bd51d6ff7021?s=180&amp;d=mm&amp;r=g 2x\" height=\"90\" width=\"90\"></p><h4>Article by <a href=\"https://www.facebook.com/somkiatspns\">Somkiat Puisungnoen</a></h4><p>To be Craftmanship</p></div></div></article></div></div>","author":"somkiat","siteTitle":"cc :: somkiat","siteHash":"3a23a5a4389e1e40c6fbb16520a8cc20df5b3591c25145ce72aaa18b19e48201","entryHash":"59ad8b0674e0151a988d7b46f491a12b1d8554bc92834101b3e01870555c723b","category":"Thai"}