{"title":"Configuring Vault as an identity provider","link":"https://www.hashicorp.com/blog/configuring-vault-as-an-identity-provider","date":1726729200000,"content":"<p>When building an application, user authentication (AuthN) is often a fundamental component. Writing your own AuthN implementation can be cumbersome and error prone. You would need to:</p>\n\n<ul>\n<li>Implement and enforce password complexity rules within your application</li>\n<li>Implement password checking yourself</li>\n<li>Enforce failed login attempts policies to protect your application against brute force attacks</li>\n</ul>\n\n<p>The password would also be stored in the database, which means you would need to encrypt it, and that comes with another set of costs:</p>\n\n<ul>\n<li>Key management</li>\n<li>General cryptography costs when checking the password</li>\n<li>Whether or not <a href=\"https://developer.hashicorp.com/vault/docs/secrets/transit#convergent-encryption\">convergent encryption</a> is used</li>\n</ul>\n\n<p>Instead it is much safer for businesses and their customers to delegate this implementation to a specialist platform like HashiCorp Vault because it can act as an identity provider (IdP). </p>\n\n<p>In this blog post, you’ll learn how to set up Vault as an OpenID Connect (OIDC) IdP for all of your applications, allowing your organization to have secrets management and identity servers through one platform, like a standard library for security.</p>\n\n<h2>How OIDC works</h2>\n\n<p>One of the most common workflows used for user AuthN is OIDC. It has slowly become one of the most popular standards for identity, and since 2021 Vault has had the ability to act as an OIDC identity provider. Here’s a quick, high-level look at an OIDC workflow:</p>\n\n<ol>\n<li>The <strong>user</strong> navigates to a web application, mobile application, or platform. This application / platform is known as the <strong>relying party (RP)</strong>. An RP is something that delegates user AuthN to an external <strong>IdP</strong>.</li>\n<li>The <strong>user</strong> enters their credentials, usually a username and password combination.</li>\n<li>The <strong>RP</strong> sends this information as an <strong>AuthN request</strong> to the external <strong>IdP</strong>.</li>\n<li>The <strong>IdP</strong> authenticates the user by checking that the credentials submitted in the AuthN request are correct.</li>\n<li>If the submitted credentials are correct, the <strong>user</strong> is authenticated and the <strong>IdP</strong> responds to the AuthN request with an <strong>access token</strong>.</li>\n<li>The authenticated <strong>user</strong> can now submit requests to the application with their <strong>access token</strong> attached</li>\n</ol>\n<img src=\"https://www.datocms-assets.com/2885/1726600340-oidc-idp-workflow.png\" alt=\"OIDC\" /><p>The access token usually comes in the form of a signed <a href=\"https://datatracker.ietf.org/doc/html/rfc7519\">JSON Web Token</a> (JWT). The JWT is signed by the IdP, which allows the RP to confirm the authenticity of the JWT. This confirmation can be done in a couple of ways:</p>\n\n<ol>\n<li>IdPs often have a token verification endpoint that you can submit the token to, and it will confirm whether or not it is valid.</li>\n<li>IdPs also publish JSON Web Key Sets (JWKS), which are a set of public cryptographic keys that can be used to verify the authenticity of the JWT signature.</li>\n</ol>\n\n<h2>Vault as an OIDC provider</h2>\n\n<p>Vault having the ability to act as an OIDC provider means that if the identity exists within Vault, RPs can delegate AuthN to Vault as set out in the OIDC workflow outlined above. Here is a diagram of that same workflow with Vault as the IdP:</p>\n<img src=\"https://www.datocms-assets.com/2885/1726600396-vault-as-oidc-idp-workflow.png\" alt=\"Vault\" /><p>Vault’s role in this process is simple: authenticate users, issue signed JWTs, and verify JWT signatures. </p>\n\n<h3>How to configure Vault as an OIDC provider</h3>\n\n<p>To configure Vault to act as an OIDC provider, you first need to enable the <a href=\"https://developer.hashicorp.com/vault/docs/auth\">auth method</a> that your users will authenticate with. The <a href=\"https://developer.hashicorp.com/vault/docs/auth/userpass\">userpass</a> auth method is a good example for a simple user database. The <a href=\"https://www.hashicorp.com/products/terraform\">Terraform</a> code below will enable this auth method:</p>\n<pre><code>resource \"vault_auth_backend\" \"userpass\" {\n type = \"userpass\"\n}</code></pre><p>In this code, no mount point has been specified so it will create it at the /userpass mount point by default. This is where your application will create new users.</p>\n\n<p>Next you need to create a key that will be used to sign JWTs:</p>\n<pre><code>resource \"vault_identity_oidc_key\" \"oidc_key\" {\n name               = \"my-key\"\n rotation_period    = 3600\n algorithm          = \"RS256\"\n allowed_client_ids = [\"*\"]\n verification_ttl   = 7200\n}</code></pre><p>This code will configure Vault to create a signing key using the RS256 algorithm. You’ll want to automatically rotate this key every hour to keep it secure, and allow all client IDs to use this key to sign JWTs. This could be narrowed down to the client ID of the OIDC role created for your application.</p>\n\n<p>The next step is to create an OIDC provider. This requires minimal configuration:</p>\n<pre><code>resource \"vault_identity_oidc\" \"oidc\" {}</code></pre><p>Next, you will need to create an OIDC role that will be used when creating JWTs:</p>\n<pre><code>resource \"vault_identity_oidc_role\" \"role\" {\n key  = vault_identity_oidc_key.oidc_key.name\n name = \"my-role\"\ntemplate = &lt;</code></pre><p>This role will ensure the required claims are included in any JWTs it issues. In this case, the role will include an email claim, which will populate from the user’s metadata, and a username which will be populated from the name of the entity in Vault.</p>\n\n<p>The final configuration step is to create a policy in Vault that will allow authenticated users to request a signed JWT.</p>\n<pre><code>resource \"vault_policy\" \"jwt\" {\n name   = \"jwt\"\n policy = &lt;</code></pre><p>The API call to Vault uses the GET method so the policy only needs the <code>read</code> capability.</p>\n\n<h3>Building an application as a relying party</h3>\n\n<p>Building an application can be split into two sections: user registration and AuthN.</p>\n\n<h4>User registration</h4>\n\n<p>Onboarding new users to Vault requires the following steps:</p>\n\n<ol>\n<li>Creating a user in the userpass auth method</li>\n<li>Creating an entity for the user in the Identity secrets engine (this secrets engine is enabled by default)</li>\n<li>Creating an alias that ties the entity and the user together</li>\n<li>Create an OIDC assignment for the user so its identity can be issued by the OIDC provider.</li>\n</ol>\n\n<p>There are several ways in which these steps can be implemented. The approach taken will depend on the language and framework being used and application specific requirements. For the purposes of this blog, Go has been chosen as the language and a granular approach has been taken to demonstrate the steps.</p>\n\n<p>This example uses the official <a href=\"https://github.com/hashicorp/vault-client-go\">Go SDK</a> for Vault and creates a dedicated function for each step.</p>\n\n<p>The first step is to create the user in the userpass auth method:</p>\n<pre><code>func createUser(vc *vault.Client, userName string, password string) error {\n\n   ctx := context.Background()\n\n   userCreateRequest := schema.UserpassWriteUserRequest{\n      Password: password,\n   }\n\n   _, err := vc.Auth.UserpassWriteUser(ctx, userName, userCreateRequest)\n   if err != nil {\n      log.Error(err)\n      return err\n   }\n\n   return nil\n}</code></pre><p>This function takes the following as inputs:</p>\n\n<ol>\n<li>A Vault client. This configures the address for Vault and token used to authenticate to Vault.</li>\n<li>The username for the user. A limitation of the userpass auth method is that only alphanumeric characters, hyphens, and underscores can be used for the username. The username also must start and end with an alphanumeric character and not a hyphen or underscore character.</li>\n<li>The password for the user</li>\n</ol>\n\n<p>A successful call to Vault will result in a 204 no content response, whilet an unsuccessful call will result in an error response. As a result, this function only returns an error type. Successful calls return nil. </p>\n\n<p>The second step is to create an entity for the user.</p>\n<pre><code>func createEntity(vc *vault.Client, userName string, email string) (interface{}, error) {\n   ctx := context.Background()\n\n   metadata := map[string]interface{}{\n      \"email\": email,\n   }\n\n   entityCreateRequest := schema.EntityCreateRequest{\n      Disabled: false,\n      Metadata: metadata,\n      Name:     userName,\n      Policies: []string{\"jwt\"}, // TODO - update this. currently hardcoded to the jwt policy\n   }\n\n   entityResult, err := vc.Identity.EntityCreate(ctx, entityCreateRequest)\n   if err != nil {\n      log.Error(err)\n      return nil, err\n   }\n\n   return entityResult.Data, nil\n\n}</code></pre><p>This function takes the following inputs:</p>\n\n<ol>\n<li>A Vault client</li>\n<li>Username. This has to match the user created in the previous function</li>\n<li>Email address of the user. This is an optional implementation. The email address is written as metadata for the user and can be included as a claim in the JWT to help with data workflows. For example, this can be used to ensure the user only reads their data from a database.</li>\n</ol>\n\n<p>The function returns an interface and an error. The interface contains the response data from Vault, which includes the entity ID. This will be needed later. The policies are currently hardcoded; however, this can be improved to pass in the policy list as a configuration parameter.</p>\n\n<p>The third step is to create the alias that ties the user and the entity together:</p>\n<pre><code>func createAlias(vc *vault.Client, canonicalId string, userName string, mountAccessor string) (interface{}, error) {\n\n   ctx := context.Background()\n\n   aliasRequest := schema.AliasCreateRequest{\n      CanonicalId:   canonicalId,\n      MountAccessor: mountAccessor,\n      Name:          userName,\n   }\n\n   aliasResponse, err := vc.Identity.AliasCreate(ctx, aliasRequest)\n   if err != nil {\n      log.Error(err)\n      return nil, err\n   }\n\n   return aliasResponse.Data, nil\n}</code></pre><p>This function takes the following inputs:</p>\n\n<ol>\n<li>A Vault client</li>\n<li>The canonical ID of the entity. This was returned in the interface from the last function</li>\n<li>The username of the user created in the userpass auth method</li>\n<li>The mount accessor ID. This is the ID of the userpass auth method created in the Vault configuration steps</li>\n</ol>\n\n<p>The function also returns an interface and error. The interface contains the alias ID returned from Vault.</p>\n\n<p>The final step is to create an OIDC assignment:</p>\n<pre><code>func createAssignment(vc *vault.Client, entityId string, name string) error {\n   ctx := context.Background()\n   entityIdList := []string{entityId}\n\n   assignmentRequest := schema.OidcWriteAssignmentRequest{\n      EntityIds: entityIdList,\n      GroupIds:  nil,\n   }\n\n   _, err := vc.Identity.OidcWriteAssignment(ctx, name, assignmentRequest)\n   if err != nil {\n      log.Error(err)\n      return err\n   }\n\n   return nil\n}</code></pre><p>This function takes the following inputs:</p>\n\n<ol>\n<li>A Vault client</li>\n<li>The entity ID returned from the interface in the create-entity step</li>\n<li>A name for the assignment. For simplicity’s sake, it makes sense to name this the same as the username</li>\n</ol>\n\n<p>The function returns only an error.</p>\n\n<p>To put this all together, you can create the following function that unites these functions in the required workflow:</p>\n<pre><code>func UserCreate(userName string, password string, emailAddr string) map[string]string {\n   vc := NewClient(os.Getenv(\"VAULT_ADDR\"), os.Getenv(\"VAULT_TOKEN\"))\n   mountAccessor := os.Getenv(\"MOUNT_ACCESSOR_ID\")\n\n   createUser(&amp;vc, userName, password) \n\n   entityResult, err := createEntity(&amp;vc, userName, emailAddr)\n\n   // Assert that the returned value is a map[string]interface{}\n   resultMap, ok := entityResult.(map[string]interface{})\n   if !ok {\n      log.Error(\"Unexpected type for entity result\")\n   }\n\n   // Access the \"id\" field and assert that it is a string\n   EntityIdValue, ok := resultMap[\"id\"].(string)\n   if !ok {\n      log.Error(\"ID is not a string or not found in entity result\")\n\n   }\n\n   log.Infof(\"Entity ID: %s\", EntityIdValue)\n\n   aliasResult, err := createAlias(&amp;vc, EntityIdValue, userName, mountAccessor)\n   if err != nil {\n      log.Error(err)\n   }\n\n   aliasResultMap, ok := aliasResult.(map[string]interface{})\n   if !ok {\n      log.Error(\"Unexpected type for alias result\")\n   }\n   aliasId, ok := aliasResultMap[\"id\"].(string)\n\n   err = createAssignment(&amp;vc, EntityIdValue, userName)\n   if err != nil {\n      log.Error(err)\n   }\n\n   finalResult := make(map[string]string)\n   finalResult[\"Username\"] = userName\n   finalResult[\"Entity ID\"] = EntityIdValue\n   finalResult[\"Alias ID\"] = aliasId\n\n   return finalResult\n\n}</code></pre><p>Things to note about this function:</p>\n\n<ul>\n<li>To configure the Vault client, this function reads the following environment variables <code>VAULT_ADDR</code> and <code>VAULT_TOKEN</code>.</li>\n<li>The mount accessor ID for the userpass auth method is passed in using the <code>MOUNT_ACCESSOR_ID</code> environment variable</li>\n<li>It takes the following inputs\n\n<ul>\n<li>Username</li>\n<li>Password</li>\n<li>Email address</li>\n</ul></li>\n<li>It executes the other functions in chronological order</li>\n<li>It returns a collection of key/value pairs called a <code>map[string] string</code> and contains the following information:\n\n<ul>\n<li>Username</li>\n<li>Entity ID</li>\n<li>Alias ID</li>\n</ul></li>\n<li>The information contained in the map can then be written to your database</li>\n</ul>\n\n<p>This function can then be added to an endpoint in your API and exposed to your frontend for user signup.</p>\n\n<h3>User AuthN</h3>\n\n<p>Authenticating users to Vault is a 2-step process:</p>\n\n<ol>\n<li>Submit username and password to Vault for AuthN</li>\n<li>Generate a JWT for the authenticated user</li>\n</ol>\n\n<p>Again these steps will be broken down into dedicated functions and another function will tie them together to implement the workflow.</p>\n\n<p>The first step is to make a call to Vault to authenticate the user:</p>\n<pre><code>func userpassAuth(userName string, password string) (string, error) {\n   ctx := context.Background()\n\n   vc := NewClient(os.Getenv(\"VAULT_ADDR\"), \"\")\n   loginRequest := schema.UserpassLoginRequest{Password: password}\n\n   vaultToken, err := vc.Auth.UserpassLogin(ctx, userName, loginRequest)\n   if err != nil {\n      return \"\", err\n   }\n\n   return vaultToken.Auth.ClientToken, nil\n}</code></pre><p>This function is slightly different to the other in terms of how it configures the Vault client. Because it is an AuthN call, the only configuration parameter required is the Vault address, so the client is configured within this micro-function. It takes these inputs:</p>\n\n<ol>\n<li>Username</li>\n<li>Password</li>\n</ol>\n\n<p>It returns a string, which will contain the Vault token if the AuthN is successful, and an error for unsuccessful AuthN.</p>\n\n<p>Next step is to generate a signed JWT for the authenticated user:</p>\n<pre><code>func generateToken(vc *vault.Client, roleName string) (interface{}, error) {\n   ctx := context.Background()\n\n   tokenResult, err := vc.Identity.OidcGenerateToken(ctx, roleName)\n   if err != nil {\n      log.Error(err)\n      return nil, err\n   }\n\n   return tokenResult.Data, nil\n}</code></pre><p>This takes the following inputs:</p>\n\n<ol>\n<li>A Vault client. This can not be the same Vault client that the rest of the application uses because the token in this client will be the identity that the JWT is issued for.</li>\n<li>The OIDC role name. This was created during the Vault configuration process.</li>\n</ol>\n\n<p>The function returns an interface which contains the JWT and an error.</p>\n\n<p>The workflow can now be put together with this function:</p>\n<pre><code>func UserAuthenticate(userName string, password string) (string, error) {\n\n   var jsonWebToken string\n   vaultToken, err := userpassAuth(userName, password)\n   if err != nil {\n      log.Error(err)\n      return \"\", err\n   } else {\n\n      authenticatedVc := NewClient(os.Getenv(\"VAULT_ADDR\"), vaultToken)\n      jwt, err := generateToken(&amp;authenticatedVc, \"my-role\")\n      if err != nil {\n         log.Error(err)\n         return \"\", err\n      }\n\n      jwtMap, ok := jwt.(map[string]interface{})\n      if !ok {\n         log.Error(\"JWT unexpected type\")\n      }\n\n      jsonWebToken, ok = jwtMap[\"token\"].(string)\n\n   }\n   return jsonWebToken, nil\n}</code></pre><p>This function creates a Vault client using the Vault token resulting from the AuthN step. This is to ensure that the JWT is created for the correct user. The OIDC role name is currently hard coded but this can easily be refactored to use environment variables. It takes the following as inputs:</p>\n\n<ol>\n<li>Username</li>\n<li>Password</li>\n</ol>\n\n<p>It returns:</p>\n\n<ol>\n<li>A string containing the JWT</li>\n<li>An error if something goes wrong during the AuthN process.</li>\n</ol>\n\n<h3>Validating a JWT</h3>\n\n<p>Once the user has been authenticated, the resulting JWT can be attached to subsequent application calls. Validating the JWT is essential for a number of reasons:</p>\n\n<ol>\n<li><strong>To check the integrity of a token</strong>. This will ensure that the JWT is in fact a real token issued by Vault. This is another form of AuthN.</li>\n<li><strong>To validate the integrity of the contents within the token</strong>. This will ensure claims within the JWT are not manipulated by malicious threat actors, leading to unauthorized access to application data.</li>\n<li><strong>To check the claims within the token</strong>. This will ensure that the token is not expired and prevents replay attacks whereby a previously valid token is used for unauthorized data access.</li>\n</ol>\n\n<p>In order to validate the token, you will need to create a function that can be used in a middleware function to ensure every application call made by a user is done using a valid JWT.</p>\n\n<p>This function will validate the provided token:</p>\n<pre><code>func ValidateToken(token string) (bool, error) {\n   vc := NewClient(os.Getenv(\"VAULT_ADDR\"), os.Getenv(\"VAULT_TOKEN\"))\n\n   ctx := context.Background()\n \n   clientId := os.Getenv(\"OIDC_CLIENT_ID\")\n\n   validateRequest := schema.OidcIntrospectRequest{\n      ClientId: clientId,\n      Token:    token,\n   }\n   validate, err := vc.Identity.OidcIntrospect(ctx, validateRequest)\n   if err != nil {\n      log.Error(err)\n   }\n\n   validateMap, ok := validate.Data[\"active\"].(bool)\n   if !ok {\n      log.Error(\"JWT not valid\")\n   }\n\n   var response bool\n   switch validateMap {\n   case true:\n      response = true\n   case false:\n      response = false\n   default:\n      response = false\n   }\n\n   return response, nil\n\n}</code></pre><p>This function takes the token as an input and returns a true or false value based on whether or not the token is valid. The OIDC client ID is required for this to work. The function has been written to read the <code>OIDC_CLIENT_ID</code> environment variable for this purpose. This can then be used in a middleware function within your application.</p>\n\n<h2>Recommendations and resources</h2>\n\n<p>As you go through configuring Vault as an IdP, it’s best practice to write output values in your Terraform code for the mount accessor ID of the userpass auth method and the client ID of the OIDC role, as these values are required when building your application. This <a href=\"https://registry.terraform.io/modules/devops-rob/oidc-provider/vault/latest\">Terraform module</a> can be used to configure Vault to act as an OIDC provider.</p>\n\n<p>When setting up the RP application to implement the OIDC workflow and building a user signup workflow, a few things to note are:</p>\n\n<ul>\n<li>The application can be made more efficient by using Goroutines or any multithreading approach and building them into your chosen framework. This will allow multiple requests to be handled in parallel. The unified workflows would each be scheduled on their own thread to make the application more scalable and able to handle higher traffic loads.</li>\n<li>It is better to use environment variables for static configuration values such as OIDC client ID and mount accessor ID.</li>\n<li>This approach makes several calls to Vault so the Vault cluster should be close to where the application is being run to reduce latency.</li>\n<li>Because so many calls are being made to Valut, there will naturally be an increased latency, which you will need to plan for.</li>\n</ul>\n\n<p>If you would like to try this for your application, sign up for a <a href=\"https://portal.cloud.hashicorp.com/sign-up\">HashiCorp Cloud Platform</a> account and <a href=\"https://developer.hashicorp.com/vault/tutorials/manage-hcp-vault-dedicated/terraform-hcp-provider-vault\">deploy a managed dedicated Vault Cluster</a> in minutes.</p>\n\n<p>You can also set up Vault as an IdP and integrate it with <a href=\"https://www.boundaryproject.io/\">HashiCorp Boundary</a> for secure remote access by following <a href=\"https://developer.hashicorp.com/vault/tutorials/auth-methods/oidc-identity-provider\">this tutorial</a>.</p>\n","author":"Rob Barnes","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"e7b04af41b3f3072b6f691f6da077a745b4cb9075e63134e5ff047009c76ff9e","category":"Tech"}