{"title":"How to close attack vectors for exposed secrets in Docker","link":"https://www.hashicorp.com/blog/how-to-close-attack-vectors-for-exposed-secrets-in-docker","date":1712592000000,"content":"<p>With the advent of containerization, software developers could build, deploy, and scale applications in a transformative way. Docker quickly became the leading containerization platform and remains one of the most common container images used today. Docker Hub is one of the prominent locations for developers and enterprises to publish and distribute docker images. </p>\n\n<p>With popularity comes greater attention from cybercriminals. <a href=\"https://cybernews.com/security/docker-hub-images-contain-thousands-of-secrets/\">Cybernews</a> recently reported 5,500 out of 10,000 public docker images contained 48,000+ sensitive secrets - a combination of harmless and potentially vulnerable API keys. This report illustrates why it's imperative that security and platform teams know the most common attack vectors for their Docker containers and understand how to close them. </p>\n\n<p>This post will provide a brief checklist of the various attack vectors into your Docker containers specifically originating from exposed secrets.</p>\n\n<h2>Docker and exposed secrets</h2>\n\n<p>Let’s quickly examine the relationship between container runtime and registry. When we spin-up a container, an image is pulled from the registry via APIs and is deployed. This is visualized below:</p>\n<img src=\"https://www.datocms-assets.com/2885/1711666978-docker-registry-flow.png\" alt=\"Docker\" /><p><em>[Image source](<a href=\"https://community.sap.com/legacyfs/online/storage/blog\">https://community.sap.com/legacyfs/online/storage/blog</a></em>attachments/2022/09/1-83.png)_</p>\n\n<p>The high number of secrets from the Cybernews report is attributed to developers re-using packages from a registry containing sensitive secrets. Secrets are commonly found in the container image metadata - the environment variables and filesystem. Also, source code leakage could allow attackers to generate newer valid tokens that could provide unauthorized system access. </p>\n\n<h2>Attack surface</h2>\n\n<p>An attack surface is a collection of all vulnerable points an attacker can use to enter the target system. Attackers skillfully exploit these vulnerable points in technology and human behavior to access sensitive assets. </p>\n\n<p>We need to understand two Docker concepts as we continue this discussion:</p>\n\n<ul>\n<li><p><strong>Filesystem</strong>: In Docker, each layer can contain directory changes. The most commonly used filesystem, OverlayFS, enables Docker to overlay these layers to create a unified filesystem for a container.</p></li>\n<li><p><strong>Layers</strong>: Docker images are created in layers - i.e., each command on the DockerFile corresponds to a layer. </p></li>\n</ul>\n\n<p>With that context, let’s understand and analyze how exposed secrets can affect these Docker image attack vectors.</p>\n\n<h3>Docker image layers</h3>\n\n<p>Secrets explicitly declared in the Dockerfile or build arguments can easily be accessed via the Docker image history command.</p>\n<pre><code>#terminal\n\ndocker image history \n</code></pre><p>This represents one of the simplest methods for an attacker to capitalize on a secret.</p>\n\n<h3>Filesystem</h3>\n\n<p>This Dockerfile demonstrates a scenario where sensitive data like SSH private key and <code>secrets.txt</code> are added to the container's filesystem and later removed.</p>\n<pre><code>#Dockerfile\nFROM nginx:latest\n\n# Copy in SSH private key, then delete it; this is INSECURE,\n# the secret will still be in the image.\nCOPY id_rsa .\nRUN rm -r id_rsa\n\nARG DB_USERNAME\nENV DB_USERNAME =$DB_USERNAME\nARG DB_PASSWORD\nENV DB_PASSWORD =$DB_PASSWORD\nARG API_KEY\nENV API_KEY =$API_KEY\n\n# Expose secrets via a publicly accessible endpoint (insecure practice)\nRUN echo \"DB_USERNAME=$DB_USERNAME\" &gt; /usr/share/nginx/html/secrets.txt\nRUN echo \"DB_PASSWORD=$DB_PASSWORD\" &gt;&gt; /usr/share/nginx/html/secrets.txt\nRUN echo \"API_KEY=$API_KEY\" &gt;&gt; /usr/share/nginx/html/secrets.txt\nRUN rm /usr/share/nginx/html/secrets.txt\n\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n</code></pre><p>Docker uses layer caching - hence, the secret is still available in one of the layers. An internal attacker can also extract individual layers of a Docker image, stored as tar files in registries, which enables them to uncover hidden secrets.  </p>\n\n<p>After creating a Dockerfile, developers mistakenly use build arguments to create an image.  For the above dockerfile, the secrets are input as arguments.</p>\n<pre><code>#terminal\n\ndocker build \\\n--build-arg DB_USERNAME=root \\\n--build-arg DB_PASSWORD=Xnkfnbgf \\\n--build-arg  API_KEY=PvL4FjrrSXyT7qr \\\n-t myapp:1.0 .</code></pre><p>While convenient, it is not secure since the arguments also get embedded in the image. A simple <code>docker history --no-trunc &amp;lt;image&gt;</code> can expose the secret values. Developers should either use multi-stage builds or secret managers.</p>\n\n<h3>Environment variables</h3>\n\n<p>Apart from Docker image access, unauthorized access to the source code of the docker image can provide additional attack vectors. The .env files are primarily used to store secrets such as API tokens, database credentials, and other forms of secrets that an application needs. When attackers have access to secrets in the .env, they can make unauthorized accesses that the secret allows. </p>\n\n<h3>Dockerfile</h3>\n\n<p>DockerFile is a standard file that contains execution instructions to build an image while spinning up containers. Hard-coding secrets into DockerFile creates a significant attack surface. When attackers access the DockerFile, they can see hard-coded secrets, the base image, the list of dependencies, and critical file locations. Developers need to use appropriate secret managers to reference variables.</p>\n\n<h3>Docker-compose.yml </h3>\n\n<p>Docker-compose defines networks, services, and storage volumes. When an attacker views the file, they can understand the application architecture and exploit or disrupt its operation. </p>\n<pre><code>services:\n  web:\n    image: my-web-app:latest\n    ports:\n      - \"80:80\"\n    networks:\n      - app-network\n  db:\n    image: postgres:latest\n    volumes:\n      - db-data:/var/lib/postgresql/data\n    environment:\n      POSTGRES_PASSWORD: example_db_password\nnetworks:\n  app-network:\nvolumes:\n  db-data:</code></pre><p>In the above <code>docker-compose.yml</code>, the postgres database password is hardcoded. The password can easily be accessed with the docker exec command as shown below:</p>\n<pre><code>#terminal\ndocker exec -it  /bin/bash\nenv</code></pre><p>Apart from secrets, an attacker can also analyze the volume mappings and identify potential points of weakness. If they discover that the database volume (db-data) is also mounted to the host filesystem, they could exploit and perform a container breakout attack, gaining access to the underlying host system. </p>\n\n<h3>CI/CD config files</h3>\n\n<p>CI/CD configuration files such as <code>.gitlab-ci.yml</code>, <code>Azure-pipelines.yml </code>, <code>Jenkinsfile</code>,  etc., contain instructions for building, testing, and deploying applications. The logs generated in CI/CD pipeline can contain debugging and logging information. If a developer includes a logging statement that inadvertently prints a sensitive secret, it can lead to unauthorized exposure and compromise. Such secret leaks need to be detected so that developers can fix their source code.</p>\n\n<p>Developers also tend to leave the registry login credentials in the CI CD configuration files. Consider the following <code>gitlab-ci.yml</code>.</p>\n<pre><code>variables:\n  DOCKER_IMAGE_TAG: latest\n  DOCKER_REGISTRY_URL: registry.example.com\n  DOCKER_IMAGE_NAME: my-docker-image\n  DOCKER_REGISTRY_USER: adminuser &lt;-- should use $CI_REGISTRY_USER  \n  DOCKER_REGISTRY_PASSWORD: secretpassword &lt;-- should use $CI_REGISTRY_PASSWORD \n\n# Jobs\nbuild:\n  stage: build\n  image: image_name:stable\n  script:\n    - docker build -t $DOCKER_REGISTRY_URL/$DOCKER_IMAGE_NAME:$DOCKER_IMAGE_TAG .\n    - docker login -u $DOCKER_REGISTRY_USER -p $DOCKER_REGISTRY_PASSWORD $DOCKER_REGISTRY_URL\n    - docker push $DOCKER_REGISTRY_URL/$DOCKER_IMAGE_NAME:$DOCKER_IMAGE_TAG</code></pre><p>In the configuration above, the developer makes a docker registry login using a hardcoded username and password, leading to unwarranted secret exposure. A good development practice is to integrate CI/CD environment with secret managers like Hashicorp Vault.  </p>\n\n<h2>Detecting secrets</h2>\n\n<p>Older or unused Docker images can contain unpatched vulnerabilities or outdated dependencies, posing security risks to the enterprise. Regularly scanning and removing unused images helps mitigate these risks by reducing the attack surface and ensuring that only secure images are deployed. </p>\n\n<p>Enterprises also need to be actively using secret scanners to detect secrets in docker images, whether they’re stored in Docker Hub, JFrog Artifactory, AWS ECR, or any other repository. HCP Vault Radar can meet these requirements and is an excellent choice since it's an add-on to the <a href=\"https://radar.cncf.io/2021-02-secrets-management\">most popular secrets manager</a>: HashiCorp Vault. Vault Radar analyzes the contents of each layer described in this post to identify secrets in the software packages and dependencies. </p>\n\n<h2>Learn more</h2>\n\n<p>Vault Radar can scan your container images and other destinations such as source code, productivity applications like Jira, Confluence, Slack, Terraform variables, server directories, and more. When it detects leaked secrets, it has options to remediate them and enhance your security posture.</p>\n\n<p>You can <a href=\"https://www.hashicorp.com/go/blubracket-integration-updates\">sign up now for an HCP Vault Radar test run</a> to detect secret sprawl in your enterprise, or learn more about <a href=\"https://www.hashicorp.com/products/vault\">HashiCorp Vault</a> and <a href=\"https://developer.hashicorp.com/hcp/docs/vault-radar\">Vault Radar</a> on our homepage.</p>\n\n<p><em>This post was originally published on <a href=\"https://dev.to/siranjeevi/how-to-close-attack-vectors-for-exposed-secrets-in-docker-26c\">Dev.to</a>.</em></p>\n","author":"Siranjeevi Dheenadhayalan","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"d1a05b6fc8b4c61d8981766e407756a2406c011dcf26f067b126fa21bbdced97","category":"Tech"}