{"title":"Reducing The Need For Pseudo-Elements","link":"https://smashingmagazine.com/2021/09/reducing-need-pseudo-elements/","date":1631700000000,"content":"<p>Per the <a href=\"https://www.w3.org/TR/selectors-4/#pseudo-element\">W3C spec</a>, “a pseudo-element represents an element not directly present in the document tree\". They have been around since version 1 of the CSS specification, when <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/::first-letter\"><code>::first-letter</code></a> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/::first-line\"><code>::first-line</code></a> were introduced. The popular <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/::before\"><code>::before</code></a> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/::after\"><code>::after</code></a> pseudo-elements were added in version 2 — these represent content that does not exist in the source document at all. They can be thought of as two extra elements you can “tack onto” their originating element. When front-end developers hear “pseudo-elements”, we think of <code>::before</code> and <code>::after</code> more often than not, as we use them in various ways to add decorations to our elements.</p>\n<p>There are additional pseudo-elements beyond these. They are listed in the spec across three categories: <a href=\"https://www.w3.org/TR/css-pseudo-4/#typographic-pseudos\">typographic</a>, <a href=\"https://www.w3.org/TR/css-pseudo-4/#highlight-pseudos\">highlight</a>, and <a href=\"https://www.w3.org/TR/css-pseudo-4/#treelike\">tree-abiding</a>.</p>\n<p>Interestingly, after years of web development, I never found myself using <code>::first-line</code>, but it’s pretty neat and responds well to window resizing! Check it out.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/9180b600-6062-410f-ac44-44f11e67d0f4/angle-arrow-anatomy-01.png\" /></p>\n<h4>Pseudo-Element Version</h4>\n<p>Many of you reading this will be accustomed to a pseudo-element version:</p>\n<ul>\n<li>We use a relatively positioned wrapper element with large right padding to accommodate our angle — this is our <code>&lt;button&gt;</code>;</li>\n<li>Many of us, students of the <a href=\"https://alistapart.com/article/slidingdoors/\">sliding doors technique</a>, are accustomed to nesting an element to take on the button’s background-color;</li>\n<li>Finally, we absolutely position a pseudo-element with its border rules into our <code>&lt;button&gt;</code>’s right padding empty space — we use <code>::before</code> for this.</li>\n</ul>\n<p>Aside from those steps, our hover styles must account for both our nested element and pseudo-element. This might seem manageable for you, but the more complicated our button designs get, the more overhead we have with hover styles. Also, with this version, buttons with word wrapping just plain fail. </p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ef8ea684-c65f-4988-99a7-911b1a0e11a4/1-reducing-need-pseudo-elements.png\" /></p>\n<p>Visit the <a href=\"https://codepen.io/smashingmag/pen/YzQNEeB\">final showcase</a> to see these other button styles made easier without pseudo-elements. In particular, the blue bevel button’s pseudo-element version is pretty brutal. The amount of overall work is greatly reduced thanks to <code>clip-path</code>.</p>\n<h3>Button Wipes</h3>\n<p>A wiping effect is a popular button style. I’ve included left-to-right and top-to-bottom wipes. </p>\n<h4>Pseudo-Element Version</h4>\n<p>This can be achieved by <code>transitioning</code> a pseudo-element’s <code>transform</code>. </p>\n<ul>\n<li>We absolutely position a <code>::before</code> pseudo-element and give it a <code>transform: scaleX(0)</code> so it’s not visible.</li>\n<li>We also must explicitly set its <code>transform-origin: 0 0</code> to ensure the wipe comes in from the left rather than center (<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin#formal_definition\"><code>transform-origin</code> defaults to center</a>).</li>\n<li>We set up <code>transitions</code> on the <code>transform</code> for some smooth jazz animation on/off hover.</li>\n<li>Because our pseudo-element is absolutely positioned, we require a nested element to hold the button’s text, <code>position: relative</code> on this nested element creates a new stacking context so our text stays on top of our wiping pseudo-element.</li>\n<li>On hover, we can target our pseudo-element and <code>transition</code> its <code>scaleX</code> to now be <code>1 (transform: scaleX(1))</code>.</li>\n</ul>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/KKqayGW\">Button wipe with pseudo-element</a> by <a href=\"https://codepen.io/marcelmoreau\">Marcel</a>.</p>\n<h4>No Pseudo-Element Version</h4>\n<p>Why worry about nested elements, pseudo-element positioning, stacking contexts, and sprawling hover rules if we don’t have to? </p>\n<p>We can reach for <code>linear-gradient()</code> and <code>background-size</code> to nail this down.</p>\n<ul>\n<li>We give our <code>&lt;button&gt;</code> a <code>background-color</code> for its default state, while also setting up a <code>linear-gradient</code> via <code>background-image</code> — but the <code>background-size</code> will be <code>0</code>, so we won’t see anything by default.</li>\n<li>On hover, we transition the <code>background-size</code> to <code>100% 100%</code> which gives us our wipe effect!</li>\n</ul>\n<p>Remember, <code>linear-gradient()</code> uses the <code>background-image</code> property and <code>background-image</code> supersedes <code>background-color</code>, so this is what takes precedence on hover.</p>\n<p>That’s it. <em>No nested element required.</em> Want a vertical wipe? Just change the <code>linear-gradient</code> direction and the <code>background-size</code> values. I’ve changed those via CSS custom properties.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/MWoJOVo\">Button wipe with NO pseudo-element</a> by <a href=\"https://codepen.io/marcelmoreau\">Marcel</a>.</p>\n<h3>Tiles With Screen Color Overlays</h3>\n<p>This is a common pattern where a semi-transparent color overlays a tile/card. Our example’s tile also has a background-image. It’s often important in this pattern to retain a set aspect-ratio so that tiles look uniform if more than one appears in a set.</p>\n<h4>Pseudo Version</h4>\n<p>Some of the same things come into play with our pseudo-element version:</p>\n<ul>\n<li>We use the <a href=\"https://alistapart.com/article/creating-intrinsic-ratios-for-video/\">aspect-ratio “padding-trick”</a>, setting a 60% padding-top value (5:3 ratio) for our tile.</li>\n<li>We must position our screen color overlay pseudo-element, giving it a 100% <code>width</code> and <code>height</code> to fill the tile — we target this pseudo-element on hover to change its <code>background-color</code>.</li>\n<li>Due to the pseudo-element’s absolute positioning, we must use a nested element for our text content, also giving it <code>position: absolute</code> in order for it to appear <em>above</em> our screen color overlay in the stacking order and to ensure it appears where it should within the tile.</li>\n</ul>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/YzQNEOM\">Tile screen color overlay with pseudo-element</a> by <a href=\"https://codepen.io/marcelmoreau\">Marcel</a>.</p>\n<h4>No Pseudo-Element Version</h4>\n<p>It can be much simpler thanks to the <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/aspect-ratio\">aspect-ratio</a> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/background-blend-mode\">background-blend-mode</a> properties.</p>\n<p><strong>Note</strong>: <code>aspect-ratio</code> does not work in Safari 14.x, but will in version 15. </p>\n<p>That said, as of this writing, <a href=\"https://caniuse.com/?search=aspect-ratio\">caniuse lists it</a> with 70%+ global support.</p>\n<ul>\n<li>The “padding-trick” is replaced by <code>aspect-ratio: 400/240</code> (we could use any 5:3-based value here).</li>\n<li>We use both <code>background-image</code> and <code>background-color</code> properties in conjunction with <code>background-blend-mode</code> — simply change the <code>background-color</code> of our tile element on hover.</li>\n</ul>\n<h5><code>Background-blend-mode</code></h5>\n<p><code>background-blend-mode</code> blends a <code>background-color</code> with an element’s <code>background-image</code>. Any Photoshop users reading this will find <code>background-blend-mode</code> reminiscent of Photoshop’s blending modes. Unlike <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode\"><code>mix-blend-mode</code></a>, <code>background-blend-mode</code> does not create a new stacking context! So no <code>z-index</code> hell!</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/mdwRqjN\">Tile screen color overlay with NO pseudo-element</a> by <a href=\"https://codepen.io/marcelmoreau\">Marcel</a>.</p>\n<ul>\n<li>You can find the <a href=\"https://codepen.io/smashingmag/pen/YzQNEeB\">full showcase demo here →</a></li>\n</ul>\nConclusion\n<p>Front-end development is exciting and fast-moving. With newer CSS properties, we can brush the dust off our old techniques and give them another look. Doing this helps foster reduced and simpler code. Pseudo-elements are helpful, but we don’t need to reach for them as much. </p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"332ef1a7ae7b1aa6130f4798f1bae5ba16473ad76b3de06f0b61786655d3076e","category":"Tech"}