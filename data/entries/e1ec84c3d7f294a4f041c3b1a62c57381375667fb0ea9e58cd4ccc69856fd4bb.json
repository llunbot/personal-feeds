{"title":"What Does AI Really Mean?","link":"https://smashingmagazine.com/2025/01/understanding-ai-meaning/","date":1736150400000,"content":"<p>In 2024, Artificial Intelligence (AI) hit the limelight with major advancements. The problem with reaching common knowledge and so much public attention so quickly is that the term becomes ambiguous. While we all have an approximation of what it means to “use AI” in something, it’s not widely understood what infrastructure having AI in your project, product, or feature entails.</p>\n<p>So, let’s break down the concepts that make AI <em>tick</em>. How is data stored and correlated, and how are the relationships built in order for an algorithm <strong>to learn</strong> how to <strong>interpret</strong> that data? As with most data-oriented architectures, it all starts with a database.</p>\nData As Coordinates\n<p>Creating intelligence, whether artificial or natural, works in a very similar way. We store chunks of information, and we then <strong>connect</strong> them. Multiple visualization tools and metaphors show this in a 3-dimensional space with dots connected by lines on a graph. Those connections and their intersection are what make up for intelligence. For example, we put together “chocolate is sweet and nice” and “drinking hot milk makes you warm”, and we make “hot chocolate”.</p>\n<p><img src=\"https://files.smashing.media/articles/understanding-ai-meaning/3D-representation-molecule.png\" /></p>\n<p>We, as human beings, don’t worry too much about making sure the connections land at the right point. Our brain just works that way, declaratively. However, for building AI, we need to be more explicit. So think of it as a map. In order for a plane to leave CountryA and arrive at CountryB it requires a precise system: we have coordinates, we have 2 axis in our maps, and they can be represented as a vector: <code>[28.3772, 81.5707]</code>.</p>\n<p>For our intelligence, we need a more complex system; 2 dimensions will not suffice; we need <strong>thousands</strong>. That’s what <strong>vector databases</strong> are. Our intelligence can now correlate terms based on the distance and/or angle between them, create cross-references, and establish patterns in which every term occurs.</p>\n<p>A specialized database that stores and manages data as high-dimensional vectors. It enables efficient <strong>similarity searches</strong> and <strong>semantic matching</strong>.</p>\nQuerying Per Approximation\n<p>As stated in the last session, matching the search terms (your prompt) to the data is the exercise of semantic matching (it establishes the pattern in which keywords in your prompt are used within its own data), and the similarity search, the distance (angular or linear) between each entry. That’s actually a roughly accurate representation. What a similarity search does is define each of the numbers in a vector (that’s thousands of coordinates long), a point in this weird multi-dimensional space. Finally, to establish similarity between each of these points, the distance and/or angles between them are measured.</p>\n<p>This is one of the reasons why AI isn’t deterministic — we also aren’t — for the same prompt, the search may produce different outputs based on how the scores are defined at that moment. If you’re building an AI system, there are algorithms you can use to establish how your data will be evaluated. </p>\n<p>This can produce more precise and accurate results depending on the type of data. The main algorithms used are 3, and Each one of them performs better for a certain kind of data, so understanding the shape of the data and how each of these concepts will correlate is important to choosing the correct one. In a very hand-wavy way, here’s the rule-of-thumb to offer you a clue for each:</p>\n<ul>\n<li><strong>Cosine Similarity</strong><br />Measures angle between vectors. So if the magnitude (the actual number) is less important. It’s great for text/semantic similarity</li>\n<li><strong>Dot Product</strong><br />Captures linear correlation and alignment. It’s great for establishing relationships between multiple points/features.</li>\n<li><strong>Euclidean Distance</strong><br />Calculates straight-line distance. It’s good for dense numerical spaces since it highlights the spatial distance.</li>\n</ul>\n<blockquote><strong>INFO</strong><br /><br />When working with non-structured data (like text entries: your tweets, a book, multiple recipes, your product’s documentation), <strong>cosine similarity</strong> is the way to go.</blockquote>\n\n<p>Now that we understand how the data bulk is stored and the relationships are built, we can start talking about how the intelligence works — let the training begin!</p>\nLanguage Models\n<p>A language model is a system trained to understand, predict, and finally generate human-like text by learning statistical patterns and relationships between words and phrases in large text datasets. For such a system, language is represented as <strong>probabilistic sequences</strong>.</p>\n<p>In that way, a language model is immediately capable of efficient completion (hence the quote stating that 90% of the code in Google is written by AI — auto-completion), translation, and conversation. Those tasks are the low-hanging fruits of AI because they depend on estimating the likelihood of word combinations and improve by reaffirming and adjusting the patterns based on usage feedback (rebalancing the similarity scores).</p>\n<p>As of now, we understand what a language model is, and we can start classifying them as <strong>large</strong> and <strong>small</strong>.</p>\n<h3>Large Language Models (LLMs)</h3>\n<p>As the name says, use large-scale datasets &amp;mdash with billions of parameters, like up to 70 billion. This allows them to be diverse and capable of creating human-like text across different knowledge domains.\nThink of them as big generalists. This makes them not only versatile but extremely powerful. And as a consequence, training them demands a lot of computational work.</p>\n<h3>Small Language Models (SLMs)</h3>\n<p>With a smaller dataset, with numbers ranging from 100 million to 3 billion parameters. They take significantly less computational effort, which makes them less versatile and better suited for specific tasks with more defined constraints. SLMs can also be deployed more efficiently and have a faster inference when processing user input.</p>\nFine-Tunning\n<p>Fine-tuning an LLM consists of adjusting the model’s weights through additional specialized training on a specific (high-quality) dataset. Basically, adapting a pre-trained model to perform better in a particular domain or task.</p>\n<p>As training iterates through the heuristics within the model, it enables a more nuanced understanding. This leads to more accurate and context-specific outputs without creating a custom language model for each task. On each training iteration, developers will tune the learning rate, weights, and batch-size while providing a dataset tailored for that particular knowledge area. Of course, each iteration depends also on appropriately benchmarking the output performance of the model.</p>\n<p>As mentioned above, <strong>fine-tuning</strong> is particularly useful for applying a determined task with a niche knowledge area, for example, creating summaries of nutritional scientific articles, correlating symptoms with a subset of possible conditions, etc.</p>\n<p>Fine-tuning is not something that can be done frequently or fast, requiring numerous iterations, and it isn’t intended for factual information, especially if dependent on current events or streamed information.</p>\nEnhancing Context With Information\n<p>Most conversations we have are directly dependent on context; with AI, it isn’t so much different. While there are definitely use cases that don’t entirely depend on current events (translations, summarization, data analysis, etc.), many others do. However, it isn’t quite feasible yet to have LLMs (or even SLMs) being trained on a daily basis.</p>\n<p>For this, a new technique can help: <strong>Retrieve-Augmented Generation</strong> (RAG). It consists of injecting a smaller dataset into the LLMs in order to provide it with more specific (and/or current) information. With a RAG, the LLM isn’t better trained; it still has all the generalistic training it had before — but now, before it generates the output, it receives an ingest of new information to be used.</p>\n<blockquote><strong>INFO</strong><br /><br />RAG enhances the LLM’s context, providing it with a more comprehensive understanding of the topic.</blockquote>\n\n<p>For an RAG to work well, data must be prepared/formatted in a way that the LLM can properly digest it. Setting it up is a multi-step process:</p>\n<ol>\n<li><strong>Retrieval</strong><br />Query external data (such as web pages, knowledge bases, and databases).</li>\n<li><strong>Pre-Processing</strong><br />Information undergoes pre-processing, including tokenization, stemming, and removal of stop words.</li>\n<li><strong>Grounded Generation</strong><br />The pre-processed retrieved information is then seamlessly incorporated into the pre-trained LLM. </li>\n</ol>\n<p>RAG first retrieves relevant information from a database using a query generated by the LLM. Integrating an RAG to an LLM enhances its context, providing it with a more comprehensive understanding of the topic. This augmented context enables the LLM to generate more precise, informative, and engaging responses.</p>\n<p>Since it provides access to fresh information via easy-to-update database records, this approach is mostly for data-driven responses. Because this data is context-focused, it also provides more accuracy to facts. Think of a RAG as a tool to turn your LLM from a generalist into a specialist.</p>\n<p>Enhancing an LLM context through RAG is particularly useful for chatbots, assistants, agents, or other usages where the output quality is directly connected to domain knowledge. But, while RAG is the strategy to collect and “inject” data into the language model’s context, this data requires input, and that is why it also requires meaning <strong>embedded</strong>.</p>\nEmbedding\n<p>To make data digestible by the LLM, we need to capture each entry’s semantic meaning so the language model can form the patterns and establish the relationships. This process is called <strong>embedding</strong>, and it works by creating a static vector representation of the data. Different language models have different levels of precision embedding. For example, you can have embeddings from 384 dimensions all the way to 3072.</p>\n<p>In other words, in comparison to our cartesian coordinates in a map (e.g., <code>[28.3772, 81.5707]</code>) with only two dimensions, an embedded entry for an LLM has from 384 to 3072 dimensions.</p>\nLet’s Build\n<p>I hope this helped you better understand what those terms mean and the processes which encompass the term “AI”. This merely scratches the surface of complexity, though. We still need to talk about AI Agents and how all these approaches intertwine to create richer experiences. Perhaps we can do that in a later article — let me know in the comments if you’d like that!</p>\n<p>Meanwhile, <a href=\"https://atila.io/x\">let me know</a> your thoughts and what you build with this!</p>\n<h3>Further Reading on SmashingMag</h3>\n<ul>\n<li>“<a href=\"https://www.smashingmagazine.com/2024/04/ai-neurodiversity-building-inclusive-tools/\">Using AI For Neurodiversity And Building Inclusive Tools</a>,” Pratik Joglekar</li>\n<li>“<a href=\"https://www.smashingmagazine.com/2024/07/how-design-effective-conversational-ai-experiences-guide/\">How To Design Effective Conversational AI Experiences: A Comprehensive Guide</a>,” Yinjian Huang</li>\n<li>“<a href=\"https://www.smashingmagazine.com/2024/02/designing-ai-beyond-conversational-interfaces/\">When Words Cannot Describe: Designing For AI Beyond Conversational Interfaces</a>,” Maximillian Piras</li>\n<li>“<a href=\"https://www.smashingmagazine.com/2024/11/ai-transformative-impact-web-design-supercharging-productivity/\">AI’s Transformative Impact On Web Design: Supercharging Productivity Across The Industry</a>,” Paul Boag</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"e1ec84c3d7f294a4f041c3b1a62c57381375667fb0ea9e58cd4ccc69856fd4bb","category":"Tech"}