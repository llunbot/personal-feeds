{"title":"Smashing Animations Part 4: Optimising SVGs","link":"https://smashingmagazine.com/2025/06/smashing-animations-part-4-optimising-svgs/","date":1749024000000,"content":"<p>SVG animations take me back to the Hanna-Barbera cartoons I watched as a kid. Shows like <em>Wacky Races</em>, <em>The Perils of Penelope Pitstop</em>, and, of course, <a href=\"https://en.wikipedia.org/wiki/Yogi_Bear\"><em>Yogi Bear</em></a>. They inspired me to lovingly recreate some classic <a href=\"https://stuffandnonsense.co.uk/toon-titles\">Toon Titles</a> using CSS, SVG, and SMIL animations.</p>\n<p>But getting animations to load quickly and work smoothly needs more than nostalgia. It takes clean design, lean code, and a process that makes complex SVGs easier to animate. Here’s how I do it.</p>\n<p><img src=\"https://files.smashing.media/articles/smashing-animations-part-4-optimising-svgs/1-toon-titles.png\" /></p>\n<p><img src=\"https://files.smashing.media/articles/smashing-animations-part-4-optimising-svgs/2-yogi-bear-bewitched-bear.png\" /></p>\nStart Clean And Design With Optimisation In Mind\n<p>Keeping things simple is key to making SVGs that are optimised and ready to animate. Tools like Adobe Illustrator convert bitmap images to vectors, but the output often contains too many extraneous groups, layers, and masks. Instead, I start cleaning in Sketch, work from a reference image, and use the Pen tool to create paths.</p>\n<blockquote><strong>Tip</strong>: <a href=\"https://affinity.serif.com/en-gb/designer/\">Affinity Designer</a> (UK) and <a href=\"https://www.sketch.com\">Sketch</a> (Netherlands) are alternatives to Adobe Illustrator and Figma. Both are independent and based in Europe. Sketch has been my default design app since Adobe killed Fireworks.</blockquote>\n\nBeginning With Outlines\n<p>For these Toon Titles illustrations, I first use the Pen tool to draw black outlines with as few anchor points as possible. The more points a shape has, the bigger a file becomes, so simplifying paths and reducing the number of points makes an SVG much smaller, often with no discernible visual difference.</p>\n<p><img src=\"https://files.smashing.media/articles/smashing-animations-part-4-optimising-svgs/3-outlines-anchor-points.png\" /></p>\n<p>Bearing in mind that parts of this Yogi illustration will ultimately be animated, I keep outlines for this Bewitched Bear’s body, head, collar, and tie separate so that I can move them independently. The head might nod, the tie could flap, and, like in those classic cartoons, Yogi’s collar will hide the joins between them.</p>\n<p><img src=\"https://files.smashing.media/articles/smashing-animations-part-4-optimising-svgs/4-separate-outlines.png\" /></p>\nDrawing Simple Background Shapes\n<p>With the outlines in place, I use the Pen tool again to draw new shapes, which fill the areas with colour. These colours sit behind the outlines, so they don’t need to match them exactly. The fewer anchor points, the smaller the file size.</p>\n<p><img src=\"https://files.smashing.media/articles/smashing-animations-part-4-optimising-svgs/5-simple-background-shapes.png\" /></p>\n<p>Sadly, neither Affinity Designer nor Sketch has tools that can simplify paths, but if you have it, using Adobe Illustrator can shave a few extra kilobytes off these background shapes.</p>\n<p><img src=\"https://files.smashing.media/articles/smashing-animations-part-4-optimising-svgs/6-adobe-illustrator-simplify-paths.png\" /></p>\nOptimising The Code\n<p>It’s not just metadata that makes SVG bulkier. The way you export from your design app also affects file size.</p>\n<p><img src=\"https://files.smashing.media/articles/smashing-animations-part-4-optimising-svgs/7-vector-artwork-ready-optimisation.png\" /></p>\n<p>Exporting just those simple background shapes from Adobe Illustrator includes unnecessary groups, masks, and bloated path data by default. Sketch’s code is barely any better, and there’s plenty of room for improvement, even in its SVGO Compressor code. I rely on Jake Archibald’s <a href=\"https://jakearchibald.github.io/svgomg/\">SVGOMG</a>, which uses SVGO v3 and consistently delivers the best optimised SVGs.</p>\n<p><img src=\"https://files.smashing.media/articles/smashing-animations-part-4-optimising-svgs/8-jake-archibald-svgomg-online-optimisation-tool.png\" /></p>\nLayering SVG Elements\n<p>My process for preparing SVGs for animation goes well beyond drawing vectors and optimising paths — it also includes how I <strong>structure the code</strong> itself. When every visual element is crammed into a single SVG file, even optimised code can be a nightmare to navigate. Locating a specific path or group often feels like searching for a needle in a haystack.</p>\n<p><img src=\"https://files.smashing.media/articles/smashing-animations-part-4-optimising-svgs/9-yogi-bear-title-card-toon-titles-recreation.png\" /></p>\n<p>That’s why I develop my SVGs in layers, exporting and optimising one set of elements at a time — always in the order they’ll appear in the final file. This lets me build the master SVG gradually by pasting it in each cleaned-up section. For example, I start with backgrounds like this gradient and title graphic.</p>\n<p><img src=\"https://files.smashing.media/articles/smashing-animations-part-4-optimising-svgs/10-gradient-background-title-graphic.png\" /></p>\n<p>Instead of facing a wall of SVG code, I can now easily identify the background gradient’s path and its associated <code>linearGradient</code>, and see the group containing the title graphic. I take this opportunity to add a comment to the code, which will make editing and adding animations to it easier in the future:</p>\n<pre><code>&lt;svg ...&gt;\n  &lt;defs&gt;\n    &lt;!-- ... --&gt;\n  &lt;/defs&gt;\n  &lt;path fill=\"url(#grad)\" d=\"…\"/&gt;\n  &lt;!-- TITLE GRAPHIC --&gt;\n  &lt;g&gt;\n    &lt;path … /&gt;\n    &lt;!-- ... --&gt; \n  &lt;/g&gt;\n&lt;/svg&gt;\n</code></pre>\n\n<p><img src=\"https://files.smashing.media/articles/smashing-animations-part-4-optimising-svgs/11-trail-gaussian-blur.png\" /></p>\n<p>Next, I add the blurred trail from Yogi’s airborne broom. This includes defining a Gaussian Blur filter and placing its path between the background and title layers:</p>\n<pre><code>&lt;svg ...&gt;\n  &lt;defs&gt;\n    &lt;linearGradient id=\"grad\" …&gt;…&lt;/linearGradient&gt;\n    &lt;filter id=\"trail\" …&gt;…&lt;/filter&gt;\n  &lt;/defs&gt;\n  &lt;!-- GRADIENT --&gt;\n  &lt;!-- TRAIL --&gt;\n  &lt;path filter=\"url(#trail)\" …/&gt;\n  &lt;!-- TITLE GRAPHIC --&gt;\n&lt;/svg&gt;\n</code></pre>\n\n<p><img src=\"https://files.smashing.media/articles/smashing-animations-part-4-optimising-svgs/12-yogi-bear-magical-stars.png\" /></p>\n<p>Then come the magical stars, added in the same sequential fashion:</p>\n<pre><code>&lt;svg ...&gt;\n  &lt;!-- GRADIENT --&gt;\n  &lt;!-- TRAIL --&gt;\n  &lt;!-- STARS --&gt;\n  &lt;!-- TITLE GRAPHIC --&gt;\n&lt;/svg&gt;\n</code></pre>\n\n<p>To keep everything organised and animation-ready, I create an empty group that will hold all the parts of Yogi:</p>\n<pre><code>&lt;g id=\"yogi\"&gt;...&lt;/g&gt;\n</code></pre>\n\n<p><img src=\"https://files.smashing.media/articles/smashing-animations-part-4-optimising-svgs/13-yogi-bear-component-parts.png\" /></p>\n<p>Then I build Yogi from the ground up — starting with background props, like his broom:</p>\n<pre><code>&lt;g id=\"broom\"&gt;...&lt;/g&gt;\n</code></pre>\n\n<p>Followed by grouped elements for his body, head, collar, and tie:</p>\n<pre><code>&lt;g id=\"yogi\"&gt;\n  &lt;g id=\"broom\"&gt;…&lt;/g&gt;\n  &lt;g id=\"body\"&gt;…&lt;/g&gt;\n  &lt;g id=\"head\"&gt;…&lt;/g&gt;\n  &lt;g id=\"collar\"&gt;…&lt;/g&gt;\n  &lt;g id=\"tie\"&gt;…&lt;/g&gt;\n&lt;/g&gt;\n</code></pre>\n\n<p><img src=\"https://files.smashing.media/articles/smashing-animations-part-4-optimising-svgs/14-yogi-bear-title-card-toon-titles-recreation.png\" /></p>\n<p>Since I export each layer from the same-sized artboard, I don’t need to worry about alignment or positioning issues later on — they’ll all slot into place automatically. I keep my code <strong>clean</strong>, <strong>readable</strong>, and <strong>ordered logically</strong> by layering elements this way. It also makes animating smoother, as each component is easier to identify.</p>\nReusing Elements With <code>&lt;use&gt;</code>\n<p>When duplicate shapes get reused repeatedly, SVG files can get bulky fast. My recreation of the “Bewitched Bear” title card contains 80 stars in three sizes. Combining all those shapes into one optimised path would bring the file size down to 3KB. But I want to animate individual stars, which would almost double that to 5KB:</p>\n<pre><code>&lt;g id=\"stars\"&gt;\n &lt;path class=\"star-small\" fill=\"#eae3da\" d=\"...\"/&gt;\n &lt;path class=\"star-medium\" fill=\"#eae3da\" d=\"...\"/&gt;\n &lt;path class=\"star-large\" fill=\"#eae3da\" d=\"...\"/&gt;\n &lt;!-- ... --&gt;\n&lt;/g&gt;\n</code></pre>\n\n<p>Moving the stars’ <code>fill</code> attribute values to their parent group reduces the overall weight a little:</p>\n<pre><code>&lt;g id=\"stars\" fill=\"#eae3da\"&gt;\n &lt;path class=\"star-small\" d=\"…\"/&gt;\n &lt;path class=\"star-medium\" d=\"…\"/&gt;\n &lt;path class=\"star-large\" d=\"…\"/&gt;\n &lt;!-- ... --&gt;\n&lt;/g&gt;\n</code></pre>\n\n<p><img src=\"https://files.smashing.media/articles/smashing-animations-part-4-optimising-svgs/15-yogi-bear-sparkling-stars.png\" /></p>\n<p>But a more efficient and manageable option is to define each star size as a reusable template:</p>\n<div>\n<pre><code>&lt;defs&gt;\n  &lt;path id=\"star-large\" fill=\"#eae3da\" fill-rule=\"evenodd\" d=\"…\"/&gt;\n  &lt;path id=\"star-medium\" fill=\"#eae3da\" fill-rule=\"evenodd\" d=\"…\"/&gt;\n  &lt;path id=\"star-small\" fill=\"#eae3da\" fill-rule=\"evenodd\" d=\"…\"/&gt;\n&lt;/defs&gt;\n</code></pre>\n</div>\n\n<p>With this setup, changing a star’s design only means updating its template once, and every instance updates automatically. Then, I reference each one using <code>&lt;use&gt;</code> and position them with <code>x</code> and <code>y</code> attributes:</p>\n<pre><code>&lt;g id=\"stars\"&gt;\n  &lt;!-- Large stars --&gt;\n  &lt;use href=\"#star-large\" x=\"1575\" y=\"495\"/&gt;\n  &lt;!-- ... --&gt;\n  &lt;!-- Medium stars --&gt;\n  &lt;use href=\"#star-medium\" x=\"1453\" y=\"696\"/&gt;\n  &lt;!-- ... --&gt;\n  &lt;!-- Small stars --&gt;\n  &lt;use href=\"#star-small\" x=\"1287\" y=\"741\"/&gt;\n  &lt;!-- ... --&gt;\n&lt;/g&gt;\n</code></pre>\n\n<p>This approach makes the SVG easier to manage, lighter to load, and faster to iterate on, especially when working with dozens of repeating elements. Best of all, it keeps the markup clean <strong>without compromising on flexibility or performance</strong>.</p>\nAdding Animations\n<p>The stars trailing behind Yogi’s stolen broom bring so much personality to the animation. I wanted them to sparkle in a seemingly random pattern against the dark blue background, so I started by defining a keyframe animation that cycles through different <code>opacity</code> levels:</p>\n<pre><code>@keyframes sparkle {\n  0%, 100% { opacity: .1; }\n  50% { opacity: 1; }\n}\n</code></pre>\n\n<p>Next, I applied this looping animation to every <code>use</code> element inside my stars group:</p>\n<pre><code>#stars use {\n  animation: sparkle 10s ease-in-out infinite;\n}\n</code></pre>\n\n<p>The secret to creating a convincing twinkle lies in <strong>variation</strong>. I staggered animation delays and durations across the stars using <code>nth-child</code> selectors, starting with the quickest and most frequent sparkle effects:</p>\n<pre><code>/* Fast, frequent */\n#stars use:nth-child(n + 1):nth-child(-n + 10) {\n  animation-delay: .1s;\n  animation-duration: 2s;\n}\n</code></pre>\n\n<p>From there, I layered in additional timings to mix things up. Some stars sparkle slowly and dramatically, others more randomly, with a variety of rhythms and pauses:</p>\n<pre><code>/* Medium */\n#stars use:nth-child(n + 11):nth-child(-n + 20) { ... }\n\n/* Slow, dramatic */\n#stars use:nth-child(n + 21):nth-child(-n + 30) { ... }\n\n/* Random */\n#stars use:nth-child(3n + 2) { ... }\n\n/* Alternating */\n#stars use:nth-child(4n + 1) { ... }\n\n/* Scattered */\n#stars use:nth-child(n + 31) { ... }\n</code></pre>\n\n<p>By thoughtfully structuring the SVG and reusing elements, I can build complex-looking animations without bloated code, making even a simple effect like changing <code>opacity</code> sparkle. </p>\n<p><img src=\"https://files.smashing.media/articles/smashing-animations-part-4-optimising-svgs/16-subtle-movements-yogi-bear.png\" /></p>\n<p>Then, for added realism, I make Yogi’s head wobble:</p>\n<div>\n<pre><code>@keyframes headWobble {\n  0% { transform: rotate(-0.8deg) translateY(-0.5px); }\n  100% { transform: rotate(0.9deg) translateY(0.3px); }\n}\n\n#head {\n  animation: headWobble 0.8s cubic-bezier(0.5, 0.15, 0.5, 0.85) infinite alternate;\n}\n</code></pre>\n</div>\n\n<p>His tie waves:</p>\n<div>\n<pre><code>@keyframes tieWave {\n  0%, 100% { transform: rotateZ(-4deg) rotateY(15deg) scaleX(0.96); }\n  33% { transform: rotateZ(5deg) rotateY(-10deg) scaleX(1.05); }\n  66% { transform: rotateZ(-2deg) rotateY(5deg) scaleX(0.98); }\n}\n\n#tie {\n  transform-style: preserve-3d;\n  animation: tieWave 10s cubic-bezier(0.68, -0.55, 0.27, 1.55) infinite;\n}\n</code></pre>\n</div>\n\n<p>His broom swings:</p>\n<div>\n<pre><code>@keyframes broomSwing {\n  0%, 20% { transform: rotate(-5deg); }\n  30% { transform: rotate(-4deg); }\n  50%, 70% { transform: rotate(5deg); }\n  80% { transform: rotate(4deg); }\n  100% { transform: rotate(-5deg); }\n}\n\n#broom {\n  animation: broomSwing 4s cubic-bezier(0.5, 0.05, 0.5, 0.95) infinite;\n}\n</code></pre>\n</div>\n\n<p>And, finally, Yogi himself gently rotates as he flies on his magical broom:</p>\n<div>\n<pre><code>@keyframes yogiWobble {\n  0% { transform: rotate(-2.8deg) translateY(-0.8px) scale(0.998); }\n  30% { transform: rotate(1.5deg) translateY(0.3px); }\n  100% { transform: rotate(3.2deg) translateY(1.2px) scale(1.002); }\n}\n\n#yogi {\n  animation: yogiWobble 3.5s cubic-bezier(.37, .14, .3, .86) infinite alternate;\n}\n</code></pre>\n</div>\n\n<p>All these subtle movements bring Yogi to life. By developing structured SVGs, I can create animations that feel full of character without writing a single line of JavaScript.</p>\n<p>Try this yourself:</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/bNdwJBN\">Bewitched Bear CSS/SVG animation [forked]</a> by <a href=\"https://codepen.io/malarkey\">Andy Clarke</a>.</p>\nConclusion\n<p>Whether you’re recreating a classic title card or animating icons for an interface, the principles are the same:</p>\n<ol>\n<li>Start clean,</li>\n<li>Optimise early, and</li>\n<li>Structure everything with animation in mind.</li>\n</ol>\n<p>SVGs offer incredible creative freedom, but only if kept <strong>lean</strong> and <strong>manageable</strong>. When you plan your process like a production cell — layer by layer, element by element — you’ll spend less time untangling code and more time bringing your work to life. </p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"27db2b108431c24619addcd3a68c01c44feda58ad3a32a4202c025f07f89d952","category":"Tech"}