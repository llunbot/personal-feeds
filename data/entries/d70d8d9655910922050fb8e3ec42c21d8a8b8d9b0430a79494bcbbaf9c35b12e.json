{"title":"Masonry In CSS: Should Grid Evolve Or Stand Aside For A New Module?","link":"https://smashingmagazine.com/2025/05/masonry-css-should-grid-evolve-stand-aside-new-module/","date":1746536400000,"content":"<p>You’ve got a Pinterest-style layout to build, but you’re tired of JavaScript. Could CSS finally have the answer? Well, for a beginner, taking a look at the pins on your Pinterest page, you might be convinced that the CSS grid layout is enough, but not until you begin to build do you realise <code>display: grid</code> with additional tweaks is less than enough. In fact, Pinterest built its layout with JavaScript, but how cool would it be if it were just CSS? If there were a CSS display property that gave such a layout without any additional JavaScript, how awesome would that be?</p>\n<p>Maybe there is. The CSS grid layout has an <strong>experimental masonry value</strong> for <code>grid-template-rows</code>. The masonry layout is an irregular, flowing grid. Irregular in the sense that, instead of following a rigid grid pattern with spaces left after shorter pieces, the items in the next row of a masonry layout rise to fill the spaces on the masonry axis. It’s the dream for portfolios, image galleries, and social feeds — designs that thrive on organic flow. But here’s the catch: while this experimental feature exists (think Firefox Nightly with a flag enabled), it’s not the seamless solution you might expect, thanks to limited browser support and some rough edges in its current form.</p>\n<p>Maybe there isn’t. CSS lacks native masonry support, forcing developers to use hacks or JavaScript libraries like <a href=\"https://masonry.desandro.com\">Masonry.js</a>. Developers with a good design background have expressed their criticism about the CSS grid form of masonry, with <a href=\"https://www.smashingmagazine.com/native-css-masonry-layout-css-grid/\">Rachel</a> highlighting that <strong>masonry’s organic flow contrasts with Grid’s strict two-dimensional structure</strong>, potentially confusing developers expecting Grid-like behaviour or <a href=\"https://ishadeed.com/article/should-masonry-be-part-of-css-grid/\">Ahmad Shadeed</a> fussing about how it makes the grid layout more complex than it should be, potentially overwhelming developers who value Grid’s clarity for structured layouts. <a href=\"https://css-tricks.com/css-masonry-css-grid/\">Geoff</a> also echoes Rachel Andrew’s concern that <em>“teaching and learning grid to get to understand masonry behaviour unnecessarily lumps two different formatting contexts into one,”</em> complicating education for designers and developers who rely on clear mental models.</p>\n<p>Perhaps there might be hope. The Apple WebKit team just sprung up a new contender, which claims not only to merge the pros of grid and masonry into a unified system shorthand but also includes flexbox concepts. Imagine the best of three CSS layout systems in one.</p>\n<p>Given these complaints and criticisms — and a new guy in the game — the question is:</p>\n<blockquote>Should CSS Grid expand to handle Masonry, or should a new, dedicated module take over, or should <code>item-flow</code> just take the reins?</blockquote>\n\n\n\nThe State Of Masonry In CSS Today\n<p>Several developers have attempted to create workarounds to achieve a masonry layout in their web applications using CSS Grid with manual row-span hacks, CSS Columns, and JavaScript libraries. Without native masonry, developers often turn to Grid hacks like this: a <code>grid-auto-rows</code> trick paired with JavaScript to fake the flow. It works — sort of — but the cracks show fast. </p>\n<p>For instance, the example below relies on JavaScript to measure each item’s height after rendering, calculate the number of 10px rows (plus gaps) the item should span while setting <code>grid-row-end</code> dynamically, and use event listeners to adjust the layout upon page load and window resize.</p>\n<div>\n<pre><code>/* HTML */\n&lt;div class=\"masonry-grid\"&gt;\n  &lt;div class=\"masonry-item\"&gt;&lt;img src=\"image1.jpg\" alt=\"Image 1\"&gt;&lt;/div&gt;\n  &lt;div class=\"masonry-item\"&gt;&lt;p&gt;Short text content here.&lt;/p&gt;&lt;/div&gt;\n  &lt;div class=\"masonry-item\"&gt;&lt;img src=\"image2.jpg\" alt=\"Image 2\"&gt;&lt;/div&gt;\n  &lt;div class=\"masonry-item\"&gt;&lt;p&gt;Longer text content that spans multiple lines to show height variation.&lt;/p&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n</div>\n\n<div>\n<pre><code>/* CSS */\n.masonry-grid {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); /* Responsive columns */\n  grid-auto-rows: 10px; /* Small row height for precise spanning */\n  grid-auto-flow: column; /* Fills columns left-to-right */\n  gap: 10px; /* Spacing between items */\n}\n\n.masonry-item {\n  /* Ensure content doesn’t overflow */\n  overflow: hidden;\n}\n\n.masonry-item img {\n  width: 100%;\n  height: auto;\n  display: block;\n}\n\n.masonry-item p {\n  margin: 0;\n  padding: 10px;\n}\n</code></pre>\n</div>\n\n<div>\n<pre><code>// JavaScript\n\nfunction applyMasonry() {\n  const grid = document.querySelector('.masonry-grid');\n  const items = grid.querySelectorAll('.masonry-item');\n\n  items.forEach(item =&gt; {\n    // Reset any previous spans\n    item.style.gridRowEnd = 'auto';\n\n    // Calculate the number of rows to span based on item height\n    const rowHeight = 10; \n    const gap = 10; \n    const itemHeight = item.getBoundingClientRect().height;\n    const rowSpan = Math.ceil((itemHeight + gap) / (rowHeight + gap));\n\n    // Apply the span\n    item.style.gridRowEnd = <code>span ${rowSpan}</code>;\n  });\n}\n\n// Run on load and resize\nwindow.addEventListener('load', applyMasonry);\nwindow.addEventListener('resize', applyMasonry);\n</code></pre>\n</div>\n\n<p>This Grid hack gets us close to a masonry layout — items stack, gaps fill, and it looks decent enough. But let’s be real: it’s not there yet. The code sample above, unlike native <code>grid-template-rows: masonry</code> (which is experimental and only exists on Firefox Nightly), relies on JavaScript to calculate spans, defeating the “no JavaScript” dream. The JavaScript logic works by recalculating spans on resize or content change. As <a href=\"https://css-tricks.com/native-css-masonry-layout-in-css-grid/\">Chris Coyier</a> noted in his critique of similar hacks, this can lead to lag on complex pages.</p>\n<p>Also, the logical DOM order might not match the visual flow, a concern <a href=\"https://www.smashingmagazine.com/native-css-masonry-layout-css-grid/\">Rachel Andrew</a> raised about masonry layouts generally. Finally, if images load slowly or content shifts (e.g., lazy-loaded media), the spans need recalculation, risking layout jumps. It’s not really the ideal hack; I’m sure you’d agree.</p>\n<p>Developers need a smooth experience, and ergonomically speaking, hacking Grid with scripts is a mental juggling act. It forces you to switch between CSS and JavaScript to tweak a layout. A native solution, whether Grid-powered or a new module, has to nail effortless responsiveness, neat rendering, and a workflow that does not make you break your tools.</p>\n<p>That’s why this debate matters — our daily grind demands it.</p>\nOption 1: Extending CSS Grid For Masonry\n<p>One way forward is to strengthen the CSS Grid with masonry powers. As of this writing, CSS grids have been extended to accommodate masonry. <code>grid-template-rows: masonry</code> is a draft of CSS Grid Level 3 that is currently experimental in Firefox Nightly. The columns of this layout will remain as a grid axis while the row takes on masonry. The child elements are then laid out item by item along the rows, as with the grid layout’s automatic placement. With this layout, items flow vertically, respecting column tracks but not row constraints.</p>\n<p>This option leaves Grid as your go-to layout system but allows it to handle the flowing, gap-filling stacks we crave.</p>\n<div>\n<pre><code>.masonry-grid {\n  display: grid;\n  gap: 10px;\n  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n  grid-template-rows: masonry;\n}\n</code></pre>\n</div>\n\n<p>First off, the grid-masonry style builds on CSS Grid’s familiarity and robust tooling (e.g., DevTools support). As a front-end developer, there’s a chance you’ve played with <code>grid-template-columns</code> or <code>grid-area</code>, so you’re halfway up the learning matrix. Masonry only extends the existing capabilities, eliminating the need to learn a whole new syntax from scratch. Also, Grid’s robust tooling comes along with Chrome DevTools’ grid overlay or Firefox’s layout inspector, removing the need for JavaScript hacks.</p>\n<p>Not so fast: there are limitations. Grid’s specifications already include properties like <code>align-content</code> and <code>grid-auto-flow</code>. Stacking masonry on the list risks turning it into a labyrinth.</p>\n<p>Then there are <strong>the edge cases</strong>. What happens when you want an item to span multiple columns and flow masonry-style? Or when gaps between items don’t align across columns? The specs are still foggy here, and early tests hint at bugs like items jumping unpredictably if content loads dynamically. This issue could break layouts, especially on responsive designs. <strong>The browser compatibility issue</strong> also exists. It’s still experimental, and even with polyfills, it does not work on other browsers except Firefox Nightly. Not something you’d want to try in your next client’s project, right? </p>\nOption 2: A Standalone Masonry Module\n<p>What if we had a <code>display: masonry</code> approach instead? Indulge me for a few minutes. This isn’t just wishful thinking. Early CSS Working Group chats have floated the idea, and it’s worth picturing how it could improve layouts. Let’s dive into the vision, <em>how</em> it might work, and <em>what</em> it gains or loses in the process.</p>\n<p>Imagine a layout system that doesn’t lean on Grid’s rigid tracks or Flexbox’s linear flow but instead thrives on vertical stacking with a horizontal twist. The goal? A clean slate for masonry’s signature look: items cascading down columns, filling gaps naturally, no hacks required. Inspired by murmurs in CSSWG discussions and the Chrome team’s alternative proposal, this module would <strong>prioritise fluidity over structure</strong>, giving designers a tool that feels as intuitive as the layouts they’re chasing. Think Pinterest but without JavaScript scaffolding.</p>\n<p>Here’s the pitch: a <code>display</code> value named <code>masonry</code> kicks off a flow-based system where items stack vertically by default, adjusting horizontally to fit the container. You’d control the direction and spacing with simple properties like the following:</p>\n<pre><code>.masonry {\n  display: masonry;\n  masonry-direction: column;\n  gap: 1rem;\n}\n</code></pre>\n\n<p>Want more control? Hypothetical extras like <code>masonry-columns: auto</code> could mimic Grid’s <code>repeat(auto-fill, minmax())</code>, while <code>masonry-align: balance</code> might even out column lengths for a polished look. It’s less about precise placement (Grid’s strength) and more about letting content breathe and flow, adapting to whatever screen size is thrown at it. The big win here is a clean break from Grid’s rigid order. A standalone module keeps them distinct: <strong>Grid for order, Masonry for flow</strong>. No more wrestling with Grid properties that don’t quite fit; you get a system tailored to the job.</p>\n<p>Of course, it’s not all smooth sailing. A brand-new spec means starting from zero. Browser vendors would need to rally behind it, which can be slow. Also, it might lead to <strong>confusion of choice</strong>, with developers asking questions like: <em>“Do I use Grid or Masonry for this gallery?”</em> But hear me out: This proposed module might muddy the waters before it clears them, but after the water is clear, it’s safe for use by all and sundry.</p>\nItem Flow: A Unified Layout Resolution\n<p>In March 2025, <a href=\"https://webkit.org/blog/16587/item-flow-part-1-a-new-unified-concept-for-layout/\">Apple’s WebKit team proposed Item Flow</a>, a new system that unifies concepts from Flexbox, Grid, and masonry into a single set of properties. Rather than choosing between enhancing Grid or creating a new masonry module, Item Flow merges their strengths, replacing <code>flex-flow</code> and <code>grid-auto-flow</code> with a shorthand called <code>item-flow</code>. This system introduces four longhand properties:</p>\n<ul>\n<li><code>item-direction</code><br />Controls flow direction (e.g., <code>row</code>, <code>column</code>, <code>row-reverse</code>).</li>\n<li><code>item-wrap</code><br />Manages wrapping behaviour (e.g., <code>wrap</code>, <code>nowrap</code>, <code>wrap-reverse</code>).</li>\n<li><code>item-pack</code><br />Determines packing density (e.g., <code>sparse</code>, <code>dense</code>, <code>balance</code>).</li>\n<li><code>item-slack</code><br />Adjusts tolerance for layout adjustments, allowing items to shrink or shift to fit.</li>\n</ul>\n<p>Item Flow aims to make masonry a natural outcome of these properties, not a separate feature. For example, a masonry layout could be achieved with:</p>\n<pre><code>.container {\n  display: grid; /* or flex */\n  item-flow: column wrap dense;\n\n  /* long hand version */\n  item-direction: column;\n  item-wrap: wrap;\n  item-pack: dense;\n\n  gap: 1rem;\n}\n</code></pre>\n\n<p>This setup allows items to flow vertically, wrap into columns, and pack tightly, mimicking masonry’s organic arrangement. The dense packing option, inspired by Grid’s <code>auto-flow: dense</code>, reorders items to minimise gaps, while <code>item-slack</code> could fine-tune spacing for visual balance.</p>\n<p>Item Flow’s promise lies in its <strong>wide use case</strong>. It enhances Grid and Flexbox with features like <code>nowrap</code> for Grid or <code>balance</code> packing for Flexbox, addressing long-standing developer wishlists. However, the proposal is still in discussion, and <a href=\"https://grok.com/chat/caeffa67-49d2-478e-834d-611d9a7bf204\">properties like <code>item-slack</code> face naming debates due to clarity issues for non-native English speakers</a>.</p>\n<p>The downside? Item Flow is a <strong>future-facing concept</strong>, and it has not yet been implemented in browsers as of April 2025. Developers must wait for standardisation and adoption, and the CSS Working Group is still gathering feedback.</p>\nWhat’s The Right Path?\n<p>While there is no direct answer to that question, the masonry debate hinges on balancing simplicity, performance, and flexibility. Extending the Grid with masonry is tempting but risks <strong>overcomplicating</strong> an already robust system. A standalone <code>display: masonry</code> module offers clarity but <strong>adds to CSS’s learning curve.</strong> Item Flow, the newest contender, proposes a unified system that could make masonry a natural extension of Grid and Flexbox, potentially putting the debate to rest at last.</p>\n<p>Each approach has trade-offs:</p>\n<ul>\n<li><strong>Grid with Masonry</strong>: Familiar but potentially clunky, with accessibility and spec concerns.</li>\n<li><strong>New Module</strong>: Clean and purpose-built, but requires learning new syntax.</li>\n<li><strong>Item Flow</strong>: Elegant and versatile but not yet available, with ongoing debates over naming and implementation.</li>\n</ul>\n<p>Item Flow’s ability to enhance existing layouts while supporting masonry makes it a compelling option, but its success depends on browser adoption and community support.</p>\nConclusion\n<p>So, where do we land after all this? The masonry showdown boils down to three paths: the extension of masonry into CSS Grid, a standalone module for masonry, or Item Flow. Now, the question is, <strong>will CSS finally free us from JavaScript for masonry</strong>, or are we still dreaming?</p>\n<p>Grid’s teasing us with a taste, and a standalone module’s whispering promises — but the finish line’s unclear, and WebKit swoops in with a killer merge shorthand, Item Flow. Browser buy-in, community push, and a few more spec revisions might tell us. For now, it’s your move — test, tweak, and weigh in. The answer’s coming, one layout at a time.</p>\n<h3>References</h3>\n<ul>\n<li>“<a href=\"https://www.smashingmagazine.com/native-css-masonry-layout-css-grid/\">Native CSS Masonry Layout in CSS Grid</a>” by Rachel Andrew</li>\n<li>“<a href=\"https://ishadeed.com/article/css-grid-masonry/\">Should Masonry be part of CSS Grid?</a>” by Ahmad Shadeed</li>\n<li>“<a href=\"https://css-tricks.com/css-masonry-css-grid/\">CSS Masonry &amp; CSS Grid</a>” by Geoff Graham</li>\n<li>“<a href=\"https://css-irl.info/masonry-in-css/\">Masonry? In CSS?!</a>” by Michelle Barker</li>\n<li>“<a href=\"https://css-tricks.com/native-css-masonry-layout-in-css-grid/\">Native CSS Masonry Layout in CSS Grids</a>” by Chris Coyier</li>\n<li>“<a href=\"https://webkit.org/blog/16587/item-flow-part-1-a-new-unified-concept-for-layout/\">Item Flow Part 1: A Unified Concept for Layout</a>” by WebKit</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"d70d8d9655910922050fb8e3ec42c21d8a8b8d9b0430a79494bcbbaf9c35b12e","category":"Tech"}