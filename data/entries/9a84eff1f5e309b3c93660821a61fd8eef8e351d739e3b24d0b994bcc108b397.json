{"title":"Addressing Accessibility Concerns With Using Fluid Type","link":"https://smashingmagazine.com/2023/11/addressing-accessibility-concerns-fluid-type/","date":1699380000000,"content":"<p>You may already be familiar with the CSS <code>clamp()</code> function. You may even be using it to fluidly scale a font size based on the browser viewport. Adrian Bece demonstrated the concept in <a href=\"https://www.smashingmagazine.com/2022/01/modern-fluid-typography-css-clamp/\">another Smashing Magazine article</a> just last year. It’s a clever <a href=\"https://css-tricks.com/snippets/css/fluid-typography/\">CSS “trick”</a> that has been floating around for a while.</p>\n<p>But if you’ve used the <code>clamp()</code>-based fluid type technique yourself, then you may have also run into articles that offer a warning about it. For example, <a href=\"https://www.smashingmagazine.com/2022/01/modern-fluid-typography-css-clamp/\">Adrian mentions this</a> in his article:</p>\n<blockquote>“It’s important to reiterate that using <code>rem</code> values doesn’t automagically make fluid typography accessible for all users; it only allows the font sizes to respond to user font preferences. Using the CSS <code>clamp</code> function in combination with the viewport units to achieve fluid sizing introduces <strong>another set of drawbacks</strong> that we need to consider.”</blockquote>\n\n<p>Here’s Una Kravets <a href=\"https://web.dev/min-max-clamp/#fluid-typography\">with a few words</a> about it on web.dev:</p>\n<blockquote>“Limiting how large text can get with <code>max()</code> or <code>clamp()</code> can cause a WCAG failure under <a href=\"https://www.w3.org/WAI/WCAG21/quickref/?showtechniques=144#resize-text\">1.4.4 Resize text (AA)</a>, because a user may be unable to scale the text to 200% of its original size. Be certain to <a href=\"https://adrianroselli.com/2019/12/responsive-type-and-zoom.html\">test the results with zoom</a>.”</blockquote>\n\n<p>Trys Mudford also has something to say about it <a href=\"https://utopia.fyi/blog/clamp/\">in the Utopia blog</a>:</p>\n<blockquote>“<a href=\"https://adrianroselli.com/2019/12/responsive-type-and-zoom.html\">Adrian Roselli</a> quite rightly warns that clamp can have a knock-on effect on the maximum font-size when the user explicitly sets a browser text zoom preference. As with any feature affecting typography, <strong>ensure you test thoroughly</strong> before using it in production.”</blockquote>\n\n<p>Mudford cites Adrian Roselli, who appears to be <a href=\"https://adrianroselli.com/2019/12/responsive-type-and-zoom.html\">the core source</a> of the other warnings:</p>\n<blockquote>“When you use <code>vw</code> units or limit how large text can get with <code>clamp()</code>, there is a chance a user may be unable to scale the text to 200% of its original size. If that happens, it is WCAG failure under <a href=\"https://www.w3.org/WAI/WCAG21/quickref/?showtechniques=144#resize-text\">1.4.4 Resize text (AA)</a> so be certain to test the results with zoom.”</blockquote>\n\n<p>So, what’s going on here? And how can we address any accessibility issues so we can keep fluidly scaling our text? That is exactly what I want to discuss in this article. Together, we will review what the WCAG guidelines say to understand the issue, then explore how we might be able to use <code>clamp()</code> in a way that adheres to WCAG Success Criterion (SC) 1.4.4.</p>\nWCAG Success Criterion 1.4.4\n<p>Let’s first review what <a href=\"https://www.w3.org/WAI/WCAG21/Understanding/resize-text.html\">WCAG Success Criterion 1.4.4</a> says about resizing text:</p>\n<blockquote>“Except for <a href=\"https://www.w3.org/WAI/WCAG21/Understanding/resize-text.html#dfn-captions\">captions</a> and <a href=\"https://www.w3.org/WAI/WCAG21/Understanding/resize-text.html#dfn-image-of-text\">images of text</a>, <a href=\"https://www.w3.org/WAI/WCAG21/Understanding/resize-text.html#dfn-text\">text</a> can be resized without <a href=\"https://www.w3.org/WAI/WCAG21/Understanding/resize-text.html#dfn-assistive-technology\">assistive technology</a> up to 200 percent without loss of content or functionality.”</blockquote>\n\n<p>Normally, if we’re setting CSS <code>font-size</code> to a non-fluid value, e.g., <code>font-size: 2rem</code>, we never have to worry about resizing behavior. All modern browsers can zoom up to 500% without additional assistive technology.</p>\n<p>So, what’s the deal with sizing text with viewport units like this:</p>\n<pre><code>h1 {\n  font-size: 5vw;\n}\n</code></pre>\n\n<p>Here’s a simple example demonstrating the problem. I suggest viewing it in either Chrome or Firefox because zooming in Safari can behave differently.</p>\n<p><img src=\"https://files.smashing.media/articles/addressing-accessibility-concerns-fluid-type/1-zoom-level-100-and-500.png\" /></p>\n<p>The text only scales up to <code>55px</code>, or 1.67 times its original size, even though we zoomed the entire page to five times its original size. And because WCAG SC 1.4.4 requires that text can scale to at least two times its original size, this simple example would fail an accessibility audit, at least in most browsers at certain viewport widths.</p>\n<p>Surely this can’t be a problem for <em>all</em> clamped font sizes with <code>vw</code> units, right? What about <a href=\"https://codepen.io/mbarvian/full/jOQjRNa\">one that only increases from <code>16px</code> to <code>18px</code></a>:</p>\n<pre><code>h1 {\n  font-size: clamp(16px, 15.33px + 0.208vw, 18px);\n}\n</code></pre>\n\n<p>The <code>vw</code> part of that inner <code>calc()</code> function (<code>clamp()</code> supports <code>calc()</code> without explicitly declaring it) is so small that it couldn’t possibly cause the same accessibility failure, right?</p>\n<p><img src=\"https://files.smashing.media/articles/addressing-accessibility-concerns-fluid-type/2-zoom-level-default-maximum.png\" /></p>\n<p>Sure enough, even though it doesn’t get to quite 500% of its original size when the page is zoomed to 500%, the size of the text certainly passes the 200% zoom specified in WCAG SC 1.4.4.</p>\n<p>So, clamped viewport-based font sizes fail WCAG SC 1.4.4 in some cases but not in others. The only advice I’ve seen for determining which situations pass or fail is to check each of them manually, as Adrian Roselli originally suggested. But that’s time-consuming and imprecise because the functions don’t scale intuitively.</p>\n<p>There must be some relationship between our inputs — i.e., the minimum font size, maximum font size, minimum breakpoint, and maximum breakpoint — that can help us determine when they pose accessibility issues.</p>\nThinking Mathematically\n<p>If we think about this problem mathematically, we really want to ensure that <code>z₅(v) ≥ 2z₁(v)</code>. Let’s break that down.</p>\n<p><code>z₁(v)</code> and <code>z₅(v)</code> are functions that take the viewport width, <code>v</code>, as their input and return a font size at a 100% zoom level and a 500% zoom level, respectively. In other words, what we want to know is at what range of viewport widths will <code>z₅(v)</code> be <em>less</em> than <code>2×z₁(v)</code>, which represents the minimum size outlined in WCAG SC 1.4.4?</p>\n<p>Using the first <code>clamp()</code> example we looked at that failed WCAG SC 1.4.4, we know that the <code>z₁</code> function is the <code>clamp()</code> expression:</p>\n<pre><code>z₁(v) = clamp(16, 5.33 + 0.0333v, 48)\n</code></pre>\n\n<p><strong>Notice</strong>: <em>The <code>vw</code> units are divided by <code>100</code> to translate from CSS where <code>100vw</code> equals the viewport width in pixels.</em></p>\n<p>As for the <code>z₅</code> function, it’s tempting to think that <code>z₅ = 5z₁</code>. But remember what we learned from that first demo: <strong>viewport-based units don’t scale up with the browser’s zoom level.</strong> This means <code>z₅</code> is more correctly expressed like this:</p>\n<pre><code>z₅(v) = clamp(16*5, 5.33*5 + 0.0333v, 48*5)\n</code></pre>\n\n<p><strong>Notice</strong>: <em>This scales everything up by <code>5</code> (or <code>500%</code>), except for <code>v</code>. This simulates how the browser scales the page when zooming.</em></p>\n<p>Let’s represent the <code>clamp()</code> function mathematically. We can convert it to a <a href=\"https://math.stackexchange.com/a/2372161\">piecewise function</a>, meaning <code>z₁(v)</code> and <code>z₅(v)</code> would ultimately look like the following figure:</p>\n<p><img src=\"https://files.smashing.media/articles/addressing-accessibility-concerns-fluid-type/3-zoom-z1v.png\" /></p>\n<p><img src=\"https://files.smashing.media/articles/addressing-accessibility-concerns-fluid-type/4-zoom-z5v.png\" /></p>\n<p>We can graph these functions to help visualize the problem. Here’s the base function, <code>z₁(v)</code>, with the viewport width, <code>v</code>, on the x-axis:</p>\n<p><img src=\"https://files.smashing.media/articles/addressing-accessibility-concerns-fluid-type/5-graphed-geogebra.png\" /></p>\n<p>This looks about right. The font size stays at <code>16px</code> until the viewport is <code>320px</code> wide, and it increases linearly from there before it hits <code>48px</code> at a viewport width of <code>1280px</code>. So far, so good.</p>\n<p>Here’s a more interesting graph comparing <code>2z₁(v)</code> and <code>z₅(v)</code>:</p>\n<p><img src=\"https://files.smashing.media/articles/addressing-accessibility-concerns-fluid-type/6-graph-two-functions.png\" /></p>\n<p>Can you spot the accessibility failure on this graph? When <code>z₅(v)</code> (in green) is less than <code>2z₁(v)</code> (in teal), the viewport-based font size fails WCAG SC 1.4.4.</p>\n<p>Let’s zoom into the bottom-left region for a closer look:</p>\n<p><img src=\"https://files.smashing.media/articles/addressing-accessibility-concerns-fluid-type/7-graph-two-functions-zoomed.png\" /></p>\n<p>This figure indicates that failure occurs when the browser width is approximately between <code>1050px</code> and <code>2100px</code>. You can verify this by <a href=\"https://codepen.io/mbarvian/full/bGQPZop\">opening the original demo again</a> and zooming into it at different viewport widths. When the viewport is less than <code>1050px</code> or greater than <code>2100px</code>, the text should scale up to at least two times its original size at a 500% zoom. But when it’s in between <code>1050px</code>  and <code>2100px</code>, it doesn’t.</p>\n<p><strong>Hint</strong>: <em>We have to manually measure the text — e.g., take a screenshot — because browsers don’t show zoomed values in DevTools.</em></p>\nGeneral Solutions\n<p>For simplicity’s sake, we’ve only focused on one <code>clamp()</code> expression so far. Can we generalize these findings somehow to ensure any clamped expression passes WCAG SC 1.4.4?</p>\n<p>Let’s take a closer look at what’s happening in the failure above. Notice that the problem is caused because <code>2z₁(v)</code> — the SC 1.4.4 requirement — reaches its peak before <code>z₅(v)</code> starts increasing.</p>\n<p>When would that be the case? <em>Everything</em> in <code>2z₁(v)</code> is scaled by 200%, including the slope of the line (<code>v</code>). The function reaches its peak value at the same viewport width where <code>z₁(v)</code> reaches its peak value (the maximum <code>1280px</code> breakpoint). That peak value is two times the maximum font size we want which, in this case, is <code>2*48</code>, or <code>96px</code>.</p>\n<p><img src=\"https://files.smashing.media/articles/addressing-accessibility-concerns-fluid-type/8-function-peak-value.png\" /></p>\n<p>However, the slope of <code>z₅(v)</code> is the same as <code>z₁(v)</code>. In other words, the function doesn’t start increasing from its lowest clamped point — five times the minimum font size we want — until the viewport width is five times the minimum breakpoint. In this case, that is <code>5*320</code>, or <code>1600px</code>.</p>\n<p><img src=\"https://files.smashing.media/articles/addressing-accessibility-concerns-fluid-type/9-function-lowest-clamped-point.png\" /></p>\n<p>Thinking about this generally, we can say that if <code>2z₁(v)</code> peaks before <code>z₅(v)</code> starts increasing, or if the maximum breakpoint is less than five times the minimum breakpoint, then the peak value of <code>2z₁(v)</code> must be less than or equal to the peak value of <code>z₅(v)</code>, or two times the maximum value that is less than or equal to five times the minimum value.</p>\n<p>Or simpler still: <strong>The maximum value must be less than or equal to 2.5 times the minimum value</strong>.</p>\n<p>What about when the maximum breakpoint is more than five times the minimum breakpoint? Let’s see what our graph looks like when we change the maximum breakpoint from <code>1280px</code> to <code>1664px</code> and the maximum font size to <code>40px</code>:</p>\n<p><img src=\"https://files.smashing.media/articles/addressing-accessibility-concerns-fluid-type/10-graph-increased-max-breakpoint.png\" /></p>\n<p>Technically, we could get away with a slightly higher maximum font size. To figure out just <em>how</em> much higher, we’d have to solve for <code>z₅(v) ≥ 2z₁(v)</code> at the point when <code>2z₁(v)</code> reaches its peak, which is when <code>v</code> equals the maximum breakpoint. (Hat tip to my brother, <a href=\"https://www.linkedin.com/in/zach-barvian/\">Zach Barvian</a>, whose excellent math skills helped me with this.)</p>\n<p>To save you the math, you can play around with <a href=\"https://fluid.style/type\">this calculator</a> to see which combinations pass WCAG SC 1.4.4.</p>\nConclusion\n<p>Summing up what we’ve covered:</p>\n<ul>\n<li>If the maximum font size is <em>less</em> than or equal to 2.5 times the minimum font size, then the text will always pass WCAG SC 1.4.4, at least on all modern browsers.</li>\n<li>If the maximum breakpoint is <em>greater</em> than five times the minimum breakpoint, it is possible to get away with a <em>slightly</em> higher maximum font size. That said, the increase is negligible, and that is a large breakpoint range to use in practice.</li>\n</ul>\n<p>Importantly, that first rule is true for non-fluid responsive type as well. If you open <a href=\"https://codepen.io/mbarvian/full/eYQwaxB\">this pen</a>, for example, notice that it uses regular media queries to increase the <code>h1</code> element’s size from an initial value of <code>1rem</code> to <code>3rem</code> (which violates our first rule), with an in-between stop for <code>2rem</code>.</p>\n<p>If you zoom in at 500% with a browser width of approximately <code>1000px</code>, you will see that the text doesn’t reach 200% of its initial size. This makes sense because if you were to describe <code>2z₁(v)</code> and <code>z₅(v)</code> mathematically, they would be even simpler piecewise functions with the same maximum and minimum limitations. <strong>This guideline would hold for any function describing a font size with a known minimum and maximum</strong>.</p>\n<p>In the future, of course, we <a href=\"https://github.com/w3c/csswg-drafts/issues/6869\">may get more tools from browsers</a> to address these issues and accommodate even larger maximum font sizes. In the meantime, though, I hope you find this article helpful when building responsive frontends.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"9a84eff1f5e309b3c93660821a61fd8eef8e351d739e3b24d0b994bcc108b397","category":"Tech"}