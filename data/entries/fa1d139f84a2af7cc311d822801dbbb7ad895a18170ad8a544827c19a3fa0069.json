{"title":"Sticky Headers And Full-Height Elements: A Tricky Combination","link":"https://smashingmagazine.com/2024/09/sticky-headers-full-height-elements-tricky-combination/","date":1725526800000,"content":"<p>I was recently asked by a student to help with a <em>seemingly</em> simple problem. She’d been working on a website for a coffee shop that sports a sticky header, and she wanted the hero section right underneath that header to span the rest of the available vertical space in the viewport.</p>\n<p>Here’s a visual demo of the desired effect for clarity.</p>\n<p>Looks like it should be easy enough, right? I was sure (read: overconfident) that the problem would only take a couple of minutes to solve, only to find it was a much deeper well than I’d assumed.</p>\n<p>Before we dive in, let’s take a quick look at the initial markup and CSS to see what we’re working with:</p>\n<pre><code>&lt;body&gt;\n  &lt;header class=\"header\"&gt;Header Content&lt;/header&gt;\n  &lt;section class=\"hero\"&gt;Hero Content&lt;/section&gt;\n  &lt;main class=\"main\"&gt;Main Content&lt;/main&gt;\n&lt;/body&gt;\n</code></pre>\n\n<pre><code>.header {\n  position: sticky;\n  top: 0; /* Offset, otherwise it won't stick! */\n}\n\n/* etc. */\n</code></pre>\n\n<p>With those declarations, the <code>.header</code> will stick to the top of the page. And yet the <code>.hero</code> element below it remains intrinsically sized. This is what we want to change.</p>\nThe Low-Hanging Fruit\n<p>The first impulse you might have, as I did, is to enclose the header and hero in some sort of parent container and give that container <code>100vh</code> to make it span the viewport. After that, we could use Flexbox to distribute the children and make the hero grow to fill the remaining space.</p>\n<pre><code>&lt;body&gt;\n  &lt;div class=\"container\"&gt;\n    &lt;header class=\"header\"&gt;Header Content&lt;/header&gt;\n    &lt;section class=\"hero\"&gt;Hero Content&lt;/section&gt;\n  &lt;/div&gt;\n  &lt;main class=\"main\"&gt;Main Content&lt;/main&gt;\n&lt;/body&gt;\n</code></pre>\n\n<pre><code>.container {\n  height: 100vh;\n  display: flex;\n  flex-direction: column;\n}\n\n.hero {\n  flex-grow: 1;\n}\n\n/* etc. */\n</code></pre>\n\n<p>This looks correct at first glance, but watch what happens when scrolling past the hero.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/yLdQgQo\">Attempt #1: Container + Flexbox [forked]</a> by <a href=\"https://codepen.io/Phendan\">Philip</a>.</p>\n<p><strong>The sticky header gets trapped in its parent container!</strong> But.. <em>why</em>?</p>\n<p>If you’re anything like me, this behavior is unintuitive, at least initially. You may have heard that <a href=\"https://css-tricks.com/almanac/properties/p/position/#aa-values\"><code>sticky</code> is a combination of <code>relative</code> and <code>fixed</code> positioning</a>, meaning it participates in the normal flow of the document but only until it hits the edges of its scrolling container, at which point it becomes <code>fixed</code>. While viewing <code>sticky</code> as a combination of other values can be a useful mnemonic, it fails to capture one important difference between <code>sticky</code> and <code>fixed</code> elements:</p>\n<p><strong>A <code>position: fixed</code> element doesn’t care about the parent it’s nested in or any of its ancestors.</strong> It will break out of the normal flow of the document and place itself directly offset from the viewport, as though glued in place a certain distance from the edge of the screen.</p>\n<p><strong>Conversely, a <code>position: sticky</code> element will be pushed along with the edges of the viewport (or next closest scrolling container), but it will never escape the boundaries of its direct parent.</strong> Well, at least if you don’t count visually <code>transform</code>-ing it. So a better way to think about it might be, <a href=\"https://css-tricks.com/sticky-as-a-local-fixed/\">to steal from Chris Coyier</a>, that “<code>position: sticky</code> is, in a sense, a locally scoped <code>position: fixed</code>.” This is an intentional design decision, one that allows for section-specific sticky headers like the ones made famous by alphabetical lists in mobile interfaces.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/OJeaWrM\">Sticky Section Headers [forked]</a> by <a href=\"https://codepen.io/Phendan\">Philip</a>.</p>\n<p>Okay, so this approach is a no-go for our predicament. We need to find a solution that doesn’t involve a container around the header.</p>\nFixed, But Not Solved\n<p>Maybe we can make our lives a bit simpler. Instead of a container, what if we gave the <code>.header</code> element a <em>fixed</em> height of, say, <code>150px</code>? Then, all we have to do is define the <code>.hero</code> element’s height as <code>height: calc(100vh - 150px)</code>.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/yLdQgGz\">Attempt #2: Fixed Height + Calc() [forked]</a> by <a href=\"https://codepen.io/Phendan\">Philip</a>.</p>\n<p>This approach <em>kinda</em> works, but the downsides are more insidious than our last attempt because they may not be immediately apparent. You probably noticed that the header is too tall, and we’d wanna do some math to decide on a better height.</p>\n<p>Thinking ahead a bit,</p>\n<ul>\n<li>What if the <code>.header</code>’s children need to wrap or rearrange themselves at different screen sizes or grow to maintain legibility on mobile?</li>\n<li>What if JavaScript is manipulating the contents?</li>\n</ul>\n<p>All of these things could subtly change the <code>.header</code>’s ideal size, and chasing the right height values for each scenario has the potential to spiral into a maintenance nightmare of unmanageable breakpoints and magic numbers — especially if we consider this needs to be done not only for the <code>.header</code> but also the <code>.hero</code> element that depends on it.</p>\n<p>I would argue that this workaround also just <em>feels</em> wrong. Fixed heights break one of the main affordances of CSS layout — the way elements automatically grow and shrink to adapt to their contents — and not relying on this usually makes our lives <em>harder</em>, not simpler.</p>\n<p>So, we’re left with…</p>\nA Novel Approach\n<p>Now that we’ve figured out the constraints we’re working with, another way to phrase the problem is that we want the <code>.header</code> and <code>.hero</code> to <em>collectively</em> span <code>100vh</code> without sizing the elements explicitly or wrapping them in a container. Ideally, we’d find <em>something</em> that already is <code>100vh</code> and align them to that. This is where it dawned on me that <code>display: grid</code> may provide just what we need!</p>\n<p>Let’s try this: We declare <code>display: grid</code> on the <code>body</code> element and add another element before the <code>.header</code> that we’ll call <code>.above-the-fold-spacer</code>. This new element gets a height of <code>100vh</code> and spans the grid’s entire width. Next, we’ll tell our spacer that it should take up two grid rows and we’ll anchor it to the top of the page.</p>\n<p>This element must be entirely empty because we don’t ever want it to be visible or to register to screen readers. We’re merely using it as a crutch to tell the grid how to behave.</p>\n<div>\n<pre><code>&lt;body&gt;\n  &lt;!-- This spacer provides the height we want --&gt;\n  &lt;div class=\"above-the-fold-spacer\"&gt;&lt;/div&gt;\n\n  &lt;!-- These two elements will place themselves on top of the spacer --&gt;\n  &lt;header class=\"header\"&gt;Header Content&lt;/header&gt;\n  &lt;section class=\"hero\"&gt;Hero Content&lt;/section&gt;\n\n  &lt;!-- The rest of the page stays unaffected --&gt;\n  &lt;main class=\"main\"&gt;Main Content&lt;/main&gt;\n&lt;/body&gt;\n</code></pre>\n</div>\n\n<pre><code>body {\n  display: grid;\n}\n\n.above-the-fold-spacer {\n  height: 100vh;\n  /* Span from the first to the last grid column line */\n  /* (Negative numbers count from the end of the grid) */\n  grid-column: 1 / -1;\n  /* Start at the first grid row line, and take up 2 rows */\n  grid-row: 1 / span 2; \n}\n\n/* etc. */\n</code></pre>\n\n<p><em>This</em> is the magic ingredient.</p>\n<p>By adding the spacer, we’ve created two grid rows that <em>together</em> take up exactly <code>100vh</code>. Now, all that’s left to do, in essence, is to tell the <code>.header</code> and <code>.hero</code> elements to align themselves to those existing rows. We do have to tell them to start at the same grid column line as the <code>.above-the-fold-spacer</code> element so that they won’t try to sit next to it. But with that done… <em>ta-da!</em></p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/YzoRNdo\">The Solution: Grid Alignment [forked]</a> by <a href=\"https://codepen.io/Phendan\">Philip</a>.</p>\n<p>The reason this works is that <strong>a grid container can have multiple children occupying the same cell overlaid on top of each other</strong>. In a situation like that, the tallest child element defines the grid row’s overall height — or, in this case, the combined height of the two rows (<code>100vh</code>).</p>\n<p>To control how exactly the two visible elements divvy up the available space between themselves, we can use the <code>grid-template-rows</code> property. I made it so that the first row uses <code>min-content</code> rather than <code>1fr</code>. This is necessary so that the <code>.header</code> doesn’t take up the same amount of space as the <code>.hero</code> but instead only takes what it needs and lets the hero have the rest.</p>\n<p>Here’s our full solution:</p>\n<pre><code>\nbody {\n  display: grid;\n  grid-template-rows: min-content 1fr;\n}\n\n.above-the-fold-spacer {\n  height: 100vh;\n  grid-column: 1 / -1;\n  grid-row: 1 / span 2;\n}\n\n.header {\n  position: sticky;\n  top: 0;\n  grid-column-start: 1;\n  grid-row-start: 1;\n}\n\n.hero {\n  grid-column-start: 1;\n  grid-row-start: 2;\n}\n</code></pre>\n\n<p>And voila: A sticky header of arbitrary size above a hero that grows to fill the remaining visible space!</p>\nCaveats and Final Thoughts\n<p>It’s worth noting that <strong>the HTML order of the elements matters here</strong>. If we define <code>.above-the-fold-spacer</code> after our <code>.hero</code> section, it will overlay and block access to the elements underneath. We can work around this by declaring either <code>order: -1</code>, <code>z-index: -1</code>, or <code>visibility: hidden</code>.</p>\n<p>Keep in mind that this is a simple example. If you were to add a sidebar to the left of your page, for example, you’d need to adjust at which column the elements start. Still, in the majority of cases, using a CSS Grid approach is likely to be less troublesome than the Sisyphean task of manually managing and coordinating the height values of multiple elements.</p>\n<p>Another upside of this approach is that it’s <strong>adaptable</strong>. If you decide you want a group of three elements to take up the screen’s height rather than two, then you’d make the invisible spacer span three rows and assign the visible elements to the appropriate one. Even if the hero element’s content causes its height to exceed <code>100vh</code>, the grid adapts without breaking anything. It’s even well-supported in all modern browsers.</p>\n<p>The more I think about this technique, the more I’m persuaded that it’s actually quite clean. Then again, you know how lawyers can talk themselves into their own arguments? If you can think of an even simpler solution I’ve overlooked, feel free to reach out and let me know!</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"fa1d139f84a2af7cc311d822801dbbb7ad895a18170ad8a544827c19a3fa0069","category":"Tech"}