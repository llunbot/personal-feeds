{"title":"CSS min() All The Things","link":"https://smashingmagazine.com/2024/10/css-min-all-the-things/","date":1729159200000,"content":"<p>Did you see <a href=\"https://frontendmasters.com/blog/what-if-you-used-container-units-for-everything/\">this post</a> that Chris Coyier published back in August? He experimented with CSS container query units, going all in and using them for every single numeric value in a demo he put together. And <a href=\"https://codepen.io/chriscoyier/pen/OJYKLXz\">the result</a> was‚Ä¶ not too bad, actually.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/ExqWXOQ\">Container Units for All Units [forked]</a> by <a href=\"https://codepen.io/chriscoyier\">Chris Coyier</a>.  </p>\n<p>What I found interesting about this is how it demonstrates the complexity of sizing things. We‚Äôre constrained to absolute and relative units in CSS, so we‚Äôre either stuck at a specific size (e.g., <code>px</code>) or computing the size based on sizing declared on another element (e.g., <code>%</code>, <code>em</code>, <code>rem</code>, <code>vw</code>, <code>vh</code>, and so on). Both come with compromises, so it‚Äôs not like there is a ‚Äúcorrect‚Äù way to go about things ‚Äî it‚Äôs about the element‚Äôs context ‚Äî and leaning heavily in any one direction doesn‚Äôt remedy that.</p>\n<p>I thought I‚Äôd try my own experiment but with the CSS <code>min()</code> function instead of container query units. Why? Well, first off, we can supply the function with <strong>any type of length unit we want</strong>, which makes the approach a little more flexible than working with one type of unit. But the real reason I wanted to do this is personal interest more than anything else.</p>\nThe Demo\n<p>I won‚Äôt make you wait for the end to see how my <code>min()</code> experiment went:</p>\n<p></p><blockquote><p>Taking website responsiveness to a whole new level üåê <a href=\"https://t.co/pKmHl5d0Dy\">pic.twitter.com/pKmHl5d0Dy</a></p>‚Äî Vayo (@vayospot) <a href=\"https://twitter.com/vayospot/status/1630863145014112257?ref_src=twsrc%5Etfw\">March 1, 2023</a></blockquote> <p></p>\n<p><br /></p>\n<p>We‚Äôll talk about that more after we walk through the details.</p>\nA Little About <code>min()</code>\n<p>The <code>min()</code> function takes two values and applies the smallest one, whichever one happens to be in the element‚Äôs context. For example, we can say we want an element to be as wide as <code>50%</code> of whatever container it is in. And if <code>50%</code> is <em>greater</em> than, say <code>200px</code>, cap the width there instead.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/LYwWLMg\">[forked]</a> by <a href=\"https://codepen.io/geoffgraham\">Geoff Graham</a>.</p>\n<p>So, <code>min()</code> is sort of like container query units in the sense that it is aware of how much available space it has in its container. But it‚Äôs different in that <code>min()</code> isn‚Äôt querying its container dimensions to compute the final value. We supply it with two acceptable lengths, and it determines which is best given the context. That makes <code>min()</code> (and <code>max()</code> for that matter) <strong>a useful tool for responsive layouts that adapt to the viewport‚Äôs size</strong>. It uses conditional logic to determine the ‚Äúbest‚Äù match, which means it can help adapt layouts without needing to reach for CSS media queries.</p>\n<pre><code>.element {\n  width: min(200px, 50%);\n}\n\n/* Close to this: */\n.element {\n  width: 200px;\n\n  @media (min-width: 600px) {\n    width: 50%;\n  }\n}\n</code></pre>\n\n<p>The difference between <code>min()</code> and <code>@media</code> in that example is that we‚Äôre telling the browser to set the element‚Äôs width to <code>50%</code> at a specific <em>breakpoint</em> of <code>600px</code>. With <code>min()</code>, it switches things up automatically as the amount of available space changes, whatever viewport size that happens to be.</p>\n<p>When I use the <code>min()</code>, I think of it as having the ability to make smart decisions based on context. We don‚Äôt have to do the thinking or calculations to determine which value is used. However, using <code>min()</code> coupled with just any CSS unit isn‚Äôt enough. For instance, relative units work better for responsiveness than absolute units. You might even think of <code>min()</code> as <a href=\"https://css-tricks.com/min-max-and-clamp-are-css-magic/\">setting a <em>maximum</em> value</a> in that it never goes below the first value but also caps itself at the second value.</p>\n<p>I mentioned earlier that we could use any type of unit in <code>min()</code>. Let‚Äôs take the same approach that Chris did and lean heavily into a type of unit to see how <code>min()</code> behaves when it is used exclusively for a responsive layout. Specifically, we‚Äôll use <strong>viewport units</strong> as they are directly relative to the size of the viewport.</p>\n<p>Now, there are different flavors of viewport units. We can use the viewport‚Äôs width (<code>vw</code>) and height (<code>vh</code>). We also have the <code>vmin</code> and <code>vmax</code> units that are slightly more intelligent in that they evaluate an element‚Äôs width and height and apply either the smaller (<code>vmin</code>) or larger (<code>vmax</code>) of the two. So, if we declare <code>100vmax</code> on an element, and that element is <code>500px</code> wide by <code>250px</code> tall, the unit computes to <code>500px</code>.</p>\n<p>That is how I am approaching this experiment. What happens if we eschew media queries in favor of only using <code>min()</code> to establish a responsive layout and lean into viewport units to make it happen? We‚Äôll take it one piece at a time.</p>\nFont Sizing\n<p>There are various approaches for responsive type. Media queries are quickly becoming the ‚Äúold school‚Äù way of doing it:</p>\n<pre><code>p { font-size: 1.1rem; }\n\n@media (min-width: 1200px) {\n  p { font-size: 1.2rem; }\n}\n\n@media (max-width: 350px) {\n  p { font-size: 0.9rem; }\n}\n</code></pre>\n\n<p>Sure, this works, but what happens when the user uses a 4K monitor? Or a foldable phone? There are other tried and true approaches; in fact, <a href=\"https://www.smashingmagazine.com/2023/11/addressing-accessibility-concerns-fluid-type/\"><code>clamp()</code> is the prevailing go-to</a>. But we‚Äôre leaning all-in on <code>min()</code>. As it happens, just one line of code is all we need to wipe out all of those media queries, substantially reducing our code:</p>\n<pre><code>p { font-size: min(6vmin, calc(1rem + 0.23vmax)); }\n</code></pre>\n\n<p>I‚Äôll walk you through those values‚Ä¶</p>\n<ol>\n<li><code>6vmin</code> is essentially 6% of the browser‚Äôs width or height, whichever is smallest. This allows the font size to shrink as much as needed for smaller contexts.</li>\n<li>For <code>calc(1rem + 0.23vmax)</code>, <code>1rem</code> is the base font size, and <code>0.23vmax</code> is a tiny fraction of the viewport‚Äòs width or height, whichever happens to be the largest.</li>\n<li>The <code>calc()</code> function adds those two values together. Since <code>0.23vmax</code> is evaluated differently depending on which viewport edge is the largest, it‚Äôs crucial when it comes to scaling the font size between the two arguments. I‚Äôve tweaked it into something that scales gradually one way or the other rather than blowing things up as the viewport size increases.</li>\n<li>Finally, the <code>min()</code> returns the smallest value suitable for the font size of the current screen size.</li>\n</ol>\n<p>And speaking of how flexible the <code>min()</code> approach is, it can restrict how far the text grows. For example, we can cap this at a maximum <code>font-size</code> equal to <code>2rem</code> as a third function parameter:</p>\n<pre><code>p { font-size: min(6vmin, calc(1rem + 0.23vmax), 2rem); }\n</code></pre>\n\n<p>This isn‚Äôt a silver bullet tactic. I‚Äôd say it‚Äôs probably best used for body text, like paragraphs. We might want to adjust things a smidge for headings, e.g., <code>&lt;h1&gt;</code>:</p>\n<pre><code>h1 { font-size: min(7.5vmin, calc(2rem + 1.2vmax)); }\n</code></pre>\n\n<p>We‚Äôve bumped up the minimum size from <code>6vmin</code> to <code>7.5vmin</code> so that it stays larger than the body text at any viewport size. Also, in the <code>calc()</code>, the base size is now <code>2rem</code>, which is smaller than the default UA styles for <code>&lt;h1&gt;</code>. We‚Äôre using <code>1.2vmax</code> as the multiplier this time, meaning it grows more than the body text, which is multiplied by a smaller value, <code>.023vmax</code>.</p>\n<p>This works for me. You can always tweak these values and see which works best for your use. Whatever the case, the <code>font-size</code> for this experiment is completely fluid and completely based on the <code>min()</code> function, adhering to my self-imposed constraint.</p>\nMargin And Padding\n<p>Spacing is a big part of layout, responsive or not. We need <code>margin</code> and <code>padding</code> to properly situate elements alongside other elements and give them breathing room, both inside and outside their box.</p>\n<p>We‚Äôre going all-in with <code>min()</code> for this, too. We could use absolute units, like pixels, but those aren‚Äôt exactly responsive.</p>\n<p><code>min()</code> can combine relative and absolute units so they are more effective. Let‚Äôs pair <code>vmin</code> with <code>px</code> this time:</p>\n<pre><code>div { margin: min(10vmin, 30px); }\n</code></pre>\n\n<p><code>10vmin</code> is likely to be smaller than <code>30px</code> when viewed on a small viewport. That‚Äôs why I‚Äôm allowing the margin to shrink dynamically this time around. As the viewport size increases, whereby <code>10vmin</code> exceeds <code>30px</code>, <code>min()</code> caps the value at <code>30px</code>, going no higher than that.</p>\n<p>Notice, too, that I didn‚Äôt reach for <code>calc()</code> this time. Margins don‚Äôt really need to grow indefinitely with screen size, as too much spacing between containers or elements generally looks awkward on larger screens. This concept also works extremely well for padding, but we don‚Äôt have to go there. Instead, it might be better to stick with a single unit, preferably <code>em</code>, since it is relative to the element‚Äôs <code>font-size</code>. We can essentially ‚Äúpass‚Äù the work that <code>min()</code> is doing on the <code>font-size</code> to the <code>margin</code> and <code>padding</code> properties because of that.</p>\n<pre><code>.card-info {\n  font-size: min(6vmin, calc(1rem + 0.12vmax));\n  padding: 1.2em;\n}\n</code></pre>\n\n<p>Now, padding scales with the <code>font-size</code>, which is powered by <code>min()</code>.</p>\nWidths\n<p>Setting <code>width</code> for a responsive design doesn‚Äôt have to be complicated, right? We could simply use a single percentage or viewport unit value to specify how much available horizontal space we want to take up, and the element will adjust accordingly. Though, container query units could be a happy path outside of this experiment.</p>\n<p>But we‚Äôre <code>min()</code> all the way!</p>\n<p><code>min()</code> comes in handy when setting constraints on how much an element responds to changes. We can set an upper limit of <code>650px</code> and, if the computed width tries to go larger, have the element settle at a full width of <code>100%</code>:</p>\n<pre><code>.container { width: min(100%, 650px); }\n</code></pre>\n\n<p>Things get interesting with text width. When the width of a text box is too long, it becomes uncomfortable to read through the texts. There are competing theories about how many characters per line of text is best for an optimal reading experience. For the sake of argument, let‚Äôs say that number should be between 50-75 characters. In other words, we ought to pack no more than 75 characters on a line, and we can do that with the <code>ch</code> unit, which is based on the <code>0</code> character‚Äôs size for whatever font is in use.</p>\n<pre><code>p {\n  width: min(100%, 75ch);\n}\n</code></pre>\n\n<p>This code basically says: <em>get as wide as needed but never wider than 75 characters.</em></p>\nSizing Recipes Based On <code>min()</code>\n<p>Over time, with a lot of tweaking and modifying of values, I have drafted a list of pre-defined values that I find work well for responsively styling different properties:</p>\n<pre><code>:root {\n  --font-size-6x: min(7.5vmin, calc(2rem + 1.2vmax));\n  --font-size-5x: min(6.5vmin, calc(1.1rem + 1.2vmax));\n  --font-size-4x: min(4vmin, calc(0.8rem + 1.2vmax));\n  --font-size-3x: min(6vmin, calc(1rem + 0.12vmax));\n  --font-size-2x: min(4vmin, calc(0.85rem + 0.12vmax));\n  --font-size-1x: min(2vmin, calc(0.65rem + 0.12vmax));\n  --width-2x: min(100vw, 1300px);\n  --width-1x: min(100%, 1200px);\n  --gap-3x: min(5vmin, 1.5rem);\n  --gap-2x: min(4.5vmin, 1rem);\n  --size-10x: min(15vmin, 5.5rem);\n  --size-9x: min(10vmin, 5rem);\n  --size-8x: min(10vmin, 4rem);\n  --size-7x: min(10vmin, 3rem);\n  --size-6x: min(8.5vmin, 2.5rem);\n  --size-5x: min(8vmin, 2rem);\n  --size-4x: min(8vmin, 1.5rem);\n  --size-3x: min(7vmin, 1rem);\n  --size-2x: min(5vmin, 1rem);\n  --size-1x: min(2.5vmin, 0.5rem);\n}\n</code></pre>\n\n<p>This is how I approached my experiment because it helps me know what to reach for in a given situation:</p>\n<pre><code>h1 { font-size: var(--font-size-6x); }\n\n.container {\n  width: var(--width-2x);\n  margin: var(--size-2x);\n}\n\n.card-grid { gap: var(--gap-3x); }\n</code></pre>\n\n<p>There we go! We have a heading that scales flawlessly, a container that‚Äôs responsive and never too wide, and a grid with dynamic spacing ‚Äî all without a single media query. The <code>--size-</code> properties declared in the variable list are the most versatile, as they can be used for properties that require scaling, e.g., margins, paddings, and so on.</p>\nThe Final Result, Again\n<p>I shared a video of the result, but here‚Äôs a link to the demo.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/wvVdPxL\">min() website [forked]</a> by <a href=\"https://codepen.io/vayospot\">Vayo</a>.  </p>\n<p>So, is <code>min()</code> the be-all, end-all for responsiveness? Absolutely not. Neither is a diet consisting entirely of container query units. I mean, it‚Äôs cool that we can scale an entire webpage like this, but the web is never a one-size-fits-all beanie.</p>\n<p>If anything, I think this and what Chris demoed are <strong>warnings against dogmatic approaches to web design</strong> as a whole, not solely unique to responsive design. CSS features, including length units and functions, are tools in a larger virtual toolshed. Rather than getting too cozy with one feature or technique, explore the shed because you might find a better tool for the job.</p>","author":"","siteTitle":"Articles on Smashing Magazine ‚Äî For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"20e840aee08410b15ca0104aef4c465b3f97806bda9bedd3e709f462677ea44e","category":"Tech"}