{"title":"Adaptive Video Streaming With Dash.js In React","link":"https://smashingmagazine.com/2025/03/adaptive-video-streaming-dashjs-react/","date":1743080400000,"content":"<p>I was recently tasked with creating video reels that needed to be played smoothly under a slow network or on low-end devices. I started with the native HTML5 <code>&lt;video&gt;</code> tag but quickly hit a wall — it just doesn’t cut it when connections are slow or devices are underpowered.</p>\n<p>After some research, I found that <strong>adaptive bitrate streaming</strong> was the solution I needed. But here’s the frustrating part: finding a comprehensive, beginner-friendly guide was so difficult. The resources on MDN and other websites were helpful but lacked the end-to-end tutorial I was looking for.</p>\n<p>That’s why I’m writing this article: to provide you with the step-by-step guide I wish I had found. I’ll bridge the gap between writing FFmpeg scripts, encoding video files, and implementing the DASH-compatible video player (<a href=\"https://dashjs.org/\">Dash.js</a>) with code examples you can follow.</p>\nGoing Beyond The Native HTML5 <code>&lt;video&gt;</code> Tag\n<p>You might be wondering why you can’t simply rely on the HTML <code>&lt;video&gt;</code> element. There’s a good reason for that. Let’s compare the difference between a native <code>&lt;video&gt;</code> element and adaptive video streaming in browsers.</p>\n<h3>Progressive Download</h3>\n<p>With progressive downloading, your browser downloads the video file linearly from the server over HTTP and starts playback as long as it has buffered enough data. This is the default behavior of the <code>&lt;video&gt;</code> element.</p>\n<pre><code>&lt;video src=\"rabbit320.mp4\" /&gt;\n</code></pre>\n\n<p>When you play the video, check your browser’s network tab, and you’ll see multiple requests with the <code>206 Partial Content</code> status code.</p>\n<p><img src=\"https://files.smashing.media/articles/adaptive-video-streaming-dashjs-react/http-206-range-requests.png\" /></p>\n<p>It uses <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests\">HTTP 206 Range Requests</a> to fetch the video file in chunks. The server sends specific byte ranges of the video to your browser. When you seek, the browser will make more range requests asking for new byte ranges (e.g., “Give me bytes 1,000,000–2,000,000”). </p>\n<p>In other words, it doesn’t fetch the entire file all at once. Instead, it delivers partial byte ranges from the single MP4 video file on demand. This is still considered a <strong>progressive download</strong> because only a single file is fetched over HTTP — there is no bandwidth or quality adaptation.</p>\n<p>If the server or browser doesn’t support range requests, the entire video file will be downloaded in a single request, returning a <code>200 OK</code> status code. In that case, the video can only begin playing once the entire file has finished downloading.</p> \n\n<p><strong>The problems?</strong> If you’re on a slow connection trying to watch high-resolution video, you’ll be waiting a long time before playback starts.</p>\n<h3>Adaptive Bitrate Streaming</h3>\n<p>Instead of serving one single video file, <strong>adaptive bitrate (ABR) streaming</strong> splits the video into multiple segments at different bitrates and resolutions. During playback, the ABR algorithm will automatically select the highest quality segment that can be downloaded in time for smooth playback based on your network connectivity, bandwidth, and other device capabilities. It continues adjusting throughout to adapt to changing conditions.</p>\n<p>This magic happens through two key browser technologies:</p>\n<ul>\n<li><strong>Media Source Extension (MSE)</strong><br />It allows passing a <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaSource\">MediaSource</a> object to the <code>src</code> attribute in <code>&lt;video&gt;</code>, enabling sending multiple <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer\">SourceBuffer</a> objects that represent video segments.</li>\n</ul>\n<div>\n<pre><code>&lt;video src=\"blob:<a href=\"https://example.com/6e31fe2a-a0a8-43f9-b415-73dc02985892&quot;\">https://example.com/6e31fe2a-a0a8-43f9-b415-73dc02985892\"</a> /&gt;</code></pre>\n</div>\n\n<ul>\n<li><strong>Media Capabilities API</strong><br />It provides information on your device’s video decoding and encoding abilities, enabling ABR to make informed decisions about which resolution to deliver.</li>\n</ul>\n<p>Together, they enable the core functionality of ABR, serving video chunks optimized for your specific device limitations in real time.</p>\nStreaming Protocols: MPEG-DASH Vs. HLS\n<p>As mentioned above, to stream media adaptively, a video is split into chunks at different quality levels across various time points. We need to facilitate the process of switching between these segments adaptively in real time. To achieve this, ABR streaming relies on specific protocols. The two most common ABR protocols are:</p>\n<ul>\n<li>MPEG-DASH,</li>\n<li>HTTP Live Streaming (HLS).</li>\n</ul>\n<p>Both of these protocols utilize HTTP to send video files. Hence, they are compatible with HTTP web servers.</p>\n<p>This article focuses on MPEG-DASH. However, it’s worth noting that DASH isn’t supported by Apple devices or browsers, as mentioned in <a href=\"https://www.mux.com/articles/hls-vs-dash-what-s-the-difference-between-the-video-streaming-protocols\">Mux’s article</a>.</p>\n<h3>MPEG-DASH</h3>\n<p>MPEG-DASH enables adaptive streaming through:</p>\n<ul>\n<li><strong>A Media Presentation Description (MPD) file</strong><br />This XML manifest file contains information on how to select and manage streams based on adaptive rules.</li>\n<li><strong>Segmented Media Files</strong><br />Video and audio files are divided into segments at different resolutions and durations using MPEG-DASH-compliant codecs and formats.</li>\n</ul>\n<p>On the client side, a DASH-compliant video player reads the MPD file and continuously monitors network bandwidth. Based on available bandwidth, the player selects the appropriate bitrate and requests the corresponding video chunk. This process repeats throughout playback, ensuring smooth, optimal quality.</p>\n<p>Now that you understand the fundamentals, let’s build our adaptive video player!</p>\nSteps To Build an Adaptive Bitrate Streaming Video Player\n<p>Here’s the plan:</p>\n<ol>\n<li>Transcode the MP4 video into audio and video renditions at different resolutions and bitrates with FFmpeg.</li>\n<li>Generate an MPD file with FFmpeg.</li>\n<li>Serve the output files from the server.</li>\n<li>Build the DASH-compatible video player to play the video.</li>\n</ol>\n<h3>Install FFmpeg</h3>\n<p>For macOS users, install FFmpeg using Brew by running the following command in your terminal:</p>\n<pre><code>brew install ffmpeg\n</code></pre>\n\n<p>For other operating systems, please <a href=\"https://www.ffmpeg.org/download.html\">refer to FFmpeg’s documentation</a>.</p>\n<h3>Generate Audio Rendition</h3>\n<p>Next, run the following script to extract the audio track and encode it in WebM format for DASH compatibility:</p>\n<div>\n<pre><code>ffmpeg -i \"input_video.mp4\" -vn -acodec libvorbis -ab 128k \"audio.webm\"\n</code></pre>\n</div>\n\n<ul>\n<li><code>-i \"input_video.mp4\"</code>: Specifies the input video file.</li>\n<li><code>-vn</code>: Disables the video stream (audio-only output).</li>\n<li><code>-acodec libvorbis</code>: Uses the <a href=\"https://ffmpeg.org/ffmpeg-codecs.html#libvorbis\"><strong>libvorbis</strong></a> codec to encode audio.</li>\n<li><code>-ab 128k</code>: Sets the audio bitrate to <strong>128 kbps</strong>.</li>\n<li><code>\"audio.webm\"</code>: Specifies the output audio file in WebM format.</li>\n</ul>\n<h3>Generate Video Renditions</h3>\n<p>Run this script to create three video renditions with varying resolutions and bitrates. The largest resolution should match the input file size. For example, if the input video is <strong>576×1024</strong> at 30 frames per second (fps), the script generates renditions optimized for vertical video playback.</p>\n<div>\n<pre><code>ffmpeg -i \"input_video.mp4\" -c:v libvpx-vp9 -keyint_min 150 -g 150 \\\n-tile-columns 4 -frame-parallel 1 -f webm \\\n-an -vf scale=576:1024 -b:v 1500k \"input_video_576x1024_1500k.webm\" \\\n-an -vf scale=480:854 -b:v 1000k \"input_video_480x854_1000k.webm\" \\\n-an -vf scale=360:640 -b:v 750k \"input_video_360x640_750k.webm\"\n</code></pre>\n</div>\n\n<ul>\n<li><code>-c:v libvpx-vp9</code>: Uses the <a href=\"https://trac.ffmpeg.org/wiki/Encode/VP9\"><strong>libvpx-vp9</strong></a> as the VP9 video encoder for WebM.</li>\n<li><code>-keyint_min 150</code> and <code>-g 150</code>: Set a <strong>150-frame keyframe interval</strong> (approximately every 5 seconds at 30 fps). This allows bitrate switching every 5 seconds.</li>\n<li><code>-tile-columns 4</code> and <code>-frame-parallel 1</code>: Optimize encoding performance through parallel processing.</li>\n<li><code>-f webm</code>: Specifies the output format as WebM.</li>\n</ul>\n<p>In each rendition:</p>\n<ul>\n<li><code>-an</code>: Excludes audio (video-only output).</li>\n<li><code>-vf scale=576:1024</code>: Scales the video to a resolution of <strong>576x1024</strong> pixels.</li>\n<li><code>-b:v 1500k</code>: Sets the video bitrate to <strong>1500 kbps</strong>.</li>\n</ul>\n<p>WebM is chosen as the output format, as they are smaller in size and optimized yet widely compatible with most web browsers.</p>\n<h3>Generate MPD Manifest File</h3>\n<p>Combine the video renditions and audio track into a DASH-compliant MPD manifest file by running the following script:</p>\n<div>\n<pre><code>ffmpeg \\\n  -f webm_dash_manifest -i \"input_video_576x1024_1500k.webm\" \\\n  -f webm_dash_manifest -i \"input_video_480x854_1000k.webm\" \\\n  -f webm_dash_manifest -i \"input_video_360x640_750k.webm\" \\\n  -f webm_dash_manifest -i \"audio.webm\" \\\n  -c copy \\\n  -map 0 -map 1 -map 2 -map 3 \\\n  -f webm_dash_manifest \\\n  -adaptation_sets \"id=0,streams=0,1,2 id=1,streams=3\" \\\n  \"input_video_manifest.mpd\"\n</code></pre>\n</div>\n\n<ul>\n<li><code>-f webm_dash_manifest -i \"…\"</code>: Specifies the inputs so that the ASH video player will switch between them dynamically based on network conditions.</li>\n<li><code>-map 0 -map 1 -map 2 -map 3</code>: Includes all video (0, 1, 2) and audio (3) in the final manifest.</li>\n<li><code>-adaptation_sets</code>: Groups streams into adaptation sets:<ul>\n<li><code>id=0,streams=0,1,2</code>: Groups the video renditions into a single adaptation set.</li>\n<li><code>id=1,streams=3</code>: Assigns the audio track to a separate adaptation set.</li>\n</ul>\n</li>\n</ul>\n<p>The resulting MPD file (<code>input_video_manifest.mpd</code>) describes the streams and enables adaptive bitrate streaming in MPEG-DASH.</p>\n<div>\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;MPD\n  xmlns:xsi=\"<a href=\"http://www.w3.org/2001/XMLSchema-instance&quot;\">http://www.w3.org/2001/XMLSchema-instance\"</a>\n  xmlns=\"urn:mpeg:DASH:schema:MPD:2011\"\n  xsi:schemaLocation=\"urn:mpeg:DASH:schema:MPD:2011\"\n  type=\"static\"\n  mediaPresentationDuration=\"PT81.166S\"\n  minBufferTime=\"PT1S\"\n  profiles=\"urn:mpeg:dash:profile:webm-on-demand:2012\"&gt;\n\n  &lt;Period id=\"0\" start=\"PT0S\" duration=\"PT81.166S\"&gt;\n    &lt;AdaptationSet\n      id=\"0\"\n      mimeType=\"video/webm\"\n      codecs=\"vp9\"\n      lang=\"eng\"\n      bitstreamSwitching=\"true\"\n      subsegmentAlignment=\"false\"\n      subsegmentStartsWithSAP=\"1\"&gt;\n\n      &lt;Representation id=\"0\" bandwidth=\"1647920\" width=\"576\" height=\"1024\"&gt;\n        &lt;BaseURL&gt;input_video_576x1024_1500k.webm&lt;/BaseURL&gt;\n        &lt;SegmentBase indexRange=\"16931581-16931910\"&gt;\n          &lt;Initialization range=\"0-645\" /&gt;\n        &lt;/SegmentBase&gt;\n      &lt;/Representation&gt;\n\n      &lt;Representation id=\"1\" bandwidth=\"1126977\" width=\"480\" height=\"854\"&gt;\n        &lt;BaseURL&gt;input_video_480x854_1000k.webm&lt;/BaseURL&gt;\n        &lt;SegmentBase indexRange=\"11583599-11583986\"&gt;\n          &lt;Initialization range=\"0-645\" /&gt;\n        &lt;/SegmentBase&gt;\n      &lt;/Representation&gt;\n\n      &lt;Representation id=\"2\" bandwidth=\"843267\" width=\"360\" height=\"640\"&gt;\n        &lt;BaseURL&gt;input_video_360x640_750k.webm&lt;/BaseURL&gt;\n        &lt;SegmentBase indexRange=\"8668326-8668713\"&gt;\n          &lt;Initialization range=\"0-645\" /&gt;\n        &lt;/SegmentBase&gt;\n      &lt;/Representation&gt;\n\n    &lt;/AdaptationSet&gt;\n\n    &lt;AdaptationSet\n      id=\"1\"\n      mimeType=\"audio/webm\"\n      codecs=\"vorbis\"\n      lang=\"eng\"\n      audioSamplingRate=\"44100\"\n      bitstreamSwitching=\"true\"\n      subsegmentAlignment=\"true\"\n      subsegmentStartsWithSAP=\"1\"&gt;\n\n      &lt;Representation id=\"3\" bandwidth=\"89219\"&gt;\n        &lt;BaseURL&gt;audio.webm&lt;/BaseURL&gt;\n        &lt;SegmentBase indexRange=\"921727-922055\"&gt;\n          &lt;Initialization range=\"0-4889\" /&gt;\n        &lt;/SegmentBase&gt;\n      &lt;/Representation&gt;\n\n    &lt;/AdaptationSet&gt;\n  &lt;/Period&gt;\n&lt;/MPD&gt;\n</code></pre>\n</div>\n\n<p>After completing these steps, you’ll have:</p>\n<ol>\n<li>Three video renditions (<code>576x1024</code>, <code>480x854</code>, <code>360x640</code>),</li>\n<li>One audio track, and</li>\n<li>An MPD manifest file.</li>\n</ol>\n<pre><code>input_video.mp4\naudio.webm\ninput_video_576x1024_1500k.webm\ninput_video_480x854_1000k.webm\ninput_video_360x640_750k.webm\ninput_video_manifest.mpd\n</code></pre>\n\n<p>The original video <code>input_video.mp4</code> should also be kept to serve as a fallback video source later.</p>\n<h3>Serve The Output Files</h3>\n<p>These output files can now be uploaded to cloud storage (e.g., AWS S3 or Cloudflare R2) for playback. While they can be served directly from a local folder, I highly recommend storing them in cloud storage and leveraging a CDN to cache the assets for better performance. Both AWS and Cloudflare support HTTP range requests out of the box.</p>\n<h3>Building The DASH-Compatible Video Player In React</h3>\n<p>There’s nothing like a real-world example to help understand how everything works. There are different ways we can implement a DASH-compatible video player, but I’ll focus on an approach using React.</p>\n<p>First, install the <a href=\"https://github.com/Dash-Industry-Forum/dash.js\">Dash.js</a> npm package by running:</p>\n<pre><code>npm i dashjs\n</code></pre>\n\n<p>Next, create a component called <code>&lt;DashVideoPlayer /&gt;</code> and initialize the Dash <a href=\"https://cdn.dashjs.org/latest/jsdoc/module-MediaPlayer.html\">MediaPlayer</a> instance by pointing it to the MPD file when the component mounts. </p>\n<p>The ref callback function runs upon the component mounting, and within the callback function, <code>playerRef</code> will refer to the actual Dash <a href=\"https://cdn.dashjs.org/latest/jsdoc/module-MediaPlayer.html\">MediaPlayer</a> instance and be bound with event listeners. We also include the original MP4 URL in the <code>&lt;source&gt;</code> element as a fallback if the browser doesn’t support MPEG-DASH.</p>\n<p>If you’re using <strong>Next.js app router</strong>, remember to add the <code>‘use client’</code> directive to enable client-side hydration, as the video player is only initialized on the client side.</p>\n\n<p>Here is the full example:</p>\n<div>\n<pre><code>import dashjs from 'dashjs'\nimport { useCallback, useRef } from 'react'\n\nexport const DashVideoPlayer = () =&gt; {\n  const playerRef = useRef()\n\n  const callbackRef = useCallback((node) =&gt; {\n    if (node !== null) {<br />      playerRef.current = dashjs.MediaPlayer().create()\n\n      playerRef.current.initialize(node, \"<a href=\"https://example.com/uri/to/input_video_manifest.mpd&quot;\">https://example.com/uri/to/input_video_manifest.mpd\"</a>, false)\n\n      playerRef.current.on('canPlay', () =&gt; {\n        // upon video is playable\n      })\n\n      playerRef.current.on('error', (e) =&gt; {\n        // handle error\n      })\n\n      playerRef.current.on('playbackStarted', () =&gt; {\n        // handle playback started\n      })\n\n      playerRef.current.on('playbackPaused', () =&gt; {\n        // handle playback paused\n      })\n\n      playerRef.current.on('playbackWaiting', () =&gt; {\n        // handle playback buffering\n      })\n    }\n  },[])\n\n  return (\n    &lt;video ref={callbackRef} width={310} height={548} controls&gt;\n      &lt;source src=\"<a href=\"https://example.com/uri/to/input_video.mp4&quot;\">https://example.com/uri/to/input_video.mp4\"</a> type=\"video/mp4\" /&gt;\n      Your browser does not support the video tag.\n    &lt;/video&gt;\n  )\n}</code></pre>\n</div>\n\n<h3>Result</h3>\n<p>Observe the changes in the video file when the network connectivity is adjusted from Fast 4G to 3G using Chrome DevTools. It switches from 480p to 360p, showing how the experience is optimized for more or less available bandwidth.</p>\nConclusion\n<p>That’s it! We just implemented a working DASH-compatible video player in React to establish a video with adaptive bitrate streaming. Again, the benefits of this are rooted in <strong>performance</strong>. When we adopt ABR streaming, we’re requesting the video in smaller chunks, allowing for more immediate playback than we’d get if we needed to fully download the video file first. And we’ve done it in a way that supports multiple versions of the same video, allowing us to serve the best format for the user’s device.</p>\n<h3>References</h3>\n<ul>\n<li>“<a href=\"https://www.zeng.dev/post/2023-http-range-and-play-mp4-in-browser/\">Http Range Request And MP4 Video Play In Browser</a>,” Zeng Xu</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/Media/Audio_and_video_delivery/Setting_up_adaptive_streaming_media_sources\">Setting up adaptive streaming media sources</a> (Mozilla Developer Network)</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/Media/DASH_Adaptive_Streaming_for_HTML_5_Video\">DASH Adaptive Streaming for HTML video</a> (Mozilla Developer Network)</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"fb6ba32bd390c9628015d4e4f3647214716b1a5b0df30acff7351d52a538ff2b","category":"Tech"}