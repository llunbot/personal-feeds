{"title":"บันทึกการนำแนวคิด 12-factors มาใช้ในการพัฒนาระบบงานด้วยภาษา Go","link":"https://www.somkiat.cc/summary-12-factors-with-go-and-docker/","date":1716285258000,"content":"<p><img width=\"150\" height=\"150\" src=\"https://www.somkiat.cc/wp-content/uploads/2024/05/go-docker-12-factor-150x150.jpeg\" loading=\"lazy\" srcset=\"https://www.somkiat.cc/wp-content/uploads/2024/05/go-docker-12-factor-150x150.jpeg 150w, https://www.somkiat.cc/wp-content/uploads/2024/05/go-docker-12-factor-75x75.jpeg 75w\" /></p>\n<figure><a href=\"https://www.somkiat.cc/wp-content/uploads/2024/05/go-docker-12-factor.jpeg\"><img src=\"https://www.somkiat.cc/wp-content/uploads/2024/05/go-docker-12-factor.jpeg\" width=\"508\" height=\"318\" /></a></figure>\n\n\n\n<p>แนว <strong><a href=\"https://12factor.net/\" target=\"_blank\">12-factors app</a></strong> นั้นเป็นแนวคิดที่สร้างมาผู้สร้างระบบ <a href=\"https://www.heroku.com/\" target=\"_blank\">Heroku</a><br />โดยถูกหยิบมาพูด หรือ ใช้งานมากขึ้นในยุคของ Cloud Native App<br />ประกอบไปด้วย 12 ข้อ และดูเหมือนว่าจะมีคนคิดเพิ่มมาอีก 3 เป็น 15 ข้อ<br />ผมเคยเขียน <a href=\"https://www.somkiat.cc/tag/12factor/\" target=\"_blank\">blog</a> อธิบายไว้เมื่อนานมาแล้ว<br />มาครั้งนี้มีคำถามจากการแบ่งปันเรื่อง Docker + Go + Microservices<br />ว่ามีตัวอย่างหรือไม่ จึงทำการสร้างตัวอย่างพร้อมอธิบายสั้น ๆ ไว้ให้<br />เพื่อช่วยให้เข้าใจมากยิ่งขึ้น<br />มาเริ่มกันเลย</p>\n\n\n\n<span></span>\n\n\n\n<p><strong>ระบบตัวอย่างจะใช้งานเครื่องมือเหล่านี้</strong></p>\n\n\n\n<ul>\n<li>ภาษา Go 1.22.3 ใช้งาน library <a href=\"https://gin-gonic.com/\">Gin web framework</a></li>\n\n\n\n<li>Docker =&gt; Docker compose</li>\n</ul>\n\n\n\n<p>จาก 12-factors นั้นในข้อที่ 1 เรื่อง Codebase จะข้ามไปเลย<br />ไม่น่าต้องคุยอะไรมากกันแล้ว</p>\n\n\n\n<p><strong>เรื่องที่ 2 คือ Dependencies ของระบบ</strong></p>\n\n\n\n<p>ภาษา Go มี <a href=\"https://go.dev/blog/using-go-modules\" target=\"_blank\">Go module</a> ให้ใช้งานแบบง่าย<br />ดังนั้นเริ่มสร้าง project กันเลย<br />โดย library ที่ใช้งานอยู่ถูก config ไว้ในไฟล์ go.mod<br />จะใช้ library อะไรก็เพิ่มกันเลย<br />โดยในระบบตัวอย่างจะใช้งาน library ดังนี้</p>\n\n\n\n<ul>\n<li>Gin web framework สำหรับสร้าง Web Server</li>\n\n\n\n<li><a href=\"https://github.com/stretchr/testify\" target=\"_blank\">Testify</a> ช่วยให้การเขียน test ง่ายขึ้น</li>\n\n\n\n<li>ส่วน logging ใช้ standard log ของ Go ไปเลย</li>\n\n\n\n<li>ใช้งาน <a href=\"https://github.com/spf13/cobra\" target=\"_blank\">Corba</a> แทน flags เพื่อช่วยจัดการ Go CLI ให้ง่ายขึ้น เพื่อสร้าง admin tasks ใน<strong>ข้อ 12 :: Admin processes</strong> เช่น ขั้นตอนของการ migrate database เป็นต้น</li>\n</ul>\n\n\n\n<p>ตัวอย่างการสร้าง</p>\n\n\n\n[gist id=\"a5e5c04c1cf3bc0be1fe812fa6d14c94\" file=\"1.txt\"]\n\n\n\n<p>ส่วน code ในไฟล์ server.go ก็ทำการ copy มาจาก official web ของ <a href=\"https://github.com/gin-gonic/gin\" target=\"_blank\">Gin</a> เลย</p>\n\n\n\n[gist id=\"a5e5c04c1cf3bc0be1fe812fa6d14c94\" file=\"server.go\"]\n\n\n\n<p>ในการจัดการ dependencies ของระบบนั้น <br />ไม่ได้สนใจเพียงสิ่งที่ code ใช้เท่านั้น<br />ถ้ามองให้กว้างขึ้นเรื่องของ OS และ software ต่าง ๆ ที่ใช้งานก็เช่นกัน<br />ควรที่จะคล้าย หรือ เหมือน production ให้ได้มากที่สุด<br />เพื่อช่วยให้เราเจอปัญหาได้รวดเร็วที่สุด<br />เพื่อแก้ไขปัญหาตั้งแต่เนิ่น ๆ ไม่ใช่ไปเจอตอนจะ deploy บน server<br />มักจะมีคำพูดที่ว่า <strong><em>\"ผมทำการ run บนเครื่องผมได้นะ แต่พอเอาขึ้น server แล้วดันทำงานไม่ได้ ไม่รู้ทำไม\"</em></strong></p>\n\n\n\n<p>ซึ่งจะตรงกับ<strong>ข้อที่ 10 :: Dev/prod parity</strong><br />เป็นแนวปฏิบัติที่สำคัญของ Continuous Delivery นั่นเอง</p>\n\n\n\n<p>ดังนั้นสามารถนำเอา Docker เข้ามาช่วยได้เลย<br />ด้วยการสร้าง <a href=\"https://docs.docker.com/build/building/multi-stage/\" target=\"_blank\">Dockerfile + Multi-stage build</a> เพื่อกำหนดสิ่งต่าง ๆ ที่จะใช้งานไปเลย เช่น</p>\n\n\n\n<ul>\n<li>OS ที่จะใช้งาน รวมทั้ง version ด้วย</li>\n\n\n\n<li>Go</li>\n</ul>\n\n\n\n<p>เขียนได้ดังนี้</p>\n\n\n\n[gist id=\"a5e5c04c1cf3bc0be1fe812fa6d14c94\" file=\"Dockerfile\"]\n\n\n\n<p>ทำให้สามารถแยกขั้นตอนการ build และ run ออกมาตามแนวคิด<strong>ข้อที่ 5 :: Build, release, run</strong><br />เพื่อความสะดวกอาจจะเขียนขั้นตอนการทำงานต่าง ๆ ใน</p>\n\n\n\n<ul>\n<li>Makefile</li>\n\n\n\n<li><a href=\"https://taskfile.dev/\" target=\"_blank\">Taskfile</a></li>\n</ul>\n\n\n\n<p>เพื่อช่วยให้ทีมที่เกี่ยวข้องทำงานร่วมกันง่ายยิ่งขึ้น</p>\n\n\n\n<p><strong>เรื่องที่ 3 คือ Config ต่าง ๆ ของระบบงาน</strong></p>\n\n\n\n<p>โดยปกติเราต้องแยก config ออกจาก code หรือ ระบบงานอยู่แล้ว<br />มีแนวทางที่หลากหลาย เช่น</p>\n\n\n\n<ul>\n<li>File config ในรูปแบบต่าง ๆ เช่น properties, json และ YAML เป็นต้น โดยใช้งาน library พวก <a href=\"https://github.com/spf13/viper\" target=\"_blank\">viper</a> และ <a href=\"https://github.com/joho/godotenv\" target=\"_blank\">godotenv</a> เป็นต้น</li>\n\n\n\n<li>ส่งผ่าน command line มาได้เลย เช่น <a href=\"https://pkg.go.dev/flag\" target=\"_blank\">flags</a> หรือ ใช้งาน corba ในการจัดการ</li>\n\n\n\n<li>ส่งผ่าน environment ของ OS นั้น ๆ หรือผ่าน Docker ได้เลย</li>\n\n\n\n<li>ใช้งาน external config server ก็ได้ เช่น Vault, Consul และ Etcd เป็นต้น</li>\n</ul>\n\n\n\n<p>ลองเลือกตาม use case ของระบบงานว่าแบบไหนที่เหมาะสม<br />หรืออาจจะใช้ร่วมกันก็ได้ เช่น <a href=\"https://docs.docker.com/compose/environment-variables/set-environment-variables/\" target=\"_blank\">.env ร่วมกับ Docker compose</a> เป็นต้น</p>\n\n\n\n<p><strong>เรื่องที่ 5 คือ Backing services (resources) ช่วยให้ทำการเพิ่ม หรือ เปลี่ยนแปลงได้ง่าย</strong></p>\n\n\n\n<p>ในแต่ละ environment ด้วย โดยไม่ต้องทำการแก้ไข code ใด<br />ซึ่งทำงานร่วมกับข้อที่ 3 คือ Config นั่นเอง<br />ยกตัวอย่างเช่น database, messaging server และ external service เป็นต้น<br />ลดการผูกมัดให้น้อยลงไปอีก (Loose couple)</p>\n\n\n\n<figure><a href=\"https://www.somkiat.cc/wp-content/uploads/2024/05/attached-resources.png\"><img src=\"https://www.somkiat.cc/wp-content/uploads/2024/05/attached-resources.png\" width=\"547\" height=\"284\" /></a></figure>\n\n\n\n<p><strong>ยกตัวอย่างเช่นการใช้งาน PostgreSQL + Viper </strong></p>\n\n\n\n[gist id=\"a5e5c04c1cf3bc0be1fe812fa6d14c94\" file=\"database.go\"]\n\n\n\n<p>ในการสร้าง database ก็ใช้งาน Docker มาช่วย<br />ก็ทำให้เราสามารถสร้าง database ได้เร็วขึ้น<br />และมีการทำงานคล้าย ๆ กับของจริงอีกด้วย</p>\n\n\n\n<p>ส่วนข้อ 6,7 และ 8 ไม่น่าต้องอธิบายอะไรแล้ว น่าจะเป็นเรื่องพื้นฐาน</p>\n\n\n\n<p><strong>เรื่องที่ 9 คือ Disposability นั่นคือ start ให้เร็ว และ จบการแบบสมบูรณ์</strong></p>\n\n\n\n<p>เรื่องที่สำคัญมาก ๆ คือ gracefull shutdown หรือ การจบการทำงานแบบสมบูรณ์<br />ยกตัวอย่างเช่น<br />เราต้องการลบ process การทำงาน จะเกิดอะไรขึ้นกับระบบงานของเรา ?</p>\n\n\n\n<p>สิ่งที่ระบบงานควรต้องทำคือ</p>\n\n\n\n<ul>\n<li>ไม่รับ request ใหม่ ๆ</li>\n\n\n\n<li>ตรวจสอบว่า มีการทำงานค้างไหม ถ้าใช่ ก็ทำให้เสร็จทั้งหมด</li>\n\n\n\n<li>จบการทำงานแบบสมบูรณ์</li>\n</ul>\n\n\n\n<p>ส่วนที่มักมีปัญหาคือ ระบบงานของเรารับสัญญาณของการ kill/terminate process จาก OS ไหม ?<br />เช่น SIGTERM และ SIGKILL เป็นต้น <br />จากนั้นก็ทำการสั่งให้รอก่อน  เช่นการ waiting หรือ delay<br />หรือถ้าเป็น process ที่สำคัญมาก ๆ อาจจะต้องมีการจัดการ task/job <br />ใน database หรือ messaging ไว้ก่อน process อีกด้วย<br />เพื่อทำให้มั่นใจว่า task/job จะทำงานได้ครบและสมบูรณ์จริง ๆ</p>\n\n\n\n<p><strong>ตัวอย่างของการรับ SIGTERM และ SIGKILL ในภาษา Go เป็นดังนี้</strong></p>\n\n\n\n<p>เท่าที่เห็นมา ไม่ค่อยมีใครทำเท่าไรนัก<br />ทำการรอ 5 วินาที ก่อนที่จะ shutdown</p>\n\n\n\n[gist id=\"a5e5c04c1cf3bc0be1fe812fa6d14c94\" file=\"server2.go\"]\n\n\n\n<p>แต่ในการทำงานจริง ๆ ควรมีระบบ monitoring ที่ดี<br />เพื่อ monitor การทำงานของแต่ละ feature ด้วย ว่ามีทำงานเป็นปกติด้วยหรือไม่</p>\n\n\n\n<p><strong>อีกเรื่องที่ยังไม่พูดถึงคือ เรื่องที่ 11 คือ Logs</strong></p>\n\n\n\n<p>ตามจริงต้องพูดรวมเรื่องของ observability เลย ทั้ง</p>\n\n\n\n<ul>\n<li>Alert system</li>\n\n\n\n<li>Application metric</li>\n\n\n\n<li>Distributed tracing</li>\n\n\n\n<li>Log aggregation</li>\n</ul>\n\n\n\n<p>แต่ในข้อนี้เน้นที่เรื่อง log<br />ก่อนอื่นต้องทำการออกแบบของ log format ก่อน<br />ให้มีรูปแบบที่เป็นมาตรฐาน ว่าจะเก็บอะไรบ้าง<br />จากนั้นจึงมาสร้าง log ด้วย library ต่าง ๆ อีกที<br />โดยแนะนำควรมี format เป็น JSON เช่น logrus, zap และ <a href=\"https://www.somkiat.cc/go-with-slog/\" target=\"_blank\">log/slog</a> เป็นต้น</p>\n\n\n\n<p>แนวทางนั้นบ้างก็ใช้งาน middleware เพื่อ log ทุก ๆ request ที่เข้ามา<br />หรือเขียน log ในแต่ละส่วนของ function ที่ต้องการไปได้เลย</p>\n\n\n\n<p>จากนั้นให้สร้างระบบ Centralized log ขึ้นมา เช่น ELK หรือ OpenSearch  และ <a href=\"https://www.somkiat.cc/lgtm-stack-from-grafana/\" target=\"_blank\">LGTM</a> ของ Grafana เป็นต้น<br />สำหรับจัดเก็บ ค้นหา visualization และ alert system ต่อไป</p>\n\n\n\n<p></p>\n\n\n\n<p>น่าจะเขียนยาวเกินไปละครับ<br />จบเพียงเท่านี้ดีกว่า เป็น note สำหรับการแบ่งปันเรื่อง 12 factor ที่ผ่านมา</p>\n\n\n\n<p><strong><em>จะเห็นได้ว่าแนวคิดนี้ สามารถนำไปปรับใช้งานในแต่ละ technology ได้เลยนะ<br />และในขั้นตอนการ build ผมจะเพิ่มการทดสอบระบบงานเข้าไปด้วย<br />เพื่อให้ได้ซึ่งคุณภาพที่สูงต่อไป</em></strong></p>\n\n\n\n<p></p>\n","author":"somkiat","siteTitle":"cc :: somkiat","siteHash":"3a23a5a4389e1e40c6fbb16520a8cc20df5b3591c25145ce72aaa18b19e48201","entryHash":"f4c5fcf816075c2c626356855c591fc3c1c2bee665a072ecb5f05dd08bf42e6b","category":"Thai"}