{"title":"Modifying Headers In HTTP(s) Requests In UI Automation Testing","link":"https://smashingmagazine.com/2021/12/headers-https-requests-ui-automation-testing/","date":1639477800000,"content":"<p>There are various methods to modify headers. You can modify headers by using browser extensions or proxy apps (such as Charles and Proxyman) that intercept the request and let you modify the response by including the headers.</p>\n<p>But first, let’s start at the beginning.</p>\nWhat Are HTTP(s) Headers?\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers\">HTTP(s) Headers</a> are key-value pairs that can be used by the client or server to pass additional information along with an HTTP(s) request or response. They hold additional information about the data being sent. An HTTP(s) header consists of a case-insensitive name followed by a colon (<code>:</code>), then by its value. Field names are case insensitive but field values are case sensitive. A header can have multiple values which are separated by commas.</p>\nModifying Headers: How Can This Be Helpful?\n<p>I was working on an application that opened the provided webpage and then give the user an option to modify elements, add events, add analytics, and so on. without any need to code. This was being done by loading the page in <code>iframe</code> and giving various options to the user on top of it. I tried with loads of websites to see how they behave in <code>iframe</code>. I observed that most of the websites don’t work in <code>iframe</code> due to <code>x-frame-options</code> and <code>content-security-policy</code> headers.</p>\n<p>Almost all websites have a header <code>X-frame-options</code> set to <code>deny</code> or <code>sameorigin</code> due to which the browser does not allow to load the webpage in an <code>iframe</code> or doesn’t when any cross-origin request tries to load it in an <code>iframe</code>. Also, the <code>content-security-policy</code> header has <code>frame-ancestors</code> directive which prevents this.</p>\n<p>It was very important to load the page in <code>iframe</code>, I was wandering around the internet to find a way to load it. It was evident that I needed to override the <code>X-frame-options</code> header to <code>allowall</code> or remove it altogether. That was when I stumbled upon <code>Requestly</code> extension which gave me the feature to modify the <code>X-frame-options</code> header by matching the page URL and hence allowing me to override the <code>X-frame-options</code> header when debugging.</p>\n<p>That was when I first got to witness the power of network headers. They carry data about the data being transferred. The ability to modify the headers of traffic that pass through your browser is a great tool to have. Besides overriding <code>X-frame-options</code>, you can delete headers to minimize online tracking, override <code>content-security-policy</code> header, test sites in production, and so on.</p>\n<p>While testing web applications, modifying headers provides a great hack:</p>\n<ul>\n<li>to test the guest mode of an application;</li>\n<li>can set cookies using headers;</li>\n<li>to test certain parts of an application that are by default disabled and can be enabled by passing a custom request header;</li>\n<li>to test different test cases associated with headers;</li>\n<li>to bypass authentication flow in your application by passing the authorization header.</li>\n</ul>\n<p>When I got to know about the automated testing of web apps, it occurred to me that modifying headers should be a feature there due to its immense applicability in web app testing. Therefore I decided to write this piece to throw some light on the ways to modify headers in automated testing.</p>\nSelenium\n<p>Selenium is widely used as a test automation framework for end-to-end testing of web applications. It was developed in 2004. Initially, Selenium IDE was being used but it only supported firefox then Selenium RC was developed to enable cross-browser testing. Now the Selenium WebDriver is being used as it provides support for the mobile experience and dynamic websites. It mimics a real user interacting with the webpage.</p>\n<h3>Advantages Of Using Selenium WebDriver</h3>\n<ul>\n<li>Selenium WebDriver is open source;</li>\n<li>It offers bindings for every major programming language;</li>\n<li>Works across multiple OS. Test written in Windows would easily work on Mac;</li>\n<li>Keyboard and cursor simulation are supported;</li>\n<li>Add-ons can be installed.</li>\n</ul>\n<h3>Limitations Of Selenium WebDriver</h3>\n<ul>\n<li>No support to modify headers;</li>\n<li>No support to add request parameters;</li>\n<li>Cannot block a request.</li>\n</ul>\n<p>As discussed, the ability to modify headers helps tremendously in testing applications but the Selenium WebDriver doesn’t support it, and <a href=\"https://github.com/seleniumhq/selenium-google-code-issue-archive/issues/141#issuecomment-191404986\">they don’t plan to include it lately</a>.</p>\n<p>This article focuses on various approaches to modify headers in a Selenium automation setup.</p>\nApproach 1: Selenium Wire (Python)\n<p><a href=\"https://github.com/wkeeling/selenium-wire\">Selenium Wire</a> extends Selenium Python bindings to give you access to the underlying requests made by the browser. You author your code in the same way as you do with Selenium, but you get extra APIs for inspecting requests and responses and making changes to them on the fly.</p>\n<p>It allows modifying requests and responses on the go using interceptors. It can also block requests, mock responses, add request parameters in the URL.</p>\n<h3>Usage</h3>\n<h4>Adding Request Headers</h4>\n<pre><code># interceptor function intercepts the network request\n# If one arg is provided, requests are intercepted\n# and can be modified\ndef interceptor(request):\n    request.headers['New-Header'] = 'Some Value'\n# setting the driver's request_interceptor to equal\n# the customised interceptor\ndriver.request_interceptor = interceptor\ndriver.get(&lt;URL_where_to_modify_the_header&gt;)\n\n# All requests will now contain New-Header</code></pre>\n\n<p>Duplicate header names are permitted in an HTTP request, so before setting the replacement header you must first delete the existing header using <code>del</code> otherwise two headers of the same name will exist.</p>\n<h4>Adding Response Headers</h4>\n<pre><code># A response interceptor takes two args which\n# then allows to tinker with the response\ndef interceptor(request, response):  \n    if request.url == 'https://server.com/some/path':\n        response.headers['New-Header'] = 'Some Value'\ndriver.response_interceptor = interceptor\ndriver.get(&lt;URL_where_to_modify_the_header)\n\n# Responses from https://server.com/some/path will now contain \n# the New-Header</code></pre>\n\n<p>A response interceptor should accept two arguments, <a href=\"https://pypi.org/project/selenium-wire/#intercepting-requests-and-responses\">one for the originating request and one for the response</a>.</p>\n<h3>Limitations</h3>\n<ul>\n<li>This is only available as a Python module.</li>\n<li>It does not support other languages.</li>\n</ul>\nApproach 2: Loading Browser Extension In Selenium Which Can Modify Headers\n<p>There are tools like <a href=\"https://requestly.io/\">Requestly</a> which is a one-stop tool to debug &amp; modify network requests. Requestly allows users to Modify Headers, Redirect URLs, Switch hosts, Mock API response, Delay network requests, Insert custom scripts, etc. It provides ready to go npm package which is a wrapper around the extension enabling the use of extension in Selenium. It supports Chrome, Firefox and Edge.</p>\n<h3>Using Requestly In Selenium</h3>\n<p>Requestly allows you to do a lot more things other than just modifying headers. All these things can be set up within a web interface and the shared list can be loaded into the application which allows the user’s flexibility to edit the rules easily in a web application.</p>\n<p><strong>To Install: <code>npm i @requestly/selenium</code></strong></p>\n<h3>Usage</h3>\n<p>A Modify Headers Rule can be created at <a href=\"https://app.requestly.io/rules\">app.requestly.io/rules</a> after installing the extension.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2d7717e3-3b0e-4104-b8c8-4675e91267a4/1-headers-https-requests-ui-automation-testing.png\" /></p>\n<p>After creating the URL, click on the <code>Share</code> button to generate a link for the URL.</p>\n<p>The URL for the above created <code>sharedList</code> is <a href=\"https://app.requestly.io/rules/#sharedList/1626984924247-Adding-Headers-Example\">here</a>.</p>\n<p>This URL is a Requestly rule which adds <code>Access-Control-Allow-Origin</code> header to all requests. </p>\n<p>This rule can be used in the Selenium WebDriver using the <code>sharedList</code> URL which is described below:</p>\n<div>\n<pre><code>require(\"chromedriver\");\nconst { Builder } = require(\"selenium-webdriver\");\nconst chrome = require(\"selenium-webdriver/chrome\");\nconst { getRequestlyExtension, importRequestlySharedList } = require(\"@requestly/selenium\");\n\nconst options = new chrome.Options().addExtensions(getRequestlyExtension(\"chrome\"));\nconst driver = new Builder()\n    .forBrowser(\"chrome\")\n    .setChromeOptions(options)\n    .build();\n\n// Imports Rules in Selenium using Requestly sharedList feature\n// importRequestlySharedList(driver, &lt;sharedList_URL&gt;);\n\nimportRequestlySharedList(driver, '<a href=\"https://app.requestly.io/rules/#sharedList/1626984924247-Adding-Headers-Example')\">https://app.requestly.io/rules/#sharedList/1626984924247-Adding-Headers-Example')</a>;</code></pre>\n</div>\n\n<p>More information can be found <a href=\"https://www.npmjs.com/package/@requestly/selenium\">here</a>.</p>\n<h3>Limitations</h3>\n<ul>\n<li>It offers an npm package limiting the module to JavaScript only.</li>\n<li>Shared Lists have to be created manually to use the rules in Selenium, hence the rules cannot be controlled through the code written for the Selenium automation test.</li>\n</ul>\nApproach 3: Using Puppeteer\n<p><a href=\"https://www.npmjs.com/package/puppeteer\">Puppeteer</a> is a Node library developed by Google which provides a high-level API to control headless Chrome or Chromium over the DevTools Protocol. It can also be configured to use full (non-headless) Chrome or Chromium.</p>\n<p>When talking about browser automation setup, Selenium automatically comes to the mind but since the advent of Puppeteer it is widely being used for web scraping. It offers more control over chrome than Selenium probably due to google’s support to it. Also due to the same reason, it rules out the need for an external driver to run the browser.</p>\n<h3>Usage</h3>\n<pre><code>const puppeteer = require('puppeteer');\n\n(async () =&gt; {\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.goto('&lt;https://example.com&gt;');\n    await page.screenshot({ path: 'example.png' });\n    await browser.close();\n})();</code></pre>\n\n<h3>Modifying Headers</h3>\n<p>The <code>page.setExtraHTTPHeaders(headers)</code> method can be used to set headers.</p>\n<p>It can also modify and remove existing headers. Once requests are intercepted using a combination of <code>page.setRequestInterception(true)</code> and <code>page.on()</code>.</p>\n<pre><code>await page.setRequestInterception(true);\npage.on('request', request =&gt; {\n// Override headers\n    const headers = Object.assign({}, request.headers(), {\n    foo: 'bar', // set \"foo\" header\n    origin: undefined, // remove \"origin\" header\n});\n\nrequest.continue({headers});\n\n});</code></pre>\n\n<p><a href=\"https://github.com/puppeteer/puppeteer/blob/main/docs/api.md\"><em>Code source</em></a></p>\n<h3>Limitations</h3>\n<ul>\n<li>Puppeteer is limited to chrome for now. It cannot be used for cross-browser testing.</li>\n<li>It has a smaller community compared to Selenium. There seems to be more support for Selenium in the community.</li>\n<li>It only supports JavaScript.</li>\n</ul>\nConclusion\n<p>Modifying network headers happens to be a very powerful tool in a testing environment. There’s a lot more to it than what can be covered in this article. I have tried to cover some of the simplest methods to modify headers in UI Automation Testing.</p>\n<p>Every method has some advantages based on the use case and language you use. Here are some of the preferences:</p>\n<ul>\n<li>If you want to use Selenium in Python, prefer Selenium-Wire as it provided a lot of features on top of Selenium-Webdriver.</li>\n<li>If you want to test on only chrome, prefer puppeteer due to its google support and out-of-the-box support for all features including modifying headers.</li>\n<li>If you work with Selenium and want to do cross-browser testing, prefer adding extensions to emulate the testing in Selenium-Webdriver. If your use-case requires you to inject scripts or redirect network resources in runtime (in addition to modifying headers), then Requestly is an ideal choice.</li>\n</ul>\n<p>Hope this article gives you insight on modifying headers in an automated web application testing setup.</p>\n<h3>Further Resources</h3>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers\">MDN Http Headers</a></li>\n<li><a href=\"https://pypi.org/project/selenium-wire/1.0.3\">Selenium-Wire</a></li>\n<li><a href=\"https://developers.google.com/web/tools/puppeteer\">Puppeteer</a></li>\n<li><a href=\"https://github.com/requestly/requestly-selenium\">Requestly-Selenium</a></li>\n<li><a href=\"https://docs.requestly.io/\">Requestly</a></li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"e36aab2c427ed1e326bea15c96cc8da1863f1c8f8766ea3c6cd37e9cb7ba1388","category":"Tech"}