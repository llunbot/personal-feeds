{"title":"Integrating Azure DevOps Pipelines with HashiCorp Vault","link":"https://www.hashicorp.com/blog/integrating-azure-devops-pipelines-with-hashicorp-vault","date":1727812800000,"content":"<p>In the past, integrating Microsoft Azure DevOps pipelines with HashiCorp Vault has been challenging in certain instances. Unlike GitHub, Azure DevOps doesn’t provide an implicit platform-level identity for its pipelines, which can complicate its integration with external services such as Vault. The best option was usually to leverage Azure platform features such as service connections and service principal names (SPNs) to <a href=\"https://itnext.io/credential-less-authentication-to-hashicorp-vault-from-azure-devops-pipelines-9e92c65fbf82\">create a platform identity</a> that allowed secure introduction to Vault.</p>\n\n<p>In February 2024, <a href=\"https://devblogs.microsoft.com/devops/workload-identity-federation-for-azure-deployments-is-now-generally-available/\">Microsoft announced</a> the general availability of <a href=\"https://learn.microsoft.com/en-gb/azure/devops/pipelines/library/connect-to-azure?view=azure-devops#create-an-azure-resource-manager-service-connection-that-uses-workload-identity-federation\">workload identity federation (WIF) for Azure DevOps</a>. This improves upon the previous integration options by providing a simplified, passwordless integration that uses the widely adopted OpenID Connect (OIDC) standard to authenticate and establish trust between Azure DevOps and Azure. It removes the <em><a href=\"https://www.hashicorp.com/resources/using-oidc-with-hashicorp-vault-and-github-actions#the-secrets-zero-problem-solutions-continuum\">secret zero problem</a></em> that affected some previous integrations, eliminates the need to manage the day-to-day lifecycle of such credentials, and avoids the possibility of credential leakage because no credential is required to set up the integration in the first place. As a result, we can now leverage WIF to provide a platform identity to Azure DevOps pipelines that need to access secret data centrally managed by HashiCorp Vault — this includes static and dynamic secrets as well as many other kinds of credentials.</p>\n\n<p>This post uses <a href=\"https://developer.hashicorp.com/hcp/docs/vault/what-is-hcp-vault\">HCP Vault Dedicated</a> to demonstrate this integration. HCP Vault Dedicated is HashiCorp’s cloud-hosted, single-tenant Vault offering. The concepts laid out here are also applicable to <a href=\"https://developer.hashicorp.com/vault/docs\">Vault Community</a> and <a href=\"https://developer.hashicorp.com/vault/docs/enterprise\">Vault Enterprise</a>, assuming they are hosted in a location accessible from within Azure.</p>\n\n<h2>Configuring Azure DevOps for workload identity federation</h2>\n\n<p>There are two ways to configure WIF within an Azure DevOps service connection. </p>\n\n<p>The first — and recommended — method is to let Azure DevOps <a href=\"https://learn.microsoft.com/en-gb/azure/devops/pipelines/library/connect-to-azure?view=azure-devops#create-a-service-connection-with-workload-identity-federation-automatic\">automatically create all the necessary objects</a> within Azure DevOps and Entra ID for you.</p>\n\n<p>The second method relies on integrating the Azure DevOps service connection with <a href=\"https://learn.microsoft.com/en-gb/azure/devops/pipelines/library/connect-to-azure?view=azure-devops#create-service-connection-with-workload-identity-federation-manual\">an existing workload identity</a> and managing all the integration touchpoints yourself. While this takes a little more effort, it provides a bit more control over the end-to-end configuration, especially if you need to leverage existing service principals or managed service identities (and their associated SPNs) that are already scoped to the roles required by your pipelines.</p>\n\n<p>While neither method is particularly difficult or complex, the end-to-end configuration in either workflow can be created using a straightforward Terraform configuration — a real bonus if you need to implement this at scale. </p>\n\n<p>The rest of this post focuses on the first method of integration and the Terraform configurations that can be used to set it up.</p>\n\n<h2>Creating the service connection with WIF</h2>\n\n<p>Although it is perfectly reasonable to configure the service connection using the manual methods described earlier, you need four bits of information in order to successfully configure the service connection using Terraform:</p>\n\n<ol>\n<li>A <code>project_id</code>, which represents the Azure DevOps project</li>\n<li>An <code>azurerm_spn_tenantid</code>, which represents the Azure tenant</li>\n<li>An <code>azurerm_subscription_id</code>, which represents the Azure subscription</li>\n<li>An <code>azurerm_subscription_name</code></li>\n</ol>\n\n<p>You can then use Microsoft’s own <a href=\"https://registry.terraform.io/providers/microsoft/azuredevops/latest\">Terraform provider for Azure DevOps</a> to create the service connection. The example below references an Azure DevOps project created in the same configuration as the service connection, but it could just as easily reference a <a href=\"https://registry.terraform.io/providers/microsoft/azuredevops/latest/docs/data-sources/project\">data lookup for an existing Azure DevOps project</a>.</p>\n<pre><code>resource \"azuredevops_serviceendpoint_azurerm\" \"automatic\" {\n  project_id                             = azuredevops_project.this.id\n  service_endpoint_name                  = \"AzureRM Service Connection for Vault with Automatic WIF\"\n  service_endpoint_authentication_scheme = \"WorkloadIdentityFederation\"\n  azurerm_spn_tenantid     \t\t = \"00000000-0000-0000-0000-000000000000\"\n  azurerm_subscription_id   \t\t = \"00000000-0000-0000-0000-000000000000\"\n  azurerm_subscription_name \t\t = \"Subscription Name\"\n}</code></pre><p>You want to limit Vault access to only the pipelines that require it, so the next step is to extract the service principal object ID associated with the service principal that is implicitly created when this configuration is applied. You can do this with the <a href=\"https://registry.terraform.io/providers/hashicorp/azuread/latest\">Terraform provider for Entra ID</a> (formerly Azure Active Directory) and its <a href=\"https://registry.terraform.io/providers/hashicorp/azuread/latest/docs/data-sources/service_principal\">service principal data lookup</a>:</p>\n<pre><code>data \"azuread_service_principal\" \"auto_wif\" {\n  client_id = azuredevops_serviceendpoint_azurerm.automatic.service_principal_id\n}</code></pre><p>You can then extract the Object ID as a Terraform output:</p>\n<pre><code>output \"auto_wif_object_id\" {\n  value       = data.azuread_service_principal.auto_wif.object_id\n  description = \"the service principal object id for the automatically generated service principal\"\n}</code></pre><p>If you prefer to locate this in the Azure portal, the value required is the object ID for the enterprise application that gets created when the service connection is configured.</p>\n<img src=\"https://www.datocms-assets.com/2885/1727807224-ado-blog-screenshot-ea.png\" alt=\"ADO\" /><p>You can then use this service principal object ID in your HashiCorp Vault configuration to bind a role on the <a href=\"https://developer.hashicorp.com/vault/docs/auth/azure\">Azure auth method</a> to a specific service principal or principals.</p>\n\n<h2>Configuring HashiCorp Vault</h2>\n\n<p>You can use standard Vault CLI commands to enable and configure the Azure auth method, and to configure an appropriate role on that auth method to let an Azure DevOps pipeline authenticate. These broadly follow the pattern laid out in the <a href=\"https://developer.hashicorp.com/vault/docs/auth/azure\">documentation for the Azure auth method</a>, with a few exceptions.</p>\n\n<p>First, you need to enable the Azure auth method. Given that this will be servicing a distinct set of Vault clients, good practice is to enable the auth method at a path that reflects its use case. There is non-standard <a href=\"https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.3\">audience claim</a> in use here, so this auth method is not suitable for standard Azure authentication workflows.</p>\n<pre><code>vault auth enable -path=\"ado\" azure</code></pre><p>Next, configure the method. Note that the <code>resource</code> parameter is subtly different from the default value of <code>https://management.azure.com/</code>. This value also appears in the audience claim of the tokens issued by Azure.</p>\n<pre><code>vault write auth/ado/config \\\n    tenant_id=00000000-0000-0000-0000-000000000000 \\\n    resource=https://management.core.windows.net/ \\\n    client_id=00000000-0000-0000-0000-000000000000\\\n    client_secret=sUp3r~S3Cr3t~cl1enT_S3Cr3t</code></pre><p>Once the auth method is configured appropriately, finish up by configuring a role on that auth method for the Azure DevOps pipelines to reference during login. The role will impart suitable policies on the issued tokens for future use by the pipeline.</p>\n\n<p>It’s a good idea to use lightweight<a href=\"https://developer.hashicorp.com/vault/tutorials/tokens/batch-tokens#batch-tokens\"> batch tokens</a> to authenticate the pipeline process. The features of the more commonly used<a href=\"https://developer.hashicorp.com/vault/tutorials/tokens/batch-tokens#service-tokens-vs-batch-tokens\"> service tokens</a> are not required in these one-shot processes, and in large-scale environments where many pipelines are executing concurrently, many times a day, using batch tokens can drastically reduce the load on the Vault cluster. Just make sure that the token time-to-live (TTL) is long enough for your pipeline to complete all the tasks it needs to in Vault.</p>\n<pre><code>vault write auth/ado/role/pipeline-role \\\n    token_policies=\"default,azure-policy\" \\\n    token_ttl=600 \\\n    token_type=batch \\\n    bound_service_principal_ids=\"00000000-0000-0000-0000-000000000000” </code></pre><p>The value(s) passed to the <code>bound_service_principal_ids</code> parameter will be the service principal object ID retrieved from the output in either the Azure portal or the Terraform configuration provided earlier.</p>\n\n<p>By binding the role to specific service principals, you’re implicitly limiting which identities associated with Azure DevOps pipelines are permitted to authenticate with Vault. Furthermore, use of the explicit binding simplifies the authentication process by removing the requirement to provide a subscription ID and a resource group name alongside the authentication request. Subscription ID and resource group are meaningless in the context of a pipeline; it is metadata that simply doesn’t exist.</p>\n\n<p>As mentioned above, the next step is to learn how to set this up with Terraform. To automate the configuration of Vault, use the <a href=\"https://registry.terraform.io/providers/hashicorp/vault/latest/docs\">Terraform provider for Vault</a>. Here is an example Terraform configuration to implement the CLI configuration described earlier: </p>\n<pre><code>resource \"vault_auth_backend\" \"ado\" {\n  type = \"azure\"\n  path = \"ado\"\n\n  tune {\n    listing_visibility = \"unauth\"\n  }\n}\n\nresource \"vault_azure_auth_backend_config\" \"ado\" {\n  backend       = vault_auth_backend.ado.path\n  tenant_id     = “00000000-0000-0000-0000-000000000000”\n  client_id     = “00000000-0000-0000-0000-000000000000”\n  client_secret = “sUp3r~S3Cr3t~cl1enT_S3Cr3t”\n  resource      = \"https://management.core.windows.net/\"\n\n  lifecycle {\n    // if we rotate the client secret outside of terraform in line with good practice, we don't want to trigger a change\n    ignore_changes = [client_secret]\n  }\n}\n\nresource \"vault_azure_auth_backend_role\" \"ado\" {\n  backend       = vault_auth_backend.ado.path\n  role          = \"pipeline-role\"\n  token_ttl     = 600\n  token_type    = “batch”\n\n  token_policies = [\n    \"default\", \"pipeline-policy\"\n  ]\n\n  bound_service_principal_ids = [“00000000-0000-0000-0000-000000000000”]\n}</code></pre><p>Again, note the presence of the distinct <code>resource</code> name, as well as the <code>bound_service_principal_ids</code> field.</p>\n\n<p>With this configuration in place, you’re ready to put it to work.</p>\n\n<h2>Configure Azure DevOps pipeline tasks</h2>\n\n<p>To authenticate with Vault and retrieve secret data, follow these four steps in the Azure DevOps pipeline:</p>\n\n<ol>\n<li>Establish your platform identity</li>\n<li>Retrieve a JWT from the platform representing that identity</li>\n<li>Present that JWT to Vault in an authentication request to retrieve a Vault token</li>\n<li>Use the Vault token from the authentication response to request secret data</li>\n</ol>\n\n<p>Steps 1-3 can be accomplished within a single pipeline task, as shown below. Remember that once the Vault token is acquired, it can be reused within the scope of the pipeline as many times as the use case requires. The complete task is here:</p>\n<pre><code>  - task: AzureCLI@2\n    displayName: \"Establish Identity and Authenticate with Vault\"\n    env:\n      VAULT_ADDR: https://my-hcp-vault-cluster-00000000.00000000.z1.hashicorp.cloud:8200\n      VAULT_NAMESPACE: admin\n    inputs:\n      azureSubscription: 'AzureRM Service Connection for Vault with Automatic WIF'\n      scriptType: 'bash'\n      scriptLocation: 'inlineScript'\n      inlineScript: |\n        JWT=$(az account get-access-token --query accessToken --output tsv)\n        VAULT_TOKEN=$(vault write -format=json auth/ado/login role=pipeline-role jwt=\"${JWT}\" | jq -r .auth.client_token)\n        \n        # set task variables for future use in other tasks\n        echo \"##vso[task.setvariable variable=VAULT_TOKEN]$VAULT_TOKEN\"\n</code></pre><p>Let’s take a closer look at what is happening.</p>\n\n<p>Before you can retrieve a JWT representing the platform identity for the pipeline, you first need to authenticate with that identity. The Azure CLI task definition provides a useful helper function to facilitate implicit authentication to Azure, which is enabled by populating the <code>azureSubscription</code> parameter on the task:</p>\n\n<pre><code>azureSubscription: 'AzureRM Service Connection for Vault with Automatic WIF'\n</code></pre>\n\n<p>This parameter associates the task with the Azure Resource Manager service connection you configured earlier. Note that the value provided to <code>azureSubscription</code> maps directly to the display name of the service connection.</p>\n<img src=\"https://www.datocms-assets.com/2885/1727807600-ado-blog-screenshot-wif.png\" alt=\"AzureRM\" /><p>Once the task authenticates, it allows you to request a JWT for your platform identity, which can be passed to a Vault authentication request that allows Vault to verify the identity of the calling client — in this case, the pipeline:</p>\n<pre><code>JWT=$(az account get-access-token --query accessToken --output tsv)</code></pre><p>After the JWT has been issued, use it to authenticate with Vault using the Azure auth method — configured on the ado/ path — and the appropriate role:</p>\n<pre><code>VAULT_TOKEN=$(vault write -format=json auth/ado/login role=pipeline-role jwt=\"${JWT}\" | jq -r .auth.client_token)</code></pre><p>This task assumes that the Vault CLI tooling is either available on the build agent or is otherwise installed as part of the pipeline. Note that the Vault address and Vault namespace (relevant for the HCP Vault Dedicated and Vault Enterprise platforms) are configured as environment variables on the task itself. </p>\n\n<p>Assuming the request to authenticate is successful, the response will be a JSON-formatted payload (due to the <code>format</code> parameter being set explicitly) from Vault that can be parsed with a tool such as <a href=\"https://jqlang.github.io/jq/\"><code>jq</code></a>, allowing the client’s Vault token to be retrieved. This can be set in the <code>VAULT_TOKEN</code> environment variable for further use within the pipeline:</p>\n<pre><code>echo \"##vso[task.setvariable variable=VAULT_TOKEN]$VAULT_TOKEN\"</code></pre><p>After successfully populating the <code>VAULT_TOKEN</code> environment variable, you can use it in other tasks to retrieve secret data from secrets engines in Vault. In the example task provided below, the <code>VAULT_TOKEN</code> environment variable is used to retrieve KV data, but in reality you could use it for any secrets engine the token’s policy permitted access to.</p>\n\n<p>Note that you don’t pass the JWT forward at this point. From a Vault perspective, it’s not needed anymore because you have the Vault token.</p>\n<pre><code>  - task: Bash@3\n    displayName: Retrieve a Pipeline Secret\n    env:\n      VAULT_ADDR: https://my-hcp-vault-cluster-00000000.00000000.z1.hashicorp.cloud:8200\n      VAULT_NAMESPACE: admin\n    inputs:\n      targetType: 'inline'\n      script: |\n         vault kv get -mount=kvv2 -format=json config/pipeline</code></pre><p>Because the Vault token has already been injected into the environment, the task produces the content of the secret.</p>\n<pre><code>{\n  \"request_id\": \"34082681-2ee7-7fde-f695-e725c7c1a74a\",\n  \"lease_id\": \"\",\n  \"lease_duration\": 0,\n  \"renewable\": false,\n  \"data\": {\n    \"data\": {\n      \"secret1\": \"Pipeline Secret 1\",\n      \"secret2\": \"Pipeline Secret 2\"\n    },\n    \"metadata\": {\n      \"created_time\": \"2024-08-27T21:33:21.899708639Z\",\n      \"custom_metadata\": null,\n      \"deletion_time\": \"\",\n      \"destroyed\": false,\n      \"version\": 5\n    }\n  },\n  \"warnings\": null,\n  \"mount_type\": \"kv\"\n}</code></pre><p>Again, as this data is being retrieved in a JSON format, it is easy to parse it for the required values — although you could just as easily alter the output format to better suit your use case.</p>\n\n<p>When you first run the pipeline, you will be asked to grant permissions to the pipeline to make use of your service connection.</p>\n\n<h2>Considerations</h2>\n\n<p>Despite the relative simplicity of the setup, it's important to highlight that the configuration by itself doesn't resolve all of the identity challenges associated with the integration of Azure DevOps and Vault.</p>\n\n<p>The service connection is a project-level construct within Azure DevOps, and as such, does not let you finely scope what the identities associated with it represent. For instance, in other CI/CD platforms with implicit identities built in, a JWT issued by those platforms could represent a pipeline run, a repository, a branch on that repository, or some other suitable construct. There is no such option here, and you’re ultimately still relying on Azure’s managed identities.</p>\n\n<p>Therefore, enforcing the principle of least privilege on pipelines’ access to secret data  —  ensuring a development pipeline doesn't access secrets belonging to a production pipeline, for example, or ensuring a feature branch doesn't access secrets belonging to a production branch  —  relies on the creation of multiple service connections in the Azure DevOps project for each desired scope, and the appropriate configuration of Vault to cater for that.</p>\n\n<p>A simple version of this model might be represented as follows:</p>\n<img src=\"https://www.datocms-assets.com/2885/1727807961-ado-blog-considerations.png\" alt=\"Multiple\" /><p>The service connections and the identities they represent should be bound to their respective roles in Vault using the aforementioned bound<em>service</em>principal_ids parameter on the role itself. This means that a pipeline can authenticate to Vault only against explicitly permitted Vault roles (conforming to Vault’s deny-by-default security stance). The policies associated with the tokens returned by Vault should then be limited in scope to the functions that role is explicitly permitted to undertake. This ensures that, for example, the identity associated with the development service connection cannot be used to authenticate against the testing-pipeline-role or the production-pipeline-role, and thus access secret data it shouldn't.</p>\n\n<p>While enabling the service connections in Azure DevOps and configuring their respective roles and policies in Vault may present a challenge at scale, automation with Terraform can ease that burden and allow you to manage the process more efficiently.</p>\n\n<h2>Summary</h2>\n\n<p>The setup defined in this tutorial allows an Azure DevOps pipeline to authenticate itself with HashiCorp Vault in a simple, secure, yet passwordless manner.</p>\n\n<p>Moreover, even if you chose to manually configure WIF using an existing service principal or managed identity, the rest of the steps presented remain the same; a common integration pattern can be created irrespective of how you choose to work.</p>\n\n<p>This integration opens up the possibility of consuming secrets from any of Vault’s secrets engines — not just static secrets as shown here, but dynamic database credentials, cloud provider credentials, PKI certificates, and much more.</p>\n\n<p>Are you an Azure DevOps user looking to centralize secrets management for your Azure DevOps pipelines?<a href=\"https://portal.cloud.hashicorp.com/sign-up\"> Register on the HashiCorp Cloud Platform</a> and get $50 of trial credit to try out this integration with HCP Vault Dedicated.</p>\n","author":"Ben Holmes","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"78df05b592663c68ac119708637997b02ebd6702fd4b0eea7cd8df8b5708ac6e","category":"Tech"}