{"title":"Reload SSL certificates from HashiCorp Vault for Spring Boot","link":"https://www.hashicorp.com/blog/reload-ssl-certificates-from-hashicorp-vault-for-spring-boot","date":1726070400000,"content":"<p>Spring Boot includes an embedded web server with the <a href=\"https://docs.spring.io/spring-boot/reference/features/ssl.html\">ability to configure SSL certificates</a> to secure connections. In this post, learn how to use <a href=\"https://developer.hashicorp.com/vault/docs/agent-and-proxy/agent\">Vault Agent</a> to generate certificates for a file and configure <a href=\"https://spring.io/blog/2023/11/07/ssl-hot-reload-in-spring-boot-3-2-0\">SSL hot reload in Spring Boot</a> to automatically update web servers with new certificates. This approach automates the handling of expiring certificates without restarting the application while keeping the application code agnostic of Vault (i.e. you don’t need to add code to your application to connect to Vault). Review a complete example of using SSL hot reload with Vault on <a href=\"https://github.com/hashicorp-dev-advocates/workshop-vault-for-developers\">GitHub</a>.</p>\n\n<h2>Set up PKI secrets engine</h2>\n\n<p>Vault has the ability to generate dynamic X.509 certificates using the <a href=\"https://developer.hashicorp.com/vault/docs/secrets/pki\">PKI secrets engine</a>. You can use Vault as a root certificate authority (CA) or <a href=\"https://developer.hashicorp.com/vault/tutorials/secrets-management/pki-engine-external-ca\">bring your own offline root CA</a>. Refer to your Vault operations team to determine how to best enable the PKI secrets engine.</p>\n\n<p>If you have the ability to configure secrets engines on your Vault server, set up the PKI secrets engine with a root CA. The example configuration here sets up a root certificate that expires in one day and configures a Vault role named <code>payments-app</code> for the web server using the certificate.</p>\n<pre><code>vault secrets enable pki\nvault secrets tune -max-lease-ttl=\"24h\" pki\nvault write -field=certificate pki/root/generate/internal \\\n    common_name=\"${COMMON_NAME}\" \\\n    issuer_name=\"root-2024\" \\\n    ttl=\"12h\" &gt; certs/root_2024_ca.crt\n\nvault write pki/config/urls \\\n    issuing_certificates=\"${VAULT_ADDR}/v1/pki/ca\" \\\n    crl_distribution_points=\"${VAULT_ADDR}/v1/pki/crl\"\n\nvault write pki/roles/payments-app allow_any_name=true</code></pre><p>Generate an intermediate CA for the web server that uses the certificate. The intermediate CA will issue certificates that expire every six hours.</p>\n<pre><code>vault secrets enable -path=pki_int pki\nvault secrets tune -max-lease-ttl=12h pki_int\nvault pki issue \\\n     --issuer_name=example-intermediate \\\n     /pki/issuer/$(vault read -field=default pki/config/issuers) \\\n     /pki_int/ \\\n     common_name=\"${COMMON_NAME} Intermediate Authority\" \\\n     key_type=\"rsa\" \\\n     key_bits=\"4096\" \\\n     max_depth_len=1 \\\n     ttl=\"12h\"\n\nvault write pki_int/roles/payments-app \\\n    issuer_ref=\"$(vault read -field=default pki_int/config/issuers)\" \\\n    allow_any_name=true \\\n    max_ttl=\"6h\"</code></pre><p>Before configuring the application, make sure its Vault role has a <a href=\"https://developer.hashicorp.com/vault/docs/concepts/policies\">policy</a> to use the PKI secrets engine. For example, the <code>payments-app</code> role should have access to issue the intermediate certificates at <code>pki_int/issue/payments-app</code> using the <code>update</code> capability.</p>\n<pre><code>path \"pki_int/issue/payments-app\" {\n capabilities = [\"update\"]\n}</code></pre><p>For additional configurations of the PKI secrets engine, refer to our <a href=\"https://developer.hashicorp.com/vault/docs/secrets/pki\">developer documentation</a>.</p>\n\n<h2>Deploy Vault Agent</h2>\n\n<p>Spring Boot’s SSL hot reload capability can reference SSL certificates from a file. How do you get the certificates from Vault and write them to a file for the application to reference? <a href=\"https://developer.hashicorp.com/vault/docs/agent-and-proxy/agent\">Vault Agent</a> automatically authenticates to Vault and writes secrets to a file based on a template. Run Vault Agent as a separate process on the same machine as your application, and it will automatically handle authentication and secret retrieval.</p>\n\n<p>The template for certificates generated by Vault references the API path to issue the certificate and any other attributes required by the PKI secrets engine configuration, such as common name. The Vault Agent <a href=\"https://github.com/hashicorp/consul-template/blob/main/docs/templating-language.md#pkicert\">template</a> writes the certificate’s CA, private key, and public key to separate files. Vault Agent needs the template file in order to check for differences in the certificate and get a new one when it expires. This example requests a certificate that expires every five minutes.</p>\n<pre><code>{{- with pkiCert \"pki_int/issue/payments-app\" \"common_name=payments.${COMMON_NAME}\" \"alt_names=localhost\" \"ttl=5m\" -}}\n{{ .Cert }}{{ .CA }}{{ .Key }}\n{{ .Key | trimSpace | writeToFile \"/vault-agent/config/certs/payments.key\" \"\" \"\" \"0400\" }}\n{{ .CA | trimSpace | writeToFile \"/vault-agent/config/certs/ca.pem\" \"\" \"\" \"0644\" }}\n{{ .Cert | trimSpace | writeToFile \"/vault-agent/config/certs/payments.crt\" \"\" \"\" \"0644\" }}\n{{- end -}}</code></pre><p>Reference the template file in Vault Agent’s configuration and set a destination to write out all certificate information for Vault Agent to track. The example below automatically authenticates to Vault using the <a href=\"https://developer.hashicorp.com/vault/docs/auth/approle\"><code>approle</code> auth method</a>. The <code>auto_auth</code> configuration will change depending on your auth method and where you run Vault Agent and your application.</p>\n<pre><code>pid_file = \"/vault-agent/pidfile\"\n\n// Define Vault Agent's connection to Vault server.\n// This example uses docker-compose with the Vault server at http://vault:8200.\nvault {\n address = \"http://vault:8200\"\n}\n\nauto_auth {\n // This example uses AppRole authentication. When you set up Vault,\n // the scripts wrote the role-id and secret-id to a file. You can think of\n // AppRole authentication method as a username/password combination\n // for automation.\n method {\n   type = \"approle\"\n   config = {\n     role_id_file_path                   = \"/vault-agent/role-id\"\n     secret_id_file_path                 = \"/vault-agent/secret-id\"\n     remove_secret_id_file_after_reading = false\n   }\n }\n}\n\ntemplate {\n source       = \"/vault/templates/cert.tpl\"\n destination  = \"/vault-agent/config/all-certs\"\n}</code></pre><p>When you run Vault Agent with <code>vault agent -config=/vault/config.hcl</code>, you can find the CA, private key, and public key written to <code>/vault-agent/config/certs</code>.</p>\n<pre><code>$ ls vault-agent/config/certs \nca.pem       payments.crt payments.key</code></pre><p>The Spring Boot application references the certificates from the <code>vault-agent/config/certs</code> directory.</p>\n\n<h2>Configure application</h2>\n\n<p>The application needs to reference the certificates from a file using Spring’s <a href=\"https://docs.spring.io/spring-boot/reference/features/ssl.html\">application properties</a>. Configure <code>application.properties</code> with <code>spring.ssl.bundle.pem</code>, which references the directory with the certificates created by Vault Agent. The properties should set <code>reload-on-update</code> to <code>true</code> so the application hot reloads when Vault Agent updates the certificates.</p>\n<pre><code>spring.ssl.bundle.pem.demo.reload-on-update=true\nspring.ssl.bundle.pem.demo.keystore.certificate=/vault-agent/config/certs/payments.crt\nspring.ssl.bundle.pem.demo.keystore.private-key=/vault-agent/config/certs/payments.key\n\nserver.ssl.bundle=demo</code></pre><p>Start the application. The logs show that the application uses the certificates from the <code>/vault-agent/config/certs</code> directory.</p>\n<pre><code>2024-08-26T15:27:07.187Z  INFO 8 --- [payments-app] [main] \nc.h.paymentsapp.PaymentsApplication  : \nStarting PaymentsApplication v0.0.1-SNAPSHOT \nusing Java 22.0.2 with PID 8 (/app/app.jar started by root in /)\n\n...\n\n2024-08-26T15:27:10.519Z  INFO 8 --- [payments-app] [main] \no.a.t.util.net.NioEndpoint.certificate   : \nConnector [https-jsse-nio-8081], TLS virtual host [_default_], certificate type [UNDEFINED] \nconfigured from keystore [/root/.keystore] using alias [tomcat] with trust store [null]\n2024-08-26T15:27:10.531Z  INFO 8 --- [payments-app] [main] o.s.b.w.embedded.tomcat.TomcatWebServer  : \nTomcat started on port 8081 (https) with context path ''\n\n...\n\n2024-08-26T15:27:10.570Z  INFO 8 --- [payments-app] [main] \nc.h.paymentsapp.PaymentsApplication  : \nStarted PaymentsApplication in 4.002 seconds (process running for 4.545)</code></pre><p>Access the application over HTTPS. The <code>curl</code> command needs to reference the files containing the certificate authority, certificate, and private key written by Vault Agent in order to verify the connection to the application.</p>\n<pre><code>$ curl --cacert vault-agent/config/certs/ca.pem --cert vault-agent/config/certs/payments.crt --key vault-agent/config/certs/payments.key https://localhost:8081/payments\n\n[{\"billing_address\":\"8 Eastern Himalayas Drive\",\"created_at\":\"2024-08-26T00:00:00Z\",\"id\":\"2310d6be-0e80-11ed-861d-0242ac120002\",\"name\":\"Red Panda\",\"status\":\"paid\"}]</code></pre><p>Use <a href=\"https://openssl.org/\">openssl</a> to verify the certificate. The certificate includes the expiration date five minutes after it was generated.</p>\n<pre><code>$ openssl s_client -showcerts -connect localhost:8081 </code></pre><p>When the certificate nears expiration, Vault Agent requests a new certificate and writes it to the files. The Spring application automatically reloads itself with the new certificate.</p>\n<pre><code>2024-08-26T15:47:03.532Z  INFO 8 --- [payments-app] [-bundle-watcher] \no.a.t.util.net.NioEndpoint.certificate   : Connector [https-jsse-nio-8081], \nTLS virtual host [_default_], certificate type [UNDEFINED] \nconfigured from keystore [/root/.keystore] using alias [tomcat] \nwith trust store [null]</code></pre><p>When you review the certificate information, you will find a new certificate with an updated expiration.</p>\n<pre><code>$ openssl s_client -showcerts -connect localhost:8081 </code></pre><p>The application now automatically loads a new certificate to its web server without the need to manually restart the application or introduce application downtime.</p>\n\n<h2>Learn more</h2>\n\n<p>By combining SSL hot reload in Spring applications with certificates generated by Vault Agent, your application automatically handles certificate expiration without introducing downtime. This approach accounts for the dynamic behavior of certificates and avoids the need for manual configuration and restart. Rather than directly connecting the application to the Vault API, Vault Agent decouples your application’s dependency on Vault by handling the authentication and retrieval of certificates. The application can read the certificates from a certificate file created by Vault Agent. This helps minimize the overall application refactoring effort.</p>\n\n<p>Find a more complete example of hot reloading Spring applications for secrets and certificates generated by Vault on <a href=\"https://github.com/hashicorp-dev-advocates/workshop-vault-for-developers\">GitHub</a>. Additional configuration for SSL hot reloading in Spring Boot can be found in the <a href=\"https://spring.io/blog/2023/11/07/ssl-hot-reload-in-spring-boot-3-2-0\">Spring documentation</a>. For more on how to use HashiCorp Vault with Spring applications, check out our tutorials on <a href=\"https://developer.hashicorp.com/vault/tutorials/app-integration/spring-reload-secrets\">reloading secrets with the Spring Cloud Vault library</a> or <a href=\"https://developer.hashicorp.com/vault/tutorials/app-integration/eaas-spring-demo\">encrypting Spring application data with transit secrets engine</a>.</p>\n","author":"Rosemary Wang","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"0bccf37e00cc93c0bb801b675a27b68882d745349de05425fcb2fd536de0f8ab","category":"Tech"}