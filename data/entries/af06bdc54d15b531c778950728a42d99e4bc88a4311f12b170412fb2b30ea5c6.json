{"title":"How To Build Server-Side Rendered (SSR) Svelte Apps With SvelteKit","link":"https://smashingmagazine.com/2023/06/build-server-side-rendered-svelte-apps-sveltekit/","date":1686740400000,"content":"<p>I’m not interested in starting a turf war between server-side rendering and client-side rendering. The fact is that SvelteKit supports both, which is one of the many perks it offers right out of the box. The server-side rendering paradigm is not a new concept. It means that the client (i.e., the user’s browser) sends a request to the server, and the server responds with the data and markup for that particular page, which is then rendered in the user’s browser.</p>\n<p><img src=\"https://files.smashing.media/articles/build-server-side-rendered-svelte-apps-sveltekit/11-what-is-ssr.png\" /></p>\n<p>To build an SSR app using the primary <a href=\"https://svelte.dev\">Svelte</a> framework, you would need to maintain two codebases, one with the server running in Node, along with with some templating engine, like <a href=\"https://handlebarsjs.com\">Handlebars</a> or <a href=\"http://mustache.github.io\">Mustache</a>. The other application is a client-side Svelte app that fetches data from the server.</p>\n<p>The approach we’re looking at in the above paragraph isn’t without disadvantages. Two that immediately come to mind that I’m sure you thought of after reading that last paragraph:</p>\n<ol>\n<li>The application is more complex because we’re effectively maintaining two systems.</li>\n<li>Sharing logic and data between the client and server code is more difficult than fetching data from an API on the client side.</li>\n</ol>\nSvelteKit Simplifies The Process\n<p>SvelteKit streamlines things by handling of complexity of the server and client on its own, allowing you to focus squarely on developing the app. There’s no need to maintain two applications or do a tightrope walk sharing data between the two.</p>\n<p>Here’s how:</p>\n<ul>\n<li>Each route can have a <code>server.page.ts</code> file that’s used to run code in the server and return data seamlessly to your client code.</li>\n<li>If you use TypeScript, SvelteKit auto-generates types that are shared between the client and server.</li>\n<li>SvelteKit provides an option to select your rendering approach based on the route. You can choose SSR for some routes and CSR for others, like maybe your admin page routes.</li>\n<li>SvelteKit also supports routing based on a file system, making it much easier to define new routes than having to hand-roll them yourself.</li>\n</ul>\nSvelteKit In Action: Job Board\n<p>I want to show you how streamlined the SvelteKit approach is to the traditional way we have been dancing between the SSR and CSR worlds, and I think there’s no better way to do that than using a real-world example. So, what we’re going to do is build a job board — basically a list of job items — while detailing SvelteKit’s role in the application.</p>\n<p><img src=\"https://files.smashing.media/articles/build-server-side-rendered-svelte-apps-sveltekit/1-job-listing-home-page.png\" /></p>\n<p>When we’re done, what we’ll have is an app where SvelteKit fetches the data from a JSON file and renders it on the server side. We’ll go step by step.</p>\nFirst, Initialize The SvelteKit Project\n<p>The official SvelteKit docs already do a great job of explaining how to set up a new project. But, in general, we start any SvelteKit project in the command line with this command:</p>\n<pre><code>npm create svelte@latest job-list-ssr-sveltekit\n</code></pre>\n\n<p>This command creates a new project folder called <code>job-list-ssr-sveltekit</code> on your machine and initializes Svelte and SvelteKit for us to use. But we don’t stop there — we get prompted with a few options to configure the project:</p>\n<ol>\n<li>First, we select a SvelteKit template. We are going to stick to using the basic Skeleton Project template.</li>\n<li>Next, we can enable type-checking if you’re into that. Type-checking provides assistance when writing code by watching for bugs in the app’s data types. I’m going to use the “TypeScript syntax” option, but you aren’t required to use it and can choose the “None” option instead.</li>\n</ol>\n<p>There are additional options from there that are more a matter of personal preference:</p>\n<ul>\n<li><a href=\"https://eslint.org\">ESLint</a> to enforce code consistency,</li>\n<li><a href=\"https://prettier.io\">Prettier</a> to clean up code formatting,</li>\n<li><a href=\"https://playwright.dev\">Playwright</a> for browser testing locally,</li>\n<li><a href=\"https://vitest.dev\">Vitest</a> for unit testing.</li>\n</ul>\n<p><img src=\"https://files.smashing.media/articles/build-server-side-rendered-svelte-apps-sveltekit/2-project-init.png\" /></p>\n<p>If you are familiar with any of these, you can add them to the project. We are going to keep it simple and not select anything from the list since what I really want to show off is the app architecture and how everything works together to get data rendered by the app.</p>\n<p>Now that we have the template for our project ready for us let’s do the last bit of setup by installing the dependencies for Svelte and SvelteKit to do their thing:</p>\n<pre><code>cd job-listing-ssr-sveltekit\nnpm install\n</code></pre>\n\n<p>There’s something interesting going on under the hood that I think is worth calling out:</p>\n<h3>Is SvelteKit A Dependency?</h3>\n<p>If you are new to Svelte or SvelteKit, you may be pleasantly surprised when you open the project’s <code>package.json</code> file. Notice that the SvelteKit is listed in the <code>devDependencies</code> section. The reason for that is Svelte (and, in turn, SvelteKit) acts like a compiler that takes all your <code>.js</code> and <code>.svelte</code> files and converts them into optimized JavaScript code that is rendered in the browser.</p>\n<p>This means the Svelte package is actually unnecessary when we deploy it to the server. That’s why it is not listed as a dependency in the package file. The final bundle of our job board app is going to contain just the app’s code, which means the <strong>size of the bundle is way smaller and loads faster than the regular Svelte-based architecture</strong>.</p>\n<p>Look at how tiny and readable the <code>package-json</code> file is!</p>\n<div>\n<pre><code>{\n    \"name\": \"job-listing-ssr-sveltekit\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"scripts\": {\n        \"dev\": \"vite dev\",\n        \"build\": \"vite build\",\n        \"preview\": \"vite preview\",\n        \"check\": \"svelte-kit sync &amp;&amp; svelte-check --tsconfig ./tsconfig.json\",\n        \"check:watch\": \"svelte-kit sync &amp;&amp; svelte-check --tsconfig ./tsconfig.json --watch\"\n    },\n    \"devDependencies\": {\n        \"@sveltejs/adapter-auto\": \"^2.0.0\",\n        \"@sveltejs/kit\": \"^1.5.0\",\n        \"svelte\": \"^3.54.0\",\n        \"svelte-check\": \"^3.0.1\",\n        \"tslib\": \"^2.4.1\",\n        \"typescript\": \"^4.9.3\",\n        \"vite\": \"^4.0.0\"\n    },\n    \"type\": \"module\"\n}\n</code></pre>\n</div>\n\n<p>I really find this refreshing, and I hope you do, too. Seeing a big list of packages tends to make me nervous because all those moving pieces make the entirety of the app architecture feel brittle and vulnerable. The concise SvelteKit output, by contrast, gives me much more confidence.</p>\nCreating The Data\n<p>We need data coming from somewhere that can inform the app on what needs to be rendered. I mentioned earlier that we would be placing data in and pulling it from a JSON file. That’s still the plan.</p>\n<p>As far as the structured data goes, what we need to define are properties for a job board item. Depending on your exact needs, there could be a lot of fields or just a few. I’m going to proceed with the following:</p>\n<ul>\n<li>Job title,</li>\n<li>Job description,</li>\n<li>Company Name,</li>\n<li>Compensation.</li>\n</ul>\n<p>Here’s how that looks in JSON:</p>\n<pre><code>[{\n    \"job_title\": \"Job 1\",\n    \"job_description\": \"Very good job\",\n    \"company_name\": \"ABC Software Company\",\n    \"compensation_per_year\": \"$40000 per year\"\n}, {\n    \"job_title\": \"Job 2\",\n    \"job_description\": \"Better job\",\n    \"company_name\": \"XYZ Software Company\",\n    \"compensation_per_year\": \"$60000 per year\"\n}]\n</code></pre>\n\n<p>Now that we’ve defined some data let’s open up the main project folder. There’s a sub-directory in there called <code>src</code>. We can open that and create a new folder called <code>data</code> and add the JSON file we just made to it. We will come back to the JSON file when we work on fetching the data for the job board.</p>\n<p><img src=\"https://files.smashing.media/articles/build-server-side-rendered-svelte-apps-sveltekit/3-json-file.png\" /></p>\nAdding TypeScript Model\n<p>Again, TypeScript is completely optional. But since it’s so widely used, I figure it’s worth showing how to set it up in a SvelteKit framework.</p>\n<p>We start by creating a new <code>models.ts</code> file in the project’s <code>src</code> folder. This is the file where we define all of the data types that can be imported and used by other components and pages, and TypeScript will check them for us.</p>\n<p>Here’s the code for the <code>models.ts</code> file:</p>\n<pre><code>export type JobsList = JobItem[]\n\nexport interface JobItem {\n  job_title: string\n  job_description: string\n  company_name: string\n  compensation_per_year: string\n}\n</code></pre>\n\n<p>There are two data types defined in the code:</p>\n<ol>\n<li><code>JobList</code> contains the array of job items.</li>\n<li><code>JobItem</code> contains the job details (or properties) that we defined earlier.</li>\n</ol>\nThe Main Job Board Page\n<p>We’ll start by developing the code for the main job board page that renders a list of available job items. Open the <code>src/routes/+page.svelte</code> file, which is the main job board. Notice how it exists in the <code>/src/routes</code> folder? That’s the <strong>file-based routing system</strong> I referred to earlier when talking about the benefits of SvelteKit. The name of the file is automatically generated into a route. That’s a real DX gem, as it saves us time from having to code the routes ourselves and maintaining more code.</p>\n<p>While <code>+page.svelte</code> is indeed the main page of the app, it’s also the template for any generic page in the app. But we can create a separation of concerns by adding more structure in the <code>/scr/routes</code> directory with more folders and sub-folders that result in different paths. SvelteKit’s docs have all the information you need for <a href=\"https://kit.svelte.dev/docs/routing#page\">routing and routing conventions</a>.</p>\n<p>This is the markup and styles we’ll use for the main job board:</p>\n<pre><code>&lt;div class=\"home-page\"&gt;\n  &lt;h1&gt;Job Listing Home page&lt;/h1&gt;\n&lt;/div&gt;\n\n&lt;style&gt;\n  .home-page {\n    padding: 2rem 4rem;\n    display: flex;\n    align-items: center;\n    flex-direction: column;\n    justify-content: center;\n  }\n&lt;/style&gt;\n</code></pre>\n\n<p>Yep, this is super simple. All we’re adding to the page is an <code>&lt;h1&gt;</code> tag for the page title and some light CSS styling to make sure the content is centered and has some nice padding for legibility. I don’t want to muddy the waters of this example with a bunch of opinionated markup and styles that would otherwise be a distraction from the app architecture.</p>\nRun The App\n<p>We’re at a point now where we can run the app using the following in the command line:</p>\n<pre><code>npm run dev -- --open\n</code></pre>\n\n<p>The <code>-- --open</code> argument automatically opens the job board page in the browser. That’s just a small but nice convenience. You can also navigate to the URL that the command line outputs.</p>\n<p><img src=\"https://files.smashing.media/articles/build-server-side-rendered-svelte-apps-sveltekit/4-initial-project-run.png\" /></p>\nThe Job Item Component\n<p>OK, so we have a main job board page that will be used to list job items from the data fetched by the app. What we need is a new component specifically for the jobs themselves. Otherwise, all we have is a bunch of data with no instructions for how it is rendered.</p>\n<p>Let’s take of that by opening the <code>src</code> folder in the project and creating a new sub-folder called <code>components</code>. And in that new <code>/src/components</code> folder, let’s add a new Svelte file called <code>JobDisplay.svelte</code>.</p>\n<p>We can use this for the component’s markup and styles:</p>\n<pre><code>&lt;script lang=\"ts\"&gt;\n  import type { JobItem } from \"../models\";\n  export let job: JobItem;\n&lt;/script&gt;\n\n&lt;div class=\"job-item\"&gt;\n  &lt;p&gt;Job Title: &lt;b&gt;{job.job_title}&lt;/b&gt;&lt;/p&gt;\n  &lt;p&gt;Description: &lt;b&gt;{job.job_description}&lt;/b&gt;&lt;/p&gt;\n  &lt;div class=\"job-details\"&gt;\n    &lt;span&gt;Company Name : &lt;b&gt;{job.company_name}&lt;/b&gt;&lt;/span&gt;\n    &lt;span&gt;Compensation per year: &lt;b&gt;{job.compensation_per_year}&lt;/b&gt;&lt;/span&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n\n&lt;style&gt;\n  .job-item {\n    border: 1px solid grey;\n    padding: 2rem;\n    width: 50%;\n    margin: 1rem;\n    border-radius: 10px;\n  }\n\n  .job-details {\n    display: flex;\n    justify-content: space-between;\n  }\n&lt;/style&gt;\n</code></pre>\n\n<p>Let’s break that down so we know what’s happening:</p>\n<ol>\n<li>At the top, we import the TypeScript <code>JobItem</code> model.</li>\n<li>Then, we define a <code>job</code> prop with a type of <code>JobItem</code>. This prop is responsible for getting the data from its parent component so that we can pass that data to this component for rendering.</li>\n<li>Next, the HTML provides this component’s markup.</li>\n<li>Last is the CSS for some light styling. Again, I’m keeping this super simple with nothing but a little padding and minor details for structure and legibility. For example, <code>justify-content: space-between</code> adds a little visual separation between job items.</li>\n</ol>\n<p><img src=\"https://files.smashing.media/articles/build-server-side-rendered-svelte-apps-sveltekit/5-job-display-component.png\" /></p>\nFetching Job Data\n<p>Now that we have the <code>JobDisplay</code> component all done, we’re ready to pass it data to fill in all those fields to be displayed in each <code>JobDisplay</code> rendered on the main job board.</p>\n<p>Since this is an SSR application, the data needs to be fetched on the server side. SvelteKit makes this easy by having a separate <code>load</code> function that can be used to fetch data and used as a hook for other actions on the server when the page loads.</p>\n<p>To fetch, let’s create yet another new file TypeScript file — this time called <code>+page.server.ts</code> — in the project’s <code>routes</code> directory. Like the <code>+page.svelte</code> file, this also has a special meaning which will make this file run in the server when the route is loaded. Since we want this on the main job board page, we will create this file in the <code>routes</code> directory and include this code in it:</p>\n<pre><code>import jobs from ’../data/job-listing.json’\nimport type { JobsList } from ’../models’;\n\nconst job_list: JobsList = jobs;\n\nexport const load = (() =&gt; {\n  return {\n    job_list\n  };\n})\n</code></pre>\n\n<p>Here’s what we’re doing with this code:</p>\n<ol>\n<li>We import data from the JSON file. This is for simplicity purposes. In the real app, you would likely fetch this data from a database by making an API call.</li>\n<li>Then, we import the TypeScript model we created for <code>JobsList</code>.</li>\n<li>Next, we create a new <code>job_list</code> variable and assign the imported data to it.</li>\n<li>Last, we define a <code>load</code> function that will return an object with the assigned data. SvelteKit will automatically call this function when the page is requested. So, the magic for SSR code happens here as we fetch the data in the server and build the HTML with the data we get back.</li>\n</ol>\nAccessing Data From The Job Board\n<p>SvelteKit makes accessing data relatively easy by passing data to the main job board page in a way that checks the types for errors in the process. We can import a type called <code>PageServerData</code> in the <code>+page.svelte</code> file. This type is autogenerated and will have the data returned by the <code>+page.server.ts</code> file. This is awesome, as we don’t have to define types again when using the data we receive.</p>\n<p>Let’s update the code in the <code>+page.svelte</code> file, like the following:</p>\n<pre><code>&lt;script lang=\"ts\"&gt;\n  import JobDisplay from ’../components/JobDisplay.svelte’;\n  import type { PageServerData } from ’./$types’;\n\n  export let data: PageServerData;\n&lt;/script&gt;\n\n&lt;div class=\"home-page\"&gt;\n  &lt;h1&gt;Job Listing Home page&lt;/h1&gt;\n\n  {#each data.job_list as job}\n    &lt;JobDisplay job={job}/&gt;\n  {/each}\n&lt;/div&gt;\n\n&lt;style&gt;....&lt;/style&gt;\n</code></pre>\n\n<p>This is so cool because:</p>\n<ol>\n<li>The <code>#each</code> syntax is a Svelte benefit that can be used to repeat the <code>JobDisplay</code> component for all the jobs for which data exists.</li>\n<li>At the top, we are importing both the JobDisplay component and <code>PageServerData</code> type from <code>./$types</code>, which is autogenerated by SvelteKit.</li>\n</ol>\n<p><img src=\"https://files.smashing.media/articles/build-server-side-rendered-svelte-apps-sveltekit/6-job-listing-home-page.png\" /></p>\nDeploying The App\n<p>We’re ready to compile and bundle this project in preparation for deployment! We get to use the same command in the Terminal as most other frameworks, so it should be pretty familiar:</p>\n<pre><code>npm run build\n</code></pre>\n\n<p><img src=\"https://files.smashing.media/articles/build-server-side-rendered-svelte-apps-sveltekit/7-build-output.png\" /></p>\n<p><strong>Note</strong>: <em>You might get the following warning when running that command: “Could not detect a supported production environment.” We will fix that in just a moment, so stay with me.</em></p>\n<p>From here, we can use the <code>npm run preview</code> command to check the latest built version of the app:</p>\n<pre><code>npm run preview\n</code></pre>\n\n<p>This process is a new way to gain confidence in the build locally before deploying it to a production environment.</p>\n<p>The next step is to deploy the app to the server. I’m using Netlify, but that’s purely for example, so feel free to go with another option. SvelteKit offers adapters that will deploy the app to different server environments. You can get the <a href=\"https://kit.svelte.dev/docs/adapters#supported-environments\">whole list of adapters in the docs</a>, of course.</p>\n<p>The real reason I’m using Netlify is that deploying there is super convenient for this tutorial, thanks to the <code>adapter-netlify</code> plugin that can be installed with this command:</p>\n<pre><code>npm i -D @sveltejs/adapter-netlify\n</code></pre>\n\n<p>This does, indeed, introduce a new dependency in the <code>package.json</code> file. I mention that because you know how much I like to keep that list short.</p>\n<p>After installation, we can update the <code>svelte.config.js</code> file to consume the adapter:</p>\n<pre><code>import adapter from ’@sveltejs/adapter-netlify’;\nimport { vitePreprocess } from ’@sveltejs/kit/vite’;\n\n/** @type {import(’@sveltejs/kit’).Config} */\nconst config = {\n    preprocess: vitePreprocess(),\n\n    kit: {\n        adapter: adapter({\n            edge: false, \n            split: false\n        })\n    }\n};\n\nexport default config;\n</code></pre>\n\n<p>Real quick, this is what’s happening:</p>\n<ol>\n<li>The <code>adapter</code> is imported from <code>adapter-netlify</code>.</li>\n<li>The new adapter is passed to the <code>adapter</code> property inside the <code>kit</code>.</li>\n<li>The <code>edge</code> boolean value can be used to configure the deployment to a Netlify edge function.</li>\n<li>The <code>split</code> boolean value is used to control whether we want to split each route into separate edge functions.</li>\n</ol>\n<h3>More Netlify-Specific Configurations</h3>\n<p>Everything from here on out is specific to Netlify, so I wanted to break it out into its own section to keep things clear.</p>\n<p>We can add a new file called <code>netlify.toml</code> at the top level of the project folder and add the following code:</p>\n<pre><code>[build]\n  command = \"npm run build\"\n  publish = \"build\"\n</code></pre>\n\n<p>I bet you know what this is doing, but now we have a new alias for deploying the app to Netlify. It also allows us to control deployment from a Netlify account as well, which might be a benefit to you. To do this, we have to:</p>\n<ol>\n<li>Create a new project in Netlify,</li>\n<li>Select the “Import an existing project” option, and</li>\n<li>Provide permission for Netlify to access the project repository. You get to choose where you want to store your repo, whether it’s GitHub or some other service.</li>\n</ol>\n<p><img src=\"https://files.smashing.media/articles/build-server-side-rendered-svelte-apps-sveltekit/8-netlify-deploy.png\" /></p>\n<p>Since we have set up the <code>netlify.toml</code> file, we can leave the default configuration and click the “Deploy” button directly from Netlify.</p>\n<p>Once the deployment is completed, you can navigate to the site using the provided URL in Netlify. This should be the final result:</p>\n<p><img src=\"https://files.smashing.media/articles/build-server-side-rendered-svelte-apps-sveltekit/9-final-output.png\" /></p>\n<p>Here’s something fun. Open up DevTools when viewing the app in the browser and notice that the HTML contains the actual data we fetched from the JSON file. This way, we know for sure that the right data is rendered and that everything is working.</p>\n<p><img src=\"https://files.smashing.media/articles/build-server-side-rendered-svelte-apps-sveltekit/10-html-ssr-screenshot.png\" /></p>\n<p><strong>Note</strong>: <em>The source code of the whole project is <a href=\"https://github.com/sriram15/job-listing-ssr-sveltekit\">available on GitHub</a>. All the steps we covered in this article are divided as separate commits in the <code>main</code> branch for your reference.</em></p>\nConclusion\n<p>In this article, we have learned about the basics of server-side rendered apps and the steps to create and deploy a real-life app using SvelteKit as the framework. Feel free to share your comments and perspective on this topic, especially if you are considering picking SvelteKit for your next project.</p>\n<h3>Further Reading On SmashingMag</h3>\n<ul>\n<li><a href=\"https://www.smashingmagazine.com/2020/07/differences-static-generated-sites-server-side-rendered-apps/?_ga=2.58526638.50654286.1684748099-1129770734.1684748099\">Differences Between Static Generated Sites And Server-Side Rendered Apps</a>, Timi Omoyeni</li>\n<li><a href=\"https://deploy-preview-9126--smashing-prod.netlify.app/2022/05/google-crux-analysis-comparison-performance-javascript-frameworks/\">How To Use Google CrUX To Analyze And Compare The Performance Of JS Frameworks</a>, Dan Shappir</li>\n<li><a href=\"https://deploy-preview-9126--smashing-prod.netlify.app/2022/07/look-remix-differences-next/\">A Look At Remix And The Differences With Next.js</a>, Facundo Giuliani</li>\n<li><a href=\"https://www.smashingmagazine.com/2016/08/getting-started-koa-2-async-functions/\">Building A Server-Side Application With Async Functions and Koa 2</a></li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"af06bdc54d15b531c778950728a42d99e4bc88a4311f12b170412fb2b30ea5c6","category":"Tech"}