{"title":"New CSS Viewport Units Do Not Solve The Classic Scrollbar Problem","link":"https://smashingmagazine.com/2023/12/new-css-viewport-units-not-solve-classic-scrollbar-problem/","date":1703066400000,"content":"<p>Browsers shipped a new set of CSS viewport units in 2022. These units make it easier to size elements in mobile browsers, where the browser’s retractable UI affects the height of the viewport as the user scrolls the page. Unfortunately, the new units do <em>not</em> make it easier to size elements in desktop browsers, where classic scrollbars affect the width and height of the viewport.</p>\n<p>The following video shows a desktop browser with classic scrollbars. As we resize the viewport (dashed line) in different ways, the CSS length <code>100dvw</code> matches the width of the viewport in all situations <em>except</em> when a vertical classic scrollbar is present on the page. In that case, <code>100dvw</code> is larger than the viewport width. This is the <strong>classic scrollbar problem</strong> of CSS viewport units. When the page has a vertical classic scrollbar, the length <code>100dvw</code> is larger than the viewport width. In fact, all viewport units have this problem.</p>\n<p><img src=\"https://files.smashing.media/articles/css-viewport-units-not-solve-classic-scrollbar-problem/1-small-large-viewport-sizes.png\" /></p>\n<p>In desktop browsers, the size of the viewport can change as well (e.g., when the user resizes the browser window, opens the browser’s sidebar, or zooms the page), but there is no separate “small viewport size” and “large viewport size” like in mobile browsers.</p>\n<p>So far, I’ve only talked about the “viewport,” but there are, in fact, two different viewports in web browsers: the <strong>visual viewport</strong> and the <strong>layout viewport</strong>. When the page initially loads in the browser, the visual viewport and the layout viewport have the exact same size and position. The two viewports diverge in the following two cases:</p>\n<ol>\n<li>When the user zooms in on a part of the page via a pinch-to-zoom or double-tap gesture, the part of the page that is visible on the screen is the visual viewport. The size of the visual viewport (in CSS pixels) decreases because it shows a smaller part of the page. The size of the layout viewport has not changed.</li>\n<li>When the browser’s virtual keyboard appears on mobile platforms, the smaller part of the page that is visible on the screen above the keyboard is once again the visual viewport. The height of the visual viewport decreases with the height of the virtual keyboard. The size of the layout viewport has again not changed.</li>\n</ol>\n<p>It’s worth noting that as part of shipping the new viewport units in 2022, Chrome <a href=\"https://twitter.com/bramus/status/1574495892010418180\">stopped resizing the layout viewport</a> and initial containing block (ICB) when the virtual keyboard is shown. This behavior is considered the <a href=\"https://groups.google.com/a/chromium.org/g/blink-dev/c/ge7xTu-VhJ0/m/hq_kcusHAQAJ\">“the best default”</a>, and it ensures that the new viewport units are consistent across browsers. This change also <a href=\"https://github.com/w3c/csswg-drafts/issues/4329#issuecomment-542615096\">made the mobile web feel less janky</a> because resizing the ICB is a costly operation. However, the virtual keyboard may still resize the layout viewport in <a href=\"https://mastodon.social/@simevidas/110844733740544334\">some mobile browsers</a>.</p>\n<p>In these two cases, the visual viewport continues to be “the rectangular section of the web browser in which the web page is rendered,” while the layout viewport becomes a larger rectangle that is only partially visible on the screen and that completely encloses the visual viewport. In all other situations, both viewports have the same size and position.</p>\n<p>One benefit of the two-viewport system is that when the user pinch-zooms and pans around the page, fixed-positioned elements don’t stick to the screen, which would almost always be a bad experience. That being said, there are valid use cases for positioning an element above the virtual keyboard (e.g., a floating action button). The CSS Working Group is <a href=\"https://github.com/w3c/csswg-drafts/issues/7475\">currently discussing</a> how to make this possible in CSS.</p>\n<p>CSS viewport units are based on the layout viewport, and they are unaffected by changes to the size of the visual viewport. Therefore, I will focus on the layout viewport in this article. For more information about the visual viewport, see the widely supported <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Visual_Viewport_API\">Visual Viewport API</a>.</p>\nThe Two Types Of Zoom\n<p>The two types of zoom are defined in the <a href=\"https://drafts.csswg.org/cssom-view/#zooming\">CSSOM View module</a>:</p>\n<blockquote>“There are two kinds of zoom: page zoom, which affects the size of the initial viewport, and the visual viewport scale factor, which acts like a magnifying glass and does not affect the initial viewport or actual viewport.”</blockquote>\n\n<p>Page zoom is available in desktop browsers, where it can be found in the browser’s menu under the names “Zoom in” and “Zoom out” or just “Zoom”. When the page is “zoomed in,” the size of the layout viewport shrinks, which causes the page to <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Reflow\">reflow</a>. If the page uses CSS media queries to adapt to different viewport widths (i.e., responsive web design), those media query breakpoints will be triggered by page zoom.</p>\n<p>Scale-factor zoom is available on all platforms. It is most commonly performed with a pinch-to-zoom gesture on the device’s touch screen (e.g., smartphone, tablet) or touchpad (e.g., laptop). As I mentioned in the previous section, the size of the layout viewport does not change when zooming into a part of the page, so the page does not reflow.</p>\n<table>\n    <thead>\n        <tr>\n            <th></th>\n            <th>Page Zoom</th>\n      <th>Visual Viewport Scale Factor</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td><strong>Available on</strong></td>\n            <td>Desktop platforms</td>\n      <td>All platforms</td>\n        </tr>\n        <tr>\n            <td><strong>Activated by</strong></td>\n            <td>Keyboard command, menu option</td>\n      <td>Pinch-to-zoom or double-tap gesture</td>\n        </tr>\n        <tr>\n            <td><strong>Resizes</strong></td>\n            <td>Both layout and visual viewport</td>\n      <td>Only visual viewport</td>\n        </tr>\n    <tr>\n            <td><strong><strong>Does it cause reflow?</strong></strong></td>\n            <td>Yes</td>\n      <td>No</td>\n        </tr>\n    </tbody>\n</table>\n\nThe Layout Viewport And The Initial Containing Block\n<p>The <strong>layout viewport</strong> is the “<a href=\"https://drafts.csswg.org/css-display/#containing-block\">containing block</a>” for fixed-positioned elements. In other words, fixed-positioned elements are positioned and sized relative to the layout viewport. For this reason, the layout viewport can be viewed as the “position fixed viewport,” which may even be <a href=\"https://youtu.be/xl9R8aTOW_I?t=272\">a better name for it</a>.</p>\n<pre><code>/* this element completely covers the layout viewport */\n.elem {\n  position: fixed;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n}\n</code></pre>\n\n<p><strong>Here’s a tip for you</strong>: Instead of <code>top: 0</code>, <code>bottom: 0</code>, <code>left: 0</code>, and <code>right: 0</code> in the snippet above, we can write <code>inset: 0</code>. The <a href=\"https://drafts.csswg.org/css-position-3/#propdef-inset\"><code>inset</code> property</a> is a shorthand property for the <code>top</code>, <code>bottom</code>, <code>left</code>, and <code>right</code> properties, and it has been <a href=\"https://caniuse.com/mdn-css_properties_inset\">supported in all major browsers</a> since April 2021.</p>\n<p>The <a href=\"https://drafts.csswg.org/css2/#initial-containing-block\"><strong>initial containing block</strong></a> <strong>(ICB)</strong> is a rectangle that is positioned at the top of the web page. The ICB has a static size, which is the “small viewport size.” When a web page initially loads in the browser, the layout viewport and the ICB have the exact same size and position. The two rectangles diverge only when the user scrolls the page: The ICB scrolls out of view, while the layout viewport remains in view and, in the case of mobile browsers, grows to the “large viewport size.”</p>\n<p>The ICB is the default containing block for absolutely positioned elements. In other words, absolutely positioned elements are, by default, positioned and sized relative to the ICB. Since the ICB is positioned at the top of the page and scrolls out of view, so do absolutely-positioned elements.</p>\n<pre><code>/* this element completely covers the ICB by default */\n.elem {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n}\n</code></pre>\n\n<p>The ICB is also the containing block for the <code>&lt;html&gt;</code> element itself, which is the root element of the web page. Since the ICB and the layout viewport initially have the same size (the “small viewport size”), authors can make the <code>&lt;body&gt;</code> element as tall as the initial viewport by setting <code>height</code> to <code>100%</code> on both the <code>&lt;html&gt;</code> and <code>&lt;body&gt;</code> element.</p>\n<pre><code>/* By default: ICB height = initial viewport height */\n\n/* &lt;html&gt; height = ICB height */\nhtml {\n  height: 100%;\n}\n\n/* &lt;body&gt; height = &lt;html&gt; height */\nbody {\n  margin: 0;\n  height: 100%;\n}\n\n/* Result: &lt;body&gt; height = initial viewport height */\n</code></pre>\n\n<p>Some websites, such as Google Search, use this method to <a href=\"https://mastodon.social/@simevidas/110703373956065210\">position the page footer at the bottom of the initial viewport</a>. Setting <code>height</code> to <code>100%</code> is necessary because, by default, the <code>&lt;html&gt;</code> and <code>&lt;body&gt;</code> elements are only as tall as the content on the page.</p>\n<table>\n    <thead>\n        <tr>\n            <th></th>\n            <th>Layout Viewport</th>\n      <th>Initial Containing Block</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td><strong>Containing block for</strong></td>\n            <td><code>position: fixed</code> elements</td>\n      <td><code>position: absolute</code> elements</td>\n        </tr>\n        <tr>\n            <td><strong>Is it visible?</strong></td>\n            <td>Always in view (at least partially2).</td>\n      <td>Scrolls out of view (positioned at the top of the page).</td>\n        </tr>\n        <tr>\n            <td><strong>Size</strong></td>\n            <td>Small or large viewport size (depending on the browser UI)</td>\n      <td>Small viewport size</td>\n        </tr>\n    </tbody>\n</table>\n\n<p>2 <em>The layout viewport is not fully visible when the user zooms in on the part of the page and when the browser’s virtual keyboard is shown.</em></p>\n\nThe New Viewport Units\n<p>The CSS viewport units are specified in the <a href=\"https://drafts.csswg.org/css-values/\">CSS Values and Units Module</a>, which is currently at Level 4. The original six viewport units shipped in browsers a decade ago. The new units shipped in major browsers <a href=\"https://caniuse.com/viewport-unit-variants\">over the past year</a>, starting with Safari 15.4 in May 2022 and ending with Samsung Internet 21 in May 2023.</p>\n<p><strong>Note</strong>: <em>The new viewport units may not be correctly implemented in <a href=\"https://mastodon.social/@simevidas/110844733740544334\">some mobile browsers</a>.</em></p>\n<table>\n    <thead>\n        <tr>\n            <th>Layout Viewport</th>\n            <th>Original Units (2013)</th>\n      <th>New Unit Equivalent (2022)</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>Width</td>\n            <td><code>vw</code></td>\n      <td><code>svw</code>, <code>lvw</code>, <code>dvw</code></td>\n        </tr>\n        <tr>\n            <td>Height</td>\n            <td><code>vh</code></td>\n      <td><code>svh</code>, <code>lvh</code>, <code>dvh</code></td>\n        </tr>\n        <tr>\n            <td>Inline Size</td>\n            <td><code>vi</code></td>\n      <td><code>svi</code>, <code>lvi</code>, <code>dvi</code></td>\n        </tr>\n        <tr>\n            <td>Block Size</td>\n            <td><code>vb</code></td>\n      <td><code>svb</code>, <code>lvb</code>, <code>dvb</code></td>\n        </tr>\n        <tr>\n            <td>Smaller Size</td>\n            <td><code>vmin</code></td>\n      <td><code>svmin</code>, <code>lvmin</code>, <code>dvmin</code></td>\n        </tr>\n        <tr>\n            <td>Larger Size</td>\n            <td><code>vmax</code></td>\n      <td><code>svmax</code>, <code>lvmax</code>, <code>dvmax</code></td>\n        </tr>\n    </tbody>\n</table>\n\n<p>A few clarifications:</p>\n<ul>\n<li>The “inline size” and “block size” are either the width or the height, depending on the writing direction. For example, in writing systems with a left-to-right writing direction, the inline size is the width (<code>vi</code> is equivalent to <code>vw</code>), and the block size is the height (<code>vb</code> is equivalent to <code>vh</code>).</li>\n<li>The ”smaller size” and “larger size” are either the width or the height, depending on which one is larger. For example, if the viewport is rather tall than it is wide (e.g., a smartphone in portrait mode), then the smaller size is the width (<code>vmin</code> is equivalent to <code>vw</code>), and the larger size is the height (<code>vmax</code> is equivalent to <code>vh</code>).</li>\n<li>Each viewport unit is equal to one-hundredth of the corresponding viewport size. For example, <code>1vw</code> is equal to one-hundredth of the viewport width, and <code>100vw</code> is equal to the entire viewport width.</li>\n</ul>\n<p>For each of the six original units, there are three new variants with the prefixes <code>s</code>, <code>l</code>, and <code>d</code> (small, large, and dynamic, respectively). This increases the total number of viewport units from 6 to 24.</p>\n<ul>\n<li><strong>The <code>s</code>-prefixed units represent the “small viewport size.”</strong><br />This means that <code>100svh</code> is the height of the initial layout viewport when the browser’s UI is expanded.</li>\n<li><strong>The <code>l</code>-prefixed units represent the “large viewport size.”</strong><br />This means that <code>100lvh</code> is the height of the layout viewport after the browser’s UI retracts. The height difference between the large and small viewport sizes is equivalent to the collapsible part of the browser’s UI:</li>\n</ul>\n<p><code>100lvh - 100svh = how much the browser’s UI retracts</code></p>\n<ul>\n<li><strong>The old unprefixed units (i.e., <code>vw</code>, <code>vh</code>, and so on) are equivalent to the <code>l</code>-prefixed units in all browsers</strong>, which means that they also represent the “large viewport size.” For example, <code>100vh</code> is equivalent to <code>100lvh</code>.</li>\n<li><strong>The <code>d</code>-prefixed units represent the current size of the layout viewport,</strong> which can be either the “small viewport size” or the “large viewport size.” This means that <code>100dvh</code> is the actual height of the layout viewport at any given point in time. This length changes whenever the browser’s UI retracts and expands.</li>\n</ul>\nWhy Do We Have New CSS Units?\n<p>In previous years, the Android version of Chrome would resize the <code>vh</code> unit whenever the browser’s UI retracted and expanded as the user scrolled the page. In other words, <code>vh</code> behaved like <code>dvh</code>. But then, in February 2017, Chrome turned <code>vh</code> into a static length that is based on the <a href=\"https://developer.chrome.com/blog/url-bar-resizing/\">“largest possible viewport”</a>. In other words, <code>vh</code> started behaving like <code>lvh</code>. This change was made in part to match Safari’s behavior on iOS, which Apple <a href=\"https://bugs.webkit.org/show_bug.cgi?id=141832#c5\">implemented as a compromise</a>:</p>\n<blockquote>“Dynamically updating the [<code>100vh</code>] height was not working. We had a few choices: drop viewport units on iOS, match the document size like before iOS 8, use the small view size, or use the large view size.<br /><br />From the data we had, using the larger view size was the best compromise. Most websites using viewport units were looking great most of the time.”</blockquote>\n\n<p>With this change in place, the same problem that occurred in iOS Safari also started happening in Chrome. Namely, an element with <code>height: 100vh</code>, which is now the “large viewport size,” is <em>taller</em> than the initial viewport, which has the “small viewport size.” That means the bottom part of the element is not visible in the viewport when the web page initially loads. This prompted discussions about creating a solution that would allow authors to size elements based on the small viewport size. One of the suggestions was an <a href=\"https://github.com/w3c/csswg-drafts/issues/4329#issuecomment-542971506\">environment variable</a>, but the CSS Working Group ultimately decided to introduce a new set of viewport units.</p>\n<pre><code>/* make the hero section as tall as the initial viewport */\n.hero {\n  height: 100svh;\n}\n</code></pre>\n\n<p>The same height can be achieved by setting <code>height</code> to <code>100%</code> on the <code>.hero</code> element and all its ancestors, including the <code>&lt;body&gt;</code> and <code>&lt;html&gt;</code> elements, but the <code>svh</code> unit gives authors more flexibility.</p>\n<p>I wasn’t able to find any good use cases for the <code>dvh</code> unit. It seems to me that sizing elements with <code>dvh</code> is not a good idea because it would cause <a href=\"https://mastodon.social/@simevidas/110833491915455255\">constant layout shifts</a> as the user scrolled the page. I had considered <code>dvh</code> for the following cases:</p>\n<ul>\n<li><strong>For fixed-positioned elements</strong>, such as modal dialogs and sidebars, <code>height: 100%</code> behaves the same as <code>height: 100dvh</code> because the containing block for fixed-positioned elements is the layout viewport, which already has a height of <code>100dvh</code>. In other words, <code>height: 100%</code> works because <code>100%</code> of <code>100dvh</code> is <code>100dvh</code>. This means that the <a href=\"https://mastodon.social/@simevidas/110817721430296488\"><code>dvh</code> unit is not necessary</a> to make fixed-positioned elements full-height in the dynamic viewport of mobile browsers.</li>\n<li><strong>For vertical scroll snapping</strong>, setting the individual “pages” to <code>height: 100dvh</code> results in a <a href=\"https://mastodon.social/@simevidas/110936041442678212\">glitchy experience in mobile browsers</a>. That being said, it is entirely possible that mobile browsers could fix this issue and make scroll snapping with <code>height: 100dvh</code> a smooth experience.</li>\n</ul>\n<p>There is no concept of a “small viewport size” and a “large viewport size” in desktop browsers. All viewport units, new and old, represent the current size of the layout viewport, which means that all width units are equivalent to each other (i.e., <code>vw</code>= <code>svw</code> = <code>lvw</code> = <code>dvw</code>), and all height units are equivalent to each other (i.e., <code>vh</code> = <code>svh</code> = <code>lvh</code> = <code>dvh</code>). For example, if you replaced <code>100vh</code> with <code>100svh</code> in your code, nothing would change in desktop browsers.</p>\n<p>This behavior isn’t exclusive to desktop platforms. It also occurs on mobile platforms in some cases, such as when a web page is embedded in an <code>&lt;iframe&gt;</code> element and when an installed web app opens in standalone mode.</p>\n<p><img src=\"https://files.smashing.media/articles/css-viewport-units-not-solve-classic-scrollbar-problem/2-test-page-viewport-units.png\" /></p>\n<p>It is possible for the small and large viewport sizes to be equivalent even during regular web browsing in mobile browsers. I have found two such cases:</p>\n<ol>\n<li>In Safari on iOS, if the user chooses the <a href=\"https://mastodon.social/@simevidas/111019750217669633\">“Hide Toolbar” option</a> from the page settings menu, the browser’s UI will retract and stay retracted while the user scrolls the page and navigates to other web pages.</li>\n<li>In Firefox on Android, if the user disables the “Scroll to hide toolbar” option in <strong>Settings → Customize</strong>, the browser’s UI will completely stop retracting when the user scrolls web pages. </li>\n</ol>\nThe Two Types Of Scrollbars\n<p>In a web browser, scrollbars can be either classic or overlay. On mobile platforms, scrollbars are exclusively overlay. On desktop platforms, the user can choose the scrollbar type in the operating system’s settings. The classic scrollbar option is usually labeled “Always show scrollbars.” On Windows, scrollbars are classic by default. On macOS, scrollbars are overlay by default (since 2011), but they automatically switch to classic if the user connects a mouse.</p>\n<p>The main difference between these two types of scrollbars is that <strong>classic scrollbars</strong> are placed in a separate ”scrollbar gutter” that consumes space when present, which reduces the size of the layout viewport; meanwhile, <strong>overlay scrollbars</strong>, as the name suggests, are laid over the web page without affecting the size of the layout viewport.</p>\n<p>When a (vertical) classic scrollbar appears on the page in a desktop browser with classic scrollbars, the width of the layout viewport shrinks by the size of the scrollbar gutter, which is usually 15 to 17 CSS pixels. This causes the page to reflow. The size and position of absolutely and fixed-positioned elements may also change. By default, the browser only shows a classic scrollbar when the page overflows, but the page can force the scrollbar (or empty scrollbar track) to be shown and hidden via the CSS <code>overflow</code> property.</p>\n<p>To prevent the page from reflowing whenever a vertical classic scrollbar is shown or hidden, authors can set <code>scrollbar-gutter: stable</code> on the <code>&lt;html&gt;</code> element. This declaration tells the browser to always <a href=\"https://drafts.csswg.org/css-overflow-3/#scrollbar-gutter-property\">reserve space for the classic scrollbar</a>. The declaration has no effect in browsers with overlay scrollbars. The <code>scrollbar-gutter</code> property is <a href=\"https://bugs.webkit.org/show_bug.cgi?id=167335\">not supported in Safari</a> at the time of writing this article.</p>\n<p>A benefit of classic scrollbars is that they make it clear when an element on the page has a scrollable overflow. In comparison, overlay scrollbars are not shown unless the user actually attempts to scroll an element that is a scroll container with overflow. This can be a problem because the user may not even notice that an element contains <a href=\"https://mastodon.social/@simevidas/110718572458922311\">more content than initially visible</a>. Chrome for Android mitigates this problem by showing the overlay scrollbar until the user scrolls the element at least once.</p>\n<p><img src=\"https://files.smashing.media/articles/css-viewport-units-not-solve-classic-scrollbar-problem/3-overlay-scrollbar-macos.png\" /></p>\n<p>Even if the Windows operating system switches to overlay scrollbars by default in the future, some users prefer classic scrollbars and will <a href=\"https://twitter.com/bramus/status/1569925357364445185\">turn them on</a> if possible. Therefore, developers should test in browsers with classic scrollbars and ensure that their websites remain usable.</p>\nIssues Related To Classic Scrollbars\n<p>When testing your website in a desktop browser with classic scrollbars, the two main issues to look out for are unexpected extra scrollbars caused by small amounts of overflow and empty scrollbar tracks that serve no real purpose. These are usually not major issues, but they make the website appear not quite right, which may confuse or even annoy some visitors.</p>\n<p><img src=\"https://files.smashing.media/articles/css-viewport-units-not-solve-classic-scrollbar-problem/4-double-scrollbar.png\" /></p>\n<h3>Issue 1: Setting <code>overflow</code> To <code>scroll</code> Instead Of <code>auto</code></h3>\n<p>Whether or not a scroll container has overflow depends on the content length, viewport width, and other factors. In situations when there is no overflow, it’s usually better to hide the scrollbar than to show an empty scrollbar track in browsers with classic scrollbars. Such an automatic scrollbar behavior can be enabled by setting <code>overflow</code> to <code>auto</code> on the scroll container.</p>\n<p>When a website is developed on macOS, which uses overlay scrollbars by default, the developer may mistakenly set <code>overflow</code> to <code>scroll</code> instead of <code>auto</code>. Overlay scrollbars behave in the same manner whether <code>overflow</code> is set to <code>auto</code> or <code>scroll</code>. The scrollbar only appears when the user attempts to scroll an element that is a scroll container with overflow. Classic scrollbars behave differently. Notably, if <code>overflow</code> is set to <code>scroll</code> but the element does not overflow, then the browser will show empty scrollbar tracks. To avoid this problem, set <code>overflow</code> to <code>auto</code> instead of <code>scroll</code>.</p>\n<p>Auto scrollbars trade the problem of empty scrollbar tracks with the problem of content reflow, but the latter problem can be avoided by setting <code>scrollbar-gutter</code> to <code>stable</code> on the scroll container, as I previously mentioned.</p>\n<p><img src=\"https://files.smashing.media/articles/css-viewport-units-not-solve-classic-scrollbar-problem/5-three-empty-scrollbar-tracks.png\" /></p>\n<h3>Issue 2: Assuming That The Full Width Of A Media Query Is Available</h3>\n<p>CSS media queries don’t take into account the fact that classic scrollbars reduce the width of the viewport. In other words, media queries assume scrollbars never exist. For example, if the width of the layout viewport is 983 pixels, and the page has a vertical classic scrollbar that is 17 pixels wide, the media query <code>(min-width: 1000px)</code> is true because it “pretends” that the scrollbar isn’t there. And indeed, if we were to hide the scrollbar, the viewport width would grow to 1,000 pixels (983 + 17 = 1000).</p>\n<pre><code>@media (min-width: 1000px) {\n/* \n  This does *not* mean that the viewport is\n  ”at least 1000px wide”.\n\n  The viewport width could be as low as 983px\n  under normal circumstances.\n*/\n}\n</code></pre>\n\n<p>This behavior is by design. Media queries “assume scrollbars never exist” in order to <a href=\"https://mastodon.social/@simevidas/110787891467464575\">prevent infinite loops</a>. Web developers should not assume that the entire <code>width</code> of a media query is available on the web page. For example, avoid setting the width of the page to <code>1000px</code> inside a <code>@media (min-width: 1000px)</code> rule.3</p>\n<p>3 Apple does not seem to agree with this reasoning. In Safari, media queries take scrollbars into account, which means that the appearance and disappearance of a classic scrollbar can trigger media query breakpoints, although the browser seems to <a href=\"https://mastodon.social/@simevidas/111128752905785569\">guard against infinite loops</a>. Nonetheless, Safari’s behavior is <a href=\"https://bugs.webkit.org/show_bug.cgi?id=52653\">considered a bug</a>.</p>\n\n<h3>Issue 3: Using <code>100vw</code> to make an element full width</h3>\n<p>The length <code>100vw</code> is equivalent to the width of the layout viewport, except in one case. If the page has a vertical classic scrollbar, <strong><code>100vw</code> is larger than the viewport width</strong>. Due to this anomaly, setting an element to <code>width: 100vw</code> causes the page to overflow horizontally by a small amount in browsers with classic scrollbars.</p>\n<p><img src=\"https://files.smashing.media/articles/css-viewport-units-not-solve-classic-scrollbar-problem/6-width-header-100vw.png\" /></p>\n<p>This is a known issue. The <a href=\"https://drafts.csswg.org/css-values/#issue-56221f3d\">CSS Values and Units module</a> includes the following note:</p>\n<blockquote>“Issue: Level 3 assumes scrollbars never existed because it was hard to implement, and only Firefox bothered to do so. This is making authors unhappy. Can we improve here?”</blockquote>\n\n<p>The note is referring to <a href=\"https://github.com/w3c/csswg-drafts/issues/1766\">Firefox’s past behavior</a>, where the browser would reduce the size of <code>100vw</code> on pages that set <code>overflow</code> to <code>scroll</code> on the <code>&lt;html&gt;</code> element. Such pages had a stable scrollbar track, and in that case, <code>100vw</code> matched the actual viewport width. This behavior was removed from Firefox in 2017, and it was <a href=\"https://github.com/w3c/csswg-drafts/issues/1766#issuecomment-327642426\">dropped from the CSS specification</a> shortly after. In a recent change of heart, the CSS Working Group decided to revert their earlier decision and <a href=\"https://github.com/w3c/csswg-drafts/issues/6026#issuecomment-1832443514\">reinstate the behavior</a>:</p>\n<blockquote>“RESOLVED: If <code>overflow: scroll</code> is set on the root element (not propagated from <code>&lt;body&gt;</code>), account for the default scrollbar width in the size of <code>vw</code>. Also, take <code>scrollbar-gutter</code> […] into account on the root.”</blockquote>\n\n<p>At the time of writing this article, this change has not yet made it into the CSS specification. It will take some time until all the major browsers ship the new behavior.</p>\nSolving The Classic Scrollbar Problem\n<p>As the title of this article states, the new viewport units did not solve the classic scrollbar problem. The new <code>svw</code>, <code>dvw</code>, and <code>lvw</code> units are equivalent to the original <code>vw</code> unit in browsers (i.e., <code>100svw</code> = <code>100dvw</code> = <code>100lvw</code> = <code>100vw</code>). At first glance, this may seem like a <a href=\"https://github.com/w3c/csswg-drafts/issues/6026#issuecomment-1381508208\">missed opportunity</a> to solve the classic scrollbar problem with the new viewport units. For example, the length <code>100dvw</code> could have represented the actual viewport width as it dynamically changes in response to the appearance and disappearance of a vertical classic scrollbar. This would have allowed developers to make <em>any</em> element on the page as wide as the viewport more easily.</p>\n<p>There are at least two reasons why the new viewport units did not solve the classic scrollbar problem:</p>\n<ol>\n<li>The new viewport units were introduced to solve the problem of <code>100vh</code> being taller than the initial viewport in mobile browsers. A small mobile viewport due to the browser’s expanded UI is different from a small desktop viewport due to the presence of classic scrollbars on the page, so the same <code>s</code>-prefixed viewport units cannot represent the small viewport in both cases. If they did, then, for example, using <code>100svh</code> to solve a layout issue in mobile browsers would have potentially unwanted side effects in desktop browsers and vice-versa.</li>\n<li>The position of the CSS Working Group is that viewport units should be <a href=\"https://github.com/w3c/csswg-drafts/issues/1766#issuecomment-461231716\">“resolvable at a computed-value time”</a> and that they should <a href=\"https://github.com/w3c/csswg-drafts/issues/4329#issuecomment-542396191\">“not depend on layout”</a>. Implementing units that depend on a layout is <a href=\"https://github.com/w3c/csswg-drafts/issues/6026#issuecomment-786919710\">“relatively hard”</a> for browsers.</li>\n</ol>\n<p>The CSS Working Group recently decided to mitigate the classic scrollbar problem by <a href=\"https://github.com/w3c/csswg-drafts/issues/5254\">making <code>100vw</code> smaller</a> in browsers with classic scrollbars when the <code>scrollbar-gutter</code> property is set to <code>stable</code> on the <code>&lt;html&gt;</code> element. The idea is that when the page has a stable scrollbar gutter, the space for the scrollbar is reserved in advance, so the appearance of the scrollbar does not decrease the viewport width. In other words, the viewport has a static width that isn’t affected by the scrollbar. In that case, the length <code>100vw</code> can safely match the viewport width at all times, whether the scrollbar is present or not. Once this behavior makes it into browsers, developers will be able to use <code>scrollbar-gutter: stable</code> to prevent <code>width: 100vw</code> from horizontally overflowing the page.</p>\n<pre><code>/* THIS BEHAVIOR HAS NOT YET SHIPPED IN BROWSERS */\n\n/* On pages with a stable scrollbar gutter */\nhtml {\n  scrollbar-gutter: stable;\n}\n\n/* 100vw can be safely used */\n.full-width {\n  width: 100vw;\n}\n</code></pre>\n\nAvoiding The Classic Scrollbar Problem\n<p><a href=\"https://css-tricks.com/the-trick-to-viewport-units-on-mobile/\">Since at least 2018</a>, developers have been using CSS custom properties that are dynamically updated via JavaScript to get the actual size of the viewport in CSS. In the following example, the custom property <code>--vw</code> is a dynamic version of the <code>vw</code> unit that is correctly updated when the viewport width changes due to the appearance or disappearance of a vertical classic scrollbar. The CSS variable falls back to <code>1vw</code> when JavaScript fails to execute or doesn’t load at all.</p>\n<pre><code>.full-width {\n  width: calc(var(--vw, 1vw) * 100);\n}\n</code></pre>\n\n<p>In the JavaScript code, <code>document.documentElement.clientWidth</code> returns the width of the ICB, which is also the width of the layout viewport. Since the global <code>resize</code> event does not fire when a classic scrollbar changes the viewport width, I’m instead using a resize observer on the <code>&lt;html&gt;</code> element.</p>\n<pre><code>new ResizeObserver(() =&gt; {\n  let vw = document.documentElement.clientWidth / 100;\n  document.documentElement.style.setProperty('--vw', `${vw}px`);\n}).observe(document.documentElement);\n</code></pre>\n\n<p>With the introduction of CSS container queries to browsers over the past year, <a href=\"https://github.com/w3c/csswg-drafts/issues/6026#issuecomment-1722407312\">another solution</a> that doesn’t require JavaScript became available. By turning the <code>&lt;body&gt;</code> element into an <code>inline-size</code> query container, the length <code>100cqw</code> — which is the width of <code>&lt;body&gt;</code> in this case — can be used instead of <code>100vw</code> to get the desired result. Unlike <code>100vw</code>, <code>100cqw</code> becomes smaller when a vertical classic scrollbar appears on the page.</p>\n<pre><code>body {\n  margin: 0;\n  container-type: inline-size;\n}\n\n.full-width {\n  width: 100vw; /* fallback for older browsers */\n  width: 100cqw;\n}\n</code></pre>\n\n<p>Container queries have been supported in all desktop browsers since February 2023. If the page has additional nested query containers, the <code>&lt;body&gt;</code> element’s width (<code>100cqw</code>) can be <a href=\"https://github.com/w3c/csswg-drafts/issues/6026#issuecomment-1722407312\">stored in a registered custom property</a> to make it available inside those query containers. Registered custom properties are <a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=1273706\">not supported in Firefox</a> at the time of writing this article.</p>\nConclusion\n<p>If you’d like to learn more about the concepts discussed in this article, I recommend the <a href=\"https://github.com/web-platform-tests/interop-2022-viewport\">viewport investigation project</a>, which was a collaboration between browser vendors to “research and improve the state of interoperability of existing viewport measurement features.” The new viewport units were, in fact, one of the focus areas of <a href=\"https://web.dev/interop-2022/\">Interop 2022</a>.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"3cf7839270d7148ff5fb3570d2a5c68c53106cc27fe5fb0ca54f1534d6fdc6d3","category":"Tech"}