{"title":"Meet <code>:has</code>, A Native CSS Parent Selector (And More)","link":"https://smashingmagazine.com/2021/06/has-native-css-parent-selector/","date":1623234600000,"content":"<p>Parent selector has been on developers’ wishlist for <a href=\"https://remysharp.com/2010/10/11/css-parent-selector/\">more than 10 years</a> and it has become one of the most requested CSS features alongside container queries ever since. The main reason this feature wasn’t implemented all this time seems to be due to <a href=\"https://snook.ca/archives/html_and_css/css-parent-selectors\">performance concerns</a>. The same was being said about the <a href=\"https://www.smashingmagazine.com/2021/05/css-container-queries-use-cases-migration-strategies/\">container queries</a> and those are currently being added to beta versions of browsers, so those performance seems to be no longer an issue. </p>\n<p>Browser render engines have improved quite a bit since then. The rendering process has been optimized to the point that browsers can effectively determine what needs to be rendered or updated and what doesn’t, opening the way for a new and exciting set of features.</p>\n<p><a href=\"https://bkardell.com/blog/canihas.html\">Brian Kardell has recently announced</a> that his team at Igalia is currently prototyping a <code>:has</code> selector that will serve as a parent selector, but it could have a much wider range of use-cases beyond it. The developer community refers to it as a <strong>“parent selector”</strong> and some <a href=\"https://twitter.com/NOVALISTIC/status/1393506232107814915\">developers have pointed out</a> that the name isn’t very accurate. A more fitting name would be a relational selector or relational pseudo-class <a href=\"https://drafts.csswg.org/selectors-4/#relational\">as per specification</a>, so I’ll be referring to <code>:has</code> as such from now on in the article.</p>\n<p>The team at Igalia has worked on some notable web engine features like <a href=\"https://www.smashingmagazine.com/2020/01/understanding-css-grid-container/\">CSS grid</a> and <a href=\"https://www.smashingmagazine.com/2021/05/css-container-queries-use-cases-migration-strategies/\">container queries</a>, so there is a chance for <code>:has</code> selector to see the light of day, but there is still a long way to go.</p>\n<p>What makes relational selector one of the most requested features in the past few years and how are the developers working around the missing selector? In this article, we’re going to answer those questions and check out the early spec of <strong><code>:has</code> selector</strong> and see how it should improve the styling workflow once it’s released.</p>\nPotential Use-Cases\n<p>The relational selector would be useful for <strong>conditionally applying styles</strong> to UI components based on the content or state of its children or its succeeding elements in a DOM tree. Upcoming relational selector prototype could extend the range and use-cases for existing selectors, improve the quality and robustness of CSS and reduce the need for using JavaScript to apply styles and CSS classes for those use-cases.</p>\n<p>Let’s take a look at a few specific examples to help us illustrate the variety of potential use-cases.</p>\n<h3>Content-Based Variations</h3>\n<p>Some UI elements can have <strong>multiple variations</strong> based on various aspects — content, location on the page, child state, etc. In those cases, we usually create multiple CSS classes to cover all the possible variations and apply them manually or with JavaScript, depending on the approach and tech stack.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8a0f8719-0588-4cf1-95bf-82413982d314/1-meet-has-native-css-parent-selector.jpg\" /></p>\n<p>Even when using CSS naming methodology like <a href=\"http://getbem.com/\">BEM</a>, developers need to keep track of the various CSS classes and make sure to apply them correctly to the parent element and, optionally, to affected child elements. Depending on the number of variations, component styles can get out of hand quickly and become difficult to manage and maintain leading to bugs, so developers would need to document all variations and use-cases by using tools like <a href=\"https://storybook.js.org/\">Storybook</a>.</p>\n<p>With a relational CSS selector, developers would be able to write content checks directly in CSS and styles would be applied automatically. This would reduce the amount of variation CSS classes, decrease the possibility of bugs caused by human error, and selectors would be self-documented with the condition checks.</p>\n<h3>Validation-Based Styles</h3>\n<p>CSS supports input pseudo-classes like <code>:valid</code> and <code>:invalid</code> to target elements that successfully validate and elements that unsuccessfully validate, respectfully. Combined with HTML input attributes like <code>pattern</code> and <code>required</code>, it enables native form validation without the need to rely on JavaScript.</p>\n<p>However, targeting elements with <code>:valid</code> and <code>:invalid</code> is limited to targeting the element itself or its adjacent element. Depending on the design and HTML structure, input container elements or preceding elements like <code>label</code> elements also need some style to be applied.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/1aa90717-11c2-426d-8175-cd8ffac54b6b/meet-has-native-css-parent-selector-2.png\" /></p>\n<p>The relational selector would extend the use-case for the input state pseudo-classes like <code>:valid</code> and <code>:invalid</code> by allowing the parent element or preceding elements to be styled based on the input validity.</p>\n<p>This doesn’t apply only to those pseudo-classes. When working with an external API that returns error messages that are appended in the input container, there won’t be a need to also apply the appropriate CSS class to the container. By writing a relational selector with a condition that checks if the child message container is empty, appropriate styles can be applied to the container.</p>\n<h3>Children Element State</h3>\n<p>Sometimes a parent element or preceding element styles depend on the state of a target element. This case is different from the validation state because the state isn’t closely related to the validity of the input.</p>\n<p>Just like in the previous example, <code>:checked</code> pseudo-class for checkbox and radio input elements is limited to targeting the element itself or its adjacent element. This is not limited to pseudo-classes like <code>:checked</code>, <code>:disabled</code>, <code>:hover</code>, <code>:visited</code>, etc. but to anything else that CSS selectors can target like the availability of specific element, attribute, CSS class, id, etc.</p>\n<p>Relation selectors would extend the range and use-cases of CSS selectors beyond the affected element or its adjacent element.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/3a1654ca-1559-40ed-a9df-031390aee3b6/3-meet-has-native-css-parent-selector.jpg\" /></p>\n<h3>Selecting Previous Siblings</h3>\n<p>CSS selectors are limited by the selection direction — child descendant or following element can be selected, but not the parent or preceding element.</p>\n<p>A relational selector could also be used as a <strong>previous sibling selector</strong>.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/1f556614-86a8-4999-91df-34ed199dba7f/4-meet-has-native-css-parent-selector.png\" /></p>\n<h3>Advanced <code>:empty</code> Selector</h3>\n<p>When working with dynamically loaded elements and using skeleton loaders, it’s common to toggle a loading CSS class on the parent element with JavaScript once the data is fetched and components are populated with data.</p>\n<p>Relational selector could eliminate the need for JavaScript CSS class toggle function by extending the range and functionality of <code>:empty</code> pseudo-class. With relational selector, necessary conditions to display an element can be defined in CSS by targeting required data HTML elements and checking if it’s populated with data. This approach should work with deeply nested and complex elements.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2c6c300b-0b0d-4872-a055-a0e78098ed65/5-meet-has-native-css-parent-selector.jpg\" /></p>\nCSS <code>:has</code> Pseudo-Class Specification\n<p>Keep in mind that <code>:has</code> is <a href=\"https://caniuse.com/css-has\">not supported in any browsers</a> so the code snippets related to the upcoming pseudo-class won’t work. Relational pseudo-class is defined in selectors level 4 specification which has been updated since its initial release in 2011, so the specification is already well-defined and ready for prototyping and development.</p>\n<p>That being said, let’s dive into the <code>:has</code> pseudo-class specification. The idea behind the pseudo-class is to apply styles to a selector if the condition (defined as a regular CSS selector) has been met.</p>\n<div>\n<pre><code>/* Select figure elements that have a figcaption as a child element */\nfigure:has(figcaption) { /* ... */ }\n\n/<em> Select button elements that have an element with .icon class as a child */\nbutton:has(.icon) { /* ... */ }\n\n/</em> Select article elements that have a h2 element followed by a paragraph element */\narticle:has(h2 + p) { /* ... */ }\n</code></pre>\n</div>\n\n<p>Similar to the other pseudo-classes like <code>:not</code>, relational pseudo selector consists of the following parts.</p>\n<pre><code>&lt;target_element&gt;:has(&lt;selector&gt;) { /* ... */ }\n</code></pre>\n\n<ul>\n<li><code>&lt;target_element&gt;</code><br />Selector for an element that will be targeted if condition passed as an argument to <code>:has</code> pseudo-class has been met. Condition selector is scoped to this element.</li>\n<li><code>&lt;selector&gt;</code><br />A condition defined with a CSS selector that needs to be met for styles to be applied to the selector.</li>\n</ul>\n<p>Like with most pseudo-classes, selectors can be chained to target child elements of a target element or adjacent element.</p>\n<div>\n<pre><code>/* Select image element that is a child of a figure element if figure element has a figcaption as a child */\nfigure:has(figcaption) img { /* ... */ }\n\n/* Select a button element that is a child of a form element if a child checkbox input element is checked */\nform:has(input[type=\"checkbox\"]:checked) button { /* ... */ }\n</code></pre>\n</div>\n\n<p>From these few examples, it is obvious how versatile, powerful and useful the <code>:has</code> pseudo-class is. It can even be <strong>combined with other pseudo-classes</strong> like <code>:not</code> to create complex relational selectors.</p>\n<div>\n<pre><code>/* Select card elements that do not have empty elements */\n.card:not(:has(*:empty)) { /* ... */ }\n\n/* Select form element that where at least one checkbox input is not checked */\nform:has(input[type=\"checkbox\"]:not(:checked)) { /* ... */ }\n</code></pre>\n</div>\n\n<p>The relational selector is not limited to the target element’s children content and state, but can also target adjacent elements in the DOM tree, effectively making it a “previous sibling selector”.</p>\n<div>\n<pre><code>/* Select paragraph elements which is followed by an image element */\np:has(+img) { /* ... */ }\n\n/* Select image elements which is followed by figcaption element that doesn't have a \"hidden\" class applied */\nimg:has(~figcaption:not(.hidden)) { /* ... */ }\n\n/* Select label elements which are followed by an input element that is not in focus */\nlabel:has(~input:not(:focus)) { /* ... */ }\n</code></pre>\n</div>\n\n<p>In a nutshell, <strong>relational selector anchors the CSS selection to an element with</strong> <code>:has</code> <strong>pseudo-class and prevents selection</strong> to move to the elements that are passed as an argument to the pseudo-class.</p>\n<pre><code>.card .title .icon -&gt; .icon element is selected\n.card:has(.title .icon) -&gt; .card element is selected\n\n.image + .caption -&gt; .caption element is selected\n.image:has(+.caption) -&gt; .image element is selected\n</code></pre>\n\n\n\nCurrent Approach And Workarounds\n<p>Developers currently have to use various workarounds to compensate for the missing relational selector. Regardless of the workarounds and as discussed in this article, it’s evident how impactful and game-changing the relational selector would be once released.</p>\n<p>In this article, we’ll cover two most-used approaches when dealing with the use-cases where relational selector would be ideal:</p>\n<ul>\n<li>CSS variation classes.</li>\n<li>JavaScript solution and jQuery implementation of <code>:has</code> pseudo-class.</li>\n</ul>\n<h3>CSS Variation Classes For Static Elements</h3>\n<p>With CSS variation classes (<a href=\"https://en.bem.info/methodology/css/#modifiers\">modifier classes</a> in BEM), developers can manually assign an appropriate CSS class to elements based on the element’s content. This approach works for static elements whose contents or state won’t change after the initial render.</p>\n<p>Let’s take a look at the following card component example which has several variations depending on the content. Some cards don’t have an image, others don’t have a description and one card has a caption on the image.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/jOBpeQo\">Card variations</a> by <a href=\"https://codepen.io/AdrianBece\">Adrian Bece</a>.</p>\n<p>For these cards to have the correct layout, developers need to apply the correct modifier CSS classes manually. Based on the design, elements can have multiple variations resulting in a large number of modifier classes which sometimes leads to <a href=\"https://csswizardry.com/2014/05/grouping-related-classes-in-your-markup/\">creative HTML workarounds</a> to group all those classes in the markup. Developers need to keep track of the CSS classes, maintain documentation and make sure to apply appropriate classes.</p>\n<pre><code>.card { /* ... */}\n.card--news { /* ... */ }\n.card--text { /* ... */ }\n.card--featured { /* ... */ }\n\n.card__title { /* ... */ }\n.card__title--news { /* ... */ }\n.card__title--text { /* ... */ }\n\n/* ... */\n</code></pre>\n\n<h3>JavaScript Workaround</h3>\n<p>For more complex cases, when the applied parent element style depends on child state or element content that changes dynamically, developers use JavaScript to apply necessary styles to the parent element depending on the changes in the content or state. This is usually handled by writing a custom solution on a case-by-case basis.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/LYWBgXy\">Filter button state</a> by <a href=\"https://codepen.io/AdrianBece\">Adrian Bece</a>.</p>\n<h3>Relational Selector In jQuery</h3>\n<p>Implementation of relational <code>:has</code> selector has existed in popular JavaScript library <a href=\"https://api.jquery.com/has-selector/#has1\">jQuery</a> since 2007 and it follows the CSS specification. Of course, the main limitation of this implementation is that the jQuery line needs to be manually attached invoked inside an event listener, whereas native CSS implementation would be a part of the browser render process and automatically respond to the page state and content changes.</p>\n<p>The downside of the JavaScript and jQuery approach is, of course, reliance on JavaScript and jQuery library dependency which can increase the overall page size and JavaScript parsing time. Also, users that are browsing the Web with JavaScript turned off will experience visual bugs if fallback is not implemented.</p>\n<pre><code>// This runs only on initial render\n$(\"button:has(+.filters input:checked)\").addClass(\"button--active\");\n\n// This runs each time input is clicked\n$(\"input\").click(function() {\n  $(\"button\").removeClass(\"highlight\");\n  $(\"button:has(+.filters input:checked)\").addClass(\"highlight\");\n})\n</code></pre>\n\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/BaWPqqO\">Email inputs — valid / invalid</a> by <a href=\"https://codepen.io/AdrianBece\">Adrian Bece</a>.</p>\nConclusion\n<p>Similar to the container queries, <code>:has</code> pseudo-class will be a major game-changer when implemented in browsers. The relational selector will allow developers to write powerful and versatile selectors that are not currently possible with CSS. </p>\n<p>Today, developers are dealing with the missing parent selector functionality by writing multiple modifier CSS classes that needed to be applied manually or with JavaScript, if the selector depends on a child element state. The relational selector should reduce the amount of modifier CSS classes by allowing developers to write self-documented robust selectors, and should reduce the need for JavaScript to apply dynamic styles.</p>\n<p>Can you think of more examples where parent selector or previous sibling selector would be useful? Are you using a different workaround to deal with the missing relational selector? Share your thoughts with us in the comments.</p>\n<h3>References</h3>\n<ul>\n<li><a href=\"https://snook.ca/archives/html_and_css/css-parent-selectors\">“Why we don't have a parent selector”</a> by Jonathan Snook</li>\n<li><a href=\"https://bkardell.com/blog/canihas.html\">“Can I :has”</a> by Brian Kardell</li>\n<li><a href=\"https://drafts.csswg.org/selectors-4/#relational\">“Selectors Level 4”</a> by W3C</li>\n<li><a href=\"https://api.jquery.com/has-selector/#has1\">jQuery <code>:has</code> selector documentation</a></li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"e3a7b443b295a01071797b70c1acafdc4452c84220189b0c2279509cbde31d79","category":"Tech"}