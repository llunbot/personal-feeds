{"title":"Daily Rant: all() and any() on empty iterables","link":"https://blog.srakrn.me/daily-rant-all-and-any-on-empty-iterables/","date":1704694298000,"content":"<pre><code>&gt;&gt;&gt; all([])\nTrue\n&gt;&gt;&gt; any([])\nFalse</code></pre>\n\n\n\n<p>This may or may not be counter-intuitive. If it is, here is the simple explanation I like:</p>\n\n\n\n<p>For a non-empty iterable <code>X</code>, you can consider <code>all(X)</code> to be equivalent to <code>X[0] and all(X[1:])</code></p>\n\n\n\n<p>When you expand everything, you get <code>X[0] and X[1] and ... and all([])</code>, notice how things will collapse if <code>all([])</code> return False, because if it is the case, <code>all()</code> will never return True.</p>\n\n\n\n<p>In the same way, you can consider <code>any(X)</code> to be equivalent to <code>X[0] or any(X[1:])</code></p>\n\n\n\n<p>When you expand everything, you get <code>X[0] or X[1] or ... or any([])</code>, notice how things will collapse if <code>any([])</code> return True, because if it is the case, <code>any()</code> will never return False.</p>\n\n\n\n<p>This is neither a good nor correct explanation, because one can argue that they can define all() and any() operator with a non-empty iterable as the base of its recursive cause. I am not even sure if a set with negative numbers of elements is a thing, which will spark even more debate.</p>\n\n\n\n<p>More about this at Neizod’s blog: <a href=\"https://neizod.dev/2022/08/22/logic-and-coding-from-phrase-not-all.html\">ตรรกะและการเขียนโค้ดจากวลี not all ~ neizod’s speculation</a></p>","author":"srakrn","siteTitle":"@srakrn's Blog","siteHash":"8610f010f52679fdf8125827e361d560c59c9ee46c9232365fabf44f77865fb7","entryHash":"ffdc02168c5cf6ca3aba198df55a518f777ec49d25667a7b77638bcfa695ee15","category":"Thai"}