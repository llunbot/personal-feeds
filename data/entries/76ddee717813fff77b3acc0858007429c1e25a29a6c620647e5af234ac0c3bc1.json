{"title":"How (and Why) to Use AppRole Correctly in HashiCorp Vault","link":"https://www.hashicorp.com/blog/how-and-why-to-use-approle-correctly-in-hashicorp-vault","date":1630339200000,"content":"<p><a href=\"https://www.vaultproject.io/\">HashiCorp Vault</a>, like many comprehensive solutions, has a learning curve. It’s opinionated about the right way to do things securely, and sometimes that opinionated complexity leads people to take shortcuts. Those shortcuts may open holes in the security around secrets or the credentials used to authenticate to Vault. Let’s walk through some best practices for using the <a href=\"https://www.vaultproject.io/docs/auth/approle\">AppRole authentication method</a> and learn why you shouldn’t take shortcuts.</p>\n<p><strong>Note</strong>: This is not a guide to hardening of Vault <em>clusters</em>; for that see our Vault <a href=\"https://learn.hashicorp.com/tutorials/vault/production-hardening\">production hardening guide</a> — and for a glimpse of trying to compromise Vault from an attacker’s point of view, I recommend my longtime colleague John Boero’s blog post from that perspective:</p><h2><a href=\"#when-you-need-approle-secret-zero\">»</a><a></a>When You Need AppRole: Secret Zero</h2>\n<p>Before applications can retrieve secrets from Vault, they need to be given a secret from which they can authenticate — this is a bit of a chicken-and-egg conundrum we refer to as the “secure introduction” or <a href=\"https://www.hashicorp.com/resources/vault-response-wrapping-makes-the-secret-zero-challenge-a-piece-of-cake\">“secret zero” problem</a>. Apps can resolve the dilemma, authenticate to Vault, and retrieve a <a href=\"https://www.vaultproject.io/docs/concepts/tokens\">token</a> in one of three basic ways:</p>\n<ul>\n<li>By using underlying platform identity (cloud provider IAM roles, Kubernetes service accounts, etc.)</li>\n<li>By using operator-provided non-platform authentication (usernames/passwords)</li>\n<li>By bypassing authentication entirely and using a token provided directly to the application — what I call “tokens from the sky”.</li>\n</ul>\n<p>Giving apps a token from the sky is least-preferred — you have to guarantee secure delivery of that token yourself, and you also don’t get application identity association unless you establish it yourself via <a href=\"https://www.vaultproject.io/docs/concepts/client-count#entity-aliases\">entity aliases</a> for every app token you create. Giving apps non-platform credentials is better (it associates identity with the application) but you still have secure-handling challenges.</p>\n<p>Applications authenticating through the platform is best, but not every platform has Vault auth integration. You might be in a cloud without any authentication plugin for Vault, or you might be using bare metal. Fortunately, Vault has an auth method that can give you many of the advantages of platform-based authentication even without native platform integration: AppRole lets you build a trusted broker for your applications easily and effectively.</p>\n<h2><a href=\"#what-makes-approle-better\">»</a><a></a>What Makes AppRole Better?</h2>\n<p>The most essential feature of AppRole that makes it better than direct token assignment is that the credential is split into a <a href=\"https://www.vaultproject.io/docs/auth/approle#roleid\">Role ID</a> and a <a href=\"https://www.vaultproject.io/docs/auth/approle#secretid\">Secret ID</a>, delivered through different channels. Further, the Secret ID is delivered to the application only at the expected time of use (usually at application startup).</p>\n<p>This pattern of authorization by using knowledge delivered just in time, in parts, through independent delivery paths should be familiar from standard multi-factor authentication methods: to log in to a service, you have an already-known identity, but you need a one-time-use token generated and delivered at the time you log in as well.</p>\n<p>The Role ID is not sensitive and can be used for any number of instances of a given application; you can hardcode it into things like VM or container images (though as a best practice, you should not provide it to processes that don’t need it, e.g. processes that manage roles rather than using them to authenticate).</p>\n<p>The Secret ID, by contrast, is:</p>\n<ul>\n<li>Intended to be access-limited so it can be used only by authorized applications; it may be usable by only a single application or even a single app instance.</li>\n<li>Intended to be short-lived to reduce the window for compromise; it may be valid for only seconds.</li>\n</ul>\n<p>Many of the steps we’ll cover in the full AppRole procedure are intended to preserve one or the other of these attributes.</p>\n<h2><a href=\"#how-to-use-approle-correctly\">»</a><a></a>How to Use AppRole Correctly</h2>\n<p>For the process we’ll be walking through, refer to the diagram below taken from the <a href=\"https://learn.hashicorp.com/tutorials/vault/approle?in=vault/auth-methods#response-wrap-the-secretid\">Response Wrap the SecretID</a> section of the <a href=\"https://learn.hashicorp.com/tutorials/vault/approle?in=vault/auth-methods\">AppRole Pull Authentication</a> tutorial (we’ll cover what response wrapping is later):</p><img src=\"https://www.datocms-assets.com/2885/1629992136-11-steps-approle.png\" /><p>There are 11 steps shown here, varying from simple operations to those with multiple options or alternatives.</p>\n<p><strong><em>Important note: “your application”</em></strong></p>\n<p>Throughout this process I’ll talk about “your application” doing things to authenticate with AppRole. But what if you have an application that expects a Vault token to be provided directly and you can’t change it to perform the necessary steps for this? In this case, the Vault binary has an <a href=\"https://www.vaultproject.io/docs/agent\">Agent mode</a> that can <a href=\"https://www.vaultproject.io/docs/agent/autoauth/methods/approle\">authenticate to Vault using AppRole</a> auth components provided in separate files and <a href=\"https://www.vaultproject.io/docs/agent/autoauth/sinks\">save the resulting token in a sink file</a> that your application can read it from. It will even renew renewable tokens by default. In either case, the same workflow applies, it will just be handled by the agent rather than directly by your application — effectively, the agent becomes a plugin of your app.</p>\n<h2><a href=\"#approle-step-by-step\">»</a><a></a>AppRole: Step-by-Step</h2>\n<p>A “step zero” for this tutorial is to use TLS to secure communications to Vault. Without that step, every other security measure Vault has is compromised from the start. Seriously, if you haven’t secured <a href=\"https://learn.hashicorp.com/tutorials/vault/raft-deployment-guide?in=vault/raft\">your Vault deployment</a> with TLS, do that before you even read the rest of this.</p>\n<h3><a href=\"#step-1\">»</a><a></a>Step 1</h3>\n<p><a href=\"https://www.vaultproject.io/docs/auth#enabling-disabling-auth-methods\">Enable the AppRole auth method</a>. This is the time to think about things like managing roles. If you will be delegating management of roles to someone, will they need to manage <em>every</em> role? If not, you may want to enable AppRole at multiple paths so you can easily grant permissions to manage sets of roles.</p>\n<p>If you’re using Vault Enterprise, you may also wish to set up <a href=\"https://www.vaultproject.io/docs/enterprise/namespaces\">namespaces</a> and enable this auth method under them. This will allow you to more easily grant the ability to manage secrets in concert with the role(s) you’re about to create.</p>\n<h3><a href=\"#step-2\">»</a><a></a>Step 2</h3>\n<p><a href=\"https://www.vaultproject.io/docs/auth/approle#configuration\">Create the role</a> and policies for the app. The role is a reusable unit containing a set of Vault policies that determine which secrets an app has access to: If two apps use the same role, they will have access to the same secrets, so make sure that you create the right number of roles to provide the level of distinction you need between apps. Consider the <a href=\"https://en.wikipedia.org/wiki/Principle_of_least_privilege\">principle of least privilege</a> for each app.</p>\n<p>Remember that a role can have multiple policies attached, so if you have apps that share some secrets but not all, you can create one policy that grants access to the common secrets for a set of applications, and app-specific policies that cover each application’s unique needs.</p>\n<p>When creating the role, there are a number of features you should use whenever possible:</p>\n<ul>\n<li><a href=\"https://www.vaultproject.io/api-docs/auth/approle#secret_id_bound_cidrs\">TTL (time to live), number of uses, and source CIDR</a> limits on the Secret ID. These control the use of the Secret ID to authenticate to Vault: where it can be used from, and how many times.</li>\n<li><a href=\"https://www.vaultproject.io/api-docs/auth/approle#token_ttl\">The same limits</a> are available separately for the token created by authenticating.</li>\n</ul>\n<h3><a href=\"#step-3-and-4\">»</a><a></a>Step 3 and 4</h3>\n<p>Request and receive the role’s Role ID.</p>\n<p>You will usually insert this into some artifact related to the application — the VM image it runs on, its configuration file template, etc.</p>\n<h3><a href=\"#step-5\">»</a><a></a>Step 5</h3>\n<p>At some future time, provision your application. Once provisioned, the running application has access to half of the information it needs to authenticate to Vault. Beginning with the next step, we provide it with the other half.</p>\n<p><strong><em>Important note: Secure process order</em></strong></p>\n<p>Steps 6–8, which generate and deliver the Secret ID, are sometimes done before step 5, but the most secure way is to do them in the order laid out here, with the application fully started prior to delivery, ready to use the Secret ID the instant it appears. This way the Secret ID is not left unconsumed (and therefore vulnerable to interception, no matter how minimally) any longer than necessary.</p>\n<p>Ideally, application instances should either wait for the Secret ID to be present and then consume it immediately, or cleanly terminate and be restarted (e.g. by a supervising orchestrator) until the Secret ID is available. However, in some cases, you may have to pre-deliver the Secret ID if your application cannot cleanly handle starting up before the Secret ID is present.</p>\n<h3><a href=\"#step-6-and-7\">»</a><a></a>Step 6 and 7</h3>\n<p>Your runtime platform now will need to request and receive a Secret ID to provide to the application. Use a Vault identity for this that is associated with policies that allow only this operation.</p>\n<p>You could have your platform retrieve a plaintext Secret ID and provide it to your app in that form, but this reintroduces an issue that you were trying to avoid: now you have to ensure the secure handling of this sensitive credential component.</p>\n<p>To mitigate this, Vault supports <a href=\"https://www.vaultproject.io/docs/concepts/response-wrapping\">response-wrapping</a> the Secret ID — instead of the literal Secret ID, it returns a single-use token that can be used for an “unwrap” operation in the Vault API. When unwrapping, Vault then returns the underlying secret — in this case an AppRole Secret ID.</p>\n<p>Secret ID response wrapping provides three basic benefits:</p>\n<ul>\n<li><strong>Concealment:</strong> As the wrapping token is handed off through your platform to the final running app, any services that handle it do not need to know the underlying Secret ID to pass that Secret ID on.</li>\n<li><strong>Exposure limitation:</strong> The wrapping token is associated with <a href=\"https://learn.hashicorp.com/tutorials/vault/approle#response-wrap-the-secretid\">a TTL of its own</a>, ensuring that unused wrapping tokens are automatically expired if not renewed, instead of remaining active and available for an attacker to exploit.</li>\n<li><strong>Tamper-evidence:</strong> If a compromised app or malicious process does intercept and unwrap the token, then when the authorized application tries to do the same, it will instead get an error response from Vault. A further layer of protection is provided against an attacker evading unwrap detection by storing an unwrapped Secret ID at a new path and passing on a new wrapping token from that new secret — wrapping tokens always include an attribute giving the path of the secret they wrap. Your applications should know and validate this path to detect malicious Secret ID rewrapping. If you are using the Vault Agent and you provide it with the source path, it will handle this validation automatically.</li>\n</ul>\n<p><strong><em>If either a wrapping token unwrap fails or the creation path is not what was expected, your system should generate an alert and you should investigate immediately. You should also alert and investigate anytime you see unexpected activity around a role’s Secret IDs</em></strong>, e.g. if you are <a href=\"https://learn.hashicorp.com/tutorials/vault/pattern-approle?in=vault/recommended-patterns\">using this pattern for CI/CD pipelines</a> and a Secret ID is generated for a pipeline role but no pipelines are running.</p>\n<p>You can ensure response wrapping by applying a policy enforcing the application of TTLs on Secret ID creation — there’s an <a href=\"https://www.vaultproject.io/docs/concepts/policies#required-response-wrapping-ttls\">example policy</a> that does exactly this in the Vault policy documentation. (Note that the Role ID is not required for this, only the role path.)</p>\n<h3><a href=\"#step-8\">»</a><a></a>Step 8</h3>\n<p>Provide the retrieved Secret ID wrapping token to the authorized application.</p>\n<p>How you do this is up to you — you could push it via a call to an API in your application, you could have the application pull it via reading from a file, or you could do a number of other things. Whichever method you use, remember to make sure it’s not delivered through the same channel you delivered the Role ID.</p>\n<p>Another good practice is to remove the wrapping token from the location you retrieved it from once you’ve used it to authenticate. You could do this, for example, by deleting the file it was read from. (If you’re using the agent, it will attempt to delete that file by default.)</p>\n<p>Below is an example workflow animation for delivering a wrapped Secret ID to an application inside a container:</p><img src=\"https://www.datocms-assets.com/2885/1629992142-app-role-flow.gif\" /><h3><a href=\"#step-9-11\">»</a><a></a>Step 9–11</h3>\n<p>The application unwraps the wrapped Secret ID, <a href=\"https://www.vaultproject.io/api-docs/auth/approle#login-with-approle\">authenticates to Vault using the provided Role ID and Secret ID</a>, and receives a Vault token.</p>\n<p>Conveniently, if you’re using the agent, it will automatically recognize a wrapping token and unwrap the Secret ID using it before trying to authenticate.</p>\n<p>A key principle is that the application should unwrap and consume the Secret ID as soon as it can — remember, if the Secret ID remains unused for a long time, then one or more of the following will be true:</p>\n<ul>\n<li>You’ll be leaving an exploitable credential exposed</li>\n<li>The wrapping token or underlying Secret ID will eventually expire, meaning your app can no longer use it</li>\n<li>If your credential has already been intercepted and exploited, you’ll be leaving the compromise undetected until you try to authenticate</li>\n</ul>\n<h3><a href=\"#step-12\">»</a><a></a>Step 12</h3>\n<p>There isn’t a step 12 on the earlier diagram, but the underlying point of doing all the previous steps is this one: use the returned token to access secrets in Vault. (The specific method of doing this will of course vary depending on the type of secret.)</p>\n<p>The agent can help here too: if your application is not Vault-aware at all, the agent can not only authenticate to Vault on its behalf, but also <a href=\"https://www.vaultproject.io/docs/agent/template\">retrieve the actual secrets your app needs and write them to a file</a> in a format your application expects them in.</p>\n<p>At this point your application has a Vault token, it’s retrieved its secrets, credential artifacts have been cleaned up, and it’s (presumably) operating normally. A good next step is to brush up on <a href=\"https://learn.hashicorp.com/tutorials/vault/policies\">best practices for Vault policy</a>, <a href=\"https://www.vaultproject.io/docs/concepts/lease\">leases on secrets in Vault</a>, and <a href=\"https://learn.hashicorp.com/tutorials/vault/tokens#renew-service-tokens\">token expiration and renewal</a>.</p>\n<h2><a href=\"#approle-best-practices\">»</a><a></a>AppRole Best Practices</h2>\n<p>In the real world, the details of how you implement AppRole may vary, but make sure to keep these basic principles in mind:</p>\n<ul>\n<li>Use identities tied to minimal-permission policies to manage roles. Monitor role management operations with alerts on unexpected operations that might indicate malicious activity.</li>\n<li>Provide credential components (Role ID and Secret ID) just-in-time by separate paths, and provide them only where the applications using them to authenticate will retrieve them.</li>\n<li>Make sure credentials are used immediately, and use the available options to limit their exposure to interception and unauthorized use (response wrapping, TTLs, use limits, and source CIDR limits). Monitor and alert on any errors in unwrapping or authentication that might indicate interception of credentials in flight.</li>\n<li>Lastly, follow general Vault best practices for <a href=\"https://learn.hashicorp.com/tutorials/vault/policies\">using policy to control permissions to secrets</a>, just as you would for any other client identity.</li>\n</ul>\n<p>If you’re looking to remove much of the complexity in operationalizing Vault for scaling use cases, consider a managed on-demand deployment with <a href=\"https://cloud.hashicorp.com/\">HCP Vault</a>.</p>","author":"Joe Thompson","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"76ddee717813fff77b3acc0858007429c1e25a29a6c620647e5af234ac0c3bc1","category":"Tech"}