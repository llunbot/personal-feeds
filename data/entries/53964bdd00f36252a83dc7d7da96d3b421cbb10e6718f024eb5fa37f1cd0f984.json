{"title":"Gatsby Headaches And How To Cure Them: i18n (Part 1)","link":"https://smashingmagazine.com/2023/06/gatsby-headaches-i18n-part-1/","date":1686585600000,"content":"<p>Internationalization, or i18n, is making your content understandable in other languages, regions, and cultures to reach a wider array of people. However, a more interesting question would be, “Why is i18n important?”. The answer is that we live in an era where hundreds of cultures interact with each other every day, i.e., we live in a globalized world. However, our current internet doesn’t satisfy its globalized needs.</p>\n<blockquote>Did you know that 60.4% of the internet is in English, but only 16.2% percent of the world speaks English?<br /><br />Source: <a href=\"https://www.visualcapitalist.com/the-most-used-languages-on-the-internet/\">Visual Capitalist</a></blockquote>\n\n<p>Yes, it’s an enormous gap, and until perfect AI translators are created, the internet community must close it.</p>\n<p>As developers, we must adapt our sites’ to support translations and formats for other countries, languages, and dialects, i.e., <strong>localize</strong> our pages. There are two main problems when implementing i18n on our sites.</p>\n<ol>\n<li><strong>Storing and retrieving content.</strong><br />We will need files to store all our translations while not bloating our page’s bundle size and a way to retrieve and display the correct translation on each page.</li>\n<li><strong>Routing content.</strong><br />Users must be redirected to a localized route with their desired language, like <code>my-site.com/es</code> or <code>en.my-site.com</code>. How are we going to create pages for each locale?</li>\n</ol>\n<p>Fortunately, in the case of <strong>Gatsby</strong> and other static site generators, translations don’t bloat up the page bundle size since they are delivered as part of the static page. The rest of the problems are widely known, and there are a lot of plugins and libraries available to address them, but it can be difficult to choose one if you don’t know their purpose, what they can do, and if they are compatible with your existing codebase. That’s why in the following hands-on guide, we will see how to use several i18n plugins for Gatsby and review some others.</p>\nThe Starter\n<p>Before showing what each plugin can do and how to use them, we first have to start with a base example. (You can skip this and <a href=\"https://github.com/Monknow/starter-gatsby-headaches-and-how-to-cure-them-i18n\">download the starter here</a>). For this tutorial, we will work with a site with multiple pages created from an array of data, like a blog or wiki. In my case, I choose a cooking blog that will initially have support only for English.</p>\n<h3>Start A New Project</h3>\n<p>To get started, let’s start a plain JavaScript Gatsby project without any plugins at first.</p>\n<pre><code>npm init gatsby\n</code></pre>\n\n<pre><code>cd my-new-site\n</code></pre>\n\n<p>For this project, we will create pages dynamically from markdown files. To be able to read and parse them to Gatsby’s data layer, we will need to use the <code>gatsby-source-filesystem</code> and <code>gatsby-transformer-remark</code> plugins. Here you can see a more <a href=\"https://www.gatsbyjs.com/docs/how-to/routing/adding-markdown-pages\">in-depth tutorial</a>.</p>\n<pre><code>npm i gatsby-source-filesystem gatsby-transformer-remark\n</code></pre>\n\n<p>Inside our <code>gatsby-config.js</code> file, we will add and configure our plugins to read all the files in a specified directory.</p>\n<pre><code>// ./gatsby-config.js\n\nmodule.exports = {\n  //...\n  plugins: [\n    {\n      resolve: `gatsby-source-filesystem`,\n      options: {\n        name: `content`,\n        path: `${__dirname}/src/content`,\n      },\n    },\n    `gatsby-transformer-remark`,\n  ],\n};\n</code></pre>\n\n<h3>Add Your Content</h3>\n<p>As you can see, we will use a new <code>./src/content/</code> directory where we will save our posts. We will create a couple of folders with each recipe’s content in markdown files, like the following:</p>\n<pre><code>├── src\n│ ├── content\n| | ├── mac-and-cheese\n| | | ├── cover.jpg\n| | | ├── index.en.md\n| | ├── burritos\n| | | ├── cover.jpg\n| | | ├── index.en.md\n| | ├── pizza\n| | | ├── cover.jpg\n| | | ├── index.en.md\n│ ├── pages\n│ ├── images\n</code></pre>\n\n<p>Each markdown file will have the following structure:</p>\n<pre><code>---\nslug: \"mac-and-cheese\"\ndate: \"2023-01-20\"\ntitle: \"How to make mac and cheese\"\ncover_image:\n    image: \"./cover.jpg\"\n    alt: \"Macaroni and cheese\"\nlocale: \"en\"\n---\n\nStep 1\nLorem ipsum...\n</code></pre>\n\n<p>You can see that the first part of the markdown file has a distinct structure and is surrounded by <code>---</code> on both ends. This is called the <a href=\"https://daily-dev-tips.com/posts/what-exactly-is-frontmatter/\">frontmatter</a> and is used to save the file’s metadata. In this case, the post’s title, date, locale, etc.</p>\n<p>As you can see, we will be using a <code>cover.jpg</code> file for each post, so to parse and use the images, we will need to install the <code>gatsby-plugin-image</code> <code>gatsby-plugin-sharp</code> and <code>gatsby-transformer-sharp</code> plugins (I know there are a lot 😅).</p>\n<pre><code>npm i gatsby-plugin-image gatsby-plugin-sharp gatsby-transformer-sharp\n</code></pre>\n\n<p>We will also need to add them to the <code>gatsby-config.js</code> file.</p>\n<pre><code>// ./gatsby-config.js\n\nmodule.exports = {\n  //...\n  plugins: [\n    {\n      resolve: `gatsby-source-filesystem`,\n      options: {\n        name: `content`,\n        path: `${__dirname}/src/content`,\n      },\n    },\n    `gatsby-plugin-sharp`,\n    `gatsby-transformer-sharp`,\n    `gatsby-transformer-remark`,\n    `gatsby-plugin-image`,\n  ],\n};\n</code></pre>\n\n<h3>Querying Your Content</h3>\n<p>We can finally start our development server:</p>\n<pre><code>npm run develop\n</code></pre>\n\n<p>And go to <code>http://localhost:8000/___graphql</code>, where we can make the following query:</p>\n<pre><code>query Query {\n  allMarkdownRemark {\n    nodes {\n      frontmatter {\n        slug\n        title\n        date\n        cover_image {\n          image {\n            childImageSharp {\n              gatsbyImageData\n            }\n          }\n          alt\n        }\n      }\n    }\n  }\n}\n</code></pre>\n\n<p>And get the following result:</p>\n<pre><code>{\n  \"data\": {\n    \"allMarkdownRemark\": {\n      \"nodes\": [\n        {\n          \"frontmatter\": {\n            \"slug\": \"/mac-and-cheese\",\n            \"title\": \"How to make mac and cheese\",\n            \"date\": \"2023-01-20\",\n            \"cover_image\": {\n              /* ... */\n            }\n          }\n        },\n        {\n          \"frontmatter\": {\n            \"slug\": \"/burritos\",\n            \"title\": \"How to make burritos\",\n            \"date\": \"2023-01-20\",\n            \"cover_image\": {\n              /* ... */\n            }\n          }\n        },\n        {\n          \"frontmatter\": {\n            \"slug\": \"/pizza\",\n            \"title\": \"How to make Pizza\",\n            \"date\": \"2023-01-20\",\n            \"cover_image\": {\n              /* ... */\n            }\n          }\n        }\n      ]\n    }\n  }\n}\n</code></pre>\n\n<p>Now the data is accessible through Gatsby’s data layer, but to access it, we will need to <a href=\"https://www.gatsbyjs.com/docs/how-to/querying-data/page-query/\">run a query</a> from the <code>./src/pages/index.js</code> page.</p>\n<p>Go ahead and delete all the boilerplate on the <code>index</code> page. Let’s add a short header for our blog and create the page query:</p>\n<pre><code>// src/pages/index.js\n\nimport * as React from \"react\";\nimport {graphql} from \"gatsby\";\n\nconst IndexPage = () =&gt; {\n  return (\n    &lt;main&gt;\n      &lt;h1&gt;Welcome to my English cooking blog!&lt;/h1&gt;\n      &lt;h2&gt;Written by Juan Diego Rodríguez&lt;/h2&gt;\n    &lt;/main&gt;\n  );\n};\n\nexport const indexQuery = graphql`\n  query IndexQuery {\n    allMarkdownRemark {\n      nodes {\n        frontmatter {\n          slug\n          title\n          date\n          cover_image {\n            image {\n              childImageSharp {\n                gatsbyImageData\n              }\n            }\n            alt\n          }\n        }\n      }\n    }\n  }\n`;\n\nexport default IndexPage;\n</code></pre>\n\n<h3>Displaying Your Content</h3>\n<p>The result from the query is injected into the <code>IndexPage</code> component as a <code>props</code> property called <code>data</code>. From there, we can render all the recipes’ information.</p>\n<pre><code>// src/pages/index.js\n\n// ...\nimport {RecipePreview} from \"../components/RecipePreview\";\n\nconst IndexPage = ({data}) =&gt; {\n  const recipes = data.allMarkdownRemark.nodes;\n\n  return (\n    &lt;main&gt;\n      &lt;h1&gt;Welcome to my English cooking blog!&lt;/h1&gt;\n      &lt;h2&gt;Written by Juan Diego Rodríguez&lt;/h2&gt;\n      {recipes.map(({frontmatter}) =&gt; {\n        return &lt;RecipePreview key={frontmatter.slug} data={frontmatter} /&gt;;\n      })}\n    &lt;/main&gt;\n  );\n};\n\n// ...\n</code></pre>\n\n<p>The <code>RecipePreview</code> component will be the following in a new directory: <code>./src/components/</code>:</p>\n<div>\n<pre><code>// ./src/components/RecipePreview.js\n\nimport * as React from \"react\";\nimport {Link} from \"gatsby\";\nimport {GatsbyImage, getImage} from \"gatsby-plugin-image\";\n\nexport const RecipePreview = ({data}) =&gt; {\n  const {cover_image, title, slug} = data;\n  const cover_image_data = getImage(cover_image.image.childImageSharp.gatsbyImageData);\n\n  return (\n    &lt;Link to={<code>/recipes/${slug}</code>}&gt;\n      &lt;h1&gt;{title}&lt;/h1&gt;\n      &lt;GatsbyImage image={cover_image_data} alt={cover_image.alt} /&gt;\n    &lt;/Link&gt;\n  );\n};\n</code></pre>\n</div>\n\n<h3>Creating Pages From Your Content</h3>\n<p>If we go to <code>http://localhost:8000/</code>, we will see all our recipes listed, but now we have to create a custom page for each recipe. We can do it using Gatsby’s <a href=\"https://www.gatsbyjs.com/docs/reference/routing/file-system-route-api/\">File System Route API</a>. It works by writing a GraphQL query inside the page’s filename, generating a page for each query result. In this case, we will make a new directory <code>./src/pages/recipes/</code> and create a file called <code>{markdownRemark.frontmatter__slug}.js</code>. This filename translates to the following query:</p>\n<pre><code>query MyQuery {\n  allMarkdownRemark {\n    nodes {\n      frontmatter {\n        slug\n      }\n    }\n  }\n}\n</code></pre>\n\n<p>And it will create a page for each recipe using its <code>slug</code> as the route.</p>\n<p>Now we just have to create the post’s component to render all its data. First, we will use the following query:</p>\n<pre><code>query RecipeQuery {\n  markdownRemark {\n    frontmatter {\n      slug\n      title\n      date\n      cover_image {\n        image {\n          childImageSharp {\n            gatsbyImageData\n          }\n        }\n        alt\n      }\n    }\n    html\n  }\n}\n</code></pre>\n\n<p>This will query the first markdown file available in our data layer, but to specify the markdown file needed for each page, we will need to use <a href=\"https://www.gatsbyjs.com/docs/graphql-reference/#query-variables\">variables in our query</a>. The File System Route API injects the <code>slug</code> in the page’s context in a property called <code>frontmatter__slug</code>. When a property is in the page’s context, it can be used as a query variable under a <code>$</code> followed by the property name, so the slug will be available as <code>$frontmatter__slug</code>.</p>\n<pre><code>query RecipeQuery {\n  query RecipeQuery($frontmatter__slug: String) {\n    markdownRemark(frontmatter: {slug: {eq: $frontmatter__slug}}) {\n      frontmatter {\n        slug\n        title\n        date\n        cover_image {\n          image {\n            childImageSharp {\n              gatsbyImageData\n            }\n          }\n          alt\n        }\n      }\n      html\n    }\n  }\n}\n</code></pre>\n\n<p>The page’s component is pretty simple. We just get the query data from the component’s <code>props</code>. Displaying the title and date is straightforward, and the <code>html</code> can be injected into a <code>p</code> tag. For the image, we just have to use the <code>GatsbyImage</code> component exposed by the <a href=\"https://www.gatsbyjs.com/plugins/gatsby-plugin-image\"><code>gatsby-plugin-image</code></a>.</p>\n<div>\n<pre><code>// src/pages/recipes/{markdownRemark.frontmatter__slug}.js\n\nconst RecipePage = ({data}) =&gt; {\n  const {html, frontmatter} = data.markdownRemark;\n  const {title, cover_image, date} = frontmatter;\n  const cover_image_data = getImage(cover_image.image.childImageSharp.gatsbyImageData);\n\n  return (\n    &lt;main&gt;\n      &lt;h1&gt;{title}&lt;/h1&gt;\n      &lt;p&gt;{date}&lt;/p&gt;\n      &lt;GatsbyImage image={cover_image_data} alt={cover_image.alt} /&gt;\n      &lt;p dangerouslySetInnerHTML={{__html: html}}&gt;&lt;/p&gt;\n    &lt;/main&gt;\n  );\n};\n\n//...\n</code></pre>\n</div>\n\n<p>The last thing is to use the <a href=\"https://www.gatsbyjs.com/docs/reference/built-in-components/gatsby-head/\">Gatsby Head API</a> to change the page’s title to the recipe’s title. This can be easily done since the query’s <code>data</code> is also available in the <code>Head</code> component.</p>\n<div>\n<pre><code>// src/pages/recipes/{markdownRemark.frontmatter__slug}.js\n\n//...\n\nexport const Head = ({data}) =&gt; &lt;title&gt;{data.markdownRemark.frontmatter.title}&lt;/title&gt;;\n</code></pre>\n</div>\n\n<p>Summing all up results in the following code:</p>\n<div>\n<pre><code>// src/pages/recipes/{markdownRemark.frontmatter__slug}.js\n\nimport * as React from \"react\";\nimport {GatsbyImage, getImage} from \"gatsby-plugin-image\";\nimport {graphql} from \"gatsby\";\n\nconst RecipePage = ({data}) =&gt; {\n  const {html, frontmatter} = data.markdownRemark;\n  const {title, cover_image, date} = frontmatter;\n  const cover_image_data = getImage(cover_image.image.childImageSharp.gatsbyImageData);\n\n  return (\n    &lt;main&gt;\n      &lt;h1&gt;{title}&lt;/h1&gt;\n      &lt;p&gt;{date}&lt;/p&gt;\n      &lt;GatsbyImage image={cover_image_data} alt={cover_image.alt} /&gt;\n      &lt;p dangerouslySetInnerHTML={{__html: html}}&gt;&lt;/p&gt;\n    &lt;/main&gt;\n  );\n};\n\nexport const recipeQuery = graphql<code>query RecipeQuery($frontmatter&amp;#95;&amp;#95;slug: String) {\n    markdownRemark(frontmatter: {slug: {eq: $frontmatter&amp;#95;&amp;#95;slug}}) {\n      frontmatter {\n        slug\n        title\n        date\n        cover&amp;#95;image {\n          image {\n            childImageSharp {\n              gatsbyImageData\n            }\n          }\n          alt\n        }\n      }\n      html\n    }\n  }</code>;\n\nexport default RecipePage;\n\nexport const Head = ({data}) =&gt; &lt;title&gt;{data.markdownRemark.frontmatter.title}&lt;/title&gt;;\n</code></pre>\n</div>\n\n<h3>Creating Localized Content</h3>\n<p>With all this finished, we have a functioning recipe blog in English. Now we will use each plugin to add i18n features and localize the site (for this tutorial) for Spanish speakers. But first, we will make a Spanish version for each markdown file in <code>./src/content/</code>. Leaving a structure like the following:</p>\n<pre><code>├── src\n│ ├── content\n| | ├── mac-and-cheese\n| | | ├── cover.jpg\n| | | ├── index.en.md\n| | | ├── index.es.md\n| | ├── burritos\n| | | ├── cover.jpg\n| | | ├── index.en.md\n| | | ├── index.es.md\n| | ├── pizza\n| | | ├── cover.jpg\n| | | ├── index.en.md\n| | | ├── index.es.md\n│ ├── pages\n│ ├── images\n</code></pre>\n\n<p>Inside our new Spanish markdown files, we will have the same structure in our frontmatter but translated to our new language and change the <code>locale</code> property in the frontmatter to <code>es</code>. However, it’s important to note that the <code>slug</code> field must be the same in each locale.</p>\n<code>gatsby-plugin-i18n</code>\n<p>This plugin is displayed in Gatsby’s <a href=\"https://www.gatsbyjs.com/docs/how-to/adding-common-features/localization-i18n/\">Internationalization Guide</a> as its first option when implementing i18n routes. The purpose of this plugin is to create localized routes by adding a language code in each page filename, so, for example, a <code>./src/pages/index.en.js</code> file would result in a <code>my-site.com/en/</code> route.</p>\n<p>I strongly recommend not using this plugin. It is outdated and hasn’t been updated since 2019, so it is kind of a disappointment to see it promoted as one of the main solutions for i18n in Gatsby’s official documentation. It also <a href=\"https://github.com/angeloocana/gatsby-plugin-i18n/issues/163\">breaks the File System API</a>, so you must use another method for creating pages, like the <code>createPages</code> function in the <a href=\"https://www.gatsbyjs.com/docs/reference/config-files/gatsby-node/#createPages\">Gatsby Node API</a>. Its only real use would be to create localized routes for certain pages, but considering that you must create a file for each page and each locale, it would be impossible to manage them on even medium sites. A 20 pages site with support for five languages would need 100 files!</p>\n<code>gatsby-theme-i18n</code>\n<p>Another plugin for implementing localized routes is <code>gatsby-theme-i18n</code>, which will be pretty easy to use in our prior example.</p>\n<p>We will first need to install the <code>gatsby-theme-i18n</code> plugin and the <code>gatsby-plugin-react-helmet</code> and <code>react-helmet</code> plugins to help add useful language metadata in our <code>&lt;head&gt;</code> tag.</p>\n<pre><code>npm install gatsby-theme-i18n gatsby-plugin-react-helmet react-helmet\n</code></pre>\n\n<p>Next, we can add it to the <code>gatsby-config.js</code>:</p>\n<pre><code>// ./gatsby-config.js\n\nmodule.exports = {\n  //...\n  plugins: [\n    //other plugins ...\n    {\n      resolve: `gatsby-theme-i18n`,\n      options: {\n        defaultLang: `en`,\n        prefixDefault: true,\n        configPath: require.resolve(`./i18n/config.json`),\n      },\n    },\n  ],\n};\n</code></pre>\n\n<p>As you can see, the plugin <code>configPath</code> points to a JSON file. This file will have all the information necessary to add each locale. We will create it in a new <code>./i18n/</code> directory at the root of our project:</p>\n<pre><code>[\n  {\n    \"code\": \"en\",\n    \"hrefLang\": \"en-US\",\n    \"name\": \"English\",\n    \"localName\": \"English\",\n    \"langDir\": \"ltr\",\n    \"dateFormat\": \"MM/DD/YYYY\"\n  },\n\n  {\n    \"code\": \"es\",\n    \"hrefLang\": \"es-ES\",\n    \"name\": \"Spanish\",\n    \"localName\": \"Español\",\n    \"langDir\": \"ltr\",\n    \"dateFormat\": \"DD.MM.YYYY\"\n  }\n]\n</code></pre>\n\n<p><strong>Note:</strong> <em>To see changes in the <code>gatsby-config.js</code> file, we will need to restart the development server.</em></p>\n<p>And just as simple as that, we added i18n routes to all our pages. Let’s head to <code>http://localhost:8000/es/</code> or <code>http://localhost:8000/en/</code> to see the result.</p>\n<h3>Querying Localized Content</h3>\n<p>At first glance, you will see a big problem: the Spanish and English pages have all the posts from both locales because we aren’t filtering the recipes for a specific locale, so we get all the available recipes. We can solve this by once again adding variables to our GraphQL queries. The <code>gatsby-theme-i18n</code> injects the current locale into the page’s context, making it available to use as a query variable under the <code>$locale</code> name.</p>\n<p><code>index</code> page query:</p>\n<pre><code>query IndexQuery($locale: String) {\n  allMarkdownRemark(filter: {frontmatter: {locale: {eq: $locale}}}) {\n    nodes {\n      frontmatter {\n        slug\n        title\n        date\n        cover_image {\n          image {\n            childImageSharp {\n              gatsbyImageData\n            }\n          }\n          alt\n        }\n      }\n    }\n  }\n}\n</code></pre>\n\n<p><code>{markdownRemark.frontmatter__slug}.js</code> page query:</p>\n<div>\n<pre><code>query RecipeQuery($frontmatter__slug: String, $locale: String) {\n  markdownRemark(frontmatter: {slug: {eq: $frontmatter__slug}, locale: {eq: $locale}}) {\n    frontmatter {\n      slug\n      title\n      date\n      cover_image {\n        image {\n          childImageSharp {\n            gatsbyImageData\n          }\n        }\n        alt\n      }\n    }\n    html\n  }\n}\n</code></pre>\n</div>\n\n<h3>Localizing Links</h3>\n<p>You will also notice that all Gatsby links are broken since they point to the non-localized routes instead of the new routes, so they will direct the user to a 404 page. To solve this, <code>gatsby-theme-i18n</code> exposes a <code>LocalizedLink</code> component that works exactly like Gatsby’s <code>Link</code> but points to the current locale. We just have to switch each <code>Link</code> component for a <code>LocalizedLink</code>.</p>\n<pre><code>// ./src/components/RecipePreview.js\n\n+ import {LocalizedLink as Link} from \"gatsby-theme-i18n\";\n- import {Link} from \"gatsby\";\n\n//...\n</code></pre>\n\n<h3>Changing Locales</h3>\n<p>Another vital feature to add will be a component to change from one locale to another. However, making a language selector isn’t completely straightforward. First, we will need to know the current page’s path, like <code>/en/recipes/pizza</code>, to extract the <code>recipes/pizza</code> part and add the desired locale, getting <code>/es/recipes/pizza</code>.</p>\n<p>To access the page’s location information (URL, HREF, path, and so on) in all our components, we will need to use the <code>wrapPageElement</code> function available in the <a href=\"https://www.gatsbyjs.com/docs/reference/config-files/gatsby-browser/#wrapPageElement\"><code>gatsby-browser.js</code></a> and <a href=\"https://www.gatsbyjs.com/docs/reference/config-files/gatsby-ssr/#wrapPageElement\"><code>gatsby-ssr.js</code></a> files. In short, this function lets you access the <code>props</code> used on each page, including a <code>location</code> object. We can set up a context provider with the location information and pass it down to all components.</p>\n<p>First, we will create the location context in a new directory: <code>./src/context/</code>.</p>\n<div>\n<pre><code>// ./src/context/LocationContext.js\n\nimport * as React from \"react\";\nimport {createContext} from \"react\";\n\nexport const LocationContext = createContext();\n\nexport const LocationProvider = ({location, children}) =&gt; {\n  return &lt;LocationContext.Provider value={location}&gt;{children}&lt;/LocationContext.Provider&gt;;\n};\n</code></pre>\n</div>\n\n<p>As you can imagine, we will pass the page’s <code>location</code> object to the provider’s <code>location</code> attribute on each Gatsby file:</p>\n<pre><code>// ./gatsby-ssr.js &amp; ./gatsby-browser.js\n\nimport * as React from \"react\";\nimport {LocationProvider} from \"./src/context/LocationContext\";\n\nexport const wrapPageElement = ({element, props}) =&gt; {\n  const {location} = props;\n\n  return &lt;LocationProvider location={location}&gt;{element}&lt;/LocationProvider&gt;;\n};\n</code></pre>\n\n<p><strong>Note</strong>: <em>Since we just created the <code>gatsby-ssr.js</code> and <code>gatsby-browser.js</code> files, we will need to restart the development server.</em></p>\n<p>Now the page’s location is available in all components through context, and we can use it in our language selector. We have also to pass down the current locale to all components, and the <code>gatsby-theme-i18n</code> exposes a useful <code>useLocalization</code> hook that let you access the current locale and the i18n config. However, a caveat is that it can’t get the current locale on Gatsby files like <code>gatsby-browser.js</code> and <code>gatsby-ssr.js</code>, only the i18n config.</p>\n<p>Ideally, we would want to render our language selector using <code>wrapPageElement</code> so it is available on all pages, but we can’t use the <code>useLocazication</code> hook. Fortunately, the <code>wrapPageElement</code> <code>props</code> argument also exposes the page’s context and, inside, its current locale.</p>\n<p>Let’s create another context to pass down the locale:</p>\n<div>\n<pre><code>// ./src/context/LocaleContext.js\n\nimport * as React from \"react\";\nimport {createContext} from \"react\";\n\nexport const LocaleContext = createContext();\n\nexport const LocaleProvider = ({locale, children}) =&gt; {\n  return &lt;LocaleContext.Provider value={locale}&gt;{children}&lt;/LocaleContext.Provider&gt;;\n};\n</code></pre>\n</div>\n\n<p>And use it in our <code>wrapPageElement</code> function:</p>\n<pre><code>// ./gatsby-ssr.js &amp; ./gatsby-browser.js\n\nimport * as React from \"react\";\nimport {LocationProvider} from \"./src/context/LocationContext\";\nimport {LocaleProvider} from \"./src/context/LocaleContext\";\n\nexport const wrapPageElement = ({element, props}) =&gt; {\n  const {location} = props;\n  const {locale} = element.props.pageContext;\n\n  return (\n    &lt;LocationProvider location={location}&gt;\n      &lt;LocaleProvider locale={locale}&gt;{element}&lt;/LocaleProvider&gt;\n    &lt;/LocationProvider&gt;\n  );\n};\n</code></pre>\n\n<p>The last thing is how to remove the locale (<code>es</code> or <code>en</code>) from the path (<code>/es/recipes/pizza</code>). Using the following simple but ugly regex, we can remove all the <code>/en/</code> and <code>/es/</code> at the beginning of the path:</p>\n<pre><code>/(\\/e(s|n)|)(\\/*|)/\n</code></pre>\n\n<p>It’s important to note that the regex pattern only works for the <code>en</code> and <code>es</code> combination of locales.</p>\n<p>Now we have to create our <code>LanguageSelector.js</code>:</p>\n<pre><code>// ./src/components/LanguageSelector\n\nimport * as React from \"react\";\nimport {useContext} from \"react\";\nimport {useLocalization} from \"gatsby-theme-i18n\";\nimport {Link} from \"gatsby\";\nimport {LocationContext} from \"../context/LocationContext\";\nimport {LocaleContext} from \"../context/LocaleContext\";\n\nexport const LanguageSelector = () =&gt; {\n  const {config} = useLocalization();\n  const locale = useContext(LocaleContext);\n  const {pathname} = useContext(LocationContext);\n\n  const removeLocalePath = /(\\/e(s|n)|)(\\/*|)/;\n  const pathnameWithoutLocale = pathname.replace(removeLocalePath, \"\");\n\n  return (\n    &lt;div&gt;\n      {config.map(({code, localName}) =&gt; {\n        return (\n          code !== locale &amp;&amp; (\n            &lt;Link key={code} to={`/${code}/${pathnameWithoutLocale}`}&gt;\n              {localName}\n            &lt;/Link&gt;\n          )\n        );\n      })}\n    &lt;/div&gt;\n  );\n};\n</code></pre>\n\n<p>Let’s break down what is happening:</p>\n<ol>\n<li>Get our i18n config through the <code>useLocalization</code> hook.</li>\n<li>Get the current locale through context.</li>\n<li>Get the page’s current pathname through context, which is the part that comes after the domain (like <code>/en/recipes/pizza</code>).</li>\n<li>We remove the locale part of the pathname using a regex pattern (leaving just <code>recipes/pizza</code>).</li>\n<li>We want to render a link for each available locale except the current one, so we will check if the locale is the same as the page before rendering a common Gatsby <code>Link</code> to the desired locale.</li>\n</ol>\n<p>Now inside our <code>gatsby-ssr.js</code> and <code>gatsby-browser.js</code> files, we can add our <code>LanguageSelector</code>:</p>\n<pre><code>// ./gatsby-ssr.js &amp; ./gatsby-browser.js\n\nimport * as React from \"react\";\nimport {LocationProvider} from \"./src/context/LocationContext\";\nimport {LocaleProvider} from \"./src/context/LocaleContext\";\nimport {LanguageSelector} from \"./src/components/LanguageSelector\";\n\nexport const wrapPageElement = ({element, props}) =&gt; {\n  const {location} = props;\n  const {locale} = element.props.pageContext;\n\n  return (\n    &lt;LocationProvider location={location}&gt;\n      &lt;LocaleProvider locale={locale}&gt;\n        &lt;LanguageSelector /&gt;\n        {element}\n      &lt;/LocaleProvider&gt;\n    &lt;/LocationProvider&gt;\n  );\n};\n</code></pre>\n\n<h3>Redirecting Users</h3>\n<p>The last detail to address is that now the non-i18n routes like <code>http://localhost:8000/</code> or <code>http://localhost:8000/recipes/pizza</code> are empty. To solve this, we can redirect the user to their desired locale using Gatsby’s redirect in <code>gatsby-node.js</code>.</p>\n<pre><code>// ./gatsby-node.js\n\nexports.createPages = async ({actions}) =&gt; {\n  const {createRedirect} = actions;\n\n  createRedirect({\n    fromPath: `/*`,\n    toPath: `/en/*`,\n    isPermanent: true,\n  });\n\n  createRedirect({\n    fromPath: `/*`,\n    toPath: `/es/*`,\n    isPermanent: true,\n    conditions: {\n      language: [`es`],\n    },\n  });\n};\n</code></pre>\n\n<p><strong>Note</strong>: <em>Redirects only work in production! Not in the local development server.</em></p>\n<p>With this, each page that doesn’t start with the English or Spanish locale will be redirected to a localized route. The wildcard <code>*</code> at the end of each route says it will redirect them to the same path, e.g., it will redirect <code>/recipes/mac-and-cheese/</code> to <code>/en/recipes/mac-and-cheese/</code>. Also, it will check for the specified language in the request’s origin and redirect to the locale if available; else, it will default to English.</p>\n<code>react-intl</code>\n<p><code>react-intl</code> is an internationalization library for any React app that can be used with Gatsby without any extra configuration. It provides a component to handle translations and many more to format numbers, dates, times, etc. Like the following:</p>\n<ul>\n<li><code>FormattedNumber</code>,</li>\n<li><code>FormattedDate</code>,</li>\n<li><code>FormattedTime</code>.</li>\n</ul>\n<p>It works by adding a provider called <code>IntlProvider</code> to pass down the current locale to all the <code>react-intl</code> components. Among others, the provider takes three main attributes:</p>\n<ul>\n<li><code>message</code><br />An object with all your translations.</li>\n<li><code>locale</code><br />The current page’s locale.</li>\n<li><code>defaultLocale</code><br />The default page’s locale.</li>\n</ul>\n<p>So, for example:</p>\n<pre><code>  &lt;IntlProvider messages={{}} locale=\"es\" defaultLocale=\"en\" &gt;\n      &lt;FormattedNumber value={15000} /&gt;\n      &lt;br /&gt;\n      &lt;FormattedDate value={Date.now()} /&gt;\n      &lt;br /&gt;\n      &lt;FormattedTime value={Date.now()} /&gt;\n      &lt;br /&gt;\n  &lt;/IntlProvider&gt;,\n</code></pre>\n\n<p>Will format the given values to Spanish and render:</p>\n<pre><code>15.000\n\n23/1/2023\n\n19:40\n</code></pre>\n\n<p>But if the <code>locale</code> attribute in <code>IntlProvider</code> was <code>en</code>, it would format the values to English and render:</p>\n<pre><code>15,000\n\n1/23/2023\n\n7:42 PM\n</code></pre>\n\n<p>Pretty cool and simple!</p>\n<h3>Using <code>react-intl</code> With Gatsby</h3>\n<p>To showcase how the <code>react-intl</code> works with Gatsby, we will continue from our prior example using <code>gatsby-theme-i18n</code>.</p>\n<p>We first will need to install the <code>react-intl</code> package:</p>\n<pre><code>npm i react-intl\n</code></pre>\n\n<p>Secondly, we have to write our translations, and in this case, we just have to translate the title and subtitle on the <code>index.js</code> page. To do so, we will create a file called <code>messajes.js</code> in the <code>./i18n/</code> directory:</p>\n<div>\n<pre><code>// ./i18n/messages.js\n\nexport const messages = {\n  en: {\n    index_page_title: \"Welcome to my English cooking blog!\",\n    index_page_subtitle: \"Written by Juan Diego Rodríguez\",\n  },\n  es: {\n    index_page_title: \"¡Bienvenidos a mi blog de cocina en español!\",\n    index_page_subtitle: \"Escrito por Juan Diego Rodríguez\",\n  },\n};\n</code></pre>\n</div>\n\n<p>Next, we have to set up the <code>IntlProvider</code> in the <code>gatsby-ssr.js</code> and <code>gatsby-browser.js</code> files:</p>\n<div>\n<pre><code>// ./gatsby-ssr.js &amp; ./gatsby-browser.js\n\nimport * as React from \"react\";\nimport {LocationProvider} from \"./src/context/LocationContext\";\nimport {LocaleProvider} from \"./src/context/LocaleContext\";\nimport {IntlProvider} from \"react-intl\";\nimport {LanguageSelector} from \"./src/components/LanguageSelector\";\nimport {messages} from \"./i18n/messages\";\n\nexport const wrapPageElement = ({element, props}) =&gt; {\n  const {location} = props;\n  const {locale} = element.props.pageContext;\n\n  return (\n    &lt;LocationProvider location={location}&gt;\n      &lt;LocaleProvider locale={locale}&gt;\n        &lt;IntlProvider messages={messages[locale]} locale={locale} defaultLocale=\"en\"&gt;\n          &lt;LanguageSelector /&gt;\n          {element}\n        &lt;/IntlProvider&gt;\n      &lt;/LocaleProvider&gt;\n    &lt;/LocationProvider&gt;\n  );\n};\n</code></pre>\n</div>\n\n<p>And use the <code>FormattedMessage</code> component with an <code>id</code> attribute holding the desired translation key name.</p>\n<pre><code>// ./src/pages/index.js\n\n// ...\nimport {FormattedMessage} from \"react-intl\";\n\nconst IndexPage = ({data}) =&gt; {\n  const recipes = data.allMarkdownRemark.nodes;\n\n  return (\n    &lt;main&gt;\n      &lt;h1&gt;\n        &lt;FormattedMessage id=\"index_page_title\" /&gt;\n      &lt;/h1&gt;\n      &lt;h2&gt;\n        &lt;FormattedMessage id=\"index_page_subtitle\" /&gt;\n      &lt;/h2&gt;\n      {recipes.map(({frontmatter}) =&gt; {\n        return &lt;RecipePreview key={frontmatter.slug} data={frontmatter} /&gt;;\n      })}\n    &lt;/main&gt;\n  );\n};\n\n// ...\n</code></pre>\n\n<p>And as simple as that, our translations will be applied depending on the current user’s locale. However, i18n isn’t only translating all the text to other languages but also adapting to the way numbers, dates, currency, and so on are formatted in the user’s regions. In our example, we can format the date on each recipe page to be formatted according to the current locale using the <code>FormattedDate</code> component.</p>\n<div>\n<pre><code>// ./src/pages/recipes/{markdownRemark.frontmatter__slug}.js\n\n//...\nimport {FormattedDate} from \"react-intl\";\n\nconst RecipePage = ({data}) =&gt; {\n  const {html, frontmatter} = data.markdownRemark;\n  const {title, cover_image, date} = frontmatter;\n  const cover_image_data = getImage(cover_image.image.childImageSharp.gatsbyImageData);\n\n  return (\n    &lt;main&gt;\n      &lt;h1&gt;{title}&lt;/h1&gt;\n      &lt;FormattedDate value={date} year=\"numeric\" month=\"long\" day=\"2-digit\" /&gt;\n      &lt;GatsbyImage image={cover_image_data} alt={cover_image.alt} /&gt;\n      &lt;p dangerouslySetInnerHTML={{__html: html}}&gt;&lt;/p&gt;\n    &lt;/main&gt;\n  );\n};\n\n//...\n</code></pre>\n</div>\n\n<p>As you can see, we feed the component the raw date and specify how we want to display it. Then the component will automatically format it to the correct locale. And with the <code>year</code>, <code>month</code>, and <code>day</code> attributes, we can further customize how to display our date. In our example, the date <code>19-01-2023</code> will be formatted the following way:</p>\n<pre><code>English: January 19, 2023\n\nSpanish: 19 de enero de 2023\n</code></pre>\n\n<p>If we want to add a localized string around the date, we can use <a href=\"https://formatjs.io/docs/getting-started/message-declaration#using-react-api-formattedmessage\"><code>react-intl</code> arguments</a>. Arguments are a way to add dynamic data inside our <code>react-intl</code> messages. It works by adding curly braces <code>{}</code> inside a message.</p>\n<p>The arguments follow this pattern <code>{ key, type, format }</code>, in which</p>\n<ul>\n<li><code>key</code> is the data to be formatted;</li>\n<li><code>type</code> specifies if the <code>key</code> is going to be a number, date, time, and so on;</li>\n<li><code>format</code> further specifies the format, e.g., if a date is going to be written like <code>10/05/2023</code> or <code>October 5, 2023</code>.</li>\n</ul>\n<p>In our case, we will name our key <code>postedOn</code>, and it will be a <code>date</code> type in a <code>long</code> format:</p>\n<pre><code>// ./i18n/messages.js\n\nexport const messages = {\n  en: {\n    // ...\n    recipe_post_date: \"Written on {postedOn, date, long}\",\n  },\n  es: {\n    // ...\n    recipe_post_date: \"Escrito el {postedOn, date, long}\",\n  },\n};\n</code></pre>\n\n<div>\n<pre><code>// ./src/pages/recipes/{markdownRemark.frontmatter__slug}.js\n\n//...\nimport {FormattedMessage} from \"react-intl\";\n\nconst RecipePage = ({data}) =&gt; {\n  const {html, frontmatter} = data.markdownRemark;\n  const {title, cover_image, date} = frontmatter;\n  const cover_image_data = getImage(cover_image.image.childImageSharp.gatsbyImageData);\n\n  return (\n    &lt;main&gt;\n      &lt;h1&gt;{title}&lt;/h1&gt;\n      &lt;FormattedMessage id=\"recipe_post_date\" values={{postedOn: new Date(date)}} /&gt;\n      &lt;GatsbyImage image={cover_image_data} alt={cover_image.alt} /&gt;\n      &lt;p dangerouslySetInnerHTML={{__html: html}}&gt;&lt;/p&gt;\n    &lt;/main&gt;\n  );\n};\n//...\n</code></pre>\n</div>\n\n<p><strong>Note</strong>: <em>For the date to work, we will need to create a new <code>Date</code> object with our <code>date</code> as its only argument.</em></p>\n<h3>Localizing The Page’s Title</h3>\n<p>The last thing you may have noticed is that the index page’s title isn’t localized. In the recipes pages’ case, this isn’t a problem since it queries the already localized title for each post, but the <code>index</code> page title doesn’t. Solving this can be tricky for two reasons:</p>\n<ol>\n<li>You can’t use <a href=\"https://www.gatsbyjs.com/docs/reference/built-in-components/gatsby-head/\">Gatsby Head API</a> directly with <code>react-intl</code> since the <code>IntlProvider</code> doesn’t exist for components created inside the Head API.</li>\n<li>You can’t use the <code>FormattedMessage</code> component inside the <code>title</code> tag since it only allows a simple string value, not a component.</li>\n</ol>\n<p>However, there is a workaround for both problems:</p>\n<ol>\n<li>We can use <code>react-helmet</code> (which we installed with <code>gatsby-theme-i18n</code>) inside the page component where the <code>IntlProvider</code> is available.</li>\n<li>We can use <a href=\"https://formatjs.io/docs/react-intl/api/\"><code>react-intl</code> imperative API</a> to get the messages as strings instead of the <code>FormmatedMessage</code> component. In this case, the imperative API exposes a <code>useIntl</code> hook which returns an <code>intl</code> object, and the <code>intl.messages</code> property holds all our messages too.</li>\n</ol>\n<p>So the <code>index</code> component would end up like this:</p>\n<pre><code>// ./src/pages/index.js\n\n// ...\nimport {FormattedMessage, useIntl} from \"react-intl\";\nimport {Helmet} from \"react-helmet\";\n\nconst IndexPage = ({data}) =&gt; {\n  const intl = useIntl();\n\n  const recipes = data.allMarkdownRemark.nodes;\n\n  return (\n    &lt;main&gt;\n      &lt;Helmet&gt;\n        &lt;title&gt;{intl.messages.index_page_title}&lt;/title&gt;\n      &lt;/Helmet&gt;\n      &lt;h1&gt;\n        &lt;FormattedMessage id=\"index_page_title\" /&gt;\n      &lt;/h1&gt;\n      &lt;h2&gt;\n        &lt;FormattedMessage id=\"index_page_subtitle\" /&gt;\n      &lt;/h2&gt;\n      {recipes.map(({frontmatter}) =&gt; {\n        return &lt;RecipePreview key={frontmatter.slug} data={frontmatter} /&gt;;\n      })}\n    &lt;/main&gt;\n  );\n};\n\n// ...\n</code></pre>\n\n<code>react-i18next</code>\n<p><code>react-i18next</code> is a well-established library for adding i18n to our react sites, and it brings the same and more features, hooks, and utils of <code>react-intl</code>. However, a crucial difference is that to set up <code>react-i18next</code>, we will need to create a wrapper plugin in <code>gatsby-node.js</code> while you can use <code>react-intl</code> as soon as you install it, so I believe it’s a better option to use with Gatsby. However, there already are plugins to set up faster the <code>react-i18next</code> library like <a href=\"https://www.npmjs.com/package/gatsby-plugin-react-i18next\"><code>gatsby-plugin-react-i18next</code></a> and <a href=\"https://www.npmjs.com/package/gatsby-theme-i18n-react-i18next\"><code>gatsby-theme-i18n-react-i18next</code></a>.</p>\nConclusion\n<p>The current state of Gatsby and especially its plugin is precarious, and each year its <a href=\"https://2022.stateofjs.com/en-US/libraries/#tier_list\">popularity goes lower</a>, so it’s important to know how to handle it and which plugins to use if you want to work with Gatsby. Despite all, I still believe Gatsby is a powerful tool and is still worth starting a new project with <code>npm init gatsby</code>.</p>\n<p>I hope you found this guide useful and leave with a better grasp of i18n in Gatsby and with less of a headache. In the next article, we will explore an in-depth solution to i18n by creating your own i18n plugin!</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"53964bdd00f36252a83dc7d7da96d3b421cbb10e6718f024eb5fa37f1cd0f984","category":"Tech"}