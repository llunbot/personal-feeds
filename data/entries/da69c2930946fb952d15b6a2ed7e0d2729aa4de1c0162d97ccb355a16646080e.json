{"title":"8 Terraform continuous validation use cases for AWS, Google Cloud, and Azure","link":"https://www.hashicorp.com/blog/8-terraform-continuous-validation-use-cases-for-aws-google-cloud-and-azure","date":1687795200000,"content":"<p>Just because everything worked when you provisioned your infrastructure, you can’t assume everything will continue to work properly after deployment. Continuous validation is a foundational feature for HashiCorp Terraform Cloud Plus that helps make sure infrastructure is working as expected. Use cases for continuous validation include closing security gaps, controlling budgets, dealing with certificate expiration, or even just knowing whether a virtual machine (VM) is up and running.</p>\n\n<p>Continuous validation for Terraform Cloud Plus provides long-term visibility and checks for your infrastructure’s health and security — including service configuration, identity and access management, or anything utilized by an application’s business logic — to ensure infrastructure is working as expected. Specifically, continuous validation lets users add assertions so Terraform can proactively monitor if configurations or modules with assertions are passing, and notify users if any assertions fail. This helps users identify issues when they first appear and avoid situations where a change is identified only during a future Terraform <em>plan</em>/<em>apply</em> or once it causes a user-facing problem.</p>\n\n<p>Users can create assertions in their Terraform configuration using <a href=\"https://developer.hashicorp.com/terraform/language/checks\">check blocks</a>, which are available in Terraform 1.5 and later. Check blocks are a new HCL language feature that allows users to define assertions as a custom condition expression and an error message. When the condition expression evaluates to true, the check passes. When the expression evaluates to false, Terraform shows a warning that includes the user-defined error message so users can take immediate actions to remedy the situation.</p>\n\n<p>Custom conditions can be created using data from Terraform providers’ resources, data sources, and <a href=\"https://developer.hashicorp.com/terraform/language/checks#scoped-data-sources\">scoped data sources</a>. Data can also be combined from multiple sources. For example, you can use checks to monitor expirable resources by comparing a resource’s expiration date attribute to the current time returned by Terraform’s built-in time functions.</p>\n\n<p>This blog post shows how you can define checks in your Terraform configuration to address a number of use cases, using data returned from Amazon Web Services (AWS), Google Cloud, and Microsoft Azure. You can use the list below to jump directly to the use cases for the cloud providers that interest you:</p>\n\n<p><strong>AWS use cases</strong></p>\n\n<ul>\n<li>Ensure your AWS account is within budget </li>\n<li>Detect threats with detailed findings for AWS accounts</li>\n</ul>\n\n<p><strong>Google Cloud use cases</strong></p>\n\n<ul>\n<li>Assert that a VM is in a running state</li>\n<li>Check if a certificate will expire within a certain timeframe </li>\n<li>Validate the status of a Cloud Function</li>\n</ul>\n\n<p><strong>Azure use cases</strong></p>\n\n<ul>\n<li>Assert that a VM is in a running state</li>\n<li>Monitor if a Container App certificate will expire within a certain timeframe</li>\n<li>Check if an App Service Function or Web App has exceeded its usage limit</li>\n</ul>\n\n<h2>AWS: Ensure your AWS account is within budget</h2>\n\n<p>AWS Budgets allows you to track and take action on your AWS costs and usage. It monitors your aggregate utilization and coverage metrics for your Reserved Instances (RIs) or Savings Plans. </p>\n\n<p>AWS Budgets can track various costs and usage, including:</p>\n\n<ul>\n<li>Setting a monthly cost budget with a fixed target amount to track all costs associated with your account. </li>\n<li>Setting a monthly cost budget with a variable target amount, with each subsequent month growing the budget target by 5%. </li>\n<li>Setting a monthly usage budget with a fixed usage amount and forecasted notifications to help ensure that you are staying within the service limits for a specific service.</li>\n<li>Setting a daily utilization or coverage budget to track your RI or Savings Plans. </li>\n</ul>\n\n<p>The example below shows how a check block can be used to assert that you remain in compliance for the budgets that have been set up. (<strong>Note:</strong> In this example we can use version 5.2 and later of the AWS provider.)</p>\n<pre><code>check \"check_budget_exceeded\" {\n  data \"aws_budgets_budget\" \"example\" {\n    name = aws_budgets_budget.example.name\n  }\n\n  assert {\n    condition = !data.aws_budgets_budget.example.budget_exceeded\n    error_message = format(\"AWS budget has been exceeded! Calculated spend: '%s' and budget limit: '%s'\",\n                 data.aws_budgets_budget.example.calculated_spend[0].actual_spend[0].amount,\n      data.aws_budgets_budget.example.budget_limit[0].amount\n      )\n  }\n}</code></pre><p>If the budget exceeds the set limit, the check block assertion will return a warning similar to this:</p>\n<pre><code>│ Warning: Check block assertion failed\n│ \n│   on main.tf line 43, in check \"check_budget_exceeded\":\n│   43:     condition = !data.aws_budgets_budget.example.budget_exceeded\n│     ├────────────────\n│     │ data.aws_budgets_budget.example.budget_exceeded is true\n│ \n│ AWS budget has been exceeded! Calculated spend: '1550.0' and budget limit: '1200.0'</code></pre><h2>AWS: Detect threats with detailed findings for AWS accounts</h2>\n\n<p>Amazon GuardDuty is a threat-detection service that continuously monitors for malicious activity and unauthorized behavior to protect your AWS accounts, workloads, and data stored in Amazon S3. AWS simplifies the collection and aggregation of account and network activities, but it can be time consuming for security teams to continuously analyze event log data for potential threats.</p>\n\n<p>The following example outlines how a check block can be utilized to assert that no threats have been identified from AWS GuardDuty. (<strong>Note:</strong> In this example we can use version 5.2 and later of the AWS provider.)</p>\n<pre><code>data \"aws_guardduty_detector\" \"example\" {}\n\ncheck \"check_guardduty_findings\" {\n  data \"aws_guardduty_finding_ids\" \"example\" {\n    detector_id = data.aws_guardduty_detector.example.id\n  }\n\n  assert {\n    condition = !data.aws_guardduty_finding_ids.example.has_findings\n    error_message = format(\"AWS GuardDuty detector '%s' has %d open findings!\",\n      data.aws_guardduty_finding_ids.example.detector_id,\n      length(data.aws_guardduty_finding_ids.example.finding_ids),\n    )\n  }\n}</code></pre><p>If findings are present, the check block assertion will return a warning similar to this:</p>\n<pre><code>│ Warning: Check block assertion failed\n│\n│   on main.tf line 24, in check \"check_guardduty_findings\":\n│   24:     condition = !data.aws_guardduty_finding_ids.example.has_findings\n│     ├────────────────\n│     │ data.aws_guardduty_finding_ids.example.has_findings is true\n│\n│ AWS GuardDuty detector 'abcdef123456' has 9 open findings!</code></pre><h2>Google Cloud: Assert that a VM is in a running state</h2>\n\n<p>VM instances provisioned using Google Compute Engine can pass through several states as part of the <a href=\"https://cloud.google.com/compute/docs/instances/instance-life-cycle\">VM instance lifecycle</a>. Once a VM is provisioned, it could experience an error or a user could suspend or stop that VM in the Google Cloud console. That change might not be detected until the next Terraform plan is generated. Continuous validation can be used to assert the state of a VM and detect if there are any unexpected status changes that occur out-of-band.</p>\n\n<p>The example below shows how a check block can be used to assert that a VM is in the running state. You can force the check to fail in this example by provisioning the VM, manually stopping it in the Google Cloud console, and then triggering a health check in Terraform Cloud. The check will fail and report that the VM is not running. (<strong>Note:</strong> In this example we can use version 4.70 and later of the Google provider, configured with a default project, region, and zone.)</p>\n<pre><code>data \"google_compute_network\" \"default\" {\n  name                    = \"default\"\n}\n\nresource \"google_compute_instance\" \"vm_instance\" {\n  name         = \"my-instance\"\n  machine_type = \"f1-micro\"\n\n  boot_disk {\n    initialize_params {\n      image = \"debian-cloud/debian-11\"\n    }\n  }\n\n  network_interface {\n    network = data.google_compute_network.default.name\n    access_config {\n    }\n  }\n}\n\ncheck \"check_vm_status\" {\n\n  # Note: in this example we reference the resource directly instead of using a data source (or a data source that is scoped to this check block)\n\n  assert {\n    condition = google_compute_instance.vm_instance.current_status == \"RUNNING\"\n    error_message = format(\"Provisioned VMs should be in a RUNNING status, instead the VM `%s` has status: %s\",\n      google_compute_instance.vm_instance.name,\n      google_compute_instance.vm_instance.current_status\n    )\n  }\n}</code></pre><h2>Google Cloud: Check if a certificate will expire within a certain timeframe</h2>\n\n<p>Certificates can be provisioned using either the Google Certificate Manager, Google Certificate Authority Service, and Google Compute Engine APIs. In this example, we provision a certificate via the Google Certificate Authority Service that has a user-supplied <a href=\"https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/privateca_certificate#lifetime\">lifetime argument</a>. After the lifetime duration passes, the certificate is automatically deleted in Google Cloud. In order to prepare for this event and not be caught off-guard, we can create a check asserting that the certificate’s expiration date is more than 30 days away. When the certificate’s expiration is approaching, health checks notifications from Terraform Cloud will alert users and allow manual intervention to be completed in time.</p>\n\n<p>In the example below, we provision a certificate with a lifetime of 30 days and 2 minutes (see <code>local.month_and_2min_in_second_duration</code>) and create a check that asserts certificates should be valid for the next 30 days (see <code>local.month_in_hour_duration</code>).</p>\n\n<p>We can see the check begin to fail by waiting 2 minutes after the certificate is provisioned and then triggering a health check in Terraform Cloud. The check will fail and report that the certificate is due to expire in less than a month. (<strong>Note:</strong> In this example we can use version 4.70 and later of the Google provider, configured with a default project, region, and zone.)</p>\n<pre><code>locals {\n  month_in_hour_duration = \"${24 * 30}h\"\n  month_and_2min_in_second_duration = \"${(60 * 60 * 24 * 30) + (60 * 2)}s\"\n}\n\nresource \"tls_private_key\" \"example\" {\n  algorithm   = \"RSA\"\n}\n\nresource \"tls_cert_request\" \"example\" {\n  private_key_pem = tls_private_key.example.private_key_pem\n\n  subject {\n    common_name  = \"example.com\"\n    organization = \"ACME Examples, Inc\"\n  }\n}\n\nresource \"google_privateca_ca_pool\" \"default\" {\n  name     = \"my-ca-pool\"\n  location = \"us-central1\"\n  tier     = \"ENTERPRISE\"\n  publishing_options {\n    publish_ca_cert = true\n    publish_crl = true\n  }\n  labels = {\n    terraform = true\n  }\n  issuance_policy {\n    baseline_values {\n      ca_options {\n        is_ca = false\n      }\n      key_usage {\n        base_key_usage {\n          digital_signature = true\n          key_encipherment = true\n        }\n        extended_key_usage {\n          server_auth = true\n        }\n      }\n    }\n  }\n}\n\nresource \"google_privateca_certificate_authority\" \"test-ca\" {\n  deletion_protection      = false\n  certificate_authority_id = \"my-authority\"\n  location                 = google_privateca_ca_pool.default.location\n  pool                     = google_privateca_ca_pool.default.name\n  config {\n    subject_config {\n      subject {\n        country_code = \"us\"\n        organization = \"google\"\n        organizational_unit = \"enterprise\"\n        locality = \"mountain view\"\n        province = \"california\"\n        street_address = \"1600 amphitheatre parkway\"\n        postal_code = \"94109\"\n        common_name = \"my-certificate-authority\"\n      }\n    }\n    x509_config {\n      ca_options {\n        is_ca = true\n      }\n      key_usage {\n        base_key_usage {\n          cert_sign = true\n          crl_sign  = true\n        }\n        extended_key_usage {\n          server_auth = true\n        }\n      }\n    }\n  }\n  type = \"SELF_SIGNED\"\n  key_spec {\n    algorithm = \"RSA_PKCS1_4096_SHA256\"\n  }\n}\n\nresource \"google_privateca_certificate\" \"default\" {\n  name                  = \"my-certificate\"\n  pool                  = google_privateca_ca_pool.default.name\n  certificate_authority = google_privateca_certificate_authority.test-ca.certificate_authority_id\n  location              = google_privateca_ca_pool.default.location\n  lifetime              = local.month_and_2min_in_second_duration # lifetime is 2mins over the threshold in the check block below\n  pem_csr               = tls_cert_request.example.cert_request_pem\n}\n\ncheck \"check_certificate_state\" {\n\n  assert {\n    condition = timecmp(plantimestamp(), timeadd(\ngoogle_privateca_certificate.default.certificate_description[0].subject_description[0].not_after_time,\n      \"-${local.month_in_hour_duration}\")) &lt; 0\n    error_message = format(\"Provisioned certificates should be valid for at least 30 days, but `%s`is due to expire on `%s`.\",\n    google_privateca_certificate.default.name,\n    \ngoogle_privateca_certificate.default.certificate_description[0].subject_description[0].not_after_time\n    )\n  }\n}</code></pre><h2>Google Cloud: Validate the status of a Cloud Function</h2>\n\n<p>Google Cloud Functions can have multiple statuses (ACTIVE, FAILED, DEPLOYING, DELETING) depending on issues that occur during deployment or triggering the function. In the example below we create a second-generation cloud function that uses source code stored as a .zip file in a Google Cloud Storage bucket. A .zip file containing the files needed by the function is uploaded by Terraform from the local machine. </p>\n\n<p>In the check, we use the <code>google_cloudfunctions2_function</code> data source’s <a href=\"https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/cloudfunctions2_function#state\">state attribute</a> to access the function’s state and assert that the function is active. (<strong>Note:</strong> In this example we can use version 4.70 and later of the Google provider, configured with a default project, region, and zone.)</p>\n<pre><code>resource \"google_storage_bucket\" \"bucket\" {\n  name     = \"my-bucket\"\n  location = \"US\"\n  uniform_bucket_level_access = true\n}\n\nresource \"google_storage_bucket_object\" \"object\" {\n  name   = \"function-source.zip\"\n  bucket = google_storage_bucket.bucket.name\n  source = \"./function-source.zip\"\n}\n\nresource \"google_cloudfunctions2_function\" \"my-function\" {\n  name = \"my-function\"\n  location = \"us-central1\"\n  description = \"a new function\"\n\n  build_config {\n    runtime = \"nodejs12\"\n    entry_point = \"helloHttp\"\n    source {\n      storage_source {\n        bucket = google_storage_bucket.bucket.name\n        object = google_storage_bucket_object.object.name\n      }\n    }\n  }\n\n  service_config {\n    max_instance_count  = 1\n    available_memory    = \"1536Mi\"\n    timeout_seconds     = 30\n  }\n}\n\ncheck \"check_cf_state\" {\n  data \"google_cloudfunctions2_function\" \"my-function\" {\n    name = google_cloudfunctions2_function.my-function.name\n    location = google_cloudfunctions2_function.my-function.location\n  }\n\n  assert {\n    condition = data.google_cloudfunctions2_function.my-function.state == \"ACTIVE\"\n    error_message = format(\"Provisioned Cloud Functions should be in an ACTIVE state, instead the function `%s` has state: %s\",\n      data.google_cloudfunctions2_function.my-function.name,\n      data.google_cloudfunctions2_function.my-function.state\n    )\n  }\n}</code></pre><h2>Azure: Assert that a VM is in a running state</h2>\n\n<p>An Azure Virtual Machine gives you the flexibility of virtualization without having to buy and maintain the physical hardware that runs it. However, you still need to maintain the virtual machine by performing tasks, such as configuring, patching, and installing the software that runs on it. Provisioned VM instances can pass through several different power states as part of the VM-instance lifecycle. Once a VM is provisioned, it could experience an error, or a user could suspend or stop that VM and that change might not be detected until the next Terraform <em>plan</em> is generated. Continuous validation can be used to assert the state of a VM and detect if there are any unexpected status changes that occur out-of-band.</p>\n\n<p>The example below shows how a check block can be used to assert that a VM is in the running state. You can force the check to fail in this example by provisioning the VM, manually stopping it, and then triggering a health check in Terraform Cloud. The check will fail and report that the VM is not running:</p>\n<pre><code>data \"azurerm_virtual_machine\" \"example\" {\n  name                = azurerm_linux_virtual_machine.example.name\n  resource_group_name = azurerm_resource_group.example.name\n}\n\ncheck \"check_vm_state\" {\n  assert {\n    condition = data.azurerm_virtual_machine.example.power_state == \"running\"\n    error_message = format(\"Virtual Machine (%s) should be in a 'running' status, instead state is '%s'\",\n      data.azurerm_virtual_machine.example.id,\n      data.azurerm_virtual_machine.example.power_state\n    )\n  }\n}</code></pre><p>The full example can be found in the AzureRM provider's <a href=\"https://github.com/hashicorp/terraform-provider-azurerm/tree/main/examples/tfc-checks/vm-power-state\">examples/tfc-checks/vm-power-state</a> folder in GitHub.</p>\n\n<h2>Azure: Monitor if a Container App certificate will expire within a certain timeframe</h2>\n\n<p>Azure App Service Certificates (and other resources) can be provisioned using a user-supplied certificate. The example below shows how to check that a certificate should be valid for the next 30 days (see <code>local.month_in_hour_duration</code>):</p>\n<pre><code>locals {\n  month_in_hour_duration = \"${24 * 30}h\"\n}\n\ndata \"azurerm_app_service_certificate\" \"example\" {\n  name                = azurerm_app_service_certificate.example.name\n  resource_group_name = azurerm_app_service_certificate.example.resource_group_name\n}\n\ncheck \"check_certificate_state\" {\n  assert {\n    condition = timecmp(plantimestamp(), timeadd(\n      data.azurerm_app_service_certificate.example.expiration_date,\n      \"-${local.month_in_hour_duration}\")) &lt; 0\n    error_message = format(\"App Service Certificate (%s) is valid for at least 30 days, but is due to expire on `%s`.\",\n      data.azurerm_app_service_certificate.example.id,\n      data.azurerm_app_service_certificate.example.expiration_date\n    )\n  }\n}</code></pre><p>The full example can be found in the AzureRM provider's <a href=\"https://github.com/hashicorp/terraform-provider-azurerm/tree/main/examples/tfc-checks/app-service-certificate-expiry\">examples/tfc-checks /app-service-certificate-expiry</a> folder on GitHub.</p>\n\n<h2>Azure: Check if an App Service Function or Web App has exceeded its usage limit</h2>\n\n<p>App Service Function and Web Apps can exceed their usage limits. The example below shows how a check block can be used to assert that a Function or Web App has not exceeded its usage limit:</p>\n<pre><code>data \"azurerm_linux_function_app\" \"example\" {\n  name                = azurerm_linux_function_app.example.name\n  resource_group_name = azurerm_linux_function_app.example.resource_group_name\n}\n\ncheck \"check_usage_limit\" {\n  assert {\n    condition = data.azurerm_linux_function_app.example.usage == \"Exceeded\"\n    error_message = format(\"Function App (%s) usage has been exceeded!\",\n      data.azurerm_linux_function_app.example.id,\n    )\n  }\n}\n</code></pre><p>The full example can be found in the AzureRM provider's <a href=\"https://github.com/hashicorp/terraform-provider-azurerm/tree/main/examples/tfc-checks/app-service-app-usage\">examples/tfc-checks/app-service-app-usage</a> folder on GitHub.</p>\n\n<h2>Getting started with Terraform Cloud</h2>\n\n<p>Terraform is the industry standard for provisioning and managing any infrastructure. Continuous validation gives users the visibility to ensure that their infrastructure works as expected, and will notify users if it fails. For more information, visit the <a href=\"https://developer.hashicorp.com/terraform/cloud-docs/workspaces/health\">Workspace Health</a> page in the Terraform Cloud documentation.</p>\n\n<p>Try these new features today — and if you are new to Terraform, <a href=\"https://app.terraform.io/public/signup/account\">sign up for Terraform Cloud</a> and <a href=\"https://www.hashicorp.com/contact-sales?interest=terraform\">contact sales for a trial</a> of Terraform Cloud Plus.</p>\n","author":"Sarah French","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"da69c2930946fb952d15b6a2ed7e0d2729aa4de1c0162d97ccb355a16646080e","category":"Tech"}