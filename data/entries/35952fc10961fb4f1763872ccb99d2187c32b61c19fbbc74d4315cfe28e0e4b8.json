{"title":"Stop the CNAME chain struggle: Simplified management with Route 53 Resolver DNS Firewall","link":"https://aws.amazon.com/blogs/aws/stop-the-cname-chain-struggle-simplified-management-with-route-53-resolver-dns-firewall/","date":1714577995000,"content":"<p>Starting today, you can configure your DNS Firewall to automatically trust all domains in a resolution chain (such as a<code>CNAME</code>, <code>DNAME</code>, or <code>Alias</code> chain).</p> \n<p>Letâ€™s walk through this in nontechnical terms for those unfamiliar with DNS.</p> \n<p><span><strong>Why use DNS Firewall?<br /> </strong></span><a href=\"https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resolver-dns-firewall.html\">DNS Firewall</a> provides protection for outbound DNS requests from your private network in the cloud (<a href=\"https://aws.amazon.com/vpc/\">Amazon Virtual Private Cloud (Amazon VPC)</a>). These requests route through <a href=\"https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resolver.html\">Amazon Route 53 Resolver</a> for domain name resolution. Firewall administrators can configure rules to filter and regulate the outbound DNS traffic.</p> \n<p>DNS Firewall helps to protect against multiple security risks.</p> \n<p>Letâ€™s imagine a malicious actor managed to install and run some code on your <a href=\"https://aws.amazon.com/ec2/\">Amazon Elastic Compute Cloud (Amazon EC2)</a> instances or containers running inside one of your virtual private clouds (VPCs). The malicious code is likely to initiate outgoing network connections. It might do so to connect to a command server and receive commands to execute on your machine. Or it might initiate connections to a third-party service in a coordinated distributed denial of service (DDoS) attack. It might also try to exfiltrate data it managed to collect on your network.</p> \n<p>Fortunately, your network and security groups are correctly configured. They block all outgoing traffic except the one to well-known API endpoints used by your app. So far so goodâ€”the malicious code cannot dial back home using regular TCP or UDP connections.</p> \n<p>But what about DNS traffic? The malicious code may send DNS requests to an authoritative DNS server they control to either send control commands or encoded data, and it can receive data back in the response. Iâ€™ve illustrated the process in the following diagram.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/03/29/dns-exfiltration-v01.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/03/29/dns-exfiltration-v01.png\" alt=\"DNS exfiltration illustrated\" width=\"800\" height=\"450\" /></a></p> \n<p>To prevent these scenarios, you can use a DNS Firewall to monitor and control the domains that your applications can query. You can deny access to the domains that you know to be bad and allow all other queries to pass through. Alternately, you can deny access to all domains except those you explicitly trust.</p> \n<p><span><strong>What is the challenge with CNAME, DNAME, and Alias records?<br /> </strong></span>Imagine you configured your DNS Firewall to allow DNS queries only to specific well-known domains and blocked all others. Your application communicates with <code>alexa.amazon.com;</code> therefore, you created a rule allowing DNS traffic to resolve that hostname.</p> \n<p>However, the DNS system has multiple types of records. The ones of interest in this article are</p> \n<ul> \n <li><code>A</code> records that map a DNS name to an IP address,</li> \n <li><code>CNAME</code> records that are synonyms for other DNS names,</li> \n <li><code> DNAME</code> records that provide redirection from a part of the DNS name tree to another part of the DNS name tree, and</li> \n <li><code>Alias</code> records that provide a Route 53 specific extension to DNS functionality. Alias records let you route traffic to selected AWS resources, such as <a href=\"https://aws.amazon.com/cloudfront/\">Amazon CloudFront</a> distributions and Amazon S3 buckets</li> \n</ul> \n<p>When querying <code>alexa.amazon.com</code>, I see itâ€™s actually a <code>CNAME</code> record that points to <code>pitangui.amazon.com</code>, which is another <code>CNAME</code> record that points to <code>tp.5fd53c725-frontier.amazon.com</code>, which, in turn, is a <code>CNAME</code> to <code>d1wg1w6p5q8555.cloudfront.net</code>. Only the last name (<code>d1wg1w6p5q8555.cloudfront.net</code>) has an <code>A</code> record associated with an IP address <code>3.162.42.28</code>. The IP address is likely to be different for you. It points to the closest <a href=\"https://aws.amazon.com/cloudfront/\">Amazon CloudFront</a> edge location, likely the one from Paris (<code>CDG52</code>) for me.</p> \n<p>A similar redirection mechanism happens when resolving <code>DNAME</code> or <code>Alias</code> records.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/03/29/2024-03-29_12-46-21.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/03/29/2024-03-29_12-46-21.png\" alt=\"DNS resolution for alexa.amazon.com\" width=\"800\" height=\"415\" /></a></p> \n<p>To allow the complete resolution of such a <code>CNAME</code> chain, you could be tempted to configure your DNS Firewall rule to allow all names under amazon.com (<code>*.amazon.com</code>), but that would fail to resolve the last <code>CNAME</code> that goes to <code>cloudfront.net</code>.</p> \n<p>Worst, the DNS CNAME chain is controlled by the service your application connects to. The chain might change at any time, forcing you to manually maintain the list of rules and authorized domains inside your DNS Firewall rules.</p> \n<p><span><strong>Introducing DNS Firewall redirection chain authorization<br /> </strong></span>Based on this explanation, youâ€™re now equipped to understand the new capability we launch today. We added a parameter to the <a href=\"https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_UpdateFirewallRule.html\">UpdateFirewallRule</a> API (also available on the <a href=\"https://aws.amazon.com/cli/\">AWS Command Line Interface (AWS CLI)</a> and <a href=\"https://console.aws.amazon.com\">AWS Management Console</a>) to configure the DNS Firewall so that it follows and automatically trusts all the domains in a <code>CNAME</code>, <code>DNAME</code>, or <code>Alias</code> chain.</p> \n<p>This parameter allows firewall administrators to only allow the domain your applications query. The firewall will automatically trust all intermediate domains in the chain until it reaches the <code>A</code> record with the IP address.</p> \n<p><span><strong>Letâ€™s see it in action<br /> </strong></span>I start with a DNS Firewall already configured with a <a href=\"https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resolver-dns-firewall-domain-lists.html\">domain list</a>, <a href=\"https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resolver-dns-firewall-rule-groups.html\">a rule group, and a rule</a> that ALLOW queries for the domain <code>alexa.amazon.com</code>. The rule group is attached to a VPC where I have an EC2 instance started.</p> \n<p>When I connect to that EC2 instance and issue a DNS query to resolve <code>alexa.amazon.com</code>, it only returns the first name in the domain chain (<code>pitangui.amazon.com</code>) and stops there. This is expected because <code>pitangui.amazon.com</code> is not authorized to be resolved.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/03/29/2024-03-29_14-12-33.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/03/29/2024-03-29_14-12-33.png\" alt=\"DNS query for alexa.amazon.com is blocked at first CNAME\" width=\"800\" height=\"518\" /></a></p> \n<p>To solve this, I update the firewall rule to trust the entire redirection chain. I use the AWS CLI to call the <code>update-firewall-rule</code> API with a new parameter <code>firewall-domain-redirection-action</code> set to <code>TRUST_REDIRECTION_DOMAIN</code>.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/03/29/2024-03-29_14-13-32.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/03/29/2024-03-29_14-13-32.png\" alt=\"AWS CLI to update the DNS firewall rule\" width=\"800\" height=\"420\" /></a></p> \n<p>The following diagram illustrates the setup at this stage.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/03/29/firewall-rule-association-v02.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/03/29/firewall-rule-association-v02.png\" alt=\"DNS Firewall rule diagram\" width=\"800\" height=\"450\" /></a></p> \n<p>Back to the EC2 instance, I try the DNS query again. This time, it works. It resolves the entire redirection chain, down to the IP address <img src=\"https://s.w.org/images/core/emoji/14.0.0/72x72/1f389.png\" alt=\"ðŸŽ‰\" />.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/03/29/2024-03-29_14-08-18.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/03/29/2024-03-29_14-08-18.png\" alt=\"DNS resolution for the full CNAME chain\" width=\"800\" height=\"501\" /></a></p> \n<p>Thanks to the trusted chain redirection, network administrators now have an easy way to implement a strategy to block all domains and authorize only known domains in their DNS Firewall without having to care about <code>CNAME</code>, <code>DNAME</code>, or <code>Alias</code> chains.</p> \n<p>This capability is available at no additional cost in all AWS Regions. <a href=\"https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resolver-dns-firewall.html\">Try it out today</a>!</p> \n<a href=\"https://twitter.com/sebsto\">-- seb</a>","author":"SÃ©bastien Stormacq","siteTitle":"AWS News Blog","siteHash":"6093e072e4117ec22616e844cb857d03ca62c57a411a8affc77cb5e8b6b15bf6","entryHash":"35952fc10961fb4f1763872ccb99d2187c32b61c19fbbc74d4315cfe28e0e4b8","category":"Tech"}