{"title":"Passkeys: A No-Frills Explainer On The Future Of Password-Less Authentication","link":"https://smashingmagazine.com/2023/10/passkeys-explainer-future-password-less-authentication/","date":1698660000000,"content":"<p>Passkeys are a new way of authenticating applications and websites. Instead of having to remember a password, a third-party service provider (e.g., Google or Apple) generates and stores a cryptographic key pair that is bound to a website domain. Since you have access to the service provider, you have access to the keys, which you can then use to log in.</p>\n<p>This cryptographic key pair contains both private and public keys that are used for authenticating messages. These key pairs are often known as <em>asymmetric</em> or <em>public key cryptography</em>.</p>\n<p>Public and private key pair? Asymmetric cryptography? Like most modern technology, passkeys are described by esoteric verbiage and acronyms that make them difficult to discuss. That’s the point of this article. I want to put the complex terms aside and help illustrate how passkeys work, explain what they are effective at, and demonstrate what it looks like to work with them.</p>\nHow Passkeys Work\n<p>Passkeys are cryptographic keys that rely on generating signatures. A <em>signature</em> is proof that a message is authentic. How so? It happens first by hashing (a fancy term for “obscuring”) the message and then creating a signature from that hash with your private key. The private key in the cryptographic key pair allows the signature to be generated, and the public key, which is shared with others, allows the service to verify that the message did, in fact, come from you.</p>\n<p>In short, passkeys consist of two keys: a <strong>public</strong> and <strong>private</strong>. One verifies a signature while the other verifies you, and the communication between them is what grants you access to an account.</p>\n<p>Here’s a quick way of generating a signing and verification key pair to authenticate a message using the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto\">SubtleCrypto API</a>. While this is only <em>part</em> of how passkeys work, it does illustrate how the concept works cryptographically underneath the specification.</p>\n<div>\n<pre><code>const message = new TextEncoder().encode(\"My message\");\n\nconst keypair = await crypto.subtle.generateKey(\n  { name: \"ECDSA\", namedCurve: \"P-256\" },\n  true,\n  [ 'sign', 'verify' ]\n);\n\nconst signature = await crypto.subtle.sign(\n  { name: \"ECDSA\", hash: \"SHA-256\" },\n  keypair.privateKey,\n  message\n);\n\n// Normally, someone else would be doing the verification using your public key\n// but it's a bit easier to see it yourself this way\nconsole.log(\n  \"Did my private key sign this message?\",\n  await crypto.subtle.verify(\n    { name: \"ECDSA\", hash: \"SHA-256\" },\n    keypair.publicKey,\n    signature,\n    message\n  )\n);\n</code></pre>\n</div>\n\n<p>Notice the three parts pulling all of this together:</p>\n<ol>\n<li><strong>Message:</strong> A message is constructed.</li>\n<li><strong>Key pair:</strong> The public and private keys are generated. One key is used for the signature, and the other is set to do the verification.</li>\n<li><strong>Signature:</strong> A signature is signed by the private key, verifying the message’s authenticity.</li>\n</ol>\n<p>From there, a third party would authenticate the private key with the public key, verifying the correct pair of keys or <strong>key pair</strong>. We’ll get into the weeds of how the keys are generated and used in just a bit, but for now, this is some context as we continue to understand why passkeys can potentially erase the need for passwords.</p>\nWhy Passkeys Can Replace Passwords\n<p>Since the responsibility of storing passkeys is removed and transferred to a third-party service provider, you only have to control the “parent” account in order to authenticate and gain access. This is a lot like requiring single sign-on (SSO) for an account via Google, Facebook, or LinkedIn, but instead, we use an account that has control of the passkey stored for each individual website.</p>\n<p>For example, I can use my Google account to store passkeys for <code>somerandomwebsite.com</code>. That allows me to prove a challenge by using that passkey’s private key and thus authenticate and log into <code>somerandomwebsite.com</code>.</p>\n<p>For the non-tech savvy, this typically looks like a prompt that the user can click to log in. Since the credentials (i.e., username and password) are tied to the domain name (<code>somerandomwebsite.com</code>), and passkeys created for a domain name are only accessible to the user at login, the user can select which passkey they wish to use for access. This is usually only one login, but in some cases, you can create multiple logins for a single domain and then select which one you wish to use from there.</p>\n<p><img src=\"https://files.smashing.media/articles/passkeys-explainer-future-password-less-authentication/1-passkeys-prompt.png\" /></p>\n<p>So, what’s the downside? Having to store additional cryptographic keys for each login and every site for which you have a passkey often <strong>requires more space than storing a password.</strong> However, I would argue that the security gains, the user experience from not having to remember a password, and the prevention of common phishing techniques more than offset the increased storage space.</p>\nHow Passkeys Protect Us\n<p>Passkeys prevent a couple of security issues that are quite common, specifically <strong>leaked database credentials</strong> and <strong>phishing attacks</strong>.</p>\n<h3>Database Leaks</h3>\n<p>Have you ever shared a password with a friend or colleague by copying and pasting it for them in an email or text? That could lead to a security leak. So would a hack on a system that stores customer information, like passwords, which is then <a href=\"https://www.consumeraffairs.com/news/new-84-billion-password-hack-breaks-records-060821.html\">sold on dark marketplaces or made public</a>. In many cases, it’s a weak set of credentials — like an email and password combination — that can be stolen with a fair amount of ease.</p>\n<p>Passkeys technology circumvents this because <strong>passkeys only store a public key to an account</strong>, and as you may have guessed by the name, this key is expected to be made accessible to anyone who wants to use it. <strong>The public key is only used for verification purposes</strong> and, for the intended use case of passkeys, is effectively useless without the private key to go with it, as the two are generated as a pair. Therefore, those previous juicy database leaks are no longer useful, as they can no longer be used for cracking the password for your account. Cracking a similar private key would take millions of years at this point in time.</p>\n<h3>Phishing</h3>\n<p>Passwords rely on knowing what the password is for a given login: anyone with that <em>same</em> information has the <em>same</em> level of access to the <em>same</em> account as you do. There are sophisticated phishing sites that look like they’re by Microsoft or Google and will redirect you to the real provider after you attempt to log into their fake site. The damage is already done at that point; your credentials are captured, and hopefully, the same credentials weren’t being used on other sites, as now you’re compromised there as well.</p>\n<p>A passkey, by contrast, is tied to a domain. You gain a new element of security: the fact that only you have the private key. Since the private key is not feasible to remember nor computationally easy to guess, we can guarantee that you are who you say we are (at least as long as your passkey provider is not compromised). So, that fake phishing site? It will not even show the passkey prompt because the domain is different, and thus completely mitigates phishing attempts.</p>\n<p>There are, of course, theoretical attacks that can make passkeys vulnerable, like someone compromising your DNS server to send you to a domain that now points to their fake site. That said, you probably have deeper issues to concern yourself with if it gets to that point.</p>\nImplementing Passkeys\n<p>At a high level, a few items are needed to start using passkeys, at least for the common sign-up and log-in process. You’ll need a temporary cache of some sort, such as <a href=\"https://redis.com\">redis</a> or <a href=\"https://cloud.google.com/appengine/docs/standard/services/memcache/using?tab=python\">memcache</a>, for storing temporary challenges that users can authenticate against, as well as a more permanent data store for storing user accounts and their public key information, which can be used to authenticate the user over the course of their account lifetime. These aren’t hard requirements but rather what’s typical of what would be developed for this kind of authentication process.</p>\n<p>To understand passkeys properly, though, we want to work through a couple of concepts. The first concept is <strong>what is actually taking place when we generate a passkey</strong>. How are passkeys generated, and what are the underlying cryptographic primitives that are being used? The second concept is <strong>how passkeys are used to verify information</strong> and why that information can be trusted.</p>\n<h3>Generating Passkeys</h3>\n<p>A passkey involves an authenticator to generate the key pair. The authenticator can either be hardware or software. For example, it can be a hardware security key, the operating system’s <a href=\"https://learn.microsoft.com/en-us/windows/security/hardware-security/tpm/trusted-platform-module-overview\">Trusted Platform Module</a> (TPM), or some other application. In the cases of Android or iOS, we can use <a href=\"https://developer.apple.com/documentation/security/certificate_key_and_trust_services/keys/protecting_keys_with_the_secure_enclave\">the device’s secure enclave</a>.</p>\n<p>To connect to an authenticator, we use what’s called the <a href=\"https://fidoalliance.org/specs/fido-v2.1-ps-20210615/fido-client-to-authenticator-protocol-v2.1-ps-20210615.html\"><strong>Client to Authenticator Protocol</strong></a> <strong>(CTAP)</strong>. CTAP allows us to connect to hardware over different connections through the browser. For example, we can connect via CTAP using an NFC, Bluetooth, or a USB connection. This is useful in cases where we want to log in on one device while another device contains our passkeys, as is the case on some operating systems that do not support passkeys at the time of writing.</p>\n<p>A passkey is built off another web API called <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API\">WebAuthn</a>. While the APIs are very similar, the WebAuthn API differs in that <strong>passkeys allow for cloud syncing of the cryptographic keys</strong> and do not require knowledge of whom the user is to log in, as that information is stored in a passkey with its <a href=\"https://www.hypr.com/security-encyclopedia/relying-party-rp\">Relying Party (RP) information</a>. The two APIs otherwise share the same flows and cryptographic operations.</p>\n<h3>Storing Passkeys</h3>\n<p>Let’s look at an extremely high-level overview of how I’ve stored and kept track of passkeys in my <a href=\"https://github.com/nealfennimore/passkeys\">demo repo</a>. This is how the database is structured.</p>\n<p><img src=\"https://files.smashing.media/articles/passkeys-explainer-future-password-less-authentication/2-diagram-users-database-public-keys.png\" /></p>\n<p>Basically, a <code>users</code> table has <code>public_keys</code>, which, in turn, contains information about the public key, as well as the public key itself.</p>\n<p>From there, I’m caching certain information, including challenges to verify authenticity and data about the sessions in which the challenges take place.</p>\n<p><img src=\"https://files.smashing.media/articles/passkeys-explainer-future-password-less-authentication/3-diagram-challenges-sessions-tables.png\" /></p>\n<p>Again, this is only a high-level look to give you a clearer idea of what information is stored and how it is stored.</p>\nVerifying Passkeys\n<p>There are several entities involved in passkey:</p>\n<ol>\n<li>The <strong>authenticator</strong>, which we previously mentioned, generates our key material.</li>\n<li>The <strong>client</strong> that triggers the passkey generation process via the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/create\"><code>navigator.credentials.create</code></a> call.</li>\n<li>The Relying Party takes the resulting public key from that call and stores it to be used for subsequent verification.</li>\n</ol>\n<p><img src=\"https://files.smashing.media/articles/passkeys-explainer-future-password-less-authentication/4-authenticator-client-relying-party.png\" /></p>\n<p>In our case, <strong>you are the client</strong> and <strong>the Relying Party is the website server</strong> you are trying to sign up and log into. The <strong>authenticator</strong> can either be your mobile phone, a hardware key, or some other device capable of generating your cryptographic keys.</p>\n<p>Passkeys are used in two phases: the <strong>attestation phase</strong> and the <strong>assertion phase</strong>. The attestation phase is likened to a registration that you perform when first signing up for a service. Instead of an email and password, we generate a passkey.</p>\n<p><img src=\"https://files.smashing.media/articles/passkeys-explainer-future-password-less-authentication/5-decision-tree-workflow.png\" /></p>\n<p>Assertion is similar to logging in to a service after we are registered, and instead of verifying with a username and password, we use the generated passkey to access the service.</p>\n<p><img src=\"https://files.smashing.media/articles/passkeys-explainer-future-password-less-authentication/6-decision-tree-workflow.png\" /></p>\n<p>Each phase initially requires a random challenge generated by the Relying Party, which is then signed by the authenticator before the client sends the signature back to the Relying Party to prove account ownership.</p>\nBrowser API Usage\n<p>We’ll be looking at how the browser constructs and supplies information for passkeys so that you can store and utilize it for your login process. First, we’ll start with the attestation phase and then the assertion phase.</p>\nAttest To It\n<p>The following shows how to create a new passkey using the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/create\"><code>navigator.credentials.create</code></a> API. From it, we receive an <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAttestationResponse\"><code>AuthenticatorAttestationResponse</code></a>, and we want to send portions of that response to the Relying Party for storage.</p>\n<div>\n<pre><code>const { challenge } = await (await fetch(\"/attestation/generate\")).json(); // Server call mock to get a random challenge\n\nconst options = {\n // Our challenge should be a base64-url encoded string\n challenge: new TextEncoder().encode(challenge),\n rp: {\n  id: window.location.host,\n  name: document.title,\n },\n user: {\n  id: new TextEncoder().encode(\"my-user-id\"),\n  name: 'John',\n  displayName: 'John Smith',\n },\n pubKeyCredParams: [ // See COSE algorithms for more: <a href=\"https://www.iana.org/assignments/cose/cose.xhtml#algorithms\">https://www.iana.org/assignments/cose/cose.xhtml#algorithms</a>\n  {\n   type: 'public-key',\n   alg: -7, // ES256\n  },\n  {\n   type: 'public-key',\n   alg: -256, // RS256\n  },\n  {\n   type: 'public-key',\n   alg: -37, // PS256\n  },\n ],\n authenticatorSelection: {\n  userVerification: 'preferred', // Do you want to use biometrics or a pin?\n  residentKey: 'required', // Create a resident key e.g. passkey\n },\n attestation: 'indirect', // indirect, direct, or none\n timeout: 60_000,\n};\n\n// Create the credential through the Authenticator\nconst credential = await navigator.credentials.create({\n publicKey: options\n});\n\n// Our main attestation response. See: <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAttestationResponse\">https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAttestationResponse</a>\nconst attestation = credential.response as AuthenticatorAttestationResponse;\n\n// Now send this information off to the Relying Party\n// An unencoded example payload with most of the useful information\nconst payload = {\n kid: credential.id,\n clientDataJSON: attestation.clientDataJSON,\n attestationObject: attestation.attestationObject,\n pubkey: attestation.getPublicKey(),\n coseAlg: attestation.getPublicKeyAlgorithm(),\n};\n</code></pre>\n</div>\n\n<p>The <code>AuthenticatorAttestationResponse</code> contains the <code>clientDataJSON</code> as well as the <code>attestationObject</code>. We also have a couple of useful methods that save us from trying to retrieve the public key from the <code>attestationObject</code> and retrieving the COSE algorithm of the public key: <code>getPublicKey</code> and <code>getPublicKeyAlgorithm</code>.</p>\n<p>Let’s dig into these pieces a little further.</p>\n<h3>Parsing The Attestation <code>clientDataJSON</code></h3>\n<p>The <code>clientDataJSON</code> object is composed of a few fields we need. We can convert it to a workable object by decoding it and then running it through <code>JSON.parse</code>.</p>\n<pre><code>type DecodedClientDataJSON = {\n challenge: string,\n origin: string,\n type: string\n};\n\nconst decoded: DecodedClientDataJSON = JSON.parse(new TextDecoder().decode(attestation.clientDataJSON));\nconst {\n challenge,\n origin,\n type\n} = decoded;\n</code></pre>\n\n<p>Now we have a few fields to check against: <code>challenge</code>, <code>origin</code>, <code>type</code>.</p>\n<p>Our <code>challenge</code> is the <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Base64\">Base64-url encoded string</a> that was passed to the server. The <code>origin</code> is the host (e.g., <code>https://my.passkeys.com</code>) of the server we used to generate the passkey. Meanwhile, the <code>type</code> is <code>webauthn.create</code>. The server should verify that all the values are expected when parsing the <code>clientDataJSON</code>.</p>\n<h3>Decoding The<code>attestationObject</code></h3>\n<p>The <code>attestationObject</code> is a <a href=\"https://cbor.io\">CBOR encoded object</a>. We need to use a CBOR decoder to actually see what it contains. We can use a package like <a href=\"https://github.com/kriszyp/cbor-x\"><code>cbor-x</code></a> for that.</p>\n<div>\n<pre><code>import { decode } from 'cbor-x/decode';\n\nenum DecodedAttestationObjectFormat {\n  none = 'none',\n  packed = 'packed',\n}\ntype DecodedAttestationObjectAttStmt = {\n  x5c?: Uint8Array[];\n  sig?: Uint8Array;\n};\n\ntype DecodedAttestationObject = {\n  fmt: DecodedAttestationObjectFormat;\n  authData: Uint8Array;\n  attStmt: DecodedAttestationObjectAttStmt;\n};\n\nconst decodedAttestationObject: DecodedAttestationObject = decode(\n new Uint8Array(attestation.attestationObject)\n);\n\nconst {\n fmt,\n authData,\n attStmt,\n} = decodedAttestationObject;\n</code></pre>\n</div>\n\n<p><img src=\"https://files.smashing.media/articles/passkeys-explainer-future-password-less-authentication/7-passkeys-attestation.png\" /></p>\n<p><code>fmt</code> will often be evaluated to <code>\"none\"</code> here for passkeys. Other types of <code>fmt</code> are generated through other types of authenticators.</p>\n<h3>Accessing <code>authData</code></h3>\n<p>The <a href=\"https://www.w3.org/TR/webauthn/#authenticator-data\"><code>authData</code></a> is a buffer of values with the following structure:</p>\n<p><img src=\"https://files.smashing.media/articles/passkeys-explainer-future-password-less-authentication/8-passkeys-attestation-small.png\" /></p>\n<table>\n    <thead>\n        <tr>\n            <th>Name</th>\n            <th>Length (bytes)</th>\n      <th>Description</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td><code>rpIdHash</code></td>\n            <td>32</td>\n      <td>This is the SHA-256 hash of the origin, e.g., <code>my.passkeys.com</code>.</td>\n        </tr>\n        <tr>\n            <td><code>flags</code></td>\n            <td>1</td>\n      <td>Flags determine multiple pieces of information (<a href=\"https://www.w3.org/TR/webauthn/#authenticator-data\">specification</a>).</td>\n        </tr>\n        <tr>\n            <td><code>signCount</code></td>\n            <td>4</td>\n      <td>This should always be <code>0000</code> for passkeys.</td>\n        </tr>\n    <tr>\n            <td><code>attestedCredentialData</code></td>\n            <td>variable</td>\n      <td>This will contain credential data if it’s available in a COSE key format.</td>\n        </tr>\n    <tr>\n            <td><code>extensions</code></td>\n            <td>variable</td>\n      <td>These are any optional extensions for authentication.</td>\n        </tr>\n    </tbody>\n</table>\n\n<p>It is recommended to use the <code>getPublicKey</code> method here instead of manually retrieving the <code>attestedCredentialData</code>.</p>\n<h3>A Note About The <code>attStmt</code> Object</h3>\n<p>This is often an empty object for passkeys. However, in other cases of a <code>packed</code> format, which includes the <code>sig</code>, we will need to perform some authentication to verify the <code>sig</code>. This is out of the scope of this article, as it often requires a hardware key or some other type of device-based login.</p>\n<h3>Retrieving The Encoded Public Key</h3>\n<p>The <code>getPublicKey</code> method can retrieve the <a href=\"https://stackoverflow.com/questions/74687281/understanding-subject-public-key-info-definition-and-indentation\">Subject Public Key Info</a> (SPKI) encoded version of the public key, which is a different from the COSE key format (more on that next) within the <code>attestedCredentialData</code> that the <code>decodedAttestationObject.attStmt</code> has. The SPKI format has the benefit of being compatible with a <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey\">Web Crypto <code>importKey</code></a> function to more easily verify assertion signatures in the next phase.</p>\n<div>\n<pre><code>// Example of importing attestation public key directly into Web Crypto\nconst pubkey = await crypto.subtle.importKey(\n  'spki',\n  attestation.getPublicKey(),\n  { name: \"ECDSA\", namedCurve: \"P-256\" },\n  true,\n  ['verify']\n);\n</code></pre>\n</div>\n\n<h3>Generating Keys With COSE Algorithms</h3>\n<p>The algorithms that can be used to generate cryptographic material for a passkey are specified by their <a href=\"https://www.iana.org/assignments/cose/cose.xhtml#algorithms\">COSE Algorithm</a>. For passkeys generated for the web, we want to be able to generate keys using the following algorithms, as they are supported natively in <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API\">Web Crypto</a>. Personally, I prefer <a href=\"https://www.ibm.com/docs/en/zos/2.5.0?topic=cryptography-elliptic-curve-digital-signature-algorithm-ecdsa\">ECDSA-based algorithms</a> since the key sizes are quite a bit smaller than RSA keys.</p>\n<p>The COSE algorithms are declared in the <code>pubKeyCredParams</code> array within the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAttestationResponse\"><code>AuthenticatorAttestationResponse</code></a>. We can retrieve the COSE algorithm from the <code>attestationObject</code> with the <code>getPublicKeyAlgorithm</code> method. For example, if <code>getPublicKeyAlgorithm</code> returned <code>-7</code>, we’d know that the key used the <code>ES256</code> algorithm.</p>\n<table>\n    <thead>\n        <tr>\n            <th>Name</th>\n            <th>Value</th>\n      <th>Description</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>ES512</td>\n            <td>-36</td>\n      <td>ECDSA w/ SHA-512</td>\n        </tr>\n        <tr>\n            <td>ES384</td>\n            <td>-35</td>\n      <td>ECDSA w/ SHA-384</td>\n        </tr>\n        <tr>\n            <td>ES256</td>\n            <td>-7</td>\n      <td>ECDSA w/ SHA-256</td>\n        </tr>\n    <tr>\n            <td>RS512</td>\n            <td>-259</td>\n      <td>RSASSA-PKCS1-v1_5 using SHA-512</td>\n        </tr>\n    <tr>\n            <td>RS384</td>\n            <td>-258</td>\n      <td>RSASSA-PKCS1-v1_5 using SHA-384</td>\n        </tr>\n    <tr>\n            <td>RS256</td>\n            <td>-257</td>\n      <td>RSASSA-PKCS1-v1_5 using SHA-256</td>\n        </tr>\n    <tr>\n            <td>PS512</td>\n            <td>-39</td>\n      <td>RSASSA-PSS w/ SHA-512</td>\n        </tr>\n    <tr>\n            <td>PS384</td>\n            <td>-38</td>\n      <td>RSASSA-PSS w/ SHA-384</td>\n        </tr>\n    <tr>\n            <td>PS256</td>\n            <td>-37</td>\n      <td>RSASSA-PSS w/ SHA-256</td>\n        </tr>\n    </tbody>\n</table>\n\n<h3>Responding To The Attestation Payload</h3>\n<p>I want to show you an example of a response we would send to the server for registration. In short, the <a href=\"https://github.com/nealfennimore/passkeys/blob/main/src/utils.ts#L28-L29\"><code>safeByteEncode</code></a> function is used to change the buffers into Base64-url encoded strings.</p>\n<pre><code>type AttestationCredentialPayload = {\n  kid: string;\n  clientDataJSON: string;\n  attestationObject: string;\n  pubkey: string;\n  coseAlg: number;\n};\n\nconst payload: AttestationCredentialPayload = {\n  kid: credential.id,\n  clientDataJSON: safeByteEncode(attestation.clientDataJSON),\n  attestationObject: safeByteEncode(attestation.attestationObject),\n  pubkey: safeByteEncode(attestation.getPublicKey() as ArrayBuffer),\n  coseAlg: attestation.getPublicKeyAlgorithm(),\n};\n</code></pre>\n\n<p>The credential id (<code>kid</code>) should always be captured to look up the user’s keys, as it will be the primary key in the <code>public_keys</code> table.</p>\n<p>From there:</p>\n<ol>\n<li>The server would check the <code>clientDataJSON</code> to ensure the same <code>challenge</code> is used.</li>\n<li>The <code>origin</code> is checked, and the <code>type</code> is set to <code>webauthn.create</code>.</li>\n<li>We check the <code>attestationObject</code> to ensure it has an <code>fmt</code> of <code>none</code>, the <code>rpIdHash</code> of the <code>authData</code>, as well as any <code>flags</code> and the <code>signCount</code>.</li>\n</ol>\n<p>Optionally, we <em>could</em> check to see if the <code>attestationObject.attStmt</code> has a <code>sig</code> and verify the public key against it, but that’s for other types of WebAuthn flows we won’t go into.</p>\n<p>We should store the public key and the COSE algorithm in the database at the very least. It is also beneficial to store the <code>attestationObject</code> in case we require more information for verification. The <code>signCount</code> is always incremented on every login attempt if supporting other types of WebAuthn logins; otherwise, it should always be for <code>0000</code> for a passkey.</p>\nAsserting Yourself\n<p>Now we have to retrieve a stored passkey using the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get\"><code>navigator.credentials.get</code></a> API. From it, we receive the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAssertionResponse\"><code>AuthenticatorAssertionResponse</code></a>, which we want to send portions of to the Relying Party for verification.</p>\n<div>\n<pre><code>const { challenge } = await (await fetch(\"/assertion/generate\")).json(); // Server call mock to get a random challenge\n\nconst options = {\n  challenge: new TextEncoder().encode(challenge),\n  rpId: window.location.host,\n  timeout: 60_000,\n};\n\n// Sign the challenge with our private key via the Authenticator\nconst credential = await navigator.credentials.get({\n  publicKey: options,\n  mediation: 'optional',\n});\n\n// Our main assertion response. See: &lt;<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAssertionResponse\">https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAssertionResponse</a>&gt;\nconst assertion = credential.response as AuthenticatorAssertionResponse;\n\n// Now send this information off to the Relying Party\n// An example payload with most of the useful information\nconst payload = {\n  kid: credential.id,\n  clientDataJSON: safeByteEncode(assertion.clientDataJSON),\n  authenticatorData: safeByteEncode(assertion.authenticatorData),\n  signature: safeByteEncode(assertion.signature),\n};\n</code></pre>\n</div>\n\n<p>The <code>AuthenticatorAssertionResponse</code> again has the <code>clientDataJSON</code>, and now the <code>authenticatorData</code>. We also have the <code>signature</code> that needs to be verified with the stored public key we captured in the attestation phase.</p>\n<h3>Decoding The Assertion <code>clientDataJSON</code></h3>\n<p>The assertion <code>clientDataJSON</code> is very similar to the attestation version. We again have the <code>challenge</code>, <code>origin</code>, and <code>type</code>. Everything is the same, except the <code>type</code> is now <code>webauthn.get</code>.</p>\n<pre><code>type DecodedClientDataJSON = {\n  challenge: string,\n  origin: string,\n  type: string\n};\n\nconst decoded: DecodedClientDataJSON = JSON.parse(new TextDecoder().decode(assertion.clientDataJSON));\nconst {\n  challenge,\n  origin,\n  type\n} = decoded;\n</code></pre>\n\n<h3>Understanding The <code>authenticatorData</code></h3>\n<p>The <code>authenticatorData</code> is similar to the previous <code>attestationObject.authData</code>, except we no longer have the public key included (e.g., the <code>attestedCredentialData</code> ), nor any <code>extensions</code>.</p>\n<table>\n    <thead>\n        <tr>\n            <th>Name</th>\n            <th>Length (bytes)</th>\n      <th>Description</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td><code>rpIdHash</code></td>\n            <td>32</td>\n      <td>This is a SHA-256 hash of the origin, e.g., <code>my.passkeys.com</code>.</td>\n        </tr>\n        <tr>\n            <td><code>flags</code></td>\n            <td>1</td>\n      <td>Flags that determine multiple pieces of information (<a href=\"https://www.w3.org/TR/webauthn/#authenticator-data\">specification</a>).</td>\n        </tr>\n        <tr>\n            <td><code>signCount</code></td>\n            <td>4</td>\n      <td>This should always be <code>0000</code> for passkeys, just as it should be for <code>authData</code>.</td>\n        </tr>\n    </tbody>\n</table>\n\n<h3>Verifying The <code>signature</code></h3>\n<p>The <code>signature</code> is what we need to verify that the user trying to log in has the private key. It is the result of the concatenation of the <code>authenticatorData</code> and <code>clientDataHash</code> (i.e., the SHA-256 version of <code>clientDataJSON</code>).</p>\n<p><img src=\"https://files.smashing.media/articles/passkeys-explainer-future-password-less-authentication/10-verifying-signature.png\" /></p>\n<p>To verify with the public key, we need to also concatenate the <code>authenticatorData</code> and <code>clientDataHash</code>. If the verification returns <code>true</code>, we know that the user is who they say they are, and we can let them authenticate into the application.</p>\n<p><img src=\"https://files.smashing.media/articles/passkeys-explainer-future-password-less-authentication/9-verifying-public-key.png\" /></p>\n<p>Here’s an example of how this is calculated:</p>\n<div>\n<pre><code>const clientDataHash = await crypto.subtle.digest(\n  'SHA-256',\n  assertion.clientDataJSON\n);\n// For concatBuffer see: &lt;<a href=\"https://github.com/nealfennimore/passkeys/blob/main/src/utils.ts#L31\">https://github.com/nealfennimore/passkeys/blob/main/src/utils.ts#L31</a>&gt;\nconst data = concatBuffer(\n  assertion.authenticatorData,\n  clientDataHash\n);\n\n// NOTE: the signature from the assertion is in ASN.1 DER encoding. To get it working with Web Crypto\n//We need to transform it into r|s encoding, which is specific for ECDSA algorithms)\n//\n// For fromAsn1DERtoRSSignature see: &lt;<a href=\"https://github.com/nealfennimore/passkeys/blob/main/src/crypto.ts#L60&gt;'\">https://github.com/nealfennimore/passkeys/blob/main/src/crypto.ts#L60&gt;'</a>\nconst isVerified = await crypto.subtle.verify(\n  { name: 'ECDSA', hash: 'SHA-256' },\n  pubkey,\n  fromAsn1DERtoRSSignature(signature, 256),\n  data\n);\n</code></pre>\n</div>\n\n<h3>Sending The Assertion Payload</h3>\n<p>Finally, we get to send a response to the server with the assertion for logging into the application.</p>\n<pre><code>type AssertionCredentialPayload = {\n  kid: string;\n  clientDataJSON: string;\n  authenticatorData: string;\n  signature: string;\n};\n\nconst payload: AssertionCredentialPayload = {\n  kid: credential.id,\n  clientDataJSON: safeByteEncode(assertion.clientDataJSON),\n  authenticatorData: safeByteEncode(assertion.authenticatorData),\n  signature: safeByteEncode(assertion.signature),\n};\n</code></pre>\n\n<p>To complete the assertion phase, we first look up the stored public key, <code>kid</code>.</p>\n<p>Next, we verify the following:</p>\n<ul>\n<li><code>clientDataJSON</code> again to ensure the same <code>challenge</code> is used,</li>\n<li>The <code>origin</code> is the same, and</li>\n<li>That the <code>type</code> is <code>webauthn.get</code>.</li>\n</ul>\n<p>The <code>authenticatorData</code> can be used to check the <code>rpIdHash</code>, <code>flags</code>, and the <code>signCount</code> one more time. Finally, we take the <code>signature</code> and ensure that the stored public key can be used to verify that the signature is valid.</p>\n<p>At this point, if all went well, the server should have verified all the information and allowed you to access your account! Congrats — you logged in with passkeys!</p>\nNo More Passwords?\n<p>Do passkeys mean the end of passwords? Probably not… at least for a while anyway. Passwords will live on. However, there’s hope that more and more of the industry will begin to use passkeys. You can already find it implemented in many of the applications you use every day.</p>\n<p>Passkeys was not the only implementation to rely on cryptographic means of authentication. A notable example is <a href=\"https://en.wikipedia.org/wiki/SQRL\">SQRL</a> (pronounced “squirrel”). The industry as a whole, however, has decided to move forth with passkeys.</p>\n<p>Hopefully, this article demystified some of the internal workings of passkeys. The industry as a whole is going to be using passkeys more and more, so it’s important to at least get acclimated. With all the security gains that passkeys provide and the fact that it’s resistant to phishing attacks, we can at least be more at ease browsing the internet when using them.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"21398ecae4a53795cfc4c05b8e1d6bde3fbaecac6b9e67c409b3c9da635be1fa","category":"Tech"}