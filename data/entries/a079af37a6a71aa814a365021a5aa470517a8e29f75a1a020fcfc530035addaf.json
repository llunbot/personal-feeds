{"title":"Internationalization In Next.js 13 With React Server Components","link":"https://smashingmagazine.com/2023/03/internationalization-nextjs-13-react-server-components/","date":1678996800000,"content":"<p>With the introduction of <a href=\"https://beta.nextjs.org/docs/getting-started\">Next.js 13</a> and the beta release of the App Router, React Server Components became publicly available. This new paradigm allows components that don‚Äôt require React‚Äôs interactive features, such as <code>useState</code> and <code>useEffect</code>, to remain server-side only.</p>\n<p>One area that benefits from this new capability is <strong>internationalization</strong>. Traditionally, internationalization requires a tradeoff in performance as loading translations results in larger client-side bundles and using message parsers impacts the client runtime performance of your app.</p>\n<p>The promise of <strong>React Server Components</strong> is that we can have our cake and eat it too. If internationalization is implemented entirely on the server side, we can achieve new levels of performance for our apps, leaving the client side for interactive features. But how can we work with this paradigm when we need interactively-controlled states that should be reflected in internationalized messages?</p>\n<p>In this article, we‚Äôll explore a multilingual app that displays street photography images from Unsplash. We‚Äôll use <a href=\"https://next-intl-docs.vercel.app/\"><code>next-intl</code></a> to implement all our internationalization needs in React Server Components, and we‚Äôll look at a technique for introducing interactivity with a minimalistic client-side footprint.</p>\n<p><img src=\"https://files.smashing.media/articles/internationalization-nextjs-13-react-server-components/13-app-final-framed.png\" /></p>\nFetching Photos From Unsplash\n<p>A key benefit of Server Components is the ability to fetch data directly from inside components via <code>async</code>/<code>await</code>. We can use this to fetch the photos from Unsplash in our page component.</p>\n<p>But first, we need to create our API client based on the official Unsplash SDK.</p>\n<pre><code>import {createApi} from 'unsplash-js';\n\nexport default createApi({\n  accessKey: process.env.UNSPLASH_ACCESS_KEY\n});\n</code></pre>\n\n<p>Once we have our Unsplash API client, we can use it in our page component.</p>\n<pre><code>import {OrderBy} from 'unsplash-js';\nimport UnsplashApiClient from './UnsplashApiClient';\n\nexport default async function Index() {\n  const topicSlug = 'street-photography';\n\n  const [topicRequest, photosRequest] = await Promise.all([\n    UnsplashApiClient.topics.get({topicIdOrSlug: topicSlug}),\n    UnsplashApiClient.topics.getPhotos({\n      topicIdOrSlug: topicSlug,\n      perPage: 4\n    })\n  ]);\n\n  return (\n    &lt;PhotoViewer\n      coverPhoto={topicRequest.response.cover_photo}\n      photos={photosRequest.response.results}\n    /&gt;\n  );\n}\n</code></pre>\n\n<p><strong>Note:</strong> <em>We use <code>Promise.all</code> to invoke both requests that we need to make in parallel. This way, we avoid a request waterfall.</em></p>\n<p>At this point, our app renders a simple photo grid.</p>\n<p><img src=\"https://files.smashing.media/articles/internationalization-nextjs-13-react-server-components/2-app-basic-photo-grid.png\" /></p>\n<p>The app currently uses hard-coded English labels, and the dates of the photos are displayed as timestamps, which is not very user-friendly (yet).</p>\nAdding Internationalization With <code>next-intl</code>\n<p>In addition to English, we‚Äôd like our app to be available in Spanish. Support for Server Components is currently in beta for <a href=\"https://next-intl-docs.vercel.app/\"><code>next-intl</code></a>, so we can use <a href=\"https://next-intl-docs.vercel.app/docs/next-13/server-components\">the installation instructions for the latest beta</a> to set up our app for internationalization.</p>\n<h3>Formatting Dates</h3>\n<p>Aside from adding a second language, we‚Äôve already found that the app doesn‚Äôt adapt well to English users because the dates should be formatted. To achieve a good user experience, we‚Äôd like to tell the user the relative time when the photo was uploaded (e.g., ‚Äú8 days ago‚Äù).</p>\n<p>Once  <code>next-intl</code> is set up, we can fix the formatting by using the <code>format.relativeTime</code> function in the component that renders each photo.</p>\n<pre><code>import {useFormatter} from 'next-intl';\n\nexport default function PhotoGridItem({photo}) {\n  const format = useFormatter();\n  const updatedAt = new Date(photo.updated_at);\n\n  return (\n    &lt;a href={photo.links.html}&gt;\n        {/* ... */}\n        &lt;p&gt;{format.relativeTime(updatedAt)}&lt;/p&gt;\n      &lt;/div&gt;\n    &lt;/a&gt;\n  );\n}\n</code></pre>\n\n<p>Now the date when a photo has been updated is easier to read.</p>\n<p><img src=\"https://files.smashing.media/articles/internationalization-nextjs-13-react-server-components/3-app-photo-item-date-formatted.png\" /></p>\n<p><strong>Hint:</strong> <em>In a traditional React app that renders on both the server and client side, it can be quite a challenge to ensure that the displayed relative date is in sync across the server and client. Since these are different environments and may be in different time zones, you need to configure a mechanism to transfer the server time to the client side. By performing the formatting only on the server side, we don‚Äôt have to worry about this problem in the first place.</em></p>\n<h3>¬°Hola! üëã Translating Our App To Spanish</h3>\n<p>Next, we can replace the static labels in the header with localized messages. These labels are passed as props from the <code>PhotoViewer</code> component, so this is our chance to introduce dynamic labels via the <code>useTranslations</code> hook.</p>\n<pre><code>import {useTranslations} from 'next-intl';\n\nexport default function PhotoViewer(/* ... */) {\n  const t = useTranslations('PhotoViewer');\n\n  return (\n    &lt;&gt;\n      &lt;Header\n        title={t('title')}\n        description={t('description')}\n      /&gt;\n      {/* ... */}\n    &lt;/&gt;\n  );\n}\n</code></pre>\n\n<p>For each internationalized label we add, we need to make sure that there is an appropriate entry set up for all languages.</p>\n<div>\n<pre><code>// en.json\n{\n  \"PhotoViewer\": {\n    \"title\": \"Street photography\",\n    \"description\": \"Street photography captures real-life moments and human interactions in public places. It is a way to tell visual stories and freeze fleeting moments of time, turning the ordinary into the extraordinary.\"\n  }\n}\n</code></pre>\n</div>\n\n<div>\n<pre><code>// es.json\n{\n  \"PhotoViewer\": {\n    \"title\": \"Street photography\",\n    \"description\": \"La fotograf√≠a callejera capta momentos de la vida real y interacciones humanas en lugares p√∫blicos. Es una forma de contar historias visuales y congelar momentos fugaces del tiempo, convirtiendo lo ordinario en lo extraordinario.\"\n  }\n}\n</code></pre>\n</div>\n\n<p><strong>Tip:</strong> <em><a href=\"https://next-intl-docs.vercel.app/docs/usage/typescript\"><code>next-intl</code> provides a TypeScript integration</a> that helps you ensure that you‚Äôre only referencing valid message keys.</em></p>\n<p>Once this is done, we can visit the Spanish version of the app at <code>/es</code>.</p>\n<p><img src=\"https://files.smashing.media/articles/internationalization-nextjs-13-react-server-components/11-app-basic-es-framed.png\" /></p>\n<p>So far, so good!</p>\nAdding Interactivity: Dynamic Ordering Of Photos\n<p>By default, the Unsplash API returns the most popular photos. We want the user to be able to change the order to show the most recent photos first.</p>\n<p>Here, the question arises whether we should resort to client-side data fetching so that we can implement this feature with <code>useState</code>. However, that would require us to move all of our components to the client side, resulting in an increased bundle size.</p>\n<p>Do we have an alternative? Yes. And it‚Äôs a capability that has been around on the web for ages: <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams\">search parameters</a> (sometimes referred to as <em>query parameters</em>). What makes search parameters a great option for our use case is that they can be read on the server side.</p>\n<p>So let‚Äôs modify our page component to receive <code>searchParams</code> via props.</p>\n<pre><code>export default async function Index({searchParams}) {\n  const orderBy = searchParams.orderBy || OrderBy.POPULAR;\n\n  const [/* ... */, photosRequest] = await Promise.all([\n    /* ... */,\n    UnsplashApiClient.topics.getPhotos({orderBy, /* ... */})\n  ]);\n</code></pre>\n\n<p>After this change, the user can navigate to <code>/?orderBy=latest</code> to change the order of the displayed photos.</p>\n<p>To make it easy for the user to change the value of the search parameter, we‚Äôd like to render an interactive <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select\"><code>select</code> element</a> from within a component.</p>\n<p><img src=\"https://files.smashing.media/articles/internationalization-nextjs-13-react-server-components/5-app-order-select-collapsed.png\" /></p>\n<p>We can mark the component with <code>'use client';</code> to attach an event handler and process change events from the <code>select</code> element. Nevertheless, we would like to keep the internationalization concerns on the server side to reduce the size of the client bundle.</p>\n<p>Let‚Äôs have a look at the required markup for our <code>select</code> element.</p>\n<pre><code>&lt;select&gt;\n  &lt;option value=\"popular\"&gt;Popular&lt;/option&gt;\n  &lt;option value=\"latest\"&gt;Latest&lt;/option&gt;\n&lt;/select&gt;\n</code></pre>\n\n<p>We can split this markup into two parts:</p>\n<ol>\n<li>Render the <code>select</code> element with an interactive Client Component.</li>\n<li>Render the internationalized <code>option</code> elements with a Server Component and pass them as <code>children</code> to the <code>select</code> element.</li>\n</ol>\n<p>Let‚Äôs implement the <code>select</code> element for the client side.</p>\n<pre><code>'use client';\n\nimport {useRouter} from 'next-intl/client';\n\nexport default function OrderBySelect({orderBy, children}) {\n  const router = useRouter();\n\n  function onChange(event) {\n    // The `useRouter` hook from `next-intl` automatically\n    // considers a potential locale prefix of the pathname.\n    router.replace('/?orderBy=' + event.target.value);\n  }\n\n  return (\n    &lt;select defaultValue={orderBy} onChange={onChange}&gt;\n      {children}\n    &lt;/select&gt;\n  );\n}\n</code></pre>\n\n<p>Now, let‚Äôs use our component in <code>PhotoViewer</code> and provide the localized <code>option</code> elements as <code>children</code>.</p>\n<pre><code>import {useTranslations} from 'next-intl';\nimport OrderBySelect from './OrderBySelect';\n\nexport default function PhotoViewer({orderBy, /* ... */}) {\n  const t = useTranslations('PhotoViewer');\n\n  return (\n    &lt;&gt;\n      {/* ... */}\n      &lt;OrderBySelect orderBy={orderBy}&gt;\n        &lt;option value=\"popular\"&gt;{t('orderBy.popular')}&lt;/option&gt;\n        &lt;option value=\"latest\"&gt;{t('orderBy.latest')}&lt;/option&gt;\n      &lt;/OrderBySelect&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>\n\n<p>With this pattern, the markup for the <code>option</code> elements is now generated on the server side and passed to the <code>OrderBySelect</code>, which handles the change event on the client side.</p>\n<p><strong>Tip</strong>: <em>Since we have to wait for the updated markup to be generated on the server side when the order is changed, we may want to show the user a loading state. React 18 introduced <a href=\"https://beta.reactjs.org/reference/react/useTransition\">the <code>useTransition</code> hook</a>, which is integrated with Server Components. This allows us to disable the <code>select</code> element while waiting for a response from the server.</em></p>\n<pre><code>import {useRouter} from 'next-intl/client';\nimport {useTransition} from 'react';\n\nexport default function OrderBySelect({orderBy, children}) {\n  const [isTransitioning, startTransition] = useTransition();\n  const router = useRouter();\n\n  function onChange(event) {\n    startTransition(() =&gt; {\n      router.replace('/?orderBy=' + event.target.value);\n    });\n  }\n\n  return (\n    &lt;select disabled={isTransitioning} /* ... */&gt;\n      {children}\n    &lt;/select&gt;\n  );\n}\n</code></pre>\n\n\n\nAdding More Interactivity: Page Controls\n<p>The same pattern that we‚Äôve explored for changing the order can be applied to page controls by introducing a <code>page</code> search parameter.</p>\n<p><img src=\"https://files.smashing.media/articles/internationalization-nextjs-13-react-server-components/6-app-pagination.png\" /></p>\n<p>Note that languages have different rules for handling decimal and thousand separators. Furthermore, languages have different forms of pluralization: while English only makes a grammatical distinction between one and zero/many elements, for example, Croatian has a separate form for ‚Äòfew‚Äô elements.</p>\n<p><code>next-intl</code> uses the <a href=\"https://next-intl-docs.vercel.app/docs/usage/messages#rendering-of-messages\">ICU syntax</a> which makes it possible to express these language subtleties.</p>\n<div>\n<pre><code>// en.json\n{\n  \"Pagination\": {\n    \"info\": \"Page {page, number} of {totalPages, number} ({totalElements, plural, =1 {one result} other {# results}} in total)\",\n    // ...\n  }\n}\n</code></pre>\n</div>\n\n<p>This time we don‚Äôt need to mark a component with <code>'use client';</code>. Instead, we can implement this with regular anchor tags.</p>\n<div>\n<pre><code>import {ArrowLeftIcon, ArrowRightIcon} from '@heroicons/react/24/solid';\nimport {Link, useTranslations} from 'next-intl';\n\nexport default function Pagination({pageInfo, orderBy}) {\n  const t = useTranslations('Pagination');\n  const totalPages = Math.ceil(pageInfo.totalElements / pageInfo.size);\n\n  function getHref(page) {\n    return {\n      // Since we're using <code>Link</code> from next-intl, a potential locale\n      // prefix of the pathname is automatically considered.\n      pathname: '/',\n      // Keep a potentially existing <code>orderBy</code> parameter. \n      query: {orderBy, page}\n    };\n  }\n\n  return (\n    &lt;&gt;\n      {pageInfo.page &gt; 1 &amp;&amp; (\n        &lt;Link aria-label={t('prev')} href={getHref(pageInfo.page - 1)}&gt;\n          &lt;ArrowLeftIcon /&gt;\n        &lt;/Link&gt;\n      )}\n      &lt;p&gt;{t('info', {...pageInfo, totalPages})}&lt;/p&gt;\n      {pageInfo.page &lt; totalPages &amp;&amp; (\n        &lt;Link aria-label={t('prev')} href={getHref(pageInfo.page + 1)}&gt;\n          &lt;ArrowRightIcon /&gt;\n        &lt;/Link&gt;\n      )}\n    &lt;/&gt;\n  );\n}\n</code></pre>\n</div>\n\nConclusion\n<h3>Server Components Are A Great Match For Internationalization</h3>\n<p>Internationalization is an important part of the user experience, whether you support multiple languages or you want to get the subtleties of a single language right. A library like <a href=\"https://next-intl-docs.vercel.app/\"><code>next-intl</code></a> can help with both cases.</p>\n<p>Implementing internationalization in Next.js apps has historically come with a performance tradeoff, but with Server Components, this is no longer the case. However, it might take some time to explore and learn patterns that will help you keep your internationalization concerns on the server side.</p>\n<p>In our street photography viewer app, we only needed to move a single component to the client side: <code>OrderBySelect</code>.</p>\n<p><img src=\"https://files.smashing.media/articles/internationalization-nextjs-13-react-server-components/12-app-components.png\" /></p>\n<p>Another aspect to note is that you might want to consider implementing loading states since the network latency introduces a delay before your users see the result of their actions.</p>\n<h3>Search Parameters Are A Great Alternative To <code>useState</code></h3>\n<p>Search parameters are a great way to implement interactive features in Next.js apps, as they help to reduce the bundle size of the client side.</p>\n<p>Apart from performance, there are other <strong>benefits of using search parameters</strong>:</p>\n<ul>\n<li>URLs with search parameters can be shared while preserving the application state.</li>\n<li>Bookmarks preserve the state as well.</li>\n<li>You can optionally integrate with the browser history, enabling undoing state changes via the back button.</li>\n</ul>\n<p>Note, however, that there are also <strong>tradeoffs to consider</strong>:</p>\n<ul>\n<li>Search parameter values are strings, so you may need to serialize and deserialize data types.</li>\n<li>The URL is part of the user interface, so using many search parameters may affect readability.</li>\n</ul>\n<p>You can have a look at the complete <a href=\"https://github.com/amannn/street-photography-viewer\">code of the example on GitHub</a>.</p>\n<p><em>Many thanks to <a href=\"https://twitter.com/delba_oliveira\">Delba de Oliveira</a> from Vercel for providing feedback for this article!</em></p>\n<h3>Further Reading On SmashingMag</h3>\n<ul>\n<li>‚Äú<a href=\"https://www.smashingmagazine.com/2023/02/understanding-app-directory-architecture-next-js/\">Understanding App Directory Architecture In Next.js</a>‚Äù, Atila Fassina</li>\n<li>‚Äú<a href=\"https://www.smashingmagazine.com/2019/05/designing-users-across-cultures-interview-jenny-shen/\">Designing For Users Across Cultures: An Interview With Jenny Shen</a>‚Äù, Rachel Andrew</li>\n<li>‚Äú<a href=\"https://www.smashingmagazine.com/2022/04/dynamic-data-fetching-authenticated-nextjs-app/\">Dynamic Data-Fetching In An Authenticated Next.js App</a>‚Äù, Caleb Olojo</li>\n<li>‚Äú<a href=\"https://www.smashingmagazine.com/2021/10/search-functionality-nuxt-app-algolia-instantsearch/\">How To Implement Search Functionality In Your Nuxt App Using Algolia InstantSearch</a>‚Äù, Miracle Onyenma</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine ‚Äî For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"a079af37a6a71aa814a365021a5aa470517a8e29f75a1a020fcfc530035addaf","category":"Tech"}