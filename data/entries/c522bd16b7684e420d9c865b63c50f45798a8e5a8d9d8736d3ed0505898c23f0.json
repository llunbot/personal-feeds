{"title":"Modern Methods For Improving Drupal’s Largest Contentful Paint Core Web Vital","link":"https://smashingmagazine.com/2023/08/methods-improving-drupal-largest-contentful-paint-core-web-vital/","date":1692093600000,"content":"<p>Let’s start with a fairly common example of a hero component on the homepage of <a href=\"https://www.drupal.org/project/umami\">Drupal’s demo installation of the Umami theme</a>.</p>\n<p>The image in this hero component is loaded by CSS via the <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/background-image\"><code>background-image</code></a> property. In order for the browser to display the image, it has a fairly long chain of dependencies:</p>\n<ol>\n<li>Download the HTML.</li>\n<li>Download and parse the CSS.</li>\n<li>Reconcile the CSS ruleset with the DOM.</li>\n<li>Download the image.</li>\n<li>Display the image.</li>\n</ol>\n<p><img src=\"https://files.smashing.media/articles/methods-improving-drupal-largest-contentful-paint-core-web-vital/drupal-lcp-umami.png\" /></p>\n<p>While browsers are generally pretty fast, these steps still take time to load, typically in seconds, and even longer on slower, high-latency network connections. And because this image is within the initial viewport, it’s very noticeable.</p>\n<p>So noticeable, in fact, that Core Web Vitals has a metric all about it called <a href=\"https://web.dev/lcp/\"><strong>Largest Contentful Paint</strong></a> <strong>(LCP)</strong>. This metric measures the time it takes, in seconds, to render the largest image or text block that is visible on the initial load. We can test for LCP in a number of ways. The following screenshot is taken from a test I ran through WebPageTest, resulting in an LCP of 2.4 seconds.</p>\n<p><img src=\"https://files.smashing.media/articles/methods-improving-drupal-largest-contentful-paint-core-web-vital/drupal-lcp-baseline.png\" /></p>\n<p>The image file used for the hero component’s background is the ninth item in the report, taking 1,041 milliseconds to even begin the download.</p>\n<p>In case you’re wondering, 2.4 seconds is not great. That’s practically an eternity when talking about page speed performance. And since the image file used for the background appears to be making up about 50% of that time, it’s a prime target for optimization.</p>\n<p>Here’s how we are approaching it.</p>\nStep 1: Use An <code>&lt;img&gt;</code> Tag Instead Of A Background Image\n<p>To avoid the five-step dependency chain I outlined above, we want to prevent loading the image with CSS. Instead, we’re going to load the image as a standard HTML <code>&lt;img&gt;</code> tag in the markup.</p>\n<p>This allows the <a href=\"https://web.dev/preload-scanner/\">browser’s preload scanner</a> to detect and download the image early in the process — something it cannot parse from a CSS file. The preload scanner does pretty much what you think it does: it scans the HTML as it’s still being downloaded and starts to pull down additional assets that it thinks are important.</p>\n<p>How do we use an HTML <code>&lt;img&gt;</code> as a replacement for a CSS <code>background-image</code>? We’re unable to simply drop an image in the markup and use it as a true background, at least in the CSS sense. Instead, we have to establish a container element — let’s give it a class name of <code>.hero</code> — and position the image in a way that stacks on top of it, and subsequently, allow other elements such as the hero content to stack on top of it. This gives us the illusion of a background image.</p>\n<p>This requires us to use <a href=\"https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Positioning\"><strong>absolute positioning</strong></a> in CSS. This takes the image <em>out</em> of the <a href=\"https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Normal_Flow\">normal document flow</a>, which is a fancy way of saying that the elements surrounding it act as if it’s not there. The image is there, of course, but its physical dimensions are ignored, allowing elements to flow right on top of it rather than around it.</p>\n<pre><code>.hero {\n  position: relative; /* Anchor the image */\n}\n\n.hero img {\n  position: absolute;\n  inset: 0;\n  width: 100%;\n  height: 100%;\n}\n</code></pre>\n\n<p>This works! The <code>&lt;img&gt;</code> element now stacks on top of the <code>.hero</code> container. But now we have a couple of new issues that need to be addressed.</p>\n<p>The first is that the image is squished and distorted. You might think this is a bug, but we’ve set the image to take up <code>width: 100%</code>  and <code>height: 100%</code> of the <code>.hero</code> container, and it is merely adjusting its aspect ratio to the aspect ratio of the container, as it’s being told to do.</p>\n<p><img src=\"https://files.smashing.media/articles/methods-improving-drupal-largest-contentful-paint-core-web-vital/drupal-lcp-umami-stretched.png\" /></p>\n<p>If we were still loading the image with the CSS <code>background-image</code> property, we could fix this by setting <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Backgrounds_and_Borders/Resizing_background_images#cover\"><code>background-size: cover</code></a> on the image. But we don’t get that luxury when working with HTML images.</p>\n<p>Fortunately, the <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit\"><code>object-fit</code></a> property can solve this for us. It works pretty similarly to the <code>background-size</code> property and actually takes the same <code>cover</code> keyword as a value. We set that on the image in CSS:</p>\n<pre><code>.hero {\n  position: relative; /* Anchor the image */\n}\n\n.hero img {\n  position: absolute;\n  inset: 0;\n  width: 100%;\n  height: 100%;\n  object-fit: cover; /* Prevents squishing */\n}\n</code></pre>\n\n<p>This brings us to the second issue we introduced when we applied absolute positioning to the image. Remember the content with the cool pink button that sat on top of the background image in the first screenshot at the beginning of the article? The image is completely covering it. It’s there, just not seen beneath the absolutely-positioned image.</p>\n<p><img src=\"https://files.smashing.media/articles/methods-improving-drupal-largest-contentful-paint-core-web-vital/drupal-umami-dexter-not-squished.jpg\" /></p>\n<p>The “problem” is that we get a <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context\">stacking context</a> anytime we explicitly declare a non-static <code>position</code> on an element. The image is taken out of the normal flow but is still visible even as elements that follow it in the markup flow right through it. As such, the content elements flow under the image and are hidden from view. I say “problem” in quotes because, again, this is expected behavior that comes by explicitly declaring <code>position: absolute</code> in CSS.</p>\n<p>The trick? We can give the <code>.hero</code> element's content container its own stacking context. We won’t use absolute positioning, however, because we want it to remain in the normal document flow. Otherwise,  it, too, would obscure its surrounding elements.</p>\n<p>That’s where setting a relative position — <code>position: relative</code> — comes into play. Elements come with <code>position: static</code> by default. By when we declare <code>position: relative</code>, it produces a stacking context but also keeps the element within the normal flow.</p>\n<pre><code>.hero {\n  position: relative; /* Anchor the image */\n}\n\n.hero img {\n  position: absolute;\n  inset: 0;\n  width: 100%;\n  height: 100%;\n  object-fit: cover; /* Prevents squishing */\n}\n\n.hero__content {\n  position: relative; /* Adds a stacking context */\n}\n</code></pre>\n\n<p>Now the content sits properly on top of the image as though the image were a true background:</p>\n<p><img src=\"https://files.smashing.media/articles/methods-improving-drupal-largest-contentful-paint-core-web-vital/drupal-umami.png\" /></p>\n<p>I’ll note that your mileage may vary depending on the order of elements inside the parent container. You may find yourself needing to set the element’s level in the stacking context using <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/z-index\"><code>z-index</code></a>.</p>\nStep 2: Use A Modern Image Format\n<p>The hero banner looks correct now, but we still have a bit of work to do. The current image is a highly-optimized JPG file, which isn’t horrible, but we can do better. The new-ish WebP image format is <a href=\"https://caniuse.com/webp\">supported by all modern browsers</a> and typically comes in at a very small file size. Let’s use that instead of a standard JPG.</p>\n<p><img src=\"https://files.smashing.media/articles/methods-improving-drupal-largest-contentful-paint-core-web-vital/drupal-lcp-homepage-inspect.png\" /></p>\n<p>After configuring Drupal to serve WebP image formats, we can see the new image size is reduced by 10% with no noticeable loss of quality! </p>\n<p><strong>Note</strong>: <em>In many cases, the file size will be reduced substantially more than that (frequently more than 50%), but in our case, the source image was already fairly optimized.</em></p>\nStep 3: Use Responsive Images\n<p>We now have the image being downloaded immediately, and we’re also using the new WebP image format, which can save up to 50% on the file size. But we’re still not done, as the same image is being served for every screen size. If we serve smaller images to smaller screen sizes, the image will download even faster to those devices. To solve this, we’ll implement responsive images.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images\">Responsive images</a> have been supported in browsers for a long time. At its core, the markup contains paths to multiple images, and information on which screen sizes to serve each lets the browser know when to display. This enables the browser to automatically pull down the images that are sized appropriately for the screen size.</p>\n<p>We set this up using the <code>&lt;picture&gt;</code> element, and it looks something like this:</p>\n<div>\n<pre><code>&lt;picture&gt;\n  &lt;source srcset=\"/img-path_wide/veggie-pasta-bake-hero-umami.jpg.webp 1x\" media=\"all and (min-width: 1400px)\" type=\"image/webp\" width=\"3000\" height=\"1285\"&gt;\n  &lt;source srcset=\"/img-path_large/veggie-pasta-bake-hero-umami.jpg.webp 1x\" media=\"all and (min-width: 800px) and (max-width: 1400px)\" type=\"image/webp\" width=\"1440\" height=\"617\"&gt;\n  &lt;source srcset=\"/img-path_medium/veggie-pasta-bake-hero-umami.jpg.webp 1x\" media=\"all and (min-width: 500px) and (max-width: 800px)\" type=\"image/webp\" width=\"1200\" height=\"514\"&gt;\n  &lt;source srcset=\"/img-path_tiny/veggie-pasta-bake-hero-umami.jpg.webp 1x\" media=\"all\" type=\"image/webp\" width=\"500\" height=\"214\"&gt;\n  &lt;img src=\"/img-oath_medium/veggie-pasta-bake-hero-umami.jpg.webp\" width=\"1200\" height=\"514\" alt=\"Mouth watering vegetarian pasta bake with rich tomato sauce and cheese toppings\"&gt;\n&lt;/picture&gt;\n</code></pre>\n</div>\n\n<p><strong>Note</strong>: <em>Drupal supports responsive images out of the box. If you’re CMS or framework does not, there are services such as <a href=\"https://cloudinary.com/\">Cloudinary</a> that can handle this for you (for a fee, of course).</em></p>\nThere’s Still More To Do\n<p>We made significant improvements and improved the LCP by 58%, from <code>2.4s</code> to <code>1.4s</code>!</p>\n<p><img src=\"https://files.smashing.media/articles/methods-improving-drupal-largest-contentful-paint-core-web-vital/drupal-lcp-waterfall-updated.png\" /></p>\n<p>But there’s still more to do. Yet another, newer image format called <a href=\"https://www.smashingmagazine.com/2021/09/modern-image-formats-avif-webp/\">AVIF</a> can help reduce our image file sizes by another 20–30%. Similarly, there’s the new <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/fetchPriority\"><code>fetchpriority</code></a> HTML attribute for images. </p>\n<p>It’s worth mentioning that the attribute is still considered “experimental” at the moment, and <a href=\"https://caniuse.com/mdn-html_elements_img_fetchpriority\">browser support isn’t currently all the way there</a> as I’m writing this.</p>\n<p>That said, we’re currently <a href=\"https://www.drupal.org/project/drupal/issues/3366828\">working on a setting</a> in the Drupal admin UI that adds <code>fetchpriority</code> to images, and when that lands, we’ll use it to inform the browser of the relative priority of the image (which in this case would be equal to <code>high</code>).</p>\nWrapping Up\n<p>In this article, we identified, measured, and fixed a very common performance issue, not only in Drupal but in everyday front-end work. </p>\n<p>Similar to accessibility, I find the biggest obstacle to making web performance better is indifference.</p>\n<p>Web developers should learn to use various testing tools such as <a href=\"https://developer.chrome.com/docs/lighthouse/overview/\">Lighthouse</a> and <a href=\"https://webpagetest.org/\">WebPageTest</a>. We should learn <a href=\"https://web.dev/metrics/\">common metrics</a>, such as Time to First Byte, LCP, and other web vitals. And most of all, we <em>need to care</em>. There is a wealth of information on websites to help guide you along your learning path.</p>\n<h3>Additional Resources</h3>\n<ul>\n<li><a href=\"https://web.dev/vitals/\">Web Vitals</a> (web.dev)</li>\n<li><a href=\"https://web.dev/lcp/\">Largest Contentful Paint</a> (web.dev)</li>\n<li>“<a href=\"https://www.smashingmagazine.com/2021/12/core-web-vitals-case-study-smashing-magazine/\">Improving Core Web Vitals, A Smashing Magazine Case Study</a>,” Barry Pollard</li>\n<li>“<a href=\"https://www.smashingmagazine.com/2022/08/core-web-vitals-tools-boost-performance/\">Core Web Vitals Tools To Boost Your Web Performance Scores</a>,” Zara Cooper</li>\n<li>“<a href=\"https://css-tricks.com/on-object-fit-and-object-position/\">A Quick Overview of <code>object-fit</code> and <code>object-position</code></a>,” Robin Rendle</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"c522bd16b7684e420d9c865b63c50f45798a8e5a8d9d8736d3ed0505898c23f0","category":"Tech"}