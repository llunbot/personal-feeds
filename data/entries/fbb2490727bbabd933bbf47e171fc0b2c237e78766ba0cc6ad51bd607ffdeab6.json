{"title":"Building An Offline-Friendly Image Upload System","link":"https://smashingmagazine.com/2025/04/building-offline-friendly-image-upload-system/","date":1745402400000,"content":"<p>So, you’re filling out an online form, and it asks you to upload a file. You click the input, select a file from your desktop, and are good to go. But something happens. The network drops, the file disappears, and you’re stuck having to re-upload the file. <strong>Poor network connectivity</strong> can lead you to spend an unreasonable amount of time trying to upload files successfully.</p>\n<p>What ruins the user experience stems from having to constantly check network stability and retry the upload several times. While we may not be able to do much about network connectivity, as developers, we can always do something to ease the pain that comes with this problem.</p>\n<p>One of the ways we can solve this problem is by tweaking image upload systems in a way that enables users to upload images offline — <strong>eliminating the need for a reliable network connection</strong>, and then having the system retry the upload process when the network becomes stable, without the user intervening.</p>\n<p>This article is going to focus on explaining how to build <strong>an offline-friendly image upload system</strong> using PWA (progressive web application) technologies such as <code>IndexedDB</code>, service workers, and the Background Sync API. We will also briefly cover tips for improving the user experience for this system.</p>\nPlanning The Offline Image Upload System\n<p>Here’s a flow chart for an offline-friendly image upload system.</p>\n<p><img src=\"https://files.smashing.media/articles/building-offline-friendly-image-upload-system/1-upload-system-flow-chart.png\" /></p>\n<p>As shown in the flow chart, the process unfolds as follows:</p>\n<ol>\n<li><strong>The user selects an image.</strong><br />The process begins by letting the user select their image.</li>\n<li><strong>The image is stored locally in <code>IndexedDB</code>.</strong><br />Next, the system checks for network connectivity. If network connectivity is available, the system uploads the image directly, avoiding unnecessary local storage usage. However, if the network is not available, the image will be stored in <code>IndexedDB</code>.</li>\n<li><strong>The service worker detects when the network is restored.</strong><br />With the image stored in <code>IndexedDB</code>, the system waits to detect when the network connection is restored to continue with the next step.</li>\n<li><strong>The background sync processes pending uploads.</strong><br />The moment the connection is restored, the system will try to upload the image again.</li>\n<li><strong>The file is successfully uploaded</strong>.<br />The moment the image is uploaded, the system will remove the local copy stored in <code>IndexedDB</code>.</li>\n</ol>\nImplementing The System\n<p>The first step in the system implementation is allowing the user to select their images. There are different ways you can achieve this:</p>\n<ul>\n<li>You can use a simple <code>&lt;input type=\"file\"&gt;</code> element;</li>\n<li>A drag-and-drop interface.</li>\n</ul>\n<p>I would advise that you use both. Some users prefer to use the drag-and-drop interface, while others think the only way to upload images is through the <code>&lt;input type=\"file\"&gt;</code> element. Having both options will help improve the user experience. You can also consider allowing users to paste images directly in the browser using the Clipboard API. </p>\n<h3>Registering The Service Worker</h3>\n<p>At the heart of this solution is the <a href=\"https://www.smashingmagazine.com/2016/02/making-a-service-worker/\">service worker</a>. Our service worker is going to be responsible for retrieving the image from the <code>IndexedDB</code> store, uploading it when the internet connection is restored, and clearing the <code>IndexedDB</code> store when the image has been uploaded.</p>\n<p>To use a service worker, you first have to register one:</p>\n<div>\n<pre><code>if ('serviceWorker' in navigator) {\n  navigator.serviceWorker.register('/service-worker.js')\n    .then(reg =&gt; console.log('Service Worker registered', reg))\n    .catch(err =&gt; console.error('Service Worker registration failed', err));\n}\n</code></pre>\n</div>\n\n<h3>Checking For Network Connectivity</h3>\n<p>Remember, the problem we are trying to solve is caused by <strong>unreliable network connectivity</strong>. If this problem does not exist, there is no point in trying to solve anything. Therefore, once the image is selected, we need to check if the user has a reliable internet connection before registering a sync event and storing the image in <code>IndexedDB</code>.</p>\n<pre><code>function uploadImage() {\n  if (navigator.onLine) {\n    // Upload Image\n  } else {\n    // register Sync Event\n    // Store Images in IndexedDB\n  }\n}\n</code></pre>\n\n<p><strong>Note</strong>: I’m only using the <code>navigator.onLine</code> property here to demonstrate how the system would work. The <code>navigator.onLine</code> property is <strong>unreliable</strong>, and I would suggest you come up with a custom solution to check whether the user is connected to the internet or not. One way you can do this is by sending a ping request to a server endpoint you’ve created.</p>\n<h3>Registering The Sync Event</h3>\n<p>Once the network test fails, the next step is to register a sync event. The sync event needs to be registered at the point where the system fails to upload the image due to a poor internet connection.</p>\n<pre><code>async function registerSyncEvent() {\n  if ('SyncManager' in window) {\n    const registration = await navigator.serviceWorker.ready;\n    await registration.sync.register('uploadImages');\n    console.log('Background Sync registered');\n  }\n}\n</code></pre>\n\n<p>After registering the sync event, you need to listen for it in the service worker.</p>\n<pre><code>self.addEventListener('sync', (event) =&gt; {\n  if (event.tag === 'uploadImages') {\n    event.waitUntil(sendImages());\n  }\n});\n</code></pre>\n\n<p>The <code>sendImages</code> function is going to be an asynchronous process that will retrieve the image from <code>IndexedDB</code> and upload it to the server. This is what it’s going to look like:</p>\n<pre><code>async function sendImages() {\n  try {\n    // await image retrieval and upload\n  } catch (error) {\n    // throw error\n  }\n}\n</code></pre>\n\n<h3>Opening The Database</h3>\n<p>The first thing we need to do in order to store our image locally is to open an <code>IndexedDB</code> store. As you can see from the code below, we are creating <strong>a global variable to store the database instance</strong>. The reason for doing this is that, subsequently, when we want to retrieve our image from <code>IndexedDB</code>, we wouldn’t need to write the code to open the database again.</p>\n<div>\n<pre><code>let database; // Global variable to store the database instance\n\nfunction openDatabase() {\n  return new Promise((resolve, reject) =&gt; {\n    if (database) return resolve(database); // Return existing database instance \n\n    const request = indexedDB.open(\"myDatabase\", 1);\n\n    request.onerror = (event) =&gt; {\n      console.error(\"Database error:\", event.target.error);\n      reject(event.target.error); // Reject the promise on error\n    };\n\n    request.onupgradeneeded = (event) =&gt; {\n        const db = event.target.result;\n        // Create the \"images\" object store if it doesn't exist.\n        if (!db.objectStoreNames.contains(\"images\")) {\n          db.createObjectStore(\"images\", { keyPath: \"id\" });\n        }\n        console.log(\"Database setup complete.\");\n    };\n\n    request.onsuccess = (event) =&gt; {\n      database = event.target.result; // Store the database instance globally\n      resolve(database); // Resolve the promise with the database instance\n    };\n  });\n}\n</code></pre>\n</div>\n\n\n\n<h3>Storing The Image In IndexedDB</h3>\n<p>With the <code>IndexedDB</code> store open, we can now store our images.</p>\n<blockquote>Now, you may be wondering why an easier solution like <code>localStorage</code> wasn’t used for this purpose.<br /><br />The reason for that is that <code>IndexedDB</code> operates asynchronously and doesn’t block the main JavaScript thread, whereas <code>localStorage</code> runs synchronously and can block the JavaScript main thread if it is being used.</blockquote>\n\n<p>Here’s how you can store the image in <code>IndexedDB</code>:</p>\n<div>\n<pre><code>async function storeImages(file) {\n  // Open the IndexedDB database.\n  const db = await openDatabase();\n  // Create a transaction with read and write access.\n  const transaction = db.transaction(\"images\", \"readwrite\");\n  // Access the \"images\" object store.\n  const store = transaction.objectStore(\"images\");\n  // Define the image record to be stored.\n  const imageRecord = {\n    id: IMAGE_ID,   // a unique ID\n    image: file     // Store the image file (Blob)\n  };\n  // Add the image record to the store.\n  const addRequest = store.add(imageRecord);\n  // Handle successful addition.\n  addRequest.onsuccess = () =&gt; console.log(\"Image added successfully!\");\n  // Handle errors during insertion.\n  addRequest.onerror = (e) =&gt; console.error(\"Error storing image:\", e.target.error);\n}\n</code></pre>\n</div>\n\n<p>With the images stored and the background sync set, the system is ready to upload the image whenever the network connection is restored.</p>\n<h3>Retrieving And Uploading The Images</h3>\n<p>Once the network connection is restored, the sync event will fire, and the service worker will retrieve the image from <code>IndexedDB</code> and upload it.</p>\n<div>\n<pre><code>async function retrieveAndUploadImage(IMAGE_ID) {\n  try {\n    const db = await openDatabase(); // Ensure the database is open\n    const transaction = db.transaction(\"images\", \"readonly\");\n    const store = transaction.objectStore(\"images\");\n    const request = store.get(IMAGE_ID);\n    request.onsuccess = function (event) {\n      const image = event.target.result;\n      if (image) {\n        // upload Image to server here\n      } else {\n        console.log(\"No image found with ID:\", IMAGE_ID);\n      }\n    };\n    request.onerror = () =&gt; {\n        console.error(\"Error retrieving image.\");\n    };\n  } catch (error) {\n    console.error(\"Failed to open database:\", error);\n  }\n}\n</code></pre>\n</div>\n\n<h3>Deleting The IndexedDB Database</h3>\n<p>Once the image has been uploaded, the <code>IndexedDB</code> store is no longer needed. Therefore, it should be deleted along with its content to free up storage.</p>\n<div>\n<pre><code>function deleteDatabase() {\n  // Check if there's an open connection to the database.\n  if (database) {\n    database.close(); // Close the database connection\n    console.log(\"Database connection closed.\");\n  }\n\n  // Request to delete the database named \"myDatabase\".\n  const deleteRequest = indexedDB.deleteDatabase(\"myDatabase\");\n\n  // Handle successful deletion of the database.\n  deleteRequest.onsuccess = function () {\n    console.log(\"Database deleted successfully!\");\n  };\n\n  // Handle errors that occur during the deletion process.\n  deleteRequest.onerror = function (event) {\n    console.error(\"Error deleting database:\", event.target.error);\n  };\n\n  // Handle cases where the deletion is blocked (e.g., if there are still open connections).\n  deleteRequest.onblocked = function () {\n    console.warn(\"Database deletion blocked. Close open connections and try again.\");\n  };\n}\n</code></pre>\n</div>\n\n<p>With that, the entire process is complete!</p>\nConsiderations And Limitations\n<p>While we’ve done a lot to help improve the experience by supporting offline uploads, the system is not without its limitations. I figured I would specifically call those out because it’s worth knowing where this solution might fall short of your needs.</p>\n<ul>\n<li><strong>No Reliable Internet Connectivity Detection</strong><br />JavaScript does not provide a foolproof way to detect online status. For this reason, you need to come up with a custom solution for detecting online status.</li>\n<li><strong>Chromium-Only Solution</strong><br />The Background Sync API is currently <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Background_Synchronization_API#browser_compatibility\">limited to Chromium-based browsers</a>. As such, this solution is only supported by Chromium browsers. That means you will need a more robust solution if you have the majority of your users on non-Chromium browsers.</li>\n<li><strong><code>IndexedDB</code> Storage Policies</strong><br />Browsers impose storage limitations and eviction policies for <code>IndexedDB</code>. For instance, in Safari, data stored in <code>IndexedDB</code> has a lifespan of seven days if the user doesn’t interact with the website. This is something you should bear in mind if you do come up with an alternative for the background sync API that supports Safari.</li>\n</ul>\nEnhancing The User Experience\n<p>Since the entire process happens in the background, we need a way to inform the users when images are stored, waiting to be uploaded, or have been successfully uploaded. Implementing certain <strong>UI elements</strong> for this purpose will indeed enhance the experience for the users. These UI elements may include toast notifications, upload status indicators like spinners (to show active processes), progress bars (to show state progress), network status indicators, or buttons to provide retry and cancel options.</p>\nWrapping Up\n<p>Poor internet connectivity can disrupt the user experience of a web application. However, by leveraging PWA technologies such as <code>IndexedDB</code>, service workers, and the Background Sync API, developers can help improve the reliability of web applications for their users, especially those in areas with unreliable internet connectivity.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"fbb2490727bbabd933bbf47e171fc0b2c237e78766ba0cc6ad51bd607ffdeab6","category":"Tech"}