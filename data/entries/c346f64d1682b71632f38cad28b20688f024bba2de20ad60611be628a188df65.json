{"title":"How To Draw Radar Charts In Web","link":"https://smashingmagazine.com/2024/02/draw-radar-charts-web/","date":1707490800000,"content":"<p>I got to work with a new type of chart for data visualization called a <strong>radar chart</strong> when a project asked for it. It was new to me, but the idea is that there is a circular, two-dimensional circle with plots going around the chart. Rather than simple X and Y axes, each plot on a radar chart is its own axis, marking a spot between the outer edge of the circle and the very center of it. The plots represent some sort of category, and when connecting them together, they are like vertices that form shapes to help see the relationship of category values, not totally unlike the vectors in an SVG.</p>\n<p><img src=\"https://files.smashing.media/articles/draw-radar-charts-web/1-supercapacitor-comparison-chart.png\" /></p>\n<p>Sometimes, the radar chart is called a <strong>spider chart</strong>, and it’s easy to see why. The axes that flow outward intersect with the connected plots and form a web-like appearance. So, if your <a href=\"https://www.urbandictionary.com/define.php?term=Spidey%20sense\">Spidey senses</a> were tingling at first glance, you know why.</p>\n<p>You already know where we’re going with this: <strong>We’re going to build a radar chart together!</strong> We’ll work from scratch with nothing but HTML, CSS, and JavaScript. But before we go there, it’s worth noting a couple of things about radar charts.</p>\n<p>First, you don’t <em>have</em> to build them from scratch. <a href=\"https://www.chartjs.org/docs/latest/samples/other-charts/radar.html\">Chart.js</a> and <a href=\"https://d3-graph-gallery.com/spider\">D3.js</a> are readily available with convenient approaches that greatly simplify the process. Seeing as I needed just one chart for the project, I decided against using a library and took on the challenge of making it myself. I learned something new, and hopefully, you do as well!</p>\n<p>Second, there are <a href=\"https://www.data-to-viz.com/caveat/spider.html\">caveats to using radar charts</a> for data visualization. While they are indeed effective, they can also be difficult to read when multiple series stack up. The relationships between plots are not nearly as decipherable as, say, bar charts. The order of the categories around the circle affects the overall shape, and the scale between series has to be consistent for drawing conclusions.</p>\n<p>That all said, let’s dive in and get our hands sticky with data plots.</p>\nThe Components\n<p>The thing I like immediately about radar charts is that they are inherently geometrical. Connecting plots produces a series of angles that form polygon shapes. The sides are straight lines. And CSS is absolutely wonderful for working with polygons given that we have the <a href=\"https://web.dev/articles/shapes-getting-started#the_polygon_function\">CSS <code>polygon()</code> function</a> for drawing them by declaring as many points as we need in the function’s arguments.</p>\n<p>We will start with a pentagonal-shaped chart with five data categories.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/abMaEyo\">Radar chart (Pentagon) [forked]</a> by <a href=\"https://codepen.io/rpsthecoder\">Preethi Sam</a>.  </p>\n<p>There are <strong>three components</strong> we need to establish in HTML before we work on styling. Those would be:</p>\n<ol>\n<li><strong>Grids</strong>: These provide the axes over which the diagrams are drawn. It’s the spider web of the bunch.</li>\n<li><strong>Graphs</strong>: These are the polygons we draw with the coordinates of each data plot before coloring them in.</li>\n<li><strong>Labels</strong>: The text that identifies the categories along the graphs’ axes.</li>\n</ol>\n<p>Here’s how I decided to stub that out in HTML:</p>\n<pre><code>&lt;!-- GRIDS --&gt;\n&lt;div class=\"wrapper\"&gt;\n  &lt;div class=\"grids polygons\"&gt;\n    &lt;div&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=\"grids polygons\"&gt;\n    &lt;div&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=\"grids polygons\"&gt;\n    &lt;div&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n\n&lt;!-- GRAPHS --&gt;\n&lt;div class=\"wrapper\"&gt;\n  &lt;div class=\"graphs polygons\"&gt;\n    &lt;div&gt;&lt;!-- Set 1 --&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=\"graphs polygons\"&gt;\n    &lt;div&gt;&lt;!-- Set 2 --&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=\"graphs polygons\"&gt;\n    &lt;div&gt;&lt;!-- Set 3 --&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;!-- etc. --&gt;\n&lt;/div&gt;\n\n&lt;!-- LABELS --&gt;\n&lt;div class=\"wrapper\"&gt;\n  &lt;div class=\"labels\"&gt;Data A&lt;/div&gt;\n  &lt;div class=\"labels\"&gt;Data B&lt;/div&gt;\n  &lt;div class=\"labels\"&gt;Data C&lt;/div&gt;\n  &lt;div class=\"labels\"&gt;Data D&lt;/div&gt;\n  &lt;div class=\"labels\"&gt;Data E&lt;/div&gt;\n  &lt;!-- etc. --&gt;\n&lt;/div&gt;\n</code></pre>\n\n<p>I’m sure you can read the markup and see what’s going on, but we’ve got three parent elements (<code>.wrapper</code>) that each holds one of the main components. The first parent contains the <code>.grids</code>, the second parent contains the <code>.graphs</code>, and the third parent contains the <code>.labels</code>.</p>\nBase Styles\n<p>We’ll start by setting up a few color variables we can use to fill things in as we go:</p>\n<pre><code>:root {\n  --color1: rgba(78, 36, 221, 0.6); /* graph set 1 */\n  --color2: rgba(236, 19, 154, 0.6); /* graph set 2 */\n  --color3: rgba(156, 4, 223, 0.6); /* graph set 3 */\n  --colorS: rgba(255, 0, 95, 0.1); /* graph shadow */\n}\n</code></pre>\n\n<p>Our next order of business is to establish the layout. CSS Grid is a solid approach for this because we can place all three grid items together on the grid in just a couple of lines:</p>\n<pre><code>/* Parent container */\n.wrapper { display: grid; }\n\n/* Placing elements on the grid */\n.wrapper &gt; div {\n  grid-area: 1 / 1; /* There's only one grid area to cover */\n}\n</code></pre>\n\n<p>Let’s go ahead and set a size on the grid items. I’m using a fixed length value of <code>300px</code>, but you can use any value you need and variablize it if you plan on using it in other places. And rather than declaring an explicit height, let’s put the burden of calculating a height on CSS using <code>aspect-ratio</code> to form perfect squares.</p>\n<pre><code>/* Placing elements on the grid */\n.wrapper div {\n  aspect-ratio: 1 / 1;\n  grid-area: 1 / 1;\n  width: 300px;\n}\n</code></pre>\n\n<p>We can’t see anything just yet. We’ll need to color things in:</p>\n<div>\n<pre><code>/* ----------\nGraphs\n---------- */\n.graphs:nth-of-type(1) &gt; div { background: var(--color1); }\n.graphs:nth-of-type(2) &gt; div { background: var(--color2); }\n.graphs:nth-of-type(3) &gt; div { background: var(--color3); }\n\n.graphs {\n  filter: \n    drop-shadow(1px 1px 10px var(--colorS))\n    drop-shadow(-1px -1px 10px var(--colorS))\n    drop-shadow(-1px 1px 10px var(--colorS))\n    drop-shadow(1px -1px 10px var(--colorS));\n}\n\n/* --------------\nGrids \n-------------- */\n.grids {\n  filter: \n    drop-shadow(1px 1px 1px #ddd)\n    drop-shadow(-1px -1px 1px #ddd)\n    drop-shadow(-1px 1px 1px #ddd)\n    drop-shadow(1px -1px 1px #ddd);\n    mix-blend-mode: multiply;\n}\n\n.grids &gt; div { background: white; }\n</code></pre>\n</div>\n\n<p>Oh, wait! We need to set widths on the grids and polygons for them to take shape:</p>\n<pre><code>.grids:nth-of-type(2) { width: 66%; }\n.grids:nth-of-type(3) { width: 33%; }\n\n/* --------------\nPolygons \n-------------- */\n.polygons { place-self: center; }\n.polygons &gt; div { width: 100%; }\n</code></pre>\n\n<p>Since we’re already here, I’m going to position the labels a smidge and give them width:</p>\n<pre><code>/* --------------\nLabels\n-------------- */\n.labels:first-of-type { inset-block-sptart: -10%; }\n\n.labels {\n  height: 1lh;\n  position: relative;\n  width: max-content;\n}\n</code></pre>\n\n<p>We still can’t see what’s going on, but we can if we temporarily draw borders around elements.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/QWoVamB\">Radar chart layout [forked]</a> by <a href=\"https://codepen.io/rpsthecoder\">Preethi Sam</a>.</p>\n<p>All combined, it doesn’t look all that great so far. Basically, we have a series of overlapping grids followed by perfectly square graphs stacked right on top of one another. The labels are off in the corner as well. We haven’t drawn anything yet, so this doesn’t bother me for now because we have the HTML elements we need, and CSS is technically establishing a layout that should come together as we start plotting points and drawing polygons.</p>\n<p>More specifically: </p>\n<ul>\n<li>The <code>.wrapper</code> elements are displayed as CSS Grid containers.</li>\n<li>The direct children of the <code>.wrapper</code> elements are <code>div</code>s placed in the exact same <code>grid-area</code>. This is causing them to stack one right on top of the other.</li>\n<li>The <code>.polygons</code> are centered (<code>place-self: center</code>).</li>\n<li>The child <code>div</code>s in the <code>.polygons</code> take up the full width (<code>width:100%</code>).</li>\n<li>Every single <code>div</code> is <code>300px</code> wide and squared off with a one-to-one <code>aspect-ratio</code>.</li>\n<li>We’re explicitly declaring a relative position on the <code>.labels</code>. This way, they can be automatically positioned when we start working in JavaScript.</li>\n</ul>\n<p>The rest? Simply apply some colors as backgrounds and drop shadows.</p>\nCalculating Plot Coordinates\n<p>Don’t worry. We are not getting into a deep dive about polygon geometry. Instead, let’s take a quick look at the equations we’re using to calculate the coordinates of each polygon’s vertices. You don’t have to know these equations to use the code we’re going to write, but it never hurts to peek under the hood to see how it comes together.</p>\n<pre><code>x1 = x + cosθ1 = cosθ1 if x=0\ny1 = y + sinθ1 = sinθ1 if y=0\nx2 = x + cosθ2 = cosθ2 if x=0\ny2 = y + sinθ2 = sinθ2 if y=0\netc.\n\nx, y = center of the polygon (assigned (0, 0) in our examples)\n\nx1, x2… = x coordinates of each vertex (vertex 1, 2, and so on)\ny1, y2… = y coordinates of each vertex\nθ1, θ2… = angle each vertex makes to the x-axis\n</code></pre>\n\n<p>We can assume that 𝜃 <strong>is</strong> <code>90deg</code> (i.e., <code>𝜋/2</code>) since a vertex can always be placed right above or below the center (i.e., <em>Data A</em> in this example). The rest of the angles can be calculated like this:</p>\n<pre><code>n = number of sides of the polygon\n\n𝜃1 = 𝜃0 + 2𝜋/𝑛 = 𝜋/2 + 2𝜋/𝑛\n𝜃2 = 𝜃0 + 4𝜋/𝑛 = 𝜋/2 + 4𝜋/𝑛\n𝜃3 = 𝜃0 + 6𝜋/𝑛 = 𝜋/2 + 6𝜋/𝑛\n𝜃3 = 𝜃0 + 8𝜋/𝑛 = 𝜋/2 + 8𝜋/𝑛\n𝜃3 = 𝜃0 + 10𝜋/𝑛 = 𝜋/2 + 10𝜋/𝑛\n</code></pre>\n\n<p>Armed with this context, we can solve for our <code>x</code> and <code>y</code> values:</p>\n<pre><code>x1 = cos(𝜋/2 + 2𝜋/# sides)\ny1 = sin(𝜋/2 + 2𝜋/# sides)\nx2 = cos(𝜋/2 + 4𝜋/# sides)\ny2 = sin(𝜋/2 + 4𝜋/# sides)\netc.\n</code></pre>\n\n<p>The number of sides depends on the number of plots we need. We said up-front that this is a pentagonal shape, so we’re working with five sides in this particular example.</p>\n<pre><code>x1 = cos(𝜋/2 + 2𝜋/5)\ny1 = sin(𝜋/2 + 2𝜋/5)\nx2 = cos(𝜋/2 + 4𝜋/5)\ny2 = sin(𝜋/2 + 4𝜋/5)\netc.\n</code></pre>\n\nDrawing Polygons With JavaScript\n<p>Now that the math is accounted for, we have what we need to start working in JavaScript for the sake of plotting the coordinates, connecting them together, and painting in the resulting polygons.</p>\n<p>For simplicity’s sake, we will leave the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API\">Canvas API</a> out of this and instead use regular HTML elements to draw the chart. You can, however, use the math outlined above and the following logic as the foundation for drawing polygons in whichever language, framework, or API you prefer.</p>\n<p>OK, so we have three types of components to work on: grids, graphs, and labels. We start with the grid and work up from there. In each case, I’ll simply drop in the code and explain what’s happening.</p>\n<h3>Drawing The Grid</h3>\n<div>\n<pre><code>// Variables\nlet sides = 5; // # of data points\nlet units = 1; // # of graphs + 1\nlet vertices = (new Array(units)).fill(\"\"); \nlet percents = new Array(units);\npercents[0] = (new Array(sides)).fill(100); // for the polygon's grid component\nlet gradient = \"conic-gradient(\";\nlet angle = 360/sides;\n\n// Calculate vertices\nwith(Math) { \n  for(i=0, n = 2 * PI; i &lt; sides; i++, n += 2 * PI) {\n    for(j=0; j &lt; units; j++) {\n      let x = ( round(cos(-1 * PI/2 + n/sides) * percents[j][i]) + 100 ) / 2; \n      let y = ( round(sin(-1 * PI/2 + n/sides) * percents[j][i]) + 100 ) / 2; \n      vertices[j] += <code>${x}% ${y} ${i == sides - 1 ? '%':'%, '}</code>;\n  }\n  gradient += <code>white ${\n    (angle &amp;#42; (i+1)) - 1}deg,\n    #ddd ${ (angle &amp;#42; (i+1)) - 1 }deg,\n    #ddd ${ (angle &amp;#42; (i+1)) + 1 }deg,\n    white ${ (angle &amp;#42; (i+1)) + 1 }deg,</code>;}\n}\n\n// Draw the grids\ndocument.querySelectorAll('.grids&gt;div').forEach((grid,i) =&gt; {\n  grid.style.clipPath =<code>polygon(${ vertices[0] })</code>;\n});\ndocument.querySelector('.grids:nth-of-type(1) &gt; div').style.background =<code>${gradient.slice(0, -1)} )</code>;\n</code></pre>\n</div>\n\n<p>Check it out! We already have a spider web.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/poYOpOG\">Radar chart (Grid) [forked]</a> by <a href=\"https://codepen.io/rpsthecoder\">Preethi Sam</a>.</p>\n<p>Here’s what’s happening in the code:</p>\n<ol>\n<li><code>sides</code> is the number of sides of the chart. Again, we’re working with five sides.</li>\n<li><code>vertices</code> is an array that stores the coordinates of each vertex.</li>\n<li>Since we are not constructing any graphs yet — only the grid — the number of <code>units</code> is set to <code>1</code>, and only one item is added to the <code>percents</code> array at <code>percents[0]</code>. For grid polygons, the data values are <code>100</code>.</li>\n<li><code>gradient</code> is a string to construct the <code>conic-gradient()</code> that establishes the grid lines.</li>\n<li><code>angle</code> is a calculation of <code>360deg</code> divided by the total number of <code>sides</code>.</li>\n</ol>\n<p>From there, we calculate the vertices:</p>\n<ol>\n<li><code>i</code> is an iterator that cycles through the total number of <code>sides</code> (i.e., <code>5</code>).</li>\n<li><code>j</code> is an iterator that cycles through the total number of <code>units</code> (i.e., <code>1</code>).</li>\n<li><code>n</code> is a counter that counts in increments of <code>2*PI</code> (i.e., <code>2𝜋</code>, <code>4𝜋</code>, <code>6𝜋</code>, and so on).</li>\n</ol>\n<p>The <code>x</code> and <code>y</code> values of each vertex are calculated as follows, based on the geometric equations we discussed earlier. Note that we multiply <code>𝜋</code> by <code>-1</code> to steer the rotation.</p>\n<div>\n<pre><code>cos(-1 * PI/2 + n/sides) // cos(𝜋/2 + 2𝜋/sides), cos(𝜋/2 + 4𝜋/sides)...\nsin(-1 * PI/2 + n/sides) // sin(𝜋/2 + 2𝜋/sides), sin(𝜋/2 + 4𝜋/sides)...\n</code></pre>\n</div>\n\n<p>We convert the <code>x</code> and <code>y</code> values into percentages (since that is how the data points are formatted) and then place them on the chart.</p>\n<div>\n<pre><code>let x = (round(cos(-1 * PI/2 + n/sides) * percents[j][i]) + 100) / 2;\nlet y = (round(sin(-1 * PI/2 + n/sides) * percents[j][i]) + 100) / 2;\n</code></pre>\n</div>\n\n<p>We also construct the <code>conic-gradient(),</code> which is part of the grid. Each color stop corresponds to each vertex’s angle — at each of the angle increments, a grey (<code>#ddd</code>) line is drawn.</p>\n<pre><code>gradient += \n  `white ${ (angle * (i+1)) - 1 }deg,\n   #ddd ${ (angle * (i+1)) - 1 }deg,\n   #ddd ${ (angle * (i+1)) + 1 }deg,\n   white ${ (angle * (i+1)) + 1 }deg,`\n</code></pre>\n\n<p>If we print out the computed variables after the <code>for</code> loop, these will be the results for the grid’s <code>vertices</code> and <code>gradient</code>:</p>\n<div>\n<pre><code>console.log(<code>polygon( ${vertices[0]} )</code>); /* grid’s polygon */\n// polygon(97.5% 34.5%, 79.5% 90.5%, 20.5% 90.5%, 2.5% 34.5%, 50% 0%)\n\nconsole.log(gradient.slice(0, -1)); /* grid’s gradient */\n// conic-gradient(white 71deg, #ddd 71deg,# ddd 73deg, white 73deg, white 143deg, #ddd 143deg, #ddd 145deg, white 145deg, white 215deg, #ddd 215deg, #ddd 217deg, white 217deg, white 287deg, #ddd 287deg, #ddd 289deg, white 289deg, white 359deg, #ddd 359deg, #ddd 361deg, white 361deg\n</code></pre>\n</div>\n\n<p>These values are assigned to the grid’s <code>clipPath</code> and <code>background</code>, respectively, and thus the grid appears on the page.</p>\n<h3>The Graph</h3>\n<div>\n<pre><code>// Following the other variable declarations \n// Each graph's data points in the order [B, C, D... A] \npercents[1] = [100, 50, 60, 50, 90]; \npercents[2] = [100, 80, 30, 90, 40];\npercents[3] = [100, 10, 60, 60, 80];\n\n// Next to drawing grids\ndocument.querySelectorAll('.graphs &gt; div').forEach((graph,i) =&gt; {\n  graph.style.clipPath =<code>polygon( ${vertices[i+1]} )</code>;\n});\n</code></pre>\n</div>\n\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/KKExZYE\">Radar chart (Graph) [forked]</a> by <a href=\"https://codepen.io/rpsthecoder\">Preethi Sam</a>.</p>\n<p>Now it looks like we’re getting somewhere! For each graph, we add its set of data points to the <code>percents</code> array after incrementing the value of <code>units</code> to match the number of graphs. And that’s all we need to draw graphs on the chart. Let’s turn our attention to the labels for the moment.</p>\n<h3>The Labels</h3>\n<div>\n<pre><code>// Positioning labels\n\n// First label is always set in the top middle\nlet firstLabel = document.querySelector('.labels:first-of-type');\nfirstLabel.style.insetInlineStart =<code>calc(50% - ${firstLabel.offsetWidth / 2}px)</code>;\n\n// Setting labels for the rest of the vertices (data points). \nlet v = Array.from(vertices[0].split(' ').splice(0, (2 * sides) - 2), (n)=&gt; parseInt(n)); \n\ndocument.querySelectorAll('.labels:not(:first-of-type)').forEach((label, i) =&gt; {\n  let width = label.offsetWidth / 2; \n  let height = label.offsetHeight;\n  label.style.insetInlineStart = <code>calc( ${ v[i&amp;#42;2] }% + ${ v[i&amp;#42;2] &amp;lt; 50 ? - 3&amp;#42;width : v[i&amp;#42;2] == 50 ? - width: width}px )</code>;\n  label.style.insetBlockStart = <code>calc( ${ v[(i&amp;#42;2) + 1] }% - ${ v[(i &amp;#42; 2) + 1] == 100 ? - height: height / 2 }px )</code>;\n});\n</code></pre>\n</div>\n\n<p>The positioning of the labels is determined by three things:</p>\n<ol>\n<li>The coordinates of the vertices (i.e., data points) they should be next to,</li>\n<li>The width and height of their text, and</li>\n<li>Any blank space needed around the labels so they don’t overlap the chart.</li>\n</ol>\n<p>All the labels are positioned <code>relative</code> in CSS. By adding the <code>inset-inline-start</code> and <code>inset-block-start</code> values in the script, we can reposition the labels using the values as coordinates. The first label is always set to the top-middle position. The coordinates for the rest of the labels are the same as their respective vertices, plus an offset. The offset is determined like this:</p>\n<ol>\n<li><strong>x-axis/horizontal</strong><br />If the label is at the left (i.e., <code>x</code> is less than <code>50%</code>), then it’s moved towards the left based on its <code>width.</code> Otherwise, it’s moved towards the right side. As such, the right or left edges of the labels, depending on which side of the chart they are on, are uniformly aligned to their vertices.</li>\n<li><strong>y-axis/vertical</strong><br />The height of each label is fixed. There’s not much offset to add except maybe moving them down half their height. Any label at the bottom (i.e., when <code>y</code> is 100%), however, could use additional space above it for breathing room.</li>\n</ol>\n<p>And guess what…</p>\nWe’re Done!\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/XWGPVLJ\">Radar chart (Pentagon) [forked]</a> by <a href=\"https://codepen.io/rpsthecoder\">Preethi Sam</a>.</p>\n<p>Not too shabby, right? The most complicated part, I think, is the math. But since we have that figured out, we can practically plug it into any other situation where a radar chart is needed. Need a four-point chart instead? Update the number of vertices in the script and account for fewer elements in the markup and styles.</p>\n<p>In fact, here are two more examples showing different configurations. In each case, I’m merely increasing or decreasing the number of vertices, which the script uses to produce different sets of coordinates that help position points along the grid.</p>\n<p>Need just three sides? All that means is two fewer coordinate sets:</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/vYPzpqJ\">Radar chart (Triangle) [forked]</a> by <a href=\"https://codepen.io/rpsthecoder\">Preethi Sam</a>.</p>\n<p>Need seven sides? We’ll produce more coordinate sets instead:</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/WNmgdqY\">Radar chart (Heptagon) [forked]</a> by <a href=\"https://codepen.io/rpsthecoder\">Preethi Sam</a>.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"c346f64d1682b71632f38cad28b20688f024bba2de20ad60611be628a188df65","category":"Tech"}