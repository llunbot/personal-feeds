{"title":"Orchestrating Complexity With Web Animations API","link":"https://smashingmagazine.com/2021/09/orchestrating-complexity-web-animations-api/","date":1631523600000,"content":"<p>There’s no middle ground between simple transitions and complex animations. You’re either fine with what CSS Transitions and Animations provide or you suddenly need all the power you can get. Web Animations API gives you a lot of tools to work with animations. But you need to know how to handle them. This article will walk you through the <strong>main points and techniques</strong> that might help you deal with complex animations while staying flexible.</p>\n<p>Before we dive into the article it is vital that you’re familiar with the basics of the Web Animations API and JavaScript. To make it clear and avoid distraction from the problem at hand the code examples provided are plain. There won’t be anything more complex than functions and objects. As nice entry points into animations themselves I would suggest <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API\">MDN as a general reference</a>, <a href=\"https://danielcwilson.com/blog/2015/07/animations-intro/\">Daniel C. Wilson’s excellent series</a>, and <a href=\"https://css-tricks.com/css-animations-vs-web-animations-api/\">CSS Animations vs Web Animations API by Ollie Williams</a>. We won’t go through the ways to define effects and tuning them to achieve the outcome you want. This article assumes you have your animations defined and need ideas and techniques to handle them.</p>\n<p>We start with an <strong>overview of interfaces</strong> and what they are for. Then we’ll look at timing and levels of control to define what, when, and for how long. After that, we’ll learn how to treat several animations as one by wrapping them in objects. That would be a good start on your way to using Web Animations API.</p>\nInterfaces\n<p>Web Animations API gives us a new dimension of control. Before that, CSS Transitions and Animation while providing a powerful way of defining effects still had a <strong>single point of actuation</strong>. Like a light switch, it was either on or off. You could play with delays and easing functions to create quite complex effects. Still, at a certain point, it becomes cumbersome and hard to work with.</p>\n<p>Web Animations API turns this single point of actuation into <strong>complete control over playback</strong>. The light switch turns into a dimmer switch with a slider. If you want you could turn it into the whole smart home thing, because additionally to the playback control you now can define and change effects at runtime. You now can adapt effects to context or you could implement an animations editor with real-time preview.</p>\n<p>We start with the Animation interface. To get an animation object, we can use the <code>Element.animate</code> method. You give it keyframes and options and it plays your animation immediately. What it also does is it returns an <code>Animation</code> object instance. Its purpose is to control the playback.</p>\n<p>Think of it as a <strong>cassette player</strong>, if you remember these. I’m aware that some of the readers might not be familiar with what it is. It’s inevitable that any attempt to apply real-world concepts to describe abstract computery things will fall apart quickly. But let it reassure you--a reader who doesn’t know the joy of rewinding a tape with a pencil--that people who know what a cassette player is will be confused even more by the end of this article.</p>\n<p>Imagine a box. It has a slot where the cassette goes and it has buttons to play, stop and rewind. That’s what the Animation interface instance is — a <strong>box that holds defined animation</strong> and provides ways to interact with its playback. You give it something to play and it gives you back controls.</p>\n<p>The controls you get are conveniently similar to the ones you get from audio and video elements. They are <em>play</em> and <em>pause</em> methods, and the <em>current time</em> property. With those three controls, you can build anything when it comes to playback.</p>\n<p>The cassette itself is a <strong>package that contains a reference</strong> to the element that is animated, the definition of effects, and options which include timing among other things. And that is what the <code>KeyframeEffect</code> is. Our cassette tape is something that holds all the recordings and info about the length of the recordings. I will leave it for the older audience’s imagination to match all those properties with the components of a physical cassette. What I will show you is how it looks like in code.</p>\n<p>When you create an animation through <code>Element.animate</code>, you’re using a shortcut that does three things. It creates a <code>KeyframeEffect</code> instance. It puts in into a new <code>Animation</code> instance. It immediately starts playing it.</p>\n<pre><code>const animation = element.animate(keyframes, options);\n</code></pre>\n\n<p>Let’s break it down and see the equivalent code that does the same thing.</p>\n<pre><code>const animation = new Animation( // (2)\n    new KeyframeEffect(element, keyframes, options) // (1)\n);\nanimation.play(); (3)\n</code></pre>\n\n<p>Get the cassette (1), put it into a player (2), then hit the Play button (3).</p>\n<p>The point of knowing how it works behind the scenes is to be able to separate the definition of keyframes and deciding when to play it. When you have a lot of animations to coordinate it might be helpful to gather them all first so you know they are ready to play. Generating them on the fly and hoping they would start playing at the right moment is not something you would want to hope for. It’s too easy to break the desired effect by a few frames drag. In case of a long sequence that drag accumulates resulting in not at all convincing experience.</p>\nTiming\n<p>As in comedy, timing is everything in animations. To make an effect work, to achieve a certain feel you need to be able to fine-tune the way properties change. There are <strong>two levels of timing</strong> you can control in Web Animations API.</p>\n<p>On the level of individual properties, we have <code>offset</code>. Offset gives you <strong>control over single property timing</strong>. By giving it a value from zero to one you define when does each effect kick in. When omitted it equals zero.</p>\n<p>You might remember from <code>@keyframes</code> in CSS how you can use percentages instead of <code>from</code>/<code>to</code>. That’s what <code>offset</code> is but divided by one hundred. The value of <code>offset</code> is a <strong>portion of the duration of a single iteration</strong>.</p>\n<p>The <code>offset</code> allows you to arrange keyframes within a <code>KeyframeEffect</code>. Being a relative number offset makes sure that no matter the duration or the rate of playback all your keyframes start at the same moment relative to each other.</p>\n<p>As we stated previously, <code>offset</code> is a <strong>portion of duration</strong>. Now I want you to avoid my mistakes and loss of time on this. It’s important to understand that duration of animation isn’t the same thing as the overall duration of an animation. Usually, they are the same and that’s what could confuse you, and what definitely confused me.</p>\n<p><em>Duration</em> is the <strong>amount of time in milliseconds</strong> that one iteration takes to finish. It will be equal to the overall duration by default. Once you add a delay or increase the number of iterations in an animation duration stops telling you the number you want to know. That is important to understand to use it to your advantage.</p>\n<p>When you need to coordinate a keyframe playback within a bigger context, like media playback, you need to use timing options. The whole duration of the animation from start to “finished” event in the following equation:</p>\n<pre><code>delay + (iterations × duration) + end delay\n</code></pre>\n\n<p>You can see it in action in the following demo:</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/jOwyqqd\">What is the actual duration of an animation?</a> by <a href=\"https://codepen.io/kirillmyshkin\">Kirill Myshkin</a>.</p>\n<p>What this allows us to do is to <strong>align several animations</strong> within the context of fixed-length media. Keeping the desired duration of animation intact you could “pad” it with <code>delay</code> at the start and <code>delayEnd</code> at the end in order to embed it into a context with a longer duration. If you think about it <code>delay</code> in this sense would act as the offset does in keyframes. Just remember that delay is set in milliseconds so you might want to convert it to a relative value.</p>\n<p>One more timing option that would help to align animation is <code>iterationStart</code>. It sets the starting position of an iteration. Take the <a href=\"https://codepen.io/kirillmyshkin/pen/Vwbdzqd\">pool ball demo</a>. By adjusting <code>iterationStart</code> slider you can set the starting position of the ball and the rotation, for instance, you can set it to start jumping from the center of the screen and make the number be straight in the camera in the last frame.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/PojWNze\">Tweak interationStart</a> by <a href=\"https://codepen.io/kirillmyshkin\">Kirill Myshkin</a>.</p>\nControl Several As One\n<p>When I worked on animation editor for a presentation app I had to arrange several animations for a single element on a timeline. My first attempt was to use <code>offset</code> to put my animation at the right starting point on a timeline.</p>\n<p>That quickly proved to be the wrong way of using <code>offset</code>. In terms of this particular UI moving animation on the timeline meant to shift its starting position without changing animation’s duration. With <code>offset</code> that meant I needed to change several things, the <code>offset</code> itself and also change the <code>offset</code> of closing property to make sure the duration doesn’t change. The solution proved to be too complex to comprehend.</p>\n<p>The second problem came with the <code>transform</code> property. Due to the fact that it can represent <strong>several characteristic changes</strong> to an element, it can get tricky to make it do what you want. In case of a desire to change those properties independently of each other, it could become even harder. Change of scale function influences all the functions following it. Here’s why that happens.</p>\n<p>Transform property can <strong>take several functions in a sequence</strong> as a value. Depending on the order of function the result changes. Take <code>scale</code> and <code>translate</code>. Sometimes it’s handy to define <code>translate</code> in percentage, which means relative to the size of an element. Say you want a ball to jump exactly three own diameters high. Now depending on where you place the scale function — before or after the <code>translate</code> — the result changes from three heights of the original size or the scaled one.</p>\n<p>It is an important trait of <code>transform</code> property. You need it to achieve quite a complex transformation. But when you need those transformations to be distinct and independent of other transformations of an element it gets in your way.</p>\n<p>There are cases when you cannot put all of the effects in one <code>transform</code> property. It can get too much pretty quickly. Especially if your keyframes come from different places you would need to have a <strong>very complex merging of a transformed string</strong>. You could hardly rely on an automatic mechanism because the logic isn't straightforward. Also, it could get hard to understand what to expect. To simplify this and retain flexibility we need to separate those into different channels.</p>\n<p>One solution is to <strong>wrap our elements into <code>div</code>s</strong> that each could be animated separately, e.g. a div for positioning on the canvas, another one for scaling, and a third one for rotation. That way, not only do you vastly simplify the definition of animations, you also open up the possibility of defining different transform origins where applicable.</p>\n<p>It might seem that things get out of control with that trick. That we are multiplying the number of problems we had before. In fact, when I first found this trick I discarded it as being too much. I thought that I could just make sure my <code>transform</code> property is <strong>compiled out of all the pieces</strong> in the right order in one piece. It took one more <code>transform</code> function to make things too complex to manage and certain things impossible to do. My <code>transform</code> property string compiler started taking more and more time to get right so I gave up.</p>\n<p>It turned out that controlling the playback of several animations is <strong>not that hard</strong> as it seems to be initially. Remember the cassette tape player analogy from the begging? What if you could use your own player that takes any number of cassettes? More than that you could add as many buttons as you want on that player.</p>\n<p>The only difference between calling <code>play</code> on a single animation and an array of animations is that you need to iterate. Here’s the code that you can use for any method of <code>Animation</code> instances:</p>\n<pre><code>// To play just call play on all of them\nanimations.forEach((animation) =&gt; animation.play());\n</code></pre>\n\n<p>We will use this to create all kinds of functions for our player.</p>\n<p>Let’s create that box the would hold the animations and play them. You can create those boxes in any way that’s suitable. To make it clear, I’ll show you an example of doing it with a function and an object. The <code>createPlayer</code> function takes an array of animations that are to be played in sync. It returns an object with a single <code>play</code> method.</p>\n<pre><code>function createPlayer(animations) {\n    return Object.freeze({\n        play: function () {\n            animations.forEach((animation) =&gt; animation.play());\n        }\n    });\n}\n</code></pre>\n\n<p>That is enough for you to know to start expanding the functionality. Let’s add pause and <code>currentTime</code> methods.</p>\n<pre><code>function createPlayer(animations) {\n    return Object.freeze({\n        play: function () {\n            animations.forEach((animation) =&gt; animation.play());\n        },\n        pause: function () {\n            animations.forEach((animation) =&gt; animation.pause());\n        },\n        currentTime: function (time = 0) {\n            animations.forEach((animation) =&gt; animation.currentTime = time);\n        }\n    });\n}\n</code></pre>\n\n<p>The <code>createPlayer</code> with those three methods gives you <strong>enough control to orchestrate any number of animations</strong>. But let’s push it a bit further. Let’s make it so our player could not only take any number of cassettes but other players as well.</p>\n<p>As we saw earlier, <code>Animation</code> interface is similar to media interfaces. Using that similarity you could put all kinds of things in your player. To accommodate for that let’s tweak the <code>currentTime</code> method to make it work with both animations objects and objects that came from <code>createPlayer</code>.</p>\n<pre><code>function currentTime(time = 0) {\n    animations.forEach(function (animation) {\n        if (typeof animation.currentTime === \"function\") {\n            animation.currentTime(time);\n        } else {\n            animation.currentTime = time;\n        }\n    });\n}\n</code></pre>\n\n<p>The player we just created is what will allow you to <strong>hide the complexity</strong> of several <code>div</code>s for single-element animations channels. Those elements could be grouped in a scene. And each scene could be a part of something bigger. All that could be done with this technique.</p>\n<p>To demonstrate the timing demo, I divided all the animations into three players. The first one is to <strong>control the playback</strong> of the preview on the right. The second one combines jumping animation of all the balls’ outlines to the left and of the one in preview.</p>\n<p>Finally, the third one is a player that <strong>combined position animations</strong> of the balls in a left container. That player allows the balls to spread in a continuous demonstration of the animation with about 60 frames per second slices.</p>\nConclusion\n<p>Web interfaces like Web Animations API expose for us certain things that browsers did all along. Browsers know how to render fast by passing on work to the GPU. With Web Animations API, we have control over it. Even though that control might seem a bit foreign or confusing, it doesn’t mean that using it should also be confusing. With an understanding of timing and playback control, you have tools to tame that API to your needs. You should be able to define how complex it should be.</p>\n<h3>Further Reading</h3>\n<ul>\n<li>“<a href=\"https://www.smashingmagazine.com/2015/06/practical-techniques-on-designing-animation/\">Practical Techniques On Designing Animation</a>,” Sarah Drasner</li>\n<li>“<a href=\"https://www.smashingmagazine.com/2020/09/design-reduced-motion-sensitivities/\">Designing With Reduced Motion For Motion Sensitivities</a>,” Val Head</li>\n<li>“<a href=\"https://www.smashingmagazine.com/2021/06/alternative-voice-ui-voice-assistants/\">An Alternative Voice UI To Voice Assistants</a>,” Ottomatias Peura</li>\n<li>“<a href=\"https://www.smashingmagazine.com/2021/02/designing-tooltips-mobile-user-interfaces/\">Designing Better Tooltips For Mobile User Interfaces</a>,” Eric Olive</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"a471ac673d37c76212ef6a88de057225c86ab1359dcc0c17d081d3ace4b6181d","category":"Tech"}