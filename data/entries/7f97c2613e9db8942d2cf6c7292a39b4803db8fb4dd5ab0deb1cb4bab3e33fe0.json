{"title":"Global vs. Local Styling In Next.js","link":"https://smashingmagazine.com/2021/07/global-local-styling-nextjs/","date":1627383600000,"content":"<p>I have had a great experience using <a href=\"https://nextjs.org/\">Next.js</a> to manage complex front-end projects. Next.js is opinionated about how to organize JavaScript code, but it doesn’t have built-in opinions about how to organize CSS.</p>\n<p>After working within the framework, I have found a series of organizational patterns that I believe both conform to the guiding philosophies of Next.js and exercise best CSS practices. In this article, we’ll build a website (a tea shop!) together to demonstrate these patterns.</p>\n<p><strong>Note</strong>: <em>You probably will not need prior Next.js experience, although it would be good to have a basic understanding of React and to be open to learning some new CSS techniques.</em></p>\nWriting “Old-Fashioned” CSS\n<p>When first looking into Next.js, we may be tempted to consider using some kind of CSS-in-JS library. Though there may be benefits depending on the project, CSS-in-JS introduces many technical considerations. It requires using a new external library, which adds to the bundle size. CSS-in-JS can also have a performance impact by causing additional renders and dependencies on the global state.</p>\n<p><strong>Recommended reading</strong>: “<em><a href=\"https://calendar.perfplanet.com/2019/the-unseen-performance-costs-of-css-in-js-in-react-apps/\">The Unseen Performance Costs Of Modern CSS-in-JS Libraries In React Apps</a>)” by Aggelos Arvanitakis</em></p>\n<p>Furthermore, the whole point of using a library like Next.js is to statically render assets whenever possible, so it doesn’t make so much sense to write JS that needs to be run in the browser to generate CSS.</p>\n<p>There are a couple of questions we have to consider when organizing style within Next.js:</p>\n<blockquote>How can we fit within the conventions/best practices of the framework?<br /><br />How can we balance “global” styling concerns (fonts, colors, main layouts, and so on) with “local” ones (styles regarding individual components)?</blockquote>\n\n<p>The answer I have come up with for the first question is to <strong>simply write good ol’ fashioned CSS</strong>. Not only does Next.js support doing so with no additional setup; it also yields results that are performant and static.</p>\n<p>To solve the second problem, I take an approach that can be summarized in four pieces:</p>\n<ol>\n<li>Design tokens</li>\n<li>Global styles</li>\n<li>Utility classes</li>\n<li>Component styles</li>\n</ol>\n<p>I’m indebted to Andy Bell’s idea of <strong>CUBE CSS</strong> (“Composition, Utility, Block, Exception”) here. If you haven’t heard of this organizational principle before, I recommended checking out its <a href=\"https://cube.fyi/\">official site</a> or <a href=\"https://podcast.smashingmagazine.com/episodes/what-is-cube-css-with-andy-bell\">feature on the Smashing Podcast</a>. One of the principles we will take from CUBE CSS is the idea that we should <em>embrace</em> rather than fear the CSS cascade. Let’s learn these techniques by applying them to a website project.</p>\nGetting Started\n<p>We’ll be building a tea store because, well, tea is tasty. We’ll start by running <code>yarn create next-app</code> to make a new Next.js project. Then, we’ll remove everything in the <code>styles/ directory</code> (it’s all sample code).</p>\n<p><strong>Note</strong>: <em>If you want to follow along with the finished project, you can check it out <a href=\"https://github.com/ajdubovoy/smashing-nextjs-local-vs-global-style\">here</a>.</em></p>\nDesign Tokens\n<p>In pretty much any CSS setup, there’s a clear benefit to <strong>storing all globally shared values in variables</strong>. If a client asks for a color to change, implementing the change is a one-liner rather than a massive find-and-replace mess. Consequently, a key part of our Next.js CSS setup will be storing all site-wide values as <em>design tokens</em>.</p>\n<p>We’ll use inbuilt CSS Custom Properties to store these tokens. (If you’re not familiar with this syntax, you can check out “<a href=\"https://www.smashingmagazine.com/2018/05/css-custom-properties-strategy-guide/\">A Strategy Guide To CSS Custom Properties</a>”.) I should mention that (in some projects) I’ve opted to use SASS/SCSS variables for this purpose. I haven’t found any real advantage, so I usually only include SASS in a project if I find I need <em>other</em> SASS features (mix-ins, iteration, importing files, and so on). CSS custom properties, by contrast, also work with the cascade and can be changed over time rather than statically compiling. So, for today, <strong>let’s stick with plain CSS</strong>.</p>\n<p>In our <code>styles/</code> directory, let’s make a new <em>design_tokens.css</em> file:</p>\n<pre><code>:root {\n  --green: #3FE79E;\n  --dark: #0F0235;\n  --off-white: #F5F5F3;\n\n  --space-sm: 0.5rem;\n  --space-md: 1rem;\n  --space-lg: 1.5rem;\n\n  --font-size-sm: 0.5rem;\n  --font-size-md: 1rem;\n  --font-size-lg: 2rem;\n}</code></pre>\n\n<p>Of course, this list can and will grow over time. Once we add this file, we need to hop over to our <em>pages/_app.jsx</em> file, which is the main layout for all our pages, and add:</p>\n<pre><code>import '../styles/design_tokens.css'</code></pre>\n\n<p>I like to think of design tokens as the glue that maintains consistency across the project. We will reference these variables on a global scale, as well as within individual components, ensuring a unified design language.</p>\nGlobal Styles\n<p>Next up, let’s add a page to our website! Let’s hop into the <em>pages/index.jsx</em> file (this is our homepage). We’ll delete all the boilerplate and add something like:</p>\n<pre><code>export default function Home() {\n  return &lt;main&gt;\n    &lt;h1&gt;Soothing Teas&lt;/h1&gt;\n\n    &lt;p&gt;Welcome to our wonderful tea shop.&lt;/p&gt;\n\n    &lt;p&gt;We have been open since 1987 and serve customers with hand-picked oolong teas.&lt;/p&gt;\n  &lt;/main&gt;\n}</code></pre>\n\n<p>Unfortunately, it will look quite plain, so let’s set some <strong>global styles for basic elements</strong>, e.g. <code>&lt;h1&gt;</code> tags. (I like to think of these styles as “reasonable global defaults”.) We may override them in specific cases, but they’re a good guess as to what we will want if we don’t.</p>\n<p>I’ll put this in the <em>styles/globals.css</em> file (which comes by default from Next.js):</p>\n<pre><code>*,\n*::before,\n*::after {\n  box-sizing: border-box;\n}\n\nbody {\n  color: var(--off-white);\n  background-color: var(--dark);\n}\n\nh1 {\n  color: var(--green);\n  font-size: var(--font-size-lg);\n}\n\np {\n  font-size: var(--font-size-md);\n}\n\np, article, section {\n  line-height: 1.5;\n}\n\n:focus {\n  outline: 0.15rem dashed var(--off-white);\n  outline-offset: 0.25rem;\n}\nmain:focus {\n  outline: none;\n}\n\nimg {\n  max-width: 100%;\n}</code></pre>\n\n<p>Of course, this version is fairly basic, but my <em>globals.css</em> file doesn’t usually end up actually needing to get too large. Here, I style basic HTML elements (headings, body, links, and so on). There is no need to wrap these elements in React components or to constantly add classes just to provide basic style.</p>\n<p>I also include any <strong>resets of default browser styles</strong>. Occasionally, I will have some site-wide layout style to provide a “sticky footer”, for example, but they only belong here if all pages share the same layout. Otherwise, it will need to be scoped inside individual components.</p>\n<p>I always include some kind of <code>:focus</code> styling to <em>clearly</em> indicate interactive elements for keyboard users when focused. It’s best to make it an integral part of the site’s design DNA!</p>\n<p>Now, our website is starting to shape up:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2e4f9a89-4301-4ac2-9782-ee34e5c943e6/1-global-vs-local-styling-nextjs.png\" /></p>\nUtility Classes\n<p>One area where our homepage could certainly improve is that the text currently always extends to the sides of the screen, so let’s limit its width. We need this layout on this page, but I imagine that we might need it on other pages, too. This is a great use case for a utility class!</p>\n<p>I try to <strong>use utility classes sparingly</strong> rather than as a replacement for just writing CSS. My personal criteria for when it makes sense to add one to a project are:</p>\n<ol>\n<li>I need it repeatedly;</li>\n<li>It does one thing well;</li>\n<li>It applies across a range of different components or pages.</li>\n</ol>\n<p>I think this case meets all three criteria, so let’s make a new CSS file <em>styles/utilities.css</em> and add:</p>\n<pre><code>.lockup {\n  max-width: 90ch;\n  margin: 0 auto;\n}</code></pre>\n\n<p>Then let’s add import <code>'../styles/utilities.css'</code> to our <em>pages/_app.jsx</em>. Finally, let’s change the <code>&lt;main&gt;</code> tag in our pages/index.jsx to <code>&lt;main className=\"lockup\"&gt;</code>.</p>\n<p>Now, our page is coming together even more. Because we used the <code>max-width</code> property, we don’t need any media queries to make our layout mobile responsive. And, because we used the <code>ch</code> measurement unit — which equates to about the width of one character — our sizing is dynamic to the user’s browser font size.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6de3bb38-4872-4bf0-b49a-1851a89ee157/2-global-vs-local-styling-nextjs.png\" /></p>\n<p>As our website grows, we can continue adding more utility classes. I take a fairly utilitarian approach here: If I’m working and find I need another class for a color or something, I add it. I don’t add every possible class under the sun — it would bloat the CSS file size and make my code confusing. Sometimes, in larger projects, I like to break things up into a <code>styles/utilities/</code> directory with a few different files; it’s up to the needs of the project.</p>\n<p>We can think of utility classes as our <strong>toolkit of common, repeated styling commands</strong> that are shared globally. They help prevent us from constantly rewriting the same CSS between different components.</p>\nComponent Styles\n<p>We’ve finished our homepage for the moment, but we still need to build a piece of our website: the online store. Our goal here will be to display <strong>a card grid of all the teas we want to sell</strong>, so we’ll need to add some components to our site.</p>\n<p>Let’s start off by adding a new page at <em>pages/shop.jsx</em>:</p>\n<pre><code>export default function Shop() {\n  return &lt;main&gt;\n    &lt;div className=\"lockup\"&gt;\n      &lt;h1&gt;Shop Our Teas&lt;/h1&gt;\n    &lt;/div&gt;\n\n  &lt;/main&gt;\n}</code></pre>\n\n<p>Then, we’ll need some teas to display. We’ll include a name, description, and image (in the public/ directory) for each tea:</p>\n<pre><code>const teas = [\n  { name: \"Oolong\", description: \"A partially fermented tea.\", image: \"/oolong.jpg\" },\n  // ...\n]</code></pre>\n\n<p><strong>Note</strong>: <em>This isn’t an article about <a href=\"https://nextjs.org/docs/basic-features/data-fetching\">data fetching</a>, so we took the easy route and defined an array at the beginning of the file.</em></p>\n<p>Next, we’ll need to define a component to display our teas. Let’s start by making a <code>components/</code> directory (Next.js doesn’t make this by default). Then, let’s add a <code>components/TeaList</code> directory. For any component that ends up needing more than one file, I usually put all the related files inside a folder. Doing so prevents our <code>components/</code> folder from getting unnavigable.</p>\n<p>Now, let’s add our <em>components/TeaList/TeaList.jsx</em> file:</p>\n<pre><code>import TeaListItem from './TeaListItem'\n\nconst TeaList = (props) =&gt; {\n  const { teas } = props\n\n  return &lt;ul role=\"list\"&gt;\n    {teas.map(tea =&gt;\n      &lt;TeaListItem tea={tea} key={tea.name} /&gt;)}\n  &lt;/ul&gt;\n}\n\nexport default TeaList</code></pre>\n\n<p>The purpose of this component is to iterate over our teas and to show a list item for each one, so now let’s define our <em>components/TeaList/TeaListItem.jsx</em> component:</p>\n<pre><code>import Image from 'next/image'\n\nconst TeaListItem = (props) =&gt; {\n  const { tea } = props\n\n  return &lt;li&gt;\n    &lt;div&gt;\n      &lt;Image src={tea.image} alt=\"\" objectFit=\"cover\" objectPosition=\"center\" layout=\"fill\" /&gt;\n    &lt;/div&gt;\n\n  &lt;div&gt;\n      &lt;h2&gt;{tea.name}&lt;/h2&gt;\n      &lt;p&gt;{tea.description}&lt;/p&gt;\n    &lt;/div&gt;\n  &lt;/li&gt;\n}\n\nexport default TeaListItem</code></pre>\n\n<p>Note that we’re using Next.js’s built-in <a href=\"https://nextjs.org/docs/api-reference/next/image\">image component</a>. I set the <code>alt</code> attribute to an empty string because the images are purely decorative in this case; we want to avoid bogging screen reader users down with long image descriptions here.</p>\n<p>Finally, let’s make a <em>components/TeaList/index.js</em> file, so that our components are easy to import externally:</p>\n<pre><code>import TeaList from './TeaList'\nimport TeaListItem from './TeaListItem'\n\nexport { TeaListItem }\n\nexport default TeaList</code></pre>\n\n<p>And then, let’s plug it all together by adding import TeaList from <code>../components/TeaList</code> and a <code>&lt;TeaList teas={teas} /&gt;</code> element to our Shop page. Now, our teas will show up in a list, but it won’t be so pretty.</p>\n<h3>Colocating Style With Components Through CSS Modules</h3>\n<p>Let’s start off by styling our cards (the <code>TeaListLitem</code> component). Now, for the first time in our project, we’re going to want to add style that is specific to just one component. Let’s create a new file <em>components/TeaList/TeaListItem.module.css</em>.</p>\n<p>You may be wondering about the module in the file extension. This is a <strong>CSS Module</strong>. Next.js supports CSS modules and includes some <a href=\"https://nextjs.org/docs/basic-features/built-in-css-support#adding-component-level-css\">good documentation</a> on them. When we write a class name from a CSS module such as <code>.TeaListItem</code>, it will automatically get transformed into something more like <code>. TeaListItem_TeaListItem__TFOk_</code> with a bunch of extra characters tacked on. Consequently, <strong>we can use any class name we want</strong> without being concerned that it will conflict with other class names elsewhere in our site.</p>\n<p>Another advantage to CSS modules is performance. Next.js includes a <a href=\"https://nextjs.org/docs/advanced-features/dynamic-import\">dynamic import feature</a>. next/dynamic lets us lazy load components so that their code only gets loaded when needed, rather than adding to the whole bundle size. If we import the necessary local styles into individual components, then users can also <strong>lazy load the CSS for dynamically imported components</strong>. For large projects, we may choose to lazy load significant chunks of our code and only to load the most necessary JS/CSS upfront. As a result, I usually end up making a new CSS Module file for every new component that needs local styling.</p>\n<p>Let’s start by adding some initial styles to our file:</p>\n<pre><code>.TeaListItem {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-sm);\n  background-color: var(--color, var(--off-white));\n  color: var(--dark);\n  border-radius: 3px;\n  box-shadow: 1px 1px 1px rgba(0, 0, 0, 0.1);\n}\n</code></pre>\n\n<p>Then, we can import style from <code>./TeaListItem.module.css</code> in our <code>TeaListitem</code> component. The style variable comes in like a JavaScript object, so we can access this class-like <code>style.TeaListItem.</code></p>\n<p><strong>Note</strong>: <em>Our class name doesn’t need to be capitalized. I’ve found that a convention of capitalized class names inside of modules (and lowercase ones outside) differentiates local vs. global class names visually.</em></p>\n<p>So, let’s take our new local class and assign it to the <code>&lt;li&gt;</code> in our <code>TeaListItem</code> component:</p>\n<pre><code>&lt;li className={style.TeaListComponent}&gt;\n</code></pre>\n\n<p>You may be wondering about the background color line (i.e. <code>var(--color, var(--off-white));</code>). What this snippet means is that <em>by default</em> the background will be our <code>--off-white</code> value. But, if we set a <code>--color</code> custom property on a card, it will override and choose that value instead.</p>\n<p>At first, we’ll want all our cards to be <code>--off-white</code>, but we may want to change the value for individual cards later. This works very similarly to props in React. We can set a default value but create a slot where we can choose other values in specific circumstances. So, I encourage us to <strong>think of CSS custom properties like CSS’s version of props</strong>.</p>\n<p>The style still won’t look great because we want to make sure that the images stay within their containers. Next.js’s Image component with the <code>layout=\"fill\"</code> prop gets <code>position: absolute;</code> from the framework, so we can limit the size by putting in a container with position: relative;.</p>\n<p>Let’s add a new class to our <em>TeaListItem.module.css</em>:</p>\n<pre><code>.ImageContainer {\n  position: relative;\n  width: 100%;\n  height: 10em;\n  overflow: hidden;\n}</code></pre>\n\n<p>And then let’s add <code>className={styles.ImageContainer}</code> on the <code>&lt;div&gt;</code> that contains our <code>&lt;Image&gt;</code>. I use relatively “simple” names such as <code>ImageContainer</code> because we’re inside a CSS module, so we don’t have to worry about conflicting with the outside style.</p>\n<p>Finally, we want to <strong>add a bit of padding</strong> on the sides of the text, so let’s add one last class and rely on the spacing variables we set up as design tokens:</p>\n<pre><code>.Title {\n  padding-left: var(--space-sm);\n  padding-right: var(--space-sm);\n}</code></pre>\n\n<p>We can add this class to the <code>&lt;div&gt;</code> that contains our name and description. Now, our cards don’t look so bad:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/febdc946-791e-4e0f-881b-4b5240f03e46/3-global-vs-local-styling-nextjs.png\" /></p>\n<h3>Combining Global And Local Style</h3>\n<p>Next, we want to have our cards show in a grid layout. In this case, we’re just at the border between local and global styles. We could certainly code our layout directly on the <code>TeaList</code> component. But, I could also imagine that having <strong>a utility class that turns a list into a grid layout</strong> could be useful in several other places.</p>\n<p>Let’s take the global approach here and add a new utility class in our <em>styles/utilities.css</em>:</p>\n<pre><code>.grid {\n  list-style: none;\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(var(--min-item-width, 30ch), 1fr));\n  gap: var(--space-md);\n}</code></pre>\n\n<p>Now, we can add the <code>.grid</code> class on any list, and we’ll get an automatically responsive grid layout. We can also change the <code>--min-item-width</code> custom property (by default <code>30ch</code>) to change the minimum width of each element.</p>\n<p><strong>Note</strong>: <em>Remember to think of custom properties like props! If this syntax looks unfamiliar, you can check out “<a href=\"https://css-tricks.com/intrinsically-responsive-css-grid-with-minmax-and-min/\">Intrinsically Responsive CSS Grid With <code>minmax()</code> And <code>min()</code></a>” by Chris Coyier.</em></p>\n<p>As we’ve written this style globally, it doesn’t require any fanciness to add <code>className=\"grid\"</code> onto our <code>TeaList</code> component. But, let’s say we want to couple this global style with some additional local store. For example, we want to bring a bit more of the “tea aesthetic” in and to make every other card have a green background. All we’d need to do is make a new <em>components/TeaList/TeaList.module.css</em> file:</p>\n<pre><code>.TeaList &gt; :nth-child(even) {\n  --color: var(--green);\n}</code></pre>\n\n<p>Remember how we made a <code>--color custom</code> property on our <code>TeaListItem</code> component? Well, now we can set it under specific circumstances. Note that we can still use child selectors within CSS modules, and it doesn’t matter that we’re selecting an element that is styled inside a different module. So, we can also use our local component styles to affect child components. This is a feature rather than a bug, as it allows us to <strong>take advantage of the CSS cascade</strong>! If we tried to replicate this effect some other way, we’d likely end up with some kind of JavaScript soup rather than three lines of CSS.</p>\n<p>Then, how can we keep the global <code>.grid</code> class on our <code>TeaList</code> component while also adding the local <code>.TeaList</code> class? This is where the syntax can get a bit funky because we have to access our <code>.TeaList</code> class out of the CSS module by doing something like <code>style.TeaList</code>.</p>\n<p>One option would be to use string interpolation to get something like:</p>\n<pre><code>&lt;ul role=\"list\" className={`${style.TeaList} grid`}&gt;</code></pre>\n\n<p>In this small case, this might be good enough. If we’re mixing-and-matching more classes, I find that this syntax makes my brain explode a bit, so I will sometimes opt to use the classnames library. In this case, we end up with a more sensible-looking list:</p>\n<pre><code>&lt;ul role=\"list\" className={classnames(style.TeaList, \"grid\")}&gt;</code></pre>\n\n<p>Now, we’ve finished up our Shop page, and we’ve made our <code>TeaList</code> component take advantage of <em>both</em> global and local styles.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/326feeee-76aa-4389-8be3-56e23587e5ba/4-global-vs-local-styling-nextjs.png\" /></p>\nA Balancing Act\n<p>We’ve now built our tea shop using only plain CSS to handle the styling. You may have noticed that we did not have to spend ages dealing with custom Webpack setups, installing external libraries, and so on. That’s because of the patterns that we’ve used work with Next.js out of the box. Furthermore, they <strong>encourage best CSS practices</strong> and fit naturally into the Next.js framework architecture.</p>\n<p>Our CSS organization consisted of four key pieces:</p>\n<ol>\n<li>Design tokens,</li>\n<li>Global styles,</li>\n<li>Utility classes,</li>\n<li>Component styles.</li>\n</ol>\n<p>As we continue building our site, our list of design tokens and utility classes will grow. Any styling that doesn’t make sense to add as a utility class, we can add into component styles using CSS modules. As a result, we can find a continuous balance between local and global styling concerns. We can also <strong>generate performant, intuitive CSS code</strong> that grows naturally alongside our Next.js site.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"7f97c2613e9db8942d2cf6c7292a39b4803db8fb4dd5ab0deb1cb4bab3e33fe0","category":"Tech"}