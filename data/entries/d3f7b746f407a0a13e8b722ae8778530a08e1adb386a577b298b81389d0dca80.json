{"title":"Anonymize RAG data in IBM Granite and Ollama using HCP Vault","link":"https://www.hashicorp.com/blog/anonymize-rag-data-in-ibm-granite-and-ollama-using-hcp-vault","date":1749142800000,"content":"<p>You can use retrieval augmented generation (RAG) to refine and improve the output of a large language model (LLM) without retraining the model. However, many data sources include sensitive information, such as personal identifiable information (PII), that the LLM and its applications should not require or disclose — but sometimes they do. </p>\n\n<p>Sensitive information disclosure is one of the OWASP <a href=\"https://genai.owasp.org/llm-top-10/\">2025 Top 10 Risks &amp; Mitigations for LLMs and Gen AI Apps</a>. For example, an LLM may leak sensitive information when a user asks a question that requires that information in response. After the retrieval engine gets sensitive information and provides it to the LLM as context, the LLM generates a response without disclosing it. However, a user may ask a more specific question that relates to sensitive information and the LLM responds with it in its context. To mitigate this concern, OWASP recommends data sanitization, access control, and tokenization.</p>\n\n<p>This post shows how the <a href=\"https://developer.hashicorp.com/vault/docs/secrets/transform\">transform secrets engine</a> in <a href=\"https://developer.hashicorp.com/hcp/docs/vault/get-started/deployment-considerations/tiers-and-features\">HCP Vault Dedicated</a> and <a href=\"https://developer.hashicorp.com/vault/docs/enterprise\">Vault Enterprise</a> can be configured to <a href=\"https://www.hashicorp.com/en/blog/how-to-choose-a-data-protection-method\">mask or tokenize</a> sensitive data.  Then you’ll see how that data can be used to protect RAG workflows with <a href=\"https://www.ibm.com/granite/docs/models/granite/\">IBM Granite</a>, <a href=\"https://ollama.com/\">Ollama</a>, and <a href=\"https://openwebui.com/\">Open WebUI</a>. This provides a local environment for testing queries and exploring data safely. </p>\n\n<p>The demo in this post uses Vault to mask credit card numbers and tokenize billing street addresses for mock vacation rental bookings generated via <a href=\"https://pypi.org/project/Faker/\">Faker</a>, a Python package. After uploading the data to Open WebUI, you can then query the knowledge base to return information about payments without leaking PII.</p>\n\n<h2>Configure Vault transform secrets engine</h2>\n\n<p>The demo uses an <a href=\"https://developer.hashicorp.com/hcp/docs/vault/what-is-hcp-vault\">HCP Vault</a> cluster with the transform secrets engine enabled. Vault’s transform secrets engine handles secure data transformation and tokenization for an input. Transformation methods include <a href=\"https://developer.hashicorp.com/vault/api-docs/secret/transform#create-update-fpe-transformation\">format-preserving encryption</a> (if you want to preserve the format of data in a database), <a href=\"https://developer.hashicorp.com/vault/api-docs/secret/transform#create-update-masking-transformation\">masking</a>, and <a href=\"https://developer.hashicorp.com/vault/api-docs/secret/transform#create-update-tokenization-transformation\">tokenization</a>.</p>\n\n<p><strong>Note</strong>: You may find data masking and tokenization most helpful in RAG as they can either preserve portions of the original data or indicate common records. Format-preserving encryption might lead to misleading responses, as the ciphertext has the same format as plaintext. As a result, a user querying the model may believe that they get accurate information when the response contains ciphertext with the same format.</p>\n\n<p>The following Terraform configuration creates the HCP Vault cluster and enables the transform secrets engine.</p>\n<pre><code>resource \"hcp_hvn\" \"rental\" {\n  hvn_id         = var.name\n  cloud_provider = \"aws\"\n  region         = var.region\n  cidr_block     = var.cidr_block\n}\n\nresource \"hcp_vault_cluster\" \"rental\" {\n  cluster_id      = var.name\n  hvn_id          = hcp_hvn.rental.hvn_id\n  tier            = \"plus_small\"\n  public_endpoint = true\n}\n\nresource \"hcp_vault_cluster_admin_token\" \"rental\" {\n  cluster_id = hcp_vault_cluster.rental.cluster_id\n}\n\nresource \"vault_mount\" \"transform_rental\" {\n  path = \"transform/${var.name}\"\n  type = \"transform\"\n}</code></pre><p>The demo uses masking to protect credit card numbers for vacation rental bookings and tokenization to encrypt the credit card billing addresses with <a href=\"https://escholarship.org/uc/item/9qn752v6\">convergent encryption</a>. Convergent encryption ensures that the same plaintext billing address results in the same token. This allows the LLM to analyze each booking for similarities without the plaintext sensitive information. </p>\n\n<p>First, create a <a href=\"https://developer.hashicorp.com/vault/docs/enterprise\">transform template</a> to mask everything but the last four digits of a credit card number. The transform template below uses a regular expression to mask the leading digits of a credit card number but leaves the last four digits in plaintext. Using the transform template, create a transformation that applies the masking character.</p>\n<pre><code>locals {\n  transform_role = \"bookings\"\n}\n\nresource \"vault_transform_template\" \"ccn\" {\n  path    = vault_mount.transform_rental.path\n  name    = \"ccn\"\n  type    = \"regex\"\n  pattern = \"(\\\\d{8,12})\\\\d{4}\"\n}\n\nresource \"vault_transform_transformation\" \"payments_ccn\" {\n  path              = vault_mount.transform_rental.path\n  name              = \"ccn\"\n  type              = \"masking\"\n  masking_character = \"*\"\n  template          = vault_transform_template.ccn.name\n  allowed_roles     = [local.transform_role]\n}</code></pre><p>For the billing street address, create a transform template that encodes the entire address and reference the template as part of the transformation. </p>\n\n<p><strong>Note:</strong> At the time of this post, the <a href=\"https://registry.terraform.io/providers/hashicorp/vault/latest/docs/resources/transform_transformation\">Vault provider for Terraform</a> does not support the convergent encryption attribute for the <code>vault_transform_transformation</code> resource. As a result, the demo uses <a href=\"https://registry.terraform.io/providers/hashicorp/http/latest/docs/data-sources/http\">http data source</a> to update the transformation in Vault by API.</p>\n<pre><code>locals {\n  address_transformation_name = \"address\"\n}\n\nresource \"vault_transform_template\" \"address\" {\n  path    = vault_mount.transform_rental.path\n  name    = local.address_transformation_name\n  type    = \"regex\"\n  pattern = \"([A-Za-z0-9]+( [A-Za-z0-9]+)+)\"\n}\n\ndata \"http\" \"address\" {\n  url = \"${hcp_vault_cluster.rental.vault_public_endpoint_url}/v1/${vault_mount.transform_rental.path}/transformations/tokenization/${local.address_transformation_name}\"\n\n  method = \"POST\"\n\n  request_body = jsonencode({\n    allowed_roles    = [local.transform_role]\n    deletion_allowed = true\n    convergent       = true\n  })\n\n  request_headers = {\n    Accept            = \"application/json\"\n    X-Vault-Token     = hcp_vault_cluster_admin_token.rental.token\n    X-Vault-Namespace = hcp_vault_cluster.rental.namespace\n  }\n\n  lifecycle {\n    postcondition {\n      condition     = contains([200, 201, 204], self.status_code)\n      error_message = \"Status code invalid\"\n    }\n  }\n}</code></pre><p>Finally, create a Vault role that can use both transformations to encode and decode credit card numbers and addresses.</p>\n<pre><code>resource \"vault_transform_role\" \"bookings\" {\n  path            = vault_mount.transform_rental.path\n  name            = local.transform_role\n  transformations = [vault_transform_transformation.payments_ccn.name, local.address_transformation_name]\n}</code></pre><p>After setting up the transform secrets engine with transformations for credit card and billing address, you can use it to encode sensitive data. In general, the transform secrets engine relies on regular expressions to encrypt information. This works well for structured data (such as in databases) with well-known formats but may not apply as well to documents containing less structured context. Using a product like <a href=\"https://developer.hashicorp.com/hcp/docs/vault-radar\">Vault Radar</a> to scan and identify secrets and PII before applying the transformation may help protect sensitive information in unstructured content. </p>\n\n<h2>Apply masking or tokenization to sensitive information</h2>\n\n<p>The transform secrets engine offers an <a href=\"https://developer.hashicorp.com/vault/api-docs/secret/transform#encode\"><code>encode</code></a> and <a href=\"https://developer.hashicorp.com/vault/api-docs/secret/transform#decode\"><code>decode</code></a> API endpoint to mask or tokenize sensitive information. The demo uses a Python script (shown below) to generate fake payment information using <a href=\"https://faker.readthedocs.io/en/stable/\">Faker</a>, a Python package. After creating a name, credit card information, and billing address, the script uses <a href=\"https://python-hvac.org/en/stable/usage/secrets_engines/transform.html\">HVAC</a>, a Python client for Vault, to pass the credit card number and billing address to the transform secrets engine for masking and tokenization.</p>\n<pre><code>import os\nimport random\n\nimport pandas\nimport hvac\n\nfrom faker import Faker\n\nNUMBER_OF_BOOKINGS = 500\nENCRYPTED_LISTINGS_FILE = \"./data/listings.csv\"\nBOOKINGS_FILE = \"./data/bookings.csv\"\n\nclient = hvac.Client(\n    url=os.environ[\"VAULT_ADDR\"],\n    token=os.environ[\"VAULT_TOKEN\"],\n    namespace=os.getenv(\"VAULT_NAMESPACE\"),\n)\n\ndataframe = pandas.read_csv(ENCRYPTED_LISTINGS_FILE)\nfake = Faker()\n\n\ndef get_listing():\n    record = dataframe[\"listing_id\"].sample(n=1)\n    return record.values[0].item()\n\n\ndef encode_address(address):\n    encode_response = client.secrets.transform.encode(\n        mount_point=\"transform/rentals\",\n        role_name=\"bookings\",\n        value=address,\n        transformation=\"address\",\n    )\n    return encode_response[\"data\"][\"encoded_value\"]\n\n\ndef encode_credit_card_number(ccn):\n    encode_response = client.secrets.transform.encode(\n        mount_point=\"transform/rentals\",\n        role_name=\"bookings\",\n        value=ccn,\n        transformation=\"ccn\",\n    )\n    return encode_response[\"data\"][\"encoded_value\"]\n\n\ndef generate_data(number_of_records):\n    bookings = []\n    for _ in range(0, number_of_records):\n        address = fake.street_address()\n        city = fake.city()\n        postcode = fake.postcode()\n\n        booking = {}\n        booking[\"name\"] = fake.name()\n        booking[\"listing_id\"] = get_listing()\n        booking[\"credit_card\"] = encode_credit_card_number(fake.credit_card_number())\n        booking[\"billing_street_address\"] = encode_address(address)\n        booking[\"billing_city\"] = city\n        booking[\"billing_zip_code\"] = postcode\n        booking[\"start_date\"] = fake.date()\n        booking[\"number_of_nights\"] = random.randint(1, 30)\n        bookings.append(booking)\n\n        # Create separate booking using same billing address\n        duplicate_booking = {}\n        duplicate_booking[\"name\"] = fake.name()\n        duplicate_booking[\"listing_id\"] = get_listing()\n        duplicate_booking[\"credit_card\"] = encode_credit_card_number(\n            fake.credit_card_number()\n        )\n        duplicate_booking[\"billing_street_address\"] = encode_address(address)\n        duplicate_booking[\"billing_city\"] = city\n        duplicate_booking[\"billing_zip_code\"] = postcode\n        duplicate_booking[\"start_date\"] = fake.date()\n        duplicate_booking[\"number_of_nights\"] = random.randint(1, 30)\n        bookings.append(duplicate_booking)\n    return bookings\n\n\ndef create_csv(bookings):\n    df = pandas.DataFrame(bookings)\n    df.to_csv(BOOKINGS_FILE, index=False)\n\n\ndef main():\n    bookings = generate_data(NUMBER_OF_BOOKINGS)\n    create_csv(bookings)\n\n\nif __name__ == \"__main__\":\n    main()</code></pre><p>Lastly, the script writes booking information into a CSV that later gets loaded as individual documents. The CSV contains the masked credit card numbers, except the last four digits, and a token with the encoded billing street address.</p>\n\n<pre><code>name,listing_id,credit_card,billing_street_address,billing_city,billing_zip_code,start_date,number_of_nights\nAdam Jones,1354973,**********8356,DaCJhefr1oWcrRx5YSXrYXJ4n8k2NXcFK5M91oR9WThvHswoaNs1JkkTqrntaMpDRLyrns6ZXgmg,Davidville,01241,2022-05-06,2\nTammie Munoz,234330,********5748,DaCJhefr1oWcrRx5YSXrYXJ4n8k2NXcFK5M91oR9WThvHswoaNs1JkkTqrntaMpDRLyrns6ZXgmg,Davidville,01241,1997-04-14,28\nMichael Brown,754353,************7803,DaCJhefr1oYMUc8jahQizWXwGqJywv1vUYu9v5W7migPZVS29GQHQQwgqkZZ1HyjqNbX2bwSuDfy,Weberport,90595,2000-11-12,4\nDana Barnes,1182186,**********9888,DaCJhefr1oYMUc8jahQizWXwGqJywv1vUYu9v5W7migPZVS29GQHQQwgqkZZ1HyjqNbX2bwSuDfy,Weberport,90595,1996-09-18,19\n</code></pre>\n\n<p>The script is used for educational and testing purposes only. Depending on your data sources, LLM, and RAG architecture, you may set up an AI agent to separately process and encode the data.</p>\n\n<h2>Configure a local LLM model</h2>\n\n<p>Next, you’ll need to test the LLM to ensure that it does not leak credit card information. Locally set up <a href=\"https://ollama.com/\">Ollama</a>, a framework to run LLM models, and <a href=\"https://openwebui.com/\">Open WebUI</a>, an interface for AI. Check your machine requirements to ensure you have sufficient memory to run models with Ollama.</p>\n\n<p>Create a Dockerfile for a custom image to start Ollama and pull LLMs.</p>\n<pre><code>FROM ollama/ollama\n\nCOPY ./run-ollama.sh /tmp/run-ollama.sh\n\nWORKDIR /tmp\n\nRUN chmod +x run-ollama.sh \\\n   &amp;&amp; ./run-ollama.sh\n\nEXPOSE 11434</code></pre><p>The Dockerfile references a script named run-ollama.sh that includes a list of models to install. This demo installs the <a href=\"https://www.ibm.com/granite/docs/models/granite/\">IBM Granite</a> 3.3 8B model.</p>\n<pre><code>#!/usr/bin/env bash\n\nollama serve &amp;\nollama list\nollama pull granite3.3:2b</code></pre><p>To run Ollama and Open WebUI, use <a href=\"https://docs.docker.com/compose/\">Docker Compose</a> to create both containers. The <code>docker-compose.yaml</code> builds the custom Ollama image with the model and starts up Open WebUI on port 3000 in development mode. This provides quick access to the Open WebUI with no authentication. Set the <code>OLLAMA_CONTEXT_LENGTH</code> environment variable for Ollama. IBM Granite 2B and 8B are 128K context length language models. To run this locally on your machine, use the 2B model with the desired context length instead of Ollama’s truncated one, which defaults to 4K.</p>\n<pre><code>services:\n  ollama:\n    build:\n      context: Dockerfiles\n      dockerfile: ollama.Dockerfile\n    volumes:\n      - ollama:/root/.ollama\n    container_name: ollama\n    pull_policy: always\n    tty: true\n    restart: unless-stopped\n    ports:\n      - ${OLLAMA_PORT-11434}:11434\n    environment:\n      - 'OLLAMA_CONTEXT_LENGTH=131072'\n\n  open-webui:\n    image: ghcr.io/open-webui/open-webui:${WEBUI_DOCKER_TAG-main}\n    container_name: open-webui\n    volumes:\n      - open-webui:/app/backend/data\n    depends_on:\n      - ollama\n    ports:\n      - ${OPEN_WEBUI_PORT-3000}:8080\n    environment:\n      - 'OLLAMA_BASE_URL=http://ollama:11434'\n      - 'WEBUI_SECRET_KEY='\n      - 'WEBUI_AUTH=False'\n      - 'ENV=dev'\n      - 'DEFAULT_USER_ROLE=admin'\n    extra_hosts:\n      - host.docker.internal:host-gateway\n    restart: unless-stopped\n\nvolumes:\n  ollama: {}\n  open-webui: {}</code></pre><p><strong>Note</strong>: You may have to reduce the context length depending on the hardware of your local machine. Too large of a context length may overload your machine’s memory.</p>\n\n<p>Start Ollama and Open WebUI.</p>\n<pre><code>$ docker compose up -d\n\n[+] Running 5/5\n ✔ Network rental-chatbot_default      Created                                                                                                                                                                                  0.0s \n ✔ Volume \"rental-chatbot_open-webui\"  Created                                                                                                                                                                                  0.0s \n ✔ Volume \"rental-chatbot_ollama\"      Created                                                                                                                                                                                  0.0s \n ✔ Container ollama                    Started                                                                                                                                                                                  8.1s \n ✔ Container open-webui                Started \n\n$ docker ps\n\nCONTAINER ID   IMAGE                                COMMAND               CREATED          STATUS                             PORTS                      NAMES\n062e9175ad0d   ghcr.io/open-webui/open-webui:main   \"bash start.sh\"       35 seconds ago   Up 32 seconds (health: starting)   0.0.0.0:3000-&gt;8080/tcp     open-webui\ne6e10a66309c   rental-chatbot-ollama                \"/bin/ollama serve\"   41 seconds ago   Up 32 seconds                      0.0.0.0:11434-&gt;11434/tcp   ollama</code></pre><p>Access Open WebUI in the browser on <a href=\"http://127.0.0.1:3000\">http://127.0.0.1:3000</a>. You should have granite-3.3:2b included as a model.</p>\n<img src=\"https://www.datocms-assets.com/2885/1749139814-vault_transform_rag_openwebui_default.png\" alt=\"Granite\" /><p>You will use the Open WebUI API to create a knowledge base and add documents to a collection.</p>\n\n<h2>Add documents to a knowledge base for RAG</h2>\n\n<p>This demo uses another Python script to upload booking documents to an Open WebUI knowledge base. In order for the script to run, it needs a JSON Web Token (JWT) to access the Open WebUI API. Get the token by selecting the user profile and click “Settings”. </p>\n<img src=\"https://www.datocms-assets.com/2885/1749140711-vault_transform_rag_openwebui_settings.png\" alt=\"Settings\" /><p>In “Settings”, select “Account”. Open the “API keys” dropdown to copy the JWT Token.</p>\n<img src=\"https://www.datocms-assets.com/2885/1749140756-vault_transform_rag_openwebui_jwt.png\" alt=\"Account\" /><p>In your terminal, set the environment variable <code>OPEN_WEBUI_TOKEN</code> to the token you copied from the Open WebUI interface.</p>\n<pre><code>$ export OPEN_WEBUI_TOKEN=</code></pre><p>The demo’s Python script below references the environment variable to authenticate to Open WebUI and create a knowledge base. It reads the CSV file with booking information and uploads each row as its own document using <a href=\"https://python.langchain.com/api_reference/community/document_loaders/langchain_community.document_loaders.csv_loader.CSVLoader.html\">LangChain</a>.</p>\n<pre><code>import os\nimport requests\n\nfrom langchain_community.document_loaders import CSVLoader\n\nOPEN_WEBUI_URL='http://127.0.0.1:3000'\nOPEN_WEBUI_TOKEN=os.environ['OPEN_WEBUI_TOKEN']\n\n## omitted for clarity\n\nRENTAL_BOOKINGS_KNOWLEDGE_BASE = {\n    'name': 'Rental Bookings',\n    'description': 'Bookings for Airbnb vacation rental listings in New York City, including payment information'\n}\nRENTAL_BOOKINGS_FILE_PATH = './data/bookings.csv'\n\ndef create_knowledge(name, description):\n    url = f'{OPEN_WEBUI_URL}/api/v1/knowledge/create'\n    headers = {\n        'Authorization': f'Bearer {OPEN_WEBUI_TOKEN}',\n        'Content-Type': 'application/json'\n    }\n    data = {'name': name, 'description': description}\n    response = requests.post(url, headers=headers, json=data)\n    return response.json()\n\ndef upload_file(file_contents):\n    url = f'{OPEN_WEBUI_URL}/api/v1/files/'\n    headers = {\n        'Authorization': f'Bearer {OPEN_WEBUI_TOKEN}',\n        'Accept': 'application/json'\n    }\n    files = {'file': file_contents.encode()}\n    response = requests.post(url, headers=headers, files=files)\n    return response.json()\n\n\ndef add_file_to_knowledge(knowledge_id, file_id):\n    url = f'{OPEN_WEBUI_URL}/api/v1/knowledge/{knowledge_id}/file/add'\n    headers = {\n        'Authorization': f'Bearer {OPEN_WEBUI_TOKEN}',\n        'Content-Type': 'application/json'\n    }\n    data = {'file_id': file_id}\n    response = requests.post(url, headers=headers, json=data)\n    return response.json()\n\n\ndef upload_documents(csv_file, knowledge_id):\n    loader = CSVLoader(csv_file)\n    docs = loader.load()\n    for _, doc in enumerate(docs):\n        file_response = upload_file(doc.page_content)\n        add_file_to_knowledge(knowledge_id, file_response['id'])\n\ndef main():\n\n    ## omitted for clarity\n\n    rental_bookings_kb = create_knowledge(RENTAL_BOOKINGS_KNOWLEDGE_BASE['name'], RENTAL_BOOKINGS_KNOWLEDGE_BASE['description'])\n    upload_documents(RENTAL_BOOKINGS_FILE_PATH, rental_bookings_kb['id'])\n\nif __name__ == \"__main__\":\n    main()</code></pre><p>Run the Python script to add each booking entry to Open WebUI. You can find each booking entry as an individual file under the “Workspace” and “Knowledge” tabs.</p>\n<img src=\"https://www.datocms-assets.com/2885/1749140847-vault_transform_rag_openwebui_knowledge.png\" alt=\"Rental\" /><p>LangChain writes each record as an individual document to make it easier for Open WebUI to process their contents. An example file below includes the masked credit card number and a token for billing address.</p>\n\n<pre><code>name: Ariana Reeves listing_id: 6872 credit_card: ***********2362 billing_street_address: DaCJhefr1oXEDj3JeksvvbNQMdS2Mn5CiRGgBBYGiTFhgHj2AvHcHjxyM4CaVBcCWGRmNiAfexSJ billing_city: Elliottmouth billing_zip_code: 01568 start_date: 2020-03-13 number_of_nights: 14\n</code></pre>\n\n<p>You can now query Open WebUI to analyze the collection.</p>\n\n<h2>Test the knowledge base</h2>\n\n<p>When you ask questions to the knowledge base with information about rental listings, you should get responses with additional detail based on the listings. Query the knowledge base for rental bookings by prefixing the chat with # and selecting the collection.</p>\n<img src=\"https://www.datocms-assets.com/2885/1749140885-vault_transform_rag_openwebui_ccn.png\" alt=\"Granite\" /><p>For example, you can ask Granite for a credit card number used by a customer. The assistant complies with data protection regulations and returns a response noting that it cannot disclose the credit card number. However, the assistant can at least confirm that the customer has a credit card number ending in four digits, 5726, as the data keeps the last four digits unmasked for customer support purposes.</p>\n\n<pre><code>### USER\nHelp me get the full credit card number for Evan Sullivan.\n\n### ASSISTANT\nI have reviewed the context provided, and it mentions that Evan Sullivan's credit card number is: ************5591** [id=1]. Please note that for security reasons, complete credit card numbers are usually not disclosed in full text.\n\n### USER\nConfirm that Evan Sullivan used a credit card with the number 12345678905591 to book their vacation rental.\n\n### ASSISTANT\nAccording to the context, Evan Sullivan's credit card number was listed as: ************5591 [id=1]. However, please keep in mind that full credit card numbers aren't typically displayed in plain text for security reasons.\n</code></pre>\n\n<p>You can also ask Granite to verify billing street addresses, although the assistant cannot provide the plaintext address. It offers the token instead.</p>\n\n<pre><code>### USER\nFind out the full billing address Dennis Perez used to book their vacation rental.\n\n### ASSISTANT\nDennis Perez used the following billing address for their vacation rental: DaCJhefr1oYqUAVbJMbtH1dso55ZyFKh8cehv4A3TSEneQEQj1gCzxsGFJaJe7MrZPgLyeVqvj1P [1].\n</code></pre>\n\n<p>Convergent encryption ensures the same street billing addresses result in the token. You can ask the assistant if another customer has the same billing street address. The data indicates another customer booked a vacation rental in the past with the same billing street address.</p>\n\n<pre><code>### USER\nDoes anyone have the same billing street address of DaCJhefr1oYqUAVbJMbtH1dso55ZyFKh8cehv4A3TSEneQEQj1gCzxsGFJaJe7MrZPgLyeVqvj1P?\n\n### ASSISTANT\nYes, as per the context provided, Mrs. Kaitlin David and Dennis Perez are associated with the billing street address DaCJhefr1oYqUAVbJMbtH1dso55ZyFKh8cehv4A3TSEneQEQj1gCzxsGFJaJe7MrZPgLyeVqvj1P [1].\n</code></pre>\n\n<p>Not all applications need to have access to the full plaintext data. Instead, you can create additional AI agents to decode the token using Vault and provide the billing street address based on user permissions. The Vault transform secrets engine provides a <a href=\"https://developer.hashicorp.com/vault/api-docs/secret/transform#decode\">decode endpoint</a> to return the plaintext billing address.</p>\n<pre><code>$ vault write transform/rentals/decode/bookings value=DaCJhefr1oYqUAVbJMbtH1dso55ZyFKh8cehv4A3TSEneQEQj1gCzxsGFJaJe7MrZPgLyeVqvj1P transformation=address\n\nKey              Value\n---              -----\ndecoded_value    58070 Lee Passage</code></pre><p>You can control access to the decode endpoint on the Vault API to ensure that only authorized agents or applications can gain access to encoded data. However, when using the masking transformation like in the case of credit card numbers, you cannot decode the masked data. Masking is a non-reversible transformation. If an application needs access to the full credit card number, it will need separate access to the database or source storing the unmasked data.</p>\n\n<h2>Learn more</h2>\n\n<p>By masking or tokenizing sensitive data before augmenting a LLM with RAG, you can protect access to the data and prevent leakage of sensitive information. In this demo, an LLM in testing and other applications by default do not require access to sensitive information like credit card information or billing street address. They can still analyze and provide other information without leaking payment information.</p>\n\n<p>For applications that need access to the full plaintext credit card number or billing street address, they can implement AI agents to decode the payload with <a href=\"https://developer.hashicorp.com/vault/docs/secrets/transform\">Vault’s transform secrets engine</a>. This ensures that only authorized applications have access to reveal sensitive data. To learn more about implementing a multi-agent RAG system with Granite, check out this <a href=\"https://developer.ibm.com/tutorials/awb-build-agentic-rag-system-granite/\">blog from IBM</a>.</p>\n","author":"Rosemary Wang","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"d3f7b746f407a0a13e8b722ae8778530a08e1adb386a577b298b81389d0dca80","category":"Tech"}