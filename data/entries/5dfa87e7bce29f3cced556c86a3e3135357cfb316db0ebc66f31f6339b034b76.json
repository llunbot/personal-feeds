{"title":"GraphQL On The Front-End (React And Apollo)","link":"https://smashingmagazine.com/2021/11/graphql-frontend-react-apollo/","date":1636025400000,"content":"<p>One of the main benefits of GraphQL is the client’s ability to request what they need from the server and receive that data exactly and predictably. Without much effort, one can easily pull nested data by just adding more properties to our queries instead of adding multiple endpoints. This prevents issues like over-fetching that can impact performance.</p>\n<p>Usually, to handle GraphQL on the client-side, we make use of the Apollo Client. It allows developers to define, handle, and make queries/mutations available within our application. It can also act as a state management tool with your client-side application.</p>\n<p>In this article, we’re going to learn how to handle real-time updates on the client-side using GraphQL. We’ll be learning how to do this with GraphQL Features like Cache Update, Subscriptions, and Optimistic UI. We’ll also be touching on how to use Apollo as a state-management tool, possibly replacing redux. Plus, we’ll look at how to create usuable GraphQL queries with Fragments, and how to use Apollo directives to write more complex queries.</p>\nInstallation\n<p>Before we begin, let’s just go through installation and setting up our project. Let’s get right into the code. To create a React app, make sure you have Node.js installed on your computer. If you haven’t built a React app before, you can check to see if you have Node.js installed by typing the following into your terminal:</p>\n<pre><code>node -v</code></pre>\n\n<p>If not, just go to the Node.js website to <a href=\"https://nodejs.org/en/download/\">download the latest version</a>.</p>\n<p>Once that’s done, we can get started with our React app by running this command:</p>\n<pre><code>npx create-react-app react-graphql</code></pre>                \n\n<p>Next, let’s navigate into our project folder on the terminal:</p>\n<pre><code>cd react-graphql</code></pre>\n\n<p>Or better still, you could just go on and clone the repo. The repo contains both the client-side and server, so we have some other dependencies that’s needed.</p>\n<p>Once that’s done, we’ll install Apollo using this line:</p>\n<pre><code>npm i @apollo/client</code></pre>\n\n<p>We’ll install those dependencies by running:</p>\n<pre><code>npm install</code></pre>\n\n<p>Just before we start, this is the <a href=\"https://github.com/Atanda1/react-graphql\">repo</a> containing the code demonstrating everything under Real-time update on GraphQL, using Apollo as a state management tool, Fragments, and Apollo directives. Also, here’s the <a href=\"https://github.com/Atanda1/subscrpition\">repo</a> containing the code demonstrating subscription on the the client-side.  </p>\nReal-time Update On GraphQL\n<p>The ability to create a real-time update on the client-side helps improve the user experience of the site, making everything seem smoother. Just imagine a situation where a user adds a new item by filling a form, and that item updates instantly by been added to the list of items on the same page. Although, this real-time update could sync with a server directly through subscriptions, or it might be manipulated on the frontend through things like Optimistic UI, or using the <code>update</code> function on the <code>useMutation</code>. So let’s get to the technical implementation. Here’s the <a href=\"https://github.com/Atanda1/react-graphql\">repo</a> containing the code demonstrating everything under Real-time update On Graphql, using Apollo as a state management tool, Fragments, and Apollo directives.</p>\n<h3>Updating the cache directly using <code>update</code> function on the <code>useMutation</code></h3>\n<p><code>useMutations</code> are imported directly from the <code>@apollo/client</code> library, and it helps us make mutations to the data on our server.</p>\n<p>Usually, we can create mutations with Apollo using <code>useMutations</code>, but beyond that, what we’ll be doing is using the <code>update</code> function to update our apollo-client cache directly through <code>useMutation</code>.</p>\n<p>In this sample below, we send queries to the server to get a list of pets using <code>useQuery</code> and make a mutation by having a form to add more pets to our server using <code>useMutation</code>. The problem we’ll have is that when a new pet is added to the server, it doesn’t get added to the list of pets(on the browser) immediately, unless the page is refreshed. This makes the user experience of this section of the app feel broken, especially since the list of pets and the form are on the same page.</p>\n<pre><code>import React, { useState } from \"react\";\nimport gql from \"graphql-tag\";\nimport { useQuery, useMutation } from \"@apollo/client\";\nimport Loader from \"../components/Loader\";\nimport PetSection from \"../components/PetSection\";\n\n//ALL_PETS uses gql from @apollo/client to allow us send nested queries \nconst ALL_PETS = gql`\n  query AllPets {\n    pets {\n      id\n      name\n      type\n      img\n    }\n  }\n`;\n\n// NEW_PET uses gql from @apollo/client to create mutations\nconst NEW_PET = gql`\n  mutation CreateAPet($newPet: NewPetInput!) {\n    addedPet(input: $newPet) {\n      id\n      name\n      type\n      img\n    }\n  }\n`;\nfunction Pets() {\n  const initialCount = 0;\n  const [count, setCount] = useState(initialCount);\n  const pets = useQuery(ALL_PETS);\n  const [createPet, newPet] = useMutation(NEW_PET);\n  const [name, setName] = useState(\"\");\n  const type = `DOG`;\n\n  const onSubmit = (input) =&gt; {\n    createPet({\n      variables: { newPet: input },\n    });\n  };\n\n  // this function triggers the submit action by calling the onSubmit function above it\n  const submit = (e) =&gt; {\n    e.preventDefault();\n    onSubmit({ name, type });\n  };\n\n//If the data is loading we display the &lt;Loader/&gt; component instead\n  if (pets.loading || newPet.loading) {\n    return &lt;Loader /&gt;;\n  }\n\n//loops through the pets data in order to get each pet and display them with props using the &lt;PetSection&gt; component\n  const petsList = pets.data.pets.map((pet) =&gt; (\n    &lt;div className=\"col-xs-12 col-md-4 col\" key={pet.id}&gt;\n      &lt;div className=\"box\"&gt;\n        &lt;PetSection pet={pet} /&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  ));\n\n  return (\n    &lt;div&gt;\n      &lt;form onSubmit={submit}&gt;\n        &lt;input\n          className=\"input\"\n          type=\"text\"\n          placeholder=\"pet name\"\n          value={name}\n          onChange={(e) =&gt; setName(e.target.value)}\n          required\n        /&gt;\n        &lt;button type=\"submit\" name=\"submit\"&gt;\n          add pet\n        &lt;/button&gt;\n      &lt;/form&gt;\n      &lt;div&gt;\n        {petsList}\n      &lt;/div&gt;\n\n    &lt;/div&gt;\n  );\n}\nexport default Pets;\n</code></pre>\n\n<p>Using <code>update</code> function in the <code>useMutation</code> hook allows us to directly update our cache by reading and writing our <code>ALL_PETS</code>. Immediately we hit the submit button, the data is added to the list of pets in the cache by altering <code>ALL_PETS</code>. This lets us update our client-side cache immediately with consistent data.</p>\n<pre><code>import React, { useState } from \"react\";\nimport gql from \"graphql-tag\";\nimport { useQuery, useMutation } from \"@apollo/client\";\nimport Loader from \"../components/Loader\";\nimport PetSection from \"../components/PetSection\";\n\n//ALL_PETS uses gql from @apollo/client to allow us send nested queries \nconst ALL_PETS = gql`\n  query AllPets {\n    pets {\n      id\n      name\n      type\n      img\n    }\n  }\n`;\n\n// NEW_PET uses gql from @apollo/client to create mutations\nconst NEW_PET = gql`\n  mutation CreateAPet($newPet: NewPetInput!) {\n    addedPet(input: $newPet) {\n      id\n      name\n      type\n      img\n    }\n  }\n`;\n\nfunction ThePets() {\n  const initialCount = 0;\n  const [count, setCount] = useState(initialCount);\n  const pets = useQuery(ALL_PETS);\n\n  //We then make use of useMutation and update() to update our ALL_PET\n\n  const [createPet, newPet] = useMutation(NEW_PET, {\n    update(cache, {data: {addedPet}}) {\n      const allPets = cache.readQuery({query: ALL_PETS})\n      cache.writeQuery({\n        query: ALL_PETS,\n        data: {pets: [addedPet, ...allPets.pets]}\n      })\n    }\n  });\n  const [name, setName] = useState(\"\");\n  const type = `DOG`;\n\n  const onSubmit = (input) =&gt; {\n    createPet({\n      variables: { newPet: input },\n    });\n  };\n\n  //Handles the submission of Pets that eventually triggers createPet through onSumit\n\n  const submit = (e) =&gt; {\n    e.preventDefault();\n    onSubmit({ name, type });\n  };\n\n  //If the data is loading we display the &lt;Loader/&gt; component instead\n\n  if (pets.loading || newPet.loading) {\n    return &lt;Loader /&gt;;\n  }\n\n//loops through the pets data in order to get each pet and display them with props using the &lt;PetSection&gt; component\n\n  const petsList = pets.data.pets.map((pet) =&gt; (\n    &lt;div className=\"col-xs-12 col-md-4 col\" key={pet.id}&gt;\n      &lt;div className=\"box\"&gt;\n        &lt;PetSection pet={pet} /&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  ));\n  return (\n    &lt;div&gt;\n      &lt;form onSubmit={submit}&gt;\n        &lt;input\n          className=\"input\"\n          type=\"text\"\n          placeholder=\"pet name\"\n          value={name}\n          onChange={(e) =&gt; setName(e.target.value)}\n          required\n        /&gt;\n        &lt;button type=\"submit\" name=\"submit\"&gt;\n          add pet\n        &lt;/button&gt;\n      &lt;/form&gt;\n      &lt;div&gt;\n        {petsList}\n      &lt;/div&gt;\n\n    &lt;/div&gt;\n  );\n}\nexport default ThePets;\n</code></pre>\n\n\n\n\n\nSubscriptions In GraphQL\n<p>Based on functionalities, subscription in GraphQL is similar to queries. The major difference is that while Queries is done just once, subscriptions are connected to the server, and automatically updates when there’s any change to that particular subscription. Here’s the <a href=\"https://github.com/Atanda1/subscrpition\">repo</a> containing the code demonstrating subscription on the the client-side.</p>\n<p>First, we have to install:</p>\n<pre><code>npm install subscriptions-transport-ws</code></pre>\n\n<p>Then we go to our <code>index.js</code> to import and use it.</p>\n<pre><code> import { WebSocketLink } from \"@apollo/client/link/ws\";\n\n//setting up our web sockets using WebSocketLink\nconst link = new WebSocketLink({\n  uri: `ws://localhost:4000/`,\n  options: {\n    reconnect: true,\n  },\n});\nconst client = new ApolloClient({\n  link,\n  uri: \"http://localhost:4000\",\n  cache: new InMemoryCache(),\n});</code></pre>\n\n<p><strong>Note:</strong> <em><code>uri</code> in the code block directly above is for our endpoint.</em></p>\n<p>Then we go into our component and instead of query like we have above, we’ll use this subscription instead:</p>\n<pre><code>import {  useMutation, useSubscription } from \"@apollo/client\";\n//initiate our subscription on the client-side\nconst ALL_PETS = gql`\n  subscription AllPets {\n    pets {\n      id\n      name\n      type\n      img\n    }\n  }\n`;</code></pre>\n\n<p>And instead of using <code>useQuery</code>, we would access our data using <code>useSubscription</code>.</p>\n<pre><code> const getMessages = useSubscription(ALL_PETS);</code></pre>\n\nOptimistic UI\n<p>Optimistic UI is a little different in the sense that it’s not syncing with the server, like a subscription. When we make a mutation, instead of waiting for another server request, it automatically uses the already inputted data to update the list of pets immediately. Then, once the original data from the server arrives, it will replace the optimistic response. This is also different from “Updating the cache directly using <code>update</code> function on the <code>useMutation</code>”, even though we are still going to update the cache in this process.</p>\n<pre><code>import React, { useState } from \"react\";\nimport gql from \"graphql-tag\";\nimport { useQuery, useMutation } from \"@apollo/client\";\nimport Loader from \"./Loader\";\nimport PetSection from \"./PetSection\";\n\n//We use ALL_PET to send our nested queries to the server\nconst ALL_PETS = gql`\n  query AllPets {\n    pets {\n      id\n      name\n      type\n      img\n    }\n  }\n`;\n\n//We use NEW_PET to handle our mutations\nconst NEW_PET = gql`\n  mutation CreateAPet($newPet: NewPetInput!) {\n    addPet(input: $newPet) {\n      id\n      name\n      type\n      img\n    }\n  }\n`;\n\nfunction OptimisticPets() {\n//We use useQuery to handle the ALL_PETS response and assign it to pets\n  const pets = useQuery(ALL_PETS);\n//We use useMutation to handle mutations and updating ALL_PETS.\n  const [createPet, newPet] = useMutation(NEW_PET\n    , {\n    update(cache, {data: {addPet}}) {\n      const allPets = cache.readQuery({query: ALL_PETS})\n      cache.writeQuery({\n        query: ALL_PETS,\n        data: {pets: [addPet, ...allPets.pets]}\n      })\n    }\n  });;\n  const [name, setName] = useState(\"\");\n  const type = `DOG`;\n //Handles mutation and creates the optimistic response\n  const onSubmit = (input) =&gt; {\n    createPet({\n      variables: { newPet: input },\n      optimisticResponse: {\n        __typename: 'Mutation',\n        addPet: {\n          __typename: 'Pet',\n          id: Math.floor(Math.random() * 1000000) + '',\n          type: \"CAT\",\n          name: input.name,\n          img: 'https://via.placeholder.com/300',\n        }\n      }\n    });\n  };\n\n//Here's our submit triggers the onSubmit function\n  const submit = (e) =&gt; {\n    e.preventDefault();\n    onSubmit({ name, type });\n  };\n//returns the loading the component when the data is still loading\n  if (pets.loading ) {\n    return &lt;Loader /&gt;;\n  }\n//loops through the pets and displays them in the PetSection component \n  const petsList = pets.data.pets.map((pet) =&gt; (\n    &lt;div className=\"col-xs-12 col-md-4 col\" key={pet.id}&gt;\n      &lt;div className=\"box\"&gt;\n        &lt;PetSection pet={pet} /&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  ));\n  return (\n    &lt;div&gt;\n      &lt;form onSubmit={submit}&gt;\n        &lt;input\n          className=\"input\"\n          type=\"text\"\n          placeholder=\"pet name\"\n          value={name}\n          onChange={(e) =&gt; setName(e.target.value)}\n          required\n        /&gt;\n        &lt;button type=\"submit\" name=\"submit\"&gt;\n          add pet\n        &lt;/button&gt;\n      &lt;/form&gt;\n      &lt;div&gt;\n        {petsList}\n      &lt;/div&gt;\n\n    &lt;/div&gt;\n  );\n}\nexport default OptimisticPets;</code></pre>\n\n<p>When the code above calls <em><code>onSubmit</code></em>, the Apollo Client cache stores an <code>addPet</code> object with the field values specified in <code>optimisticResponse</code>. However, it does not overwrite the main cached <code>pets(ALL_PETS)</code> with the same cache identifier. Instead, it stores a separate, optimistic version of the object. This ensures that our cached data <strong>remains accurate</strong> if our <code>optimisticResponse</code> is wrong.</p>\n<p>Apollo Client notifies all active queries that include the modified <code>pets(ALL_PETS)</code>. Those queries automatically update, and their associated components re-render to show our optimistic data. This doesn’t require any network requests, so it displays instantly to the user.</p>\n<p>Eventually, our server responds to the mutation’s actual to get the correct <code>addPet</code> object. Then, Apollo Client cache discards our optimistic version of the <code>addPet</code> object. It also overwrites the cached version with values returned from the server.</p>\n<p>Apollo Client immediately notifies all affected queries <strong>again</strong>. The concerned components re-render, but if the server’s response matches our <code>optimisticResponse</code>, this is entire process is invisible to the user.</p>\nUsing Apollo As A State Management Tool On The Client-side\n<p>When we think of state management tools or libraries concerning react, redux comes to mind. Interestingly, Apollo can also act as a management tool for our local state. Similar to what we’ve been doing with our API.</p>\n<h3>Client-side Schemas And Resolvers</h3>\n<p>To achieve this, we’ll have to write schemas on the client-side to define the type of data we want and how we want it to be structured. To do this, we’ll create <code>Client.js</code> where we’ll define the schemas and resolvers, after which, we’ll make it globally accessible in our project with the Apollo client. </p>\n<p>For this example, I’ll be extending the <code>User</code> type that exists already to add <code>height</code> as an integer. The resolvers is also added to populate the <code>height</code> field in our schema.</p>\n<pre><code>import { ApolloClient } from 'apollo-client'\nimport { InMemoryCache } from 'apollo-cache-inmemory'\nimport { ApolloLink } from 'apollo-link'\nimport { HttpLink } from 'apollo-link-http'\nimport { setContext } from 'apollo-link-context'\nimport gql from 'graphql-tag'\n\n//Extending the User type\nconst typeDefs = gql`\n  extend type User {\n    height: Int\n  }\n`\n\n//Declaring our height inside our resolvers within the client-side\nconst resolvers = {\n  User : {\n    height() {\n      return 35\n    }\n  }\n}\nconst cache = new InMemoryCache()\nconst http = new HttpLink({\n  uri: 'http://localhost:4000/'\n})\nconst link = ApolloLink.from([\n  http\n])\n\nconst client = new ApolloClient({\n  link,\n  cache,\n  typeDefs,\n  resolvers\n})\nexport default client\n\nclient.js</code></pre>\n\n<p>We can then import the <code>client</code> into our <code>index.js</code>:</p>\n<pre><code>import client from \"./client\"\nimport {\n  ApolloProvider,\n} from \"@apollo/client\";\n\n//importing our client.js file into ApolloProvider\nReactDOM.render(\n  &lt;ApolloProvider client={client}&gt;\n    &lt;Routing /&gt;\n  &lt;/ApolloProvider&gt;,\n  document.getElementById(\"root\")\n);\n\nindex.js</code></pre>\n\n<p>Within the component, it will use it just like this. We add <code>@client</code> to indicate that the query is from the client-side, and it should not try to pull it from the server.</p>\n<pre><code>const ALL_PETS = gql`\n  query AllPets {\n    pets {\n      id\n      name\n      type\n      img\n      owner {\n        id\n        height @client\n      }\n    }\n  }\n`;</code></pre>\n\n<p>So we’re pulling data from both the server and the client within the same query, and it’ll be accessible through the <code>useQuery</code> hook.</p>\nFragments-Creating Reusable Queries\n<p>Sometimes we might need to pull the same query in different components. So instead of hardcoding it multiple times, we assign that query to some sort of variable, and use that variable instead.</p>\n<p>In our component we just define the fragment as <code>PetFields</code> on <code>Pet</code>(which is the Type). That way we can just use it in both our <code>query</code> and <code>mutation</code>.</p>\n<pre><code>const DUPLICATE_FIELD = gql`\n  fragment PetFields on Pet {\n      id\n      name\n      type\n      img\n  }\n`\nconst ALL_PETS = gql`\n  query AllPets {\n    pets {\n      ...PetFields\n    }\n  }\n  ${DUPLICATE_FIELD}\n`;\nconst NEW_PET = gql`\n  mutation CreateAPet($newPet: NewPetInput!) {\n    addPet(input: $newPet) {\n        ...PetFields\n    }\n  }\n  ${DUPLICATE_FIELD}\n`;</code></pre>\n\nApollo Directives\n<p>When making queries, we might want to have some conditionals that remove or include a field or fragment if a particular condition is fulfilled or not. The default directives include:</p>\n<p><code>@skip</code>: Indicates that a field/fragment should be skipped if a condition is fulfilled.</p>\n<pre><code>const ALL_PETS = gql`\n  query AllPets($name: Boolean!){\n    pets {\n      id\n      name @skip: (if: $name)\n      type\n      img\n    }\n  }\n`;</code></pre>\n\n<p>Here <code>$name</code> is a boolean that’s added as a variable when we are calling this query. Which is then used with <code>@skip</code> to determine when to display the field <code>name</code>. If true, it skips, and if falses it resolves that field.</p>\n<p><code>@includes</code> also work in a similar manner. If the condition is <code>true</code>, that field is resolved and added, and if it’s <code>false</code>, it’s not resolved.</p>\n<p>We also have <code>@deprecated</code> that can be used in <code>schemas</code> to retire fields, where you can even add reasons.</p>\n<p>We also have <a href=\"https://github.com/Saeris/graphql-directives\">libraries</a> that allow us to add even more directives, they could prove useful when building somewhat complicated stuff with GraphQL.</p>\nTips And Tricks With Using GraphQL Lodash Inside Your Queries\n<p><a href=\"https://github.com/APIs-guru/graphql-lodash\">GraphQL Lodash</a> is a library that can help us a query in a more efficient way, more like an advanced form of the Apollo directives.</p>\n<p>It can help you query your server in a way that returns data more neatly and compactly. For instance, you’re querying the <code>title</code> of <code>films</code> like this:</p>\n<pre><code>films {\n  title\n}</code></pre>\n\n<p>And it returns the <code>title</code> of movies as objects in an array.</p>\n<pre><code>\"films\": [\n    {\n      \"title\" : \"Prremier English\"\n    },\n    {\n      \"title\" : \"There was a country\"\n    },\n    {\n      \"title\" : \"Fast and Furious\"\n    }\n    {\n      \"title\" : \"Beauty and the beast\"\n    }\n]</code></pre>\n\n<p>But, when we use lodash’s <code>map</code> directive, when can sort of loop through the films array to have a single array with all the titles as direct children. We would send a query our server that looks like this:</p>\n<pre><code>films @_(map: \"title\") {\n  title\n}</code></pre>\n\n<p>You’ll get this response which one might consider relatively neater than the previous one.</p>\n<pre><code>\"films\": [  \n  \"Premier English\",\n  \"There was a country\",\n  \"Fast and Furious\",\n  \"Beauty and the beast\"\n]</code></pre>\n\n<p>Another one that proves useful is the is <code>keyby</code> directive. You can send a simple query like this:</p>\n<pre><code>people {\n  name\n  age\n  gender\n}</code></pre>\n\n<p>Response:</p>\n<pre><code>\"people\" : [\n  {\n    \"name\":  \"James Walker\",\n    \"age\": \"19\",\n    \"gender\": \"male\"\n  },\n  {\n    \"name\":  \"Alexa Walker\",\n    \"age\": \"19\",\n    \"gender\": \"female\"\n  }, \n]</code></pre>\n\n<p>Let’s use <code>@_keyup</code> directive in our query:</p>\n<pre><code>people @_(keyBy: \"name\") {\n  name\n  age\n  gender\n}</code></pre>\n\n<p>The response will look just like this:</p>\n<pre><code>\"people\" : [\n  \"James Walker\" : {\n     \"name\":  \"James Walker\",\n     \"age\": \"19\",\n     \"gender\": \"male\"    \n  }\n  \"Alexa Walker\" : {\n     \"name\":  \"Alexa Walker\",\n     \"age\": \"19\",\n     \"gender\": \"female\"\n  }\n]</code></pre>\n\n<p>So in this case each response has a key, that’s the <code>name</code> of the person.</p>\nConclusion\n<p>In this article, we covered advanced topics to achieve real-time update of data using the <code>update()</code> function, subscription, and Optimistic UI. All in a bit to improve user experience. </p>\n<p>We also touched upon using GraphQL to manage state on the client-side, and creating resuable queries with GrahQL fragments. The latter allows us to use the same queries in different components where it’s needed without having to repeat the entire thing every time. </p>\n<p>In the end, we went through Apollo directives and Grahql Lodash to help us query our servers in a faster and better way. You can also check out <a href=\"https://frontendmasters.com/courses/client-graphql-react/\">Scott Moss’s tutorial</a> if you’re looking to cover Graphql and react from scratch.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"5dfa87e7bce29f3cced556c86a3e3135357cfb316db0ebc66f31f6339b034b76","category":"Tech"}