{"title":"The Key To Good Component Design Is Selfishness","link":"https://smashingmagazine.com/2023/01/key-good-component-design-selfishness/","date":1674234000000,"content":"<p>When developing a new feature, what determines whether an existing component will work or not? And when a component doesn‚Äôt work, what exactly does that mean?</p>\n<p>Does the component functionally not do what it‚Äôs expected to do, like a tab system that doesn‚Äôt switch to the correct panel? Or is it too rigid to support the designed content, such as a button with an icon after the content instead of before it? Or perhaps it‚Äôs too pre-defined and structured to support a slight variant, like a modal that always had a header section, now requiring a variant without one?</p>\n<p>Such is the life of a component. All too often, they‚Äôre built for a narrow objective, then hastily extended for minor one-off variations again and again until it no longer <em>works</em>. At that point, a new component is created, the technical debt grows, the onboarding learning curve becomes steeper, and the maintainability of the codebase is more challenging.</p>\n<p>Is this simply the inevitable lifecycle of a component? Or can this situation be averted? And, most importantly, if it <em>can</em> be averted, how?</p>\n<p>Selfishness. Or perhaps, self-interest. Better yet, maybe a little bit of both.</p>\n<p>Far too often, components are far too considerate. Too considerate of one another and, especially, too considerate of their own content. In order to create components that scale with a product, the name of the game is self-interest bordering on selfishness ‚Äî cold-hearted, narcissistic, the-world-revolves-around-me selfishness.</p>\n<p>This article isn‚Äôt going to settle the centuries-old debate about the line between self-interest and selfishness. Frankly, I‚Äôm not qualified to take part in any philosophical debate. However, what this article <em>is</em> going to do is demonstrate that building selfish components is in the best interest of every other component, designer, developer, and person consuming your content. In fact, selfish components create so much good around them that you could almost say they‚Äôre selfless.</p>\n<p>I don‚Äôt know ü§∑‚Äç‚ôÄÔ∏è Let‚Äôs look at some components and decide for ourselves.</p>\n<p><strong>Note</strong>: <em>All code examples and demos in this article will be based on React and TypeScript. However, the concepts and patterns are framework agnostic.</em></p>\nThe Consideration Iterations\n<p>Perhaps, the best way to demonstrate a considerate component is by walking through the lifecycle of one. We‚Äôll be able to see how they start small and functional but become unwieldy once the design evolves. Each iteration backs the component further into a corner until the design and needs of the product outgrow the capabilities of the component itself.</p>\n<p>Let‚Äôs consider the modest <code>Button</code> component. It‚Äôs deceptively complex and quite often trapped in the consideration pattern, and therefore, a great example of working through.</p>\n<h3>Iteration 1</h3>\n<p>While these sample designs are quite barebones, like not showing various <code>:hover</code>, <code>:focus</code>, and <code>disabled</code> states, they do showcase a simple button with two color themes.</p>\n<p><img src=\"https://files.smashing.media/articles/key-good-component-design-selfishness/1-barebones-button-design.jpeg\" /></p>\n<p>At first glance, it‚Äôs possible the resulting <code>Button</code> component could be as barebones as the design.</p>\n<div>\n<pre><code>// First, extend native HTML button attributes like onClick and disabled from React.\ntype ButtonProps = React.ComponentPropsWithoutRef&lt;\"button\"&gt; &amp; {\n  text: string;\n  theme: 'primary' | 'secondary';\n}\n</code></pre>\n</div>\n\n<pre><code>&lt;Button\n  onClick={someFunction}\n  text=\"Add to cart\"\n  theme=\"primary\"\n/&gt;\n</code></pre>\n\n<p>It‚Äôs possible, and perhaps even likely, that we‚Äôve all seen a <code>Button</code> component like this. Maybe we‚Äôve even made one like it ourselves. Some of the namings may be different, but the props, or the API of the <code>Button</code>, are roughly the same.</p>\n<p>In order to meet the requirements of the design, the <code>Button</code> defines props for the <code>theme</code> and <code>text</code>. This first iteration works and meets the current needs of both the design and the product. </p>\n<p>However, the current needs of the design and product are rarely the final needs. When the next design iterations are created, the <em>Add to cart</em> button now requires an icon.</p>\n<h3>Iteration 2</h3>\n<p>After validating the UI of the product, it was decided that adding an icon to the <em>Add to cart</em> button would be beneficial. The designs explain, though, that not every button will include an icon.</p>\n<p><img src=\"https://files.smashing.media/articles/key-good-component-design-selfishness/2-button-design-iteration-new-icon-variant.jpeg\" /></p>\n<p>Returning to our <code>Button</code> component, its props can be extended with an optional <code>icon</code> prop which maps to the name of an icon to conditionally render.</p>\n<pre><code>type ButtonProps = {\n  theme: 'primary' | 'secondary';\n  text: string;\n  icon?: 'cart' | '...all-other-potential-icon-names';\n}\n</code></pre>\n\n<pre><code>&lt;Button\n  theme=\"primary\"\n  onClick={someFunction}\n  text=\"Add to cart\"\n  icon=\"cart\"\n/&gt;\n</code></pre>\n\n<p>Whew! Crisis averted.</p>\n<p>With the new <code>icon</code> prop, the <code>Button</code> can now support variants with or without an icon. Of course, this assumes the icon will always be shown at the end of the text, which, to the surprise of nobody, is not the case when the next iteration is designed.</p>\n<h3>Iteration 3</h3>\n<p>The previous <code>Button</code> component implementation included the icon at the text‚Äôs end, but the new designs require an icon to optionally be placed at the start of the text. The single <code>icon</code> prop will no longer fit the needs of the latest design requirements.</p>\n<p><img src=\"https://files.smashing.media/articles/key-good-component-design-selfishness/3-updated-button-design-variants-multiple%20icon-placements.jpeg\" /></p>\n<p>There are a few different directions that can be taken to meet this new product requirement. Maybe an <code>iconPosition</code> prop can be added to the <code>Button</code>. But what if there comes a need to have an icon on both sides? Maybe our <code>Button</code> component can get ahead of this assumed requirement and make a few changes to the props.</p>\n<p>The single <code>icon</code> prop will no longer fit the needs of the product, so it‚Äôs removed. In its place, two new props are introduced, <code>iconAtStart</code> and <code>iconAtEnd</code>.</p>\n<pre><code>type ButtonProps = {\n  theme: 'primary' | 'secondary' | 'tertiary';\n  text: string;\n  iconAtStart?: 'cart' | '...all-other-potential-icon-names';\n  iconAtEnd?: 'cart' | '...all-other-potential-icon-names';\n}\n</code></pre>\n\n<p>After refactoring the existing uses of <code>Button</code> in the codebase to use the new props, another crisis is averted. Now, the <code>Button</code> has some flexibility. It‚Äôs all hardcoded and wrapped in conditionals within the component itself, but surely, what the UI doesn‚Äôt know can‚Äôt hurt it.</p>\n<p>Up until this point, the <code>Button</code> icons have always been the same color as the text. It seems reasonable and like a reliable default, but let‚Äôs throw a wrench into this well-oiled component by defining a variation with a contrasting color icon.</p>\n<h3>Iteration 4</h3>\n<p>In order to provide a sense of feedback, this confirmation UI stage was designed to be shown temporarily when an item has been added to the cart successfully.</p>\n<p>Maybe this is a time when the development team chooses to push back against the product requirements. But despite the push, the decision is made to move forward with providing color flexibility to <code>Button</code> icons.</p>\n<p><img src=\"https://files.smashing.media/articles/key-good-component-design-selfishness/4-button-design-iteration-contrasting%20icon-color.jpeg\" /></p>\n<p>Again, multiple approaches can be taken for this. Maybe an <code>iconClassName</code> prop is passed into the <code>Button</code> to have greater control over the icon‚Äôs appearance. But there are other product development priorities, and instead, a quick fix is done.</p>\n<p>As a result, an <code>iconColor</code> prop is added to the <code>Button</code>.</p>\n<pre><code>type ButtonProps = {\n  theme: 'primary' | 'secondary' | 'tertiary';\n  text: string;\n  iconAtStart?: 'cart' | '...all-other-potential-icon-names';\n  iconAtEnd?: 'cart' | '...all-other-potential-icon-names';\n  iconColor?: 'green' | '...other-theme-color-names';\n}\n</code></pre>\n\n<p>With the quick fix in place, the <code>Button</code> icons can now be styled differently than the text. The UI can provide the designed confirmation, and the product can, once again, move forward.</p>\n<p>Of course, as product requirements continue to grow and expand, so do their designs.</p>\n<h3>Iteration 5</h3>\n<p>With the latest designs, the <code>Button</code> must now be used with only an icon. This can be done in a few different approaches, yet again, but all of them require some amount of refactoring.</p>\n<p><img src=\"https://files.smashing.media/articles/key-good-component-design-selfishness/5-design-iteration-icon-only-button.jpeg\" /></p>\n<p>Perhaps a new <code>IconButton</code> component is created, duplicating all other button logic and styles into two places. Or maybe that logic and styles are centralized and shared across both components. However, in this example, the development team decides to keep all the variants in the same <code>Button</code> component.</p>\n<p>Instead, the <code>text</code> prop is marked as optional. This could be as quick as marking it as optional in the props but could require additional refactoring if there‚Äôs any logic expecting the <code>text</code> to exist. </p>\n<p>But then comes the question, if the <code>Button</code> is to have only an icon, which icon prop should be used? Neither <code>iconAtStart</code> nor <code>iconAtEnd</code> appropriately describes the <code>Button</code>. Ultimately, it‚Äôs decided to bring the original <code>icon</code> prop back and use <em>it</em> for the icon-only variant.</p>\n<pre><code>type ButtonProps = {\n  theme: 'primary' | 'secondary' | 'tertiary';\n  iconAtStart?: 'cart' | '...all-other-potential-icon-names';\n  iconAtEnd?: 'cart' | '...all-other-potential-icon-names';\n  iconColor?: 'green' | '...other-theme-color-names';\n  icon?: 'cart' | '...all-other-potential-icon-names';\n  text?: string;\n}\n</code></pre>\n\n<p>Now, the <code>Button</code> API is getting confusing. Maybe a few comments are left in the component to explain when and when not to use specific props, but the learning curve is growing steeper, and the potential for error is increasing.</p>\n<p>For example, without adding great complexity to the <code>ButtonProps</code> type, there is no stopping a person from using the <code>icon</code> and <code>text</code> props at the same time. This could either break the UI or be resolved with greater conditional complexity within the <code>Button</code> component itself. Additionally, the <code>icon</code> prop can be used with either or both of the <code>iconAtStart</code> and <code>IconAtEnd</code> props as well. Again, this could either break the UI or be resolved with even more layers of conditionals within the component.</p>\n<p>Our beloved <code>Button</code> has become quite unmanageable at this point. Hopefully, the product has reached a point of stability where no new changes or requirements will ever happen again. Ever.</p>\n<h3>Iteration 6</h3>\n<p>So much for never having any more changes. ü§¶</p>\n<p><img src=\"https://files.smashing.media/articles/key-good-component-design-selfishness/6-final-button-iteration-formatted-content.jpeg\" /></p>\n<p>This next and final iteration of the <code>Button</code> is the proverbial straw that breaks the camel‚Äôs back. In the <em>Add to cart</em> button, if the current item is already in the cart, we want to show the quantity of which on the button. On the surface, this is a straightforward change of dynamically building the <code>text</code> prop string. But the component breaks down because the current item count requires a different font weight and an underline. Because the <code>Button</code> accepts only a plain text string and no other child elements, the component no longer <em>works</em>.</p>\n<p>Would this design have broken the <code>Button</code> if this was the second iteration? Maybe not. The component and codebase were both much younger then. But the codebase has grown so much by this point that refactoring for this requirement is a mountain to climb.</p>\n<p>This is when one of the following things will likely happen:</p>\n<ol>\n<li>Do a much larger refactor to move the <code>Button</code> away from a <code>text</code> prop to accepting <code>children</code> or accepting a component or markup as the <code>text</code> value.</li>\n<li>The <code>Button</code> is split into a separate <code>AddToCart</code> button with an even more rigid API specific to this one use case. This also either duplicates any button logic and styles into multiple places or extracts them into a centralized file to share everywhere.</li>\n<li>The <code>Button</code> is deprecated, and a <code>ButtonNew</code> component is created, splitting the codebase, introducing technical debt, and increasing the onboarding learning curve.</li>\n</ol>\n<p>Neither outcome is ideal.</p>\n<p>So, where did the <code>Button</code> component go wrong?</p>\nSharing Is Impairing\n<p>What is the responsibility of an HTML <code>button</code> element exactly? Narrowing down this answer will shine light onto the issues facing the previous <code>Button</code> component.</p>\n<p>The responsibilities of the native HTML <code>button</code> element go no further than:</p>\n<ol>\n<li>Display, without opinion, whatever content is passed into it.</li>\n<li>Handle native functionality and attributes such as <code>onClick</code> and <code>disabled</code>.</li>\n</ol>\n<p>Yes, each browser has its own version of how a <code>button</code> element may look and display content, but CSS resets are often used to strip those opinions away. As a result, the <code>button</code> element boils down to little more than a functional container for triggering events.</p>\n<p>The onus of formatting any content within the <code>button</code> isn‚Äôt the responsibility of the <code>button</code> but of the content itself. The <code>button</code> shouldn‚Äôt care. The <code>button</code> should not share the responsibility for its content. </p>\n<blockquote>The core issue with the considerate component design is that component props define the content and not the component itself.</blockquote>\n\n<p>In the previous <code>Button</code> component, the first major limitation was the <code>text</code> prop. From the first iteration, a limitation was placed on the content of the <code>Button</code>. While the <code>text</code> prop fit with the designs at that stage, it immediately deviated from the two core responsibilities of the native HTML <code>button</code>. It immediately forced the <code>Button</code> to be aware of and responsible for its content.</p>\n<p>In the following iterations, the icon was introduced. While it seemed reasonable to bake a conditional icon into the <code>Button</code>, also doing so deviated from the core <code>button</code> responsibilities. Doing so limited the use cases of the component. In later iterations, the icon needed to be available in different positions, and the <code>Button</code> props were forced to expand to style the icon.</p>\n<p>When the component is responsible for the content it displays, it needs an API that can accommodate all content variations. Eventually, that API will break down because the content will forever and always change.</p>\nIntroducing The Me In Team\n<p>There‚Äôs an adage used in all team sports, ‚ÄúThere‚Äôs no ‚ÄòI‚Äô in a team.‚Äù While this mindset is noble, some of the greatest individual athletes have embodied other ideas.</p>\n<p>Michael Jordan famously responded with his own perspective, <em>‚ÄúThere‚Äôs an ‚ÄòI‚Äô in win.‚Äù</em> The late Kobe Bryant had a similar idea, <em>‚ÄúThere‚Äôs an ‚ÄòM-E‚Äô in [team].‚Äù</em></p>\n<p>Our original <code>Button</code> component was a team player. It shared the responsibility of its content until it reached the point of deprecation. How could the <code>Button</code> have avoided such constraints by embodying a <em>‚ÄúM-E in team‚Äù</em> attitude?</p>\nMe, Myself, And UI\n<blockquote>When the component is responsible for the content it displays, it will break down because the content will forever and always change.</blockquote>\n\n<p>How would a selfish component design approach have changed our original <code>Button</code>?</p>\n<p>Keeping the two core responsibilities of the HTML <code>button</code> element in mind, the structure of our <code>Button</code> component would have immediately been different.</p>\n<div>\n<pre><code>// First, extend native HTML button attributes like onClick and disabled from React.\ntype ButtonProps = React.ComponentPropsWithoutRef&lt;\"button\"&gt; &amp; {\n  theme: 'primary' | 'secondary' | 'tertiary';\n}\n</code></pre>\n</div>\n\n<pre><code>&lt;Button\n  onClick={someFunction}\n  theme=\"primary\"\n&gt;\n  &lt;span&gt;Add to cart&lt;/span&gt;\n&lt;/Button&gt;\n</code></pre>\n\n<p>By removing the original <code>text</code> prop in lieu of limitless <code>children</code>, the <code>Button</code> is able to align with its core responsibilities. The <code>Button</code> can now act as little more than a container for triggering events.</p>\n<p>By moving the <code>Button</code> to its native approach of supporting child content, the various icon-related props are no longer required. An icon can now be rendered anywhere within the <code>Button</code> regardless of size and color. Perhaps the various icon-related props could be extracted into their own selfish <code>Icon</code> component.</p>\n<pre><code>&lt;Button\n  onClick={someFunction}\n  theme=\"primary\"\n&gt;\n  &lt;Icon name=\"cart\" /&gt;\n  &lt;span&gt;Add to cart&lt;/span&gt;\n&lt;/Button&gt;\n</code></pre>\n\n<p>With the content-specific props removed from the <code>Button</code>, it can now do what all selfish characters do best, think about itself.</p>\n<div>\n<pre><code>// First, extend native HTML button attributes like onClick and disabled from React.\ntype ButtonProps = React.ComponentPropsWithoutRef&lt;\"button\"&gt; &amp; {\n  size: 'sm' | 'md' | 'lg';\n  theme: 'primary' | 'secondary' | 'tertiary';\n  variant: 'ghost' | 'solid' | 'outline' | 'link'\n}\n</code></pre>\n</div>\n\n<p>With an API specific to itself and independent content, the <code>Button</code> is now a maintainable component. The self-interest props keep the learning curve minimal and intuitive while retaining great flexibility for various <code>Button</code> use cases.</p>\n<p><code>Button</code> icons can now be placed at either end of the content.</p>\n<pre><code>&lt;Button\n  onClick={someFunction}\n  size=\"md\"\n  theme=\"primary\"\n  variant=\"solid\"\n&gt;\n  &lt;Box display=\"flex\" gap=\"2\" alignItems=\"center\"&gt;\n    &lt;span&gt;Add to cart&lt;/span&gt;\n    &lt;Icon name=\"cart\" /&gt;\n  &lt;/Box&gt;\n&lt;/Button&gt;\n</code></pre>\n\n<p>Or, a <code>Button</code> could have only an icon.</p>\n<pre><code>&lt;Button\n  onClick={someFunction}\n  size=\"sm\"\n  theme=\"secondary\"\n  variant=\"solid\"\n&gt;\n  &lt;Icon name=\"cart\" /&gt;\n&lt;/Button&gt;\n</code></pre>\n\n<p>However, a product may evolve over time, and selfish component design improves the ability to evolve along with it. Let‚Äôs go beyond the <code>Button</code> and into the cornerstones of selfish component design.</p>\nThe Keys to Selfish Design\n<p>Much like when creating a fictional character, it‚Äôs best to show, not tell, the reader that they‚Äôre selfish. By reading about the character‚Äôs thoughts and actions, their personality and traits can be understood. Component design can take the same approach.</p>\n<p>But how exactly do we show in a component‚Äôs design and use that it is selfish?</p>\n<h3>HTML Drives The Component Design</h3>\n<p>Many times, components are built as direct abstractions of native HTML elements like a <code>button</code> or <code>img</code>. When this is the case, let the native HTML element drive the design of the component. </p>\n<p>Specifically, if the native HTML element accepts children, the abstracted component should as well. Every aspect of a component that deviates from its native element is something that must be learned anew.</p>\n<p>When our original <code>Button</code> component deviated from the native behavior of the <code>button</code> element by not supporting child content, it not only became rigid but it required a mental model shift just to use the component.</p>\n<p>There has been a lot of time and thought put into the structure and definitions of HTML elements. The wheel doesn‚Äôt need to be reinvented every time.</p>\n<h3>Children Fend For Themselves</h3>\n<p>If you‚Äôve ever read <em>Lord of the Flies</em>, you know just how dangerous it can be when a group of children is forced to fend for themselves. However, in the case of selfish component design, we‚Äôll be doing exactly that.</p>\n<p>As shown in our original <code>Button</code> component, the more it tried to style its content, the more rigid and complicated it became. When we removed that responsibility, the component was able to do a lot more but with a lot less.</p>\n<p>Many elements are little more than semantic containers. It‚Äôs not often we expect a <code>section</code> element to style its content. A <code>button</code> element is just a very specific type of semantic container. The same approach can apply when abstracting it to a component.</p>\n<h3>Components Are Singularly Focused</h3>\n<p>Think of selfish component design as arranging a bunch of terrible first dates. A component‚Äôs props are like the conversation that is entirely focused on them and their immediate responsibilities:</p>\n<ul>\n<li><strong>How do I look?</strong><br />Props need to feed the ego of the component. In our refactored <code>Button</code> example, we did this with props like <code>size</code>, <code>theme</code>, and <code>variant</code>.</li>\n<li><strong>What am I doing?</strong><br />A component should only be interested in what it, and it alone, is doing. Again, in our refactored <code>Button</code> component, we do this with the <code>onClick</code> prop. As far as the <code>Button</code> is concerned, if there‚Äôs another click event somewhere within its content, that‚Äôs the content‚Äôs problem. The <code>Button</code> does. not. care.</li>\n<li><strong>When and where am I going next?</strong><br />Any jet-setting traveler is quick to talk about their next destination. For components like modals, drawers, and tooltips, when and where they‚Äôre going is just as gravely important. Components like these are not always rendered in the DOM. This means that in addition to knowing how they look and what they do, they need to know when and where to be. In other words, this can be described with props like <code>isShown</code> and <code>position</code>.</li>\n</ul>\n<h3>Composition Is King</h3>\n<p>Some components, such as modals and drawers, can often contain different layout variations. For example, some modals will show a header bar while others do not. Some drawers may have a footer with a call to action. Others may have no footer at all.</p>\n<p>Instead of defining each layout in a single <code>Modal</code> or <code>Drawer</code> component with conditional props like <code>hasHeader</code> or <code>showFooter</code>, break the single component into multiple composable child components.</p>\n<pre><code>&lt;Modal&gt;\n  &lt;Modal.CloseButton /&gt;\n  &lt;Modal.Header&gt; ... &lt;/Modal.Header&gt;\n  &lt;Modal.Main&gt; ... &lt;Modal.Main&gt;\n&lt;/Modal&gt;\n</code></pre>\n\n<pre><code>&lt;Drawer&gt;\n  &lt;Drawer.Main&gt; ... &lt;/Drawer.Main&gt;\n  &lt;Drawer.Footer&gt; ... &lt;/Drawer.Footer&gt;\n&lt;/Drawer&gt;\n</code></pre>\n\n<p>By using component composition, each individual component can be as selfish as it wants to be and used only when and where it‚Äôs needed. This keeps the root component‚Äôs API clean and can move many props to their specific child component.</p>\n<p>Let‚Äôs explore this and the other keys to selfish component design a bit more.</p>\nYou‚Äôre So Vain, You Probably Think This Code Is About You\n<p>Perhaps the keys of selfish design make sense when looking back at the evolution of our <code>Button</code> component. Nevertheless, let‚Äôs apply them again to another commonly problematic component ‚Äî the modal.</p>\n<p><img src=\"https://files.smashing.media/articles/key-good-component-design-selfishness/7-edit-profile-modal.png\" /></p>\n<p><img src=\"https://files.smashing.media/articles/key-good-component-design-selfishness/8-upload-successful-modal-iteration.png\" /></p>\n<p><img src=\"https://files.smashing.media/articles/key-good-component-design-selfishness/9-friends-modal-iteration.png\" /></p>\n<p>For this example, we have the benefit of foresight in the three different modal layouts. This will help steer the direction of our <code>Modal</code> while applying each key of selfish design along the way.</p>\n<p>First, let‚Äôs go over our mental model and break down the layouts of each design.</p>\n<p>In the <strong>Edit Profile</strong> modal, there are defined header, main and footer sections. There‚Äôs also a close button. In the <strong>Upload Successful</strong> modal, there‚Äôs a modified header with no close button and a hero-like image. The buttons in the footer are also stretched. Lastly, in the <strong>Friends</strong> modal, the close button returns, but now the content area is scrollable, and there‚Äôs no footer.</p>\n<p>So, what did we learn?</p>\n<p>We learned that the header, main and footer sections are interchangeable. They may or may not exist in any given view. We also learned that the close button functions independently and is not tied to any specific layout or section.</p>\n<p>Because our <code>Modal</code> can be comprised of interchangeable layouts and arrangements, that‚Äôs our sign to take a composable child component approach. This will allow us to plug and play pieces into the <code>Modal</code> as needed.</p>\n<p>This approach allows us to very narrowly define the responsibilities of our root <code>Modal</code> component.</p>\n<p><strong>Conditionally render with any combination of content layouts.</strong></p>\n<p>That‚Äôs it. So long as our <code>Modal</code> is just a conditionally-rendered container, it will never need to care about or be responsible for its content.</p>\n<p>With the core responsibility of our <code>Modal</code> defined, and the composable child component approach decided, let‚Äôs break down each composable piece and its role.</p>\n<table>\n    <thead>\n        <tr>\n            <th>Component</th>\n            <th>Role</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td><code>&lt;Modal&gt;</code></td>\n            <td>This is the entry point of the entire <code>Modal</code> component. This container is responsible for when and where to render, how the modal looks, and what it does, like handle accessibility considerations.</td>\n        </tr>\n        <tr>\n            <td><code>&lt;Modal.CloseButton /&gt;</code></td>\n            <td>An interchangeable <code>Modal</code> child component that can be included only when needed. This component will work similarly to our refactored <code>Button</code> component. It will be responsible for how it looks, where it‚Äôs shown, and what it does.</td>\n        </tr>\n        <tr>\n            <td><code>&lt;Modal.Header&gt;</code></td>\n            <td>The header section will be an abstraction of the native HTML <code>header</code> element. It will be little more than a semantic container for any content, like headings or images, to be shown.</td>\n        </tr>\n    <tr>\n            <td><code>&lt;Modal.Main&gt;</code></td>\n            <td>The main section will be an abstraction of the native HTML <code>main</code> element. It will be little more than a semantic container for any content. </td>\n        </tr>\n    <tr>\n            <td><code>&lt;Modal.Footer&gt;</code></td>\n            <td>The footer section will be an abstraction of the native HTML <code>footer</code> element. It will be little more than a semantic container for any content. </td>\n        </tr>\n    </tbody>\n</table>\n\n<p>With each component and its role defined, we can start creating props to support those roles and responsibilities.</p>\n<h4><code>Modal</code></h4>\n<p>Earlier, we defined the barebones responsibility of the <code>Modal</code>, knowing when to conditionally render. This can be achieved using a prop like <code>isShown</code>. Therefore, we can use these props, and whenever it‚Äôs <code>true</code>, the <code>Modal</code> and its content will render.</p>\n<pre><code>type ModalProps = {\n  isShown: boolean;\n}\n</code></pre>\n\n<pre><code>&lt;Modal isShown={showModal}&gt;\n  ...\n&lt;/Modal&gt;\n</code></pre>\n\n<p>Any styling and positioning can be done with CSS in the <code>Modal</code> component directly. There‚Äôs no need to create specific props at this time.</p>\n<h4><code>Modal.CloseButton</code></h4>\n<p>Given our previously refactored <code>Button</code> component, we know how the <code>CloseButton</code> should work. Heck, we can even use our <code>Button</code> to build our <code>CloseButton</code> component.</p>\n<div>\n<pre><code>import { Button, ButtonProps } from 'components/Button';\n\nexport function CloseButton({ onClick, ...props }: ButtonProps) {\n  return (\n    &lt;Button {...props} onClick={onClick} variant=\"ghost\" theme=\"primary\" /&gt;\n  )\n}\n</code></pre>\n</div>\n\n<pre><code>&lt;Modal&gt;\n  &lt;Modal.CloseButton onClick={closeModal} /&gt;\n&lt;/Modal&gt;\n</code></pre>\n\n<h4><code>Modal.Header</code>, <code>Modal.Main</code>, <code>Modal.Footer</code></h4>\n<p>Each of the individual layout sections, <code>Modal.Header</code>, <code>Modal.Main</code>, and <code>Modal.Footer</code>, can take direction from their HTML equivalents, <code>header</code>, <code>main</code>, and <code>footer</code>. Each of these elements supports any variation of child content, and therefore, our components will do the same.</p>\n<p>There are no special props needed. They serve only as semantic containers.</p>\n<pre><code>&lt;Modal&gt;\n  &lt;Modal.CloseButton onClick={closeModal} /&gt;\n  &lt;Modal.Header&gt; ... &lt;/Modal.Header&gt;\n  &lt;Modal.Main&gt; ... &lt;/Modal.Main&gt;\n  &lt;Modal.Footer&gt; ... &lt;/Modal.Footer&gt;\n&lt;/Modal&gt;\n</code></pre>\n\n<p>With our <code>Modal</code> component and its child component defined, let‚Äôs see how they can be used interchangeably to create each of the three designs.</p>\n<p><strong>Note</strong>: <em>The full markup and styles are not shown so as not to take away from the core takeaways.</em></p>\n<h3>Edit Profile Modal</h3>\n<p>In the <strong>Edit Profile</strong> modal, we use each of the <code>Modal</code> components. However, each is used only as a container that styles and positions itself. This is why we haven‚Äôt included a <code>className</code> prop for them. Any content styling should be handled by the content itself, not our container components.</p>\n<pre><code>&lt;Modal&gt;\n  &lt;Modal.CloseButton onClick={closeModal} /&gt;\n\n  &lt;Modal.Header&gt;\n    &lt;h1&gt;Edit Profile&lt;/h1&gt;\n  &lt;/Modal.Header&gt;\n\n  &lt;Modal.Main&gt;\n    &lt;div className=\"modal-avatar-selection-wrapper\"&gt; ... &lt;/div&gt;\n    &lt;form className=\"modal-profile-form\"&gt; ... &lt;/form&gt;\n  &lt;/Modal.Main&gt;\n\n  &lt;Modal.Footer&gt;\n    &lt;div className=\"modal-button-wrapper\"&gt;\n      &lt;Button onClick={closeModal} theme=\"tertiary\"&gt;Cancel&lt;/Button&gt;\n      &lt;Button onClick={saveProfile} theme=\"secondary\"&gt;Save&lt;/Button&gt;\n    &lt;/div&gt;\n  &lt;/Modal.Footer&gt;\n&lt;/Modal&gt;\n</code></pre>\n\n<h3>Upload Successful Modal</h3>\n<p>Like in the previous example, the <strong>Upload Successful</strong> modal uses its components as opinionless containers. The styling for the content is handled by the content itself. Perhaps this means the buttons could be stretched by the <code>modal-button-wrapper</code> class, or we could add a <em>‚Äúhow do I look?‚Äù</em> prop, like <code>isFullWidth</code>, to the <code>Button</code> component for a wider or full-width size.</p>\n<pre><code>&lt;Modal&gt;\n  &lt;Modal.Header&gt;\n    &lt;img src=\"...\" alt=\"...\" /&gt;\n    &lt;h1&gt;Upload Successful&lt;/h1&gt;\n  &lt;/Modal.Header&gt;\n\n  &lt;Modal.Main&gt;\n    &lt;p&gt; ... &lt;/p&gt;\n    &lt;div className=\"modal-copy-upload-link-wrapper\"&gt; ... &lt;/div&gt;\n  &lt;/Modal.Main&gt;\n\n  &lt;Modal.Footer&gt;\n    &lt;div className=\"modal-button-wrapper\"&gt;\n      &lt;Button onClick={closeModal} theme=\"tertiary\"&gt;Skip&lt;/Button&gt;\n      &lt;Button onClick={saveProfile} theme=\"secondary\"&gt;Save&lt;/Button&gt;\n    &lt;/div&gt;\n  &lt;/Modal.Footer&gt;\n&lt;/Modal&gt;\n</code></pre>\n\n<h3>Friends Modal</h3>\n<p>Lastly, our <strong>Friends</strong> modal does away with the <code>Modal.Footer</code> section. Here, it may be enticing to define the overflow styles on <code>Modal.Main</code>, but that is extending the container‚Äôs responsibilities to its content. Instead, handling those styles is better suited in the <code>modal-friends-wrapper</code> class.</p>\n<pre><code>&lt;Modal&gt;\n  &lt;Modal.CloseButton onClick={closeModal} /&gt;\n\n  &lt;Modal.Header&gt;\n    &lt;h1&gt;AngusMcSix's Friends&lt;/h1&gt;\n  &lt;/Modal.Header&gt;\n\n  &lt;Modal.Main&gt;\n      &lt;div className=\"modal-friends-wrapper\"&gt;\n        &lt;div className=\"modal-friends-friend-wrapper\"&gt; ... &lt;/div&gt;\n        &lt;div className=\"modal-friends-friend-wrapper\"&gt; ... &lt;/div&gt;\n        &lt;div className=\"modal-friends-friend-wrapper\"&gt; ... &lt;/div&gt;\n      &lt;/div&gt;\n  &lt;/Modal.Main&gt;\n&lt;/Modal&gt;\n</code></pre>\n\n<p>With a selfishly designed <code>Modal</code> component, we can accommodate evolving and changing designs with flexible and tightly scoped components.</p>\n<h3>Next Modal Evolutions</h3>\n<p>Given all that we‚Äôve covered, let‚Äôs throw around some hypotheticals regarding our <code>Modal</code> and how it may evolve. How would <em>you</em> approach these design variations?</p>\n<p>A design requires a fullscreen modal. How would you adjust the <code>Modal</code> to accommodate a fullscreen variation?</p>\n<p>Another design is for a 2-step registration process. How could the <code>Modal</code> accommodate this type of design and functionality?</p>\n<p><img src=\"https://files.smashing.media/articles/key-good-component-design-selfishness/10-modal-registration-stage-1.png\" /></p>\n<p><img src=\"https://files.smashing.media/articles/key-good-component-design-selfishness/11-modal-registration-stage-2.png\" /></p>\nRecap\n<p>Components are the workhorses of modern web development. Greater importance continues to be placed on component libraries, either standalone or as part of a design system. With how fast the web moves, having components that are accessible, stable, and resilient is absolutely critical.</p>\n<p>Unfortunately, components are often built to do too much. They are built to inherit the responsibilities and concerns of their content and surroundings. So many patterns that apply this level of consideration break down further each iteration until a component no longer <em>works</em>. At this point, the codebase splits, more technical debt is introduced, and inconsistencies creep into the UI.</p>\n<p>If we break a component down to its core responsibilities and build an API of props that only define those responsibilities, without consideration of content inside or around the component, we build components that can be resilient to change. This selfish approach to component design ensures a <strong>component is only responsible for itself and not its content</strong>. Treating components as little more than semantic containers means content can change or even move between containers without effect. The less considerate a component is about its content and its surroundings, the better for everybody ‚Äî better for the content that will forever change, better for the consistency of the design and UI, which in turn is better for the people consuming that changing content, and lastly, better for the developers using the components.</p>\n<p>The key to the good component design is selfishness. Being a considerate team player is the responsibility of the developer.</p>","author":"","siteTitle":"Articles on Smashing Magazine ‚Äî For Web Designers And Developers","siteHash":"f300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"fac270c2ae0be73bc8510fc84b5f98509547563b038109377fb47c","category":"Tech"}