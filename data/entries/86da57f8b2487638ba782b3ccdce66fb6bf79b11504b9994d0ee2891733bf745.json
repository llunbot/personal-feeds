{"title":"Introducing Amazon MemoryDB for Redis – A Redis-Compatible, Durable, In-Memory Database Service","link":"https://aws.amazon.com/blogs/aws/introducing-amazon-memorydb-for-redis-a-redis-compatible-durable-in-memory-database-service/","date":1629394929000,"content":"<p>Interactive applications need to process requests and respond very quickly, and this requirement extends to all the components of their architecture. That is even more important when you adopt microservices and your architecture is composed of many small independent services that communicate with each other.</p> \n<p>For this reason, database performance is critical to the success of applications. To reduce read latency to microseconds, you can put an in-memory cache in front of a durable database. For caching, many developers use <a href=\"https://redis.io/\">Redis</a>, an open-source in-memory data structure store. In fact, according to <a href=\"https://insights.stackoverflow.com/survey/2021#section-most-loved-dreaded-and-wanted-databases\">Stack Overflow’s 2021 Developer Survey</a>, Redis has been the most loved database for five years.</p> \n<p>To implement this setup on AWS, you can use <a href=\"https://aws.amazon.com/elasticache/redis/\">Amazon ElastiCache for Redis</a>, a fully managed in-memory caching service, as a low latency cache in front of a durable database service such as <a href=\"https://aws.amazon.com/rds/aurora/\">Amazon Aurora</a> or <a href=\"https://aws.amazon.com/dynamodb/\">Amazon DynamoDB</a> to minimize data loss. However, this setup requires you to introduce custom code in your applications to keep the cache in sync with the database. You’ll also incur costs for running both a cache and a database.</p> \n<p><span><strong>Introducing Amazon MemoryDB for Redis<br /> </strong></span>Today, I am excited to announce the general availability of <a href=\"https://aws.amazon.com/memorydb\">Amazon MemoryDB for Redis</a>, a new Redis-compatible, durable, in-memory database. MemoryDB makes it easy and cost-effective to build applications that require <strong>microsecond read</strong> and <strong>single-digit millisecond write</strong> performance with <strong>data durability</strong> and <strong>high availability</strong>.</p> \n<p>Instead of using a low-latency cache in front of a durable database, you can now simplify your architecture and use MemoryDB as a single, <strong>primary database</strong>. With MemoryDB, all your data is stored in memory, enabling low latency and high throughput data access. MemoryDB uses a distributed <a href=\"https://en.wikipedia.org/wiki/Transaction_log\">transactional log</a> that stores data across multiple <a href=\"https://aws.amazon.com/about-aws/global-infrastructure/regions_az/#Availability_Zones\">Availability Zones (AZs)</a> to enable fast failover, database recovery, and node restarts with high durability.</p> \n<p>MemoryDB maintains compatibility with open-source Redis and supports the same set of Redis data types, parameters, and commands that you are familiar with. This means that the code, applications, drivers, and tools you already use today with open-source Redis can be used with MemoryDB. As a developer, you get immediate access to many data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, <a href=\"https://en.wikipedia.org/wiki/HyperLogLog\">hyperloglogs</a>, geospatial indexes, and streams. You also get access to advanced features such as built-in replication, least recently used (LRU) eviction, transactions, and automatic partitioning. MemoryDB is compatible with Redis 6.2 and will support newer versions as they are released in open source.</p> \n<p>One question you might have at this point is how MemoryDB compares to ElastiCache because both services give access to Redis data structures and API:</p> \n<ul> \n <li>MemoryDB can safely be the primary database for your applications because it provides data durability and microsecond read and single-digit millisecond write latencies. With MemoryDB, you don’t need to add a cache in front of the database to achieve the low latency you need for your interactive applications and microservices architectures.</li> \n <li>On the other hand, ElastiCache provides microsecond latencies for both reads and writes. It is ideal for caching workloads where you want to accelerate data access from your existing databases. ElastiCache can also be used as a primary datastore for use cases where data loss might be acceptable (for example, because you can quickly rebuild the database from another source).</li> \n</ul> \n<p><span><strong>Creating an Amazon MemoryDB Cluster</strong></span><br /> In the <a href=\"https://console.aws.amazon.com/memorydb/home\">MemoryDB console</a>, I follow the link on the left navigation pane to the <strong>Clusters</strong> section and choose <strong>Create cluster</strong>. This opens <strong>Cluster settings</strong> where I enter a name and a description for the cluster.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/11/amazon-memorydb-redis-create-cluster.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/11/amazon-memorydb-redis-create-cluster-1024x752.png\" /></a></p> \n<p>All MemoryDB clusters run in a <a href=\"https://docs.aws.amazon.com/vpc/latest/userguide/how-it-works.html#how-it-works-subnet\">virtual private cloud (VPC)</a>. In <strong>Subnet groups </strong>I create a subnet group by selecting one of my VPCs and providing a list of subnets that the cluster will use to distribute its nodes.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/11/amazon-memorydb-redis-subnet-group-vpc.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/11/amazon-memorydb-redis-subnet-group-vpc-1024x568.png\" /></a></p> \n<p>In <strong>Cluster settings</strong>, I can change the network port, the parameter group that controls the runtime properties of my nodes and clusters, the node type, the number of shards, and the number of replicas per shard. Data stored in the cluster is partitioned across shards. The number of shards and the number of replicas per shard determine the number of nodes in my cluster. Considering that for each shard there is a primary node plus the replicas, I expect this cluster to have eight nodes.</p> \n<p>For <strong>Redis version compatibility</strong>, I choose 6.2. I leave all other options to their default and choose <strong>Next</strong>.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/11/amazon-memorydb-redis-cluster-settings.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/11/amazon-memorydb-redis-cluster-settings-1024x908.png\" /></a></p> \n<p>In the <strong>Security</strong> section of <strong>Advanced settings</strong> I add the <code>default</code> security group for the VPC I used for the subnet group and choose an access control list (ACL) that I created before. MemoryDB ACLs are based on <a href=\"https://redis.io/topics/acl\">Redis ACLs</a> and provide user credentials and permissions to connect to the cluster.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/11/amazon-memorydb-redis-security.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/11/amazon-memorydb-redis-security-1024x806.png\" /></a></p> \n<p>In the <strong>Snapshot</strong> section, I leave the default to have MemoryDB automatically create a daily snapshot and select a retention period of 7 days.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/11/amazon-memorydb-redis-snapshot.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/11/amazon-memorydb-redis-snapshot-1024x478.png\" /></a></p> \n<p>For <strong>Maintenance</strong>, I leave the defaults and then choose <strong>Create</strong>. In this section I can also provide an <a href=\"https://aws.amazon.com/sns/\">Amazon Simple Notification Service (SNS)</a> topic to be notified of important cluster events.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/11/amazon-memorydb-redis-maintenance.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/11/amazon-memorydb-redis-maintenance-1024x804.png\" /></a></p> \n<p>After a few minutes, the cluster is running and I can connect using the <a href=\"https://redis.io/topics/rediscli\">Redis command line interface</a> or any <a href=\"https://redis.io/clients\">Redis client</a>.</p> \n<p><span><strong>Using Amazon MemoryDB as Your Primary Database<br /> </strong></span>Managing customer data is a critical component of many business processes. To test the durability of my new Amazon MemoryDB cluster, I want to use it as a customer database. For simplicity, let’s build a simple microservice in Python that allows me to create, update, delete, and get one or all customer data from a Redis cluster using a <a href=\"https://en.wikipedia.org/wiki/Representational_state_transfer\">REST</a> API.</p> \n<p>Here’s the code of my <code>server.py</code> implementation:</p> \n<pre><code>from flask import Flask, request\nfrom flask_restful import Resource, Api, abort\nfrom rediscluster import RedisCluster\nimport logging\nimport os\nimport uuid\n\nhost = os.environ['HOST']\nport = os.environ['PORT']\ndb_host = os.environ['DBHOST']\ndb_port = os.environ['DBPORT']\ndb_username = os.environ['DBUSERNAME']\ndb_password = os.environ['DBPASSWORD']\n\nlogging.basicConfig(level=logging.INFO)\n\nredis = RedisCluster(startup_nodes=[{\"host\": db_host, \"port\": db_port}],\n            decode_responses=True, skip_full_coverage_check=True,\n            ssl=True, username=db_username, password=db_password)\n\nif redis.ping():\n    logging.info(\"Connected to Redis\")\n\napp = Flask(__name__)\napi = Api(app)\n\n\nclass Customers(Resource):\n\n    def get(self):\n        key_mask = \"customer:*\"\n        customers = []\n        for key in redis.scan_iter(key_mask):\n            customer_id = key.split(':')[1]\n            customer = redis.hgetall(key)\n            customer['id'] = customer_id\n            customers.append(customer)\n            print(customer)\n        return customers\n\n    def post(self):\n        print(request.json)\n        customer_id = str(uuid.uuid4())\n        key = \"customer:\" + customer_id\n        redis.hset(key, mapping=request.json)\n        customer = request.json\n        customer['id'] = customer_id\n        return customer, 201\n\n\nclass Customers_ID(Resource):\n\n    def get(self, customer_id):\n        key = \"customer:\" + customer_id\n        customer = redis.hgetall(key)\n        print(customer)\n        if customer:\n            customer['id'] = customer_id\n            return customer\n        else:\n            abort(404)\n\n    def put(self, customer_id):\n        print(request.json)\n        key = \"customer:\" + customer_id\n        redis.hset(key, mapping=request.json)\n        return '', 204\n\n    def delete(self, customer_id):\n        key = \"customer:\" + customer_id\n        redis.delete(key)\n        return '', 204\n\n\napi.add_resource(Customers, '/customers')\napi.add_resource(Customers_ID, '/customers/&lt;customer_id&gt;')\n\n\nif __name__ == '__main__':\n    app.run(host=host, port=port)</code></pre> \n<p>This is the <code>requirements.txt</code> file, which lists the Python modules required by the application:</p> \n<div> \n <pre><code>redis-py-cluster\nFlask\nFlask-RESTful</code></pre> \n</div> \n<p>The same code works with MemoryDB, ElastiCache, or any Redis Cluster database.</p> \n<p>I start a Linux <a href=\"https://aws.amazon.com/ec2/\">Amazon Elastic Compute Cloud (Amazon EC2)</a> instance in the same VPC as the MemoryDB cluster. To be able to connect to the MemoryDB cluster, I assign the <code>default</code> security group. I also add another security group that gives me SSH access to the instance.</p> \n<p>I copy the <code>server.py</code> and <code>requirements.txt</code> files onto the instance and then install the dependencies:</p> \n<div> \n <pre><code>pip3 install --user -r requirements.txt</code></pre> \n</div> \n<p>Now, I start the microservice:</p> \n<div> \n <pre><code>python3 server.py</code></pre> \n</div> \n<p>In another terminal connection, I use <a href=\"https://curl.se/\">curl</a> to create a customer in my database with an HTTP POST on the <code>/customers</code> resource:</p> \n<div> \n <pre><code>curl -i --header \"Content-Type: application/json\" --request POST \\\n     --data '{\"name\": \"Danilo\", \"address\": \"Somewhere in London\",\n              \"phone\": \"+1-555-2106\",\"email\": \"danilop@example.net\", \"balance\": 1000}' \\\n     http://localhost:8080/customers</code></pre> \n</div> \n<p>The result confirms that the data has been stored and a unique ID (a <a href=\"https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)\">UUIDv4</a> generated by the Python code) has been added to the fields:</p> \n<div> \n <pre><code>HTTP/1.0 201 CREATED\nContent-Type: application/json\nContent-Length: 172\nServer: Werkzeug/2.0.1 Python/3.7.10\nDate: Wed, 11 Aug 2021 18:16:58 GMT\n\n{\"name\": \"Danilo\", \"address\": \"Somewhere in London\",\n \"phone\": \"+1-555-2106\", \"email\": \"danilop@example.net\",\n \"balance\": 1000, \"id\": \"3894e683-1178-4787-9f7d-118511686415\"}</code></pre> \n</div> \n<p>All the fields are stored in a Redis Hash with a key formed as <code>customer:&lt;id&gt;</code>.</p> \n<p>I repeat the previous command a couple of times to create three customers. The customer data is the same, but each one has a unique ID.</p> \n<p>Now, I get a list of all customer with an HTTP GET to the <code>/customers</code> resource:</p> \n<div> \n <pre><code>curl -i http://localhost:8080/customers</code></pre> \n</div> \n<p>In the code there is an iterator on the matching keys using the <a href=\"https://redis.io/commands/scan\">SCAN</a> command. In the response, I see the data for the three customers:</p> \n<div> \n <pre><code>HTTP/1.0 200 OK\nContent-Type: application/json\nContent-Length: 526\nServer: Werkzeug/2.0.1 Python/3.7.10\nDate: Wed, 11 Aug 2021 18:20:11 GMT\n\n[{\"name\": \"Danilo\", \"address\": \"Somewhere in London\",\n\"phone\": \"+1-555-2106\", \"email\": \"danilop@example.net\",\n\"balance\": \"1000\", \"id\": \"1d734b6a-56f1-48c0-9a7a-f118d52e0e70\"},\n{\"name\": \"Danilo\", \"address\": \"Somewhere in London\",\n\"phone\": \"+1-555-2106\", \"email\": \"danilop@example.net\",\n\"balance\": \"1000\", \"id\": \"89bf6d14-148a-4dfa-a3d4-253492d30d0b\"},\n{\"name\": \"Danilo\", \"address\": \"Somewhere in London\",\n\"phone\": \"+1-555-2106\", \"email\": \"danilop@example.net\",\n\"balance\": \"1000\", \"id\": \"3894e683-1178-4787-9f7d-118511686415\"}]</code></pre> \n</div> \n<p>One of the customers has just spent all his balance. I update the field with an HTTP PUT on the URL of the customer resource that includes the ID (<code>/customers/&lt;id&gt;</code>):</p> \n<div> \n <pre><code>curl -i --header \"Content-Type: application/json\" \\\n     --request PUT \\\n     --data '{\"balance\": 0}' \\\n     http://localhost:8080/customers/3894e683-1178-4787-9f7d-118511686415</code></pre> \n</div> \n<p>The code is updating the fields of the Redis Hash with the data of the request. In this case, it’s setting the <code>balance</code> to zero. I verify the update by getting the customer data by ID:</p> \n<div> \n <pre><code>curl -i http://localhost:8080/customers/3894e683-1178-4787-9f7d-118511686415</code></pre> \n</div> \n<p>In the response, I see that the balance has been updated:</p> \n<div> \n <pre><code>HTTP/1.0 200 OK\nContent-Type: application/json\nContent-Length: 171\nServer: Werkzeug/2.0.1 Python/3.7.10\nDate: Wed, 11 Aug 2021 18:32:15 GMT\n\n{\"name\": \"Danilo\", \"address\": \"Somewhere in London\",\n\"phone\": \"+1-555-2106\", \"email\": \"danilop@example.net\",\n\"balance\": \"0\", \"id\": \"3894e683-1178-4787-9f7d-118511686415\"}</code></pre> \n</div> \n<p>That’s the power of Redis! I was able to create the skeleton of a microservice with just a few lines of code. On top of that, MemoryDB gives me the durability and the high availability I need in production without the need to add another database in the backend.</p> \n<p>Depending on my workload, I can scale my MemoryDB cluster horizontally, by adding or removing nodes, or vertically, by moving to larger or smaller node types. MemoryDB supports write scaling with sharding and read scaling by adding replicas. My cluster continues to stay online and support read and write operations during resizing operations.</p> \n<p><span><strong>Availability and Pricing<br /> </strong></span><a href=\"https://aws.amazon.com/memorydb\">Amazon MemoryDB for Redis</a> is available today in US East (N. Virginia), EU (Ireland), Asia Pacific (Mumbai), and South America (Sao Paulo) with more AWS Regions coming soon.</p> \n<p>You can create a MemoryDB cluster in minutes using the <a href=\"https://console.aws.amazon.com\">AWS Management Console</a>, <a href=\"https://aws.amazon.com/cli/\">AWS Command Line Interface (CLI)</a>, or <a href=\"https://aws.amazon.com/tools/\">AWS SDKs</a>. <a href=\"https://aws.amazon.com/cloudformation/\">AWS CloudFormation</a> support will be coming soon. For the nodes, MemoryDB currently supports R6g <a href=\"https://aws.amazon.com/ec2/graviton/\">Graviton2</a> instances.</p> \n<p>To migrate from ElastiCache for Redis to MemoryDB, you can take a backup of your ElastiCache cluster and restore it to a MemoryDB cluster. You can also create a new cluster from a <a href=\"https://redis.io/topics/persistence\">Redis Database Backup (RDB)</a> file stored on <a href=\"https://aws.amazon.com/s3/\">Amazon Simple Storage Service (Amazon S3)</a>.</p> \n<p>With MemoryDB, you pay for what you use based on on-demand instance hours per node, volume of data written to your cluster, and snapshot storage. For more information, see the <a href=\"https://aws.amazon.com/memorydb/pricing\">MemoryDB pricing page</a>.</p> \n<p><span><strong>Learn More<br /> </strong></span>Check out the video below for a quick overview.</p> \n<p></p> \n<p><a href=\"https://aws.amazon.com/memorydb\"><strong>Start using Amazon MemoryDB for Redis as your primary database today.</strong></a></p> \n<p>— <a href=\"https://twitter.com/danilop\">Danilo</a></p>","author":"Danilo Poccia","siteTitle":"AWS News Blog","siteHash":"6093e072e4117ec22616e844cb857d03ca62c57a411a8affc77cb5e8b6b15bf6","entryHash":"86da57f8b2487638ba782b3ccdce66fb6bf79b11504b9994d0ee2891733bf745","category":"Tech"}