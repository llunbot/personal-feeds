{"title":"Announcing the Public Beta of HCP Packer","link":"https://www.hashicorp.com/blog/announcing-the-public-beta-of-hcp-packer","date":1634659200000,"content":"<p>Today, we are announcing the <a href=\"https://cloud.hashicorp.com/packer\">public beta of HCP Packer</a>. This offering is free, and lets DevOps teams track and automate build updates across their Packer and Terraform workflows. In this post, we’ll show you some of the ways that HCP Packer can help improve the machine image management process throughout your organization.</p>\n<p><a href=\"https://packer.io\">HashiCorp Packer</a> enables teams to create identical machine images for multiple clouds from a single source configuration. The single source is important because these images are built on top of base images, such as the ones that build an operating system or handle system-level security. But as images are provisioned across deployments, it can be difficult to figure out who maintains what, how images have changed over time, where they are deployed, and how to update them. This is especially problematic when performing critical system updates or resolving security issues.</p>\n<p>HCP Packer addresses those issues by helping DevOps teams automate build management across provisioning pipelines. To note: it’s not just “Packer in the cloud.” HCP Packer lets your team integrate custom metadata into your existing Packer images, which is then used to track how those images are used across other images and throughout deployments.</p>\n<p>This is a critical part of any multi-cloud environment because it helps you track the lifecycle of images across clouds, and automate image updates across the Packer and Terraform lifecycle.</p>\n<h2><a href=\"#track-the-lifecycle-of-images-across-clouds\">»</a><a></a>Track the Lifecycle of Images Across Clouds</h2>\n<p>You can’t standardize what you can’t track. By connecting your existing Packer builds to HCP Packer, you will be able to see pertinent metadata about an image, such as who maintains it and its associated version control repos. Critically, HCP Packer also tracks every iteration of that image. With this information available via the UI or API, your team can track the downstream builds that leverage this image iteration across cloud environments. If an image is used by multiple teams within an organization, you’ll know exactly where updates will need to be made.</p>\n<p>The image below shows how HCP Packer tracks images and their iterations across clouds.</p><img src=\"https://www.datocms-assets.com/2885/1634314948-hcp-packer-image-tracking.png\" /><h2><a href=\"#automate-image-updates-across-the-packer-and-terraform-lifecycle\">»</a><a></a>Automate Image Updates Across the Packer and Terraform Lifecycle</h2>\n<p>Understanding what builds are impacted by configuration changes is helpful. The next step is making this information actionable. How can you ensure that all of an image’s downstream builds are appropriately updated, especially in the case of security incidents? If teams want to use the most stable version of an image, how can you ensure that they will always be able to use the appropriate iteration?</p>\n<p>HCP Packer comes with a powerful feature called <a href=\"https://cloud.hashicorp.com/docs/packer/manage-image-use\">channels</a>. With channels, DevOps teams can automate changes dynamically across child images as well as your entire provisioning pipeline. Simply create labels for images that indicate the stability and nature of a build. Then, pin a specific iteration of an image to that channel. When you reference the channel name across your builds, they will use this image iteration. If a more stable version of that image emerges, pin this new image iteration to the channel. When you run <code>packer build</code> or <code>terraform apply</code>, the build will automatically update with the new image. Here’s how that works:</p>\n<h3><a href=\"#building-images-from-a-base-image\">»</a><a></a>Building Images From a Base Image</h3>\n<p>Often organizations use one or several base images within all images across deployments. These are often called “golden images,” and may include a specific operating system or critical security tools like <a href=\"https://www.vaultproject.io/\">HashiCorp Vault</a>. HCP Packer introduces a new data source for Packer images, allowing your teams to reference these images dynamically within other child images’ Packer configurations. Here is an example of a how a child image can be built on top of a golden image that is being tracked in HCP Packer:</p><pre><code>data \"packer-artifact-registry\" \"base-image\" {\n\tImage_name\t= \"base-hardened-ubuntu-18.04\"\n\tImage_version = \"latest\"\n\tcloud \t= \"amazon\"\n}\n\nsource \"amazon-ebs\" \"marketing-layer-2\" {\n\tsource_ami \t= data.packer-artifact-registry.base-image.id\n\tfource_deregister = true\n\tinstance_type \t= \"t2.small\"\n\tssh_username = \"ubuntu\"\n\tami_name \t= \"custom-secondary-image-redis-server\"\n}</code></pre><p>Referencing golden images with data from HCP Packer ensures a higher level of standardization across your organization’s deployments.</p>\n<h3><a href=\"#integrating-with-terraform-provisioning-pipelines\">»</a><a></a>Integrating with Terraform Provisioning Pipelines</h3>\n<p>Recently, we announced that<a href=\"https://www.hashicorp.com/blog/announcing-hashicorp-packer-1-5-with-hcl2-support\"> Packer templates can now be written in HashiCorp Configuration Language (HCL)</a>. With this change, your teams can use the same familiar language and syntax across both the multi-cloud infrastructure you provision and the images built on top of it. HCP Packer takes this a step further, allowing you to reference and update images within your provisioning pipelines, reducing manual work for you and your team.</p>\n<p>Using the <a href=\"https://registry.terraform.io/providers/hashicorp/hcp/latest/docs\">HCP provider for Terraform</a> and HCP Packer channels, your organization can ensure that every provisioning pipeline uses the appropriate images at all times. Simply reference HCP Packer channel names with the provider, and then trigger a new Terraform run every time an image is updated using Terraform Cloud. If this HCL is plugged into a Terraform configuration, this provisioning pipeline will always use the “production” iteration of an Ubuntu Packer image:</p><pre><code>data \"hcp_packer_iteration\" \"ubuntu\"  {\n\tBucket_name\t=  \"learn-packer-ubuntu\"\n\tChannel\t=  \"production\"\n}\n\ndata \"hcp_packer_image\" \"ubuntu-aws-west\"  {\nbucket_name\t= \"learn-packer-ubuntu\"\n\tcloud_provider =  \"aws\"\n\titeration_id    \t=  \"data.hcp_packer_iteration.ubuntu.id\"\n\tregion\t\t=  \"us-west-2\"\n}</code></pre><p>In the configuration above you can see an example of these channel names being referenced in the HCP Packer provider for Terraform.</p>\n<h3><a href=\"#getting-started-with-hcp-packer\">»</a><a></a>Getting Started with HCP Packer</h3>\n<p>Try HCP Packer today and introduce more automation to your builds. To get started, <a href=\"https://cloud.hashicorp.com/packer\">sign up for HCP Packer</a> for free and check out <a href=\"https://learn.hashicorp.com/collections/packer/hcp-get-started\">the Packer tutorial collection on HashiCorp Learn</a>. You will learn to integrate HCP Packer into your existing images and update these base images across child images and your Terraform provisioning pipelines.</p>\n<p>If you are a Terraform Cloud Business customer and would like to discuss using HCP Packer at scale, contact your HashiCorp Customer Success Manager.</p>","author":"Michelle Greer","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"4a706774f6e9dfcf3a167c9f7ee6dddd27786ba9030d05d16b258508d8957c09","category":"Tech"}