{"title":"A Kubernetes User's Guide to HashiCorp Nomad Secret Management","link":"https://www.hashicorp.com/blog/a-kubernetes-user-s-guide-to-hashicorp-nomad-secret-management","date":1628623800000,"content":"<p>Both Kubernetes and HashiCorp Nomad are mature orchestrators used for managing the lifecycle of containerized applications. We recently created a comparison and mapping of concepts between Kubernetes and HashiCorp Nomad in another guide titled: <a href=\"https://www.hashicorp.com/blog/a-kubernetes-user-s-guide-to-hashicorp-nomad\">A Kubernetes User's Guide to HashiCorp Nomad</a>. If you’re familiar with Kubernetes but not with Nomad, that guide will provide helpful context for this guide.</p>\n<p>This guide is a continuation of the earlier guide focusing on the topic of secrets management; a major competency required for cloud security. A secret, in this context, means any sensitive information that you want to tightly control access to, such as API keys, passwords, OAuth tokens, certificates, and SSH keys.</p>\n<p>First, we will compare the native secrets management functionality of Kubernetes to HashiCorp Vault. Then we will outline how Vault integrates with Kubernetes and Nomad.</p>\n<h2><a href=\"#kubernetes-secrets\">»</a><a></a>Kubernetes Secrets</h2>\n<p>In Kubernetes, a <a href=\"https://kubernetes.io/docs/concepts/configuration/secret/\">Secret</a> is an object that is used to store sensitive information as unencrypted base64-encoded strings. It can be mounted as a file on containers, made available as environment variables in the Pod, or retrieved when the image is pulled for the Pod.</p><img src=\"https://www.datocms-assets.com/2885/1628621977-k8s-secrets.png\" /><p>Secrets are stored in <a href=\"https://etcd.io/\">etcd</a>, the central key-value store for Kubernetes cluster data. This storage approach allows users to create one Secret that can then be referenced by any number of Pods.</p>\n<p>Kubernetes secrets are static as they are generated in preparation for an application by users, not dynamically when the Pod initializes, and remain the same for long periods of time. While Kubernetes’s native capabilities enable a simple mechanism for users to store and retrieve sensitive data, its limitations could cause serious issues when deploying containers at scale in production.</p>\n<h3><a href=\"#limitations\">»</a><a></a>Limitations</h3>\n<p>First, Kubernetes secrets are base64 encoded, not encrypted. By default, they are available to anyone with API access or anyone with access to etcd running in the control plane.</p>\n<p>More importantly, there is no lease or time-to-live with these secrets. They never expire and will remain in place until deleted even if the application using the secret has been removed or deleted from production.</p>\n<p>For these reasons above, most Kuberentes users turn to external solutions to help them achieve better security. Among many secret management tools, <a href=\"https://www.vaultproject.io/\">HashiCorp Vault</a> has <a href=\"https://radar.cncf.io/2021-02-secrets-management\">the broadest adoption</a> across many companies and industries.</p>\n<h2><a href=\"#hashicorp-vault\">»</a><a></a>HashiCorp Vault</h2>\n<p>HashiCorp Vault provides a centralized secrets repository that encrypts data by default during transit and at rest. Vault provides options for static secrets, <a href=\"https://www.hashicorp.com/blog/why-we-need-dynamic-secrets\">dynamic credentials</a>, and has <a href=\"https://www.vaultproject.io/docs/secrets\">many plugins</a> for extending core functionality. In addition,  Vault has built-in mechanisms for secret renewal, rotation, and revocation, along with logging, monitoring, and telemetry support. The goal is to give you a centralized place to manage secrets using a common workflow across your applications.</p>\n<p>Vault is built around a few core concepts.</p>\n<h3><a href=\"#core-concepts\">»</a><a></a>Core Concepts</h3>\n<p><strong>Secrets</strong>: Vault stores, generates, or encrypts secrets via <a href=\"https://www.vaultproject.io/docs/secrets\">secret engines</a>. Vault can generate dynamic secrets on-demand. With dynamic secrets, users delegate the responsibility for creating and managing the lifecycle of a secret to Vault.</p>\n<p><strong>Policies</strong>: Vault uses policies to manage and safeguard access and secret distribution to applications and infrastructure. Security teams write Vault policies to define which secrets and operations an authenticated user or machine can perform.</p>\n<p><strong>Authentication</strong>: Before a user or machine can interact with Vault, it must authenticate against an authentication backend. Once authenticated, a Vault token is returned to the user/machine with any attached policies that grant the token a set of permissions.</p>\n<p><strong>Encryption</strong>: Vault was built with the belief that everything should be encrypted at all times if possible. So it uses ciphertext wrapping to <a href=\"https://www.hashicorp.com/blog/how-vault-encrypts-application-data-during-transit-and-at-rest\">encrypt all data at rest and in-transit</a>. This minimizes the exposure of secrets and sensitive information.</p><img src=\"https://www.datocms-assets.com/2885/1628621855-how-vault-works-3.png\" /><h2><a href=\"#kubernetes-and-vault-integrations\">»</a><a></a>Kubernetes and Vault Integrations</h2>\n<p>Vault can be integrated to store and manage access to secrets for Kubernetes in <a href=\"https://www.vaultproject.io/docs/platform/k8s\">a number of ways</a>. When integrated, Vault will broker access to secrets and the system instead of having Kubernetes use its native capabilities that allow Pods to use shared static credentials for things like database access.</p>\n<h3><a href=\"#authentication-with-vault\">»</a><a></a>Authentication with Vault</h3>\n<p>Kubernetes has its own implementation of authentication and authorization. In Kubernetes, a Role contains a set of permissions and it can be granted to a human User that interacts with Kuberentes clusters or a Service Account, which provides an identity for Pods running in the cluster. Users and Pods can use those identities (service account credentials) as a mechanism to authenticate to the API and issue requests.</p>\n<p>Vault comes with a pluggable authentication backend to allow information to be verified by external authentication providers, such as GitHub, LDAP, IAM, etc. Vault supports the Kubernetes authentication method and the actual authentication is delegated to Kuberentes. Users need to map the identity data in Kubernetes to a set of Vault policies.</p><img src=\"https://www.datocms-assets.com/2885/1628621945-k8s-auth-with-vault.png\" /><p>Pods can use a Kuberentes service account token to authenticate to Vault. Vault verifies this token against Kubernetes' TokenReviewer API. If the token is valid, Vault maps the Pod’s identity to a Vault policy using the mapping configured previously. Vault returns an internally managed Vault Token to the Pod, attaching the correct policies assigned.</p>\n<h3><a href=\"#dynamic-secrets-with-vault\">»</a><a></a>Dynamic Secrets with Vault</h3>\n<p>Vault can generate dynamic secrets on-demand and manage the lifecycle of a dynamic secret for users. When the frontend Pod needs to access a backend database, the Pod will ask Vault. Vault, acting as a broker, will connect to the database and generate a set of unique credentials with a limited scope and lifetime. Vault then grants one of the credentials to this Pod. Vault will automatically rotate the credentials and revoke the access when they are no longer needed.</p><img src=\"https://www.datocms-assets.com/2885/1628621952-k8s-dynamic-secrets-vault.png\" /><h3><a href=\"#vault-agent-injector-and-annotation\">»</a><a></a>Vault Agent Injector and Annotation</h3>\n<p>From an implementation perspective, the authentication and secret retrieval described above can be automated by <a href=\"https://www.vaultproject.io/docs/platform/k8s/injector\">Vault Agent injector</a> and Pod annotations. The injector is a <a href=\"https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/\">Kubernetes Mutation Webhook Controller</a>, which can be automatically installed and configured using the official <a href=\"https://github.com/hashicorp/vault-helm\">Vault Helm chart</a>.</p><p>The controller intercepts events related to creating or updating Pods. Users add secret-related annotations into the Pod spec. When the injector parses an event and finds annotations in the Pod spec, the injector will modify the deployment spec to include Vault agent containers into the Pod.</p>\n<p>The Vault agent containers can render secrets to a shared memory volume in the Pod using Vault Agent Templates. Users can define what secrets they want and how to render them with templating configurations. In this way, secrets are automatically available for the containers in the same Pod and the containers are not required to be aware of Vault's existence.</p><img src=\"https://www.datocms-assets.com/2885/1628621984-vault-agent-injector-annotation.png\" /><h2><a href=\"#nomad-and-vault-integration\">»</a><a></a>Nomad and Vault Integration</h2>\n<p>Unlike Kubernetes, Nomad is designed to focus solely on cluster management and scheduling. It makes no attempt to provide its own native secrets management capabilities and delegates that, along with role-based-access control, to Vault or whatever external authentication providers you choose.</p>\n<p>Similar to Kubernetes, Nomad doesn’t run Vault for you. Users will need to configure and install Vault separately. However,Nomad’s native integration with Vault allows users to take full advantage of Vault’s capabilities in secret management and enables simplified operations for users. Nomad server and client agents coordinate with Vault to <a href=\"https://learn.hashicorp.com/tutorials/nomad/vault-nomad-secrets?in=nomad/integrate-vault\">derive a Vault token</a>, extract the policies attached to it, make the token available to the task, and handle the token’s renewal.</p>\n<p>Enabling Vault integration with Nomad only requires configuration for the location of the Vault service and a Vault token in a Nomad server’s configuration file. The policy attached to the token must enable the Nomad server to perform a basic set of operations for Vault integration.</p><pre><code>vault {\n  enabled = true\n  address = \"http://active.vault.service.consul:8200\"\n  task_token_ttl = \"1h\"\n  create_from_role = \"nomad-cluster\"\n  token = \"\"\n  namespace = \"\"\n}</code></pre><p>In terms of authentication, Nomad delegates the responsibility to Vault. Because Vault supports a number of authentication backends, Nomad can leverage an organization's existing workflows where users or application platforms authenticate with a pre-existing provider (LDAP, Okta, Amazon IAM, etc) to obtain Nomad tokens. This saves you from implementing a new authentication method, its roles, and mechanisms (i.e. Namespaces and Service Accounts) as required by Kubernetes.</p>\n<p>Using the same example as before, a frontend application (task) wants to access a backend database. In the Nomad job spec, which defines the deployment of the frontend application, users just need to add two additional blocks:</p>\n<p><strong>Vault stanza</strong>: The Vault policy <code>access-db</code> allows it to retrieve credentials to access the database. Nomad will automatically retrieve a Vault token for the task and handle token renewal for the task.</p><pre><code>vault {\n  policies = [\"access-tables\"]\n}</code></pre><p><strong>Template stanza</strong>: Similar to a Vault agent template in Kubernetes, the template stanza integrates with Vault to render dynamic secrets into configuration files. The same underlying tool being used is <a href=\"https://github.com/hashicorp/consul-template\">Consul template</a>. But unlike Kubernetes, you don’t need additional Vault agent containers to run alongside the frontend application. In this example, the database credential that is provided by Vault will be encoded as a JSON string for the app to consume.</p><pre><code>template {\n\n  data = &lt;</code></pre><h2><a href=\"#conclusion-and-resources\">»</a><a></a>Conclusion and Resources</h2>\n<p>The engineers who work on Vault and Kubernetes have created a number of excellent methods for integrating the technologies for a number of different architectures and workflows. However, the process is even simpler for Vault and Nomad.</p>\n<p>Nomad's focus on only orchestration and open integration for other capabilities allows you to easily add Vault or another secrets management solution into your deployment workflow. The fact that Nomad and Vault are developed by the same company with <a href=\"https://www.hashicorp.com/tao-of-hashicorp\">common principles</a> gives extra depth and simplicity to their integration, as illustrated above. Additionally, Nomad and Vault's flexibility allow you to manage jobs and their secrets across a heterogeneous environment given Nomad’s focus on <a href=\"https://www.nomadproject.io/use-cases/non-containerized-application-orchestration\">diverse workload orchestration</a> vs Kubernetes’ container-focused approach.</p>\n<p>To learn more about how to integrate Nomad or Kubernetes with Vault, read our tutorials on HashiCorp Learn:</p>\n<ul>\n<li><a href=\"https://learn.hashicorp.com/collections/nomad/integrate-vault\">Integrate Nomad with Vault</a></li>\n<li><a href=\"https://learn.hashicorp.com/collections/vault/kubernetes\">Integrate Kubernetes with Vault</a></li>\n</ul>","author":"Lynn Frank","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"aa139799e2e20dca9bdaa80b69437a96ee4ccffe7376d85b6e583fc1169e29f5","category":"Tech"}