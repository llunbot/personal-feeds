{"title":"Longest Increasing Subsequence","link":"https://neizod.dev/2021/09/13/longest-increasing-subsequence.html","date":1631522228000,"content":"<p>โจทย์สุดพื้นฐานในเรื่อง<a href=\"//en.wikipedia.org/wiki/Dynamic_programming\">กำหนดการพลวัตร</a> ถามแค่ว่าจากอาเรย์ของจำนวนเต็มขนาดความยาว $n$ ตัว ให้หาลำดับย่อย (เลือกแบบกระโดดข้ามได้แต่ห้ามสลับตำแหน่ง) ที่ยาวที่สุด ที่สมาชิกแต่ละตัวในลำดับย่อยนั้นมีค่า<a href=\"//en.wikipedia.org/wiki/Monotonic_function#Monotonicity_in_calculus_and_analysis\">เพิ่มขึ้นโดยแท้</a> ซึ่งถ้าทำได้อย่างมีประสิทธิภาพเราจะได้อัลกอริทึมที่เร็ว $O(n \\log n)$ และอันที่จริงมันก็ไม่ยากเลยเพราะเราสามารถเขียนแค่นี้เพื่อหาขนาดของลำดับย่อยที่ยาวที่สุดได้</p>\n\n<div><div><pre><code><span>from</span> <span>bisect</span> <span>import</span> <span>bisect_left</span>\n\n<span>def</span> <span>lis_size</span><span>(</span><span>xs</span><span>):</span>\n    <span>tops</span> <span>=</span> <span>[]</span>\n    <span>for</span> <span>x</span> <span>in</span> <span>xs</span><span>:</span>\n        <span>i</span> <span>=</span> <span>bisect_left</span><span>(</span><span>tops</span><span>,</span> <span>x</span><span>)</span>\n        <span>tops</span><span>[</span><span>i</span><span>:</span><span>i</span><span>+</span><span>1</span><span>]</span> <span>=</span> <span>[</span><span>x</span><span>]</span>\n    <span>return</span> <span>len</span><span>(</span><span>tops</span><span>)</span>\n</code></pre></div></div>\n\n<p>อย่างไรก็ตามมันจะมีจุดที่งงๆ เวลาที่เราไม่ได้ต้องการหาแค่ขนาดของลำดับย่อย แต่ยังต้องการไล่สมาชิกทุกตัวในลำดับที่ว่านั้นด้วย เพราะตัวแปร <code>tops</code> ในโค้ดข้างต้นนั้นมัน<strong>ไม่ได้</strong>เก็บลำดับดังกล่าว แต่ <code>tops[k-1]</code> จะเก็บเพียงแค่สมาชิกตัวสุดท้ายที่มีขนาดเล็กที่สุดเมื่อต้องการสร้างลำดับย่อยความยาว <code>k</code> ซึ่งการสร้างลำดับย่อยความยาวอื่นๆ อาจจะมีหรือไม่มี <code>tops[k-1]</code> ก็ได้ … อนึ่งถ้าไปดู<a href=\"//en.wikipedia.org/wiki/File:LISDemo.gif\">แอนิเมชันใน WikiPedia</a> ก็อาจสับสนจนเข้าใจไปว่าเราต้องทำกำหนดการพลวัตรบนตาราง 2 มิติเพื่อแก้ปัญหานี้หรือเปล่า ซึ่งไม่ใช่เลยเพราะเราใช้ตารางมิติเดียวก็เพียงพอแล้ว</p>\n\n<p>และอันที่จริงมันน่าจะมีวิธีอธิบายให้เห็นภาพได้กระจ่างแจ้งง่ายดายกว่านั้น เช่นการใช้โครงสร้างข้อมูลแบบ<a href=\"//en.wikipedia.org/wiki/Tree_(graph_theory)#Rooted_tree\">ต้นไม้มีราก</a>มาอธิบายประกอบ โดยเราจะไล่จับสมาชิกแต่ละตัวในอาเรย์ตั้งต้นมาสร้างเป็นโหนดต่อลงไปในต้นไม้ ซึ่งโหนดใหม่แต่ละโหนดที่เพิ่มเข้ามานั้นจะพยายามไปอยู่ ณ ความลึกที่ต่ำที่สุดที่มันมีค่าไม่น้อยกว่าโหนดเดิมในต้นไม้ แต่ที่ระดับความลึกหนึ่งๆ มันจะมองเห็นแค่โหนดที่เล็กที่สุดในระดับนั้นเท่านั้น</p>\n\n<blockquote>\n  <p><img src=\"/images/algorithm/lis/construct.svg\" /></p>\n\n  <p>ตัวอย่างการใช้ต้นไม้มาช่วยอธิบายการสร้างลำดับย่อยค่าเพิ่มขึ้นที่ยาวที่สุด</p>\n</blockquote>\n\n<p>หรือก็คือเขียนเป็นโค้ดเพิ่มอีกนิดหน่อยได้ดังนี้</p>\n\n<div><div><pre><code><span>from</span> <span>math</span> <span>import</span> <span>inf</span>\n<span>from</span> <span>bisect</span> <span>import</span> <span>bisect_left</span>\n<span>from</span> <span>collections</span> <span>import</span> <span>namedtuple</span>\n\n<span>Node</span> <span>=</span> <span>namedtuple</span><span>(</span><span>'Node'</span><span>,</span> <span>'value prevent_eq parent'</span><span>,</span> <span>defaults</span><span>=</span><span>(</span><span>-</span><span>inf</span><span>,</span> <span>-</span><span>inf</span><span>,</span> <span>None</span><span>))</span>\n<span>Node</span><span>.</span><span>ancestors</span> <span>=</span> <span>lambda</span> <span>s</span><span>:</span> <span>(</span> <span>[]</span> <span>if</span> <span>s</span><span>.</span><span>parent</span> <span>is</span> <span>None</span> <span>else</span>\n                             <span>s</span><span>.</span><span>parent</span><span>.</span><span>ancestors</span><span>()</span> <span>+</span> <span>[</span><span>s</span><span>.</span><span>value</span><span>]</span> <span>)</span>\n\n<span>def</span> <span>lis</span><span>(</span><span>xs</span><span>):</span>\n    <span>tops</span> <span>=</span> <span>[</span><span>Node</span><span>()]</span>\n    <span>for</span> <span>key</span><span>,</span> <span>x</span> <span>in</span> <span>enumerate</span><span>(</span><span>xs</span><span>):</span>\n        <span>i</span> <span>=</span> <span>bisect_left</span><span>(</span><span>tops</span><span>,</span> <span>Node</span><span>(</span><span>x</span><span>))</span>\n        <span>tops</span><span>[</span><span>i</span><span>:</span><span>i</span><span>+</span><span>1</span><span>]</span> <span>=</span> <span>[</span><span>Node</span><span>(</span><span>x</span><span>,</span> <span>-</span><span>key</span><span>,</span> <span>tops</span><span>[</span><span>i</span><span>-</span><span>1</span><span>])]</span>\n    <span>return</span> <span>tops</span><span>[</span><span>-</span><span>1</span><span>].</span><span>ancestors</span><span>()</span>\n</code></pre></div></div>\n\n<p>แต่นั่นก็อาจไม่ใช่คำตอบเดียวที่เป็นไปได้ของลำดับย่อยที่ยาวที่สุด ถ้าเรากลับไปดูขั้นตอนการเพิ่มโหนดลงต้นไม้ที่ต้องชี้กลับไปหาโหนด <code>parent</code> ในความลึกก่อนหน้า เราจะพบว่ามันไม่จำเป็นต้องชี้ไปโหนดที่มีค่าน้อยสุดเท่านั้น แต่โหนดใหม่นี้สามารถชี้ไปยังโหนดเดิมโหนดไหนก็ได้ที่มีค่าน้อยกว่ามันเลย หรือในอีกแง่หนึ่งคือเราจะไม่สร้างต้นไม้แล้ว แต่สร้างเป็นกราฟมีทิศทางแบ่งเป็นเลเยอร์ตามระดับความลึกแทน โดยให้โหนดใหม่ที่เพิ่มเข้ามาชี้กลับไปยังทุกโหนด <code>parents</code> ในความลึกก่อนหน้าที่มีค่าน้อยกว่านั่นเอง</p>\n\n<blockquote>\n  <p><img src=\"/images/algorithm/lis/distinct.svg\" /></p>\n\n  <p>ตัวอย่างคำตอบลำดับย่อยที่ยาวที่สุด โดยกรณีนี้มี 4 ลำดับย่อยที่แตกต่างกัน</p>\n</blockquote>\n\n<p>สังเกตว่าในแต่ละชั้นเราอาจชี้กลับไปหา <code>parents</code> ได้หลายตัว ดังนั้นจำนวนคำตอบลำดับย่อยที่แตกต่างกันก็อาจเพิ่มเป็น<a href=\"//en.wikipedia.org/wiki/Exponential_growth\">เอกซ์โพเนนเชียล</a>ได้ ซึ่งถ้าเราต้องการจะไล่เขียนทุกลำดับย่อยอยู่แล้วก็ไม่มีทางทำได้เร็วกว่านี้ แต่ถ้าต้องการนับแค่จำนวนคำตอบที่แตกต่างกัน เราก็อาจใช้ท่านับจำนวนดิบสะสมแล้วคำนวณเฉพาะจุดที่ต้องการเพื่อทำให้ความเร็วยังคงเป็น $O(n \\log n)$ เช่นนี้ได้</p>\n\n<div><div><pre><code><span>PreCell</span> <span>=</span> <span>namedtuple</span><span>(</span><span>'PreCell'</span><span>,</span> <span>'inv_value acc parent_index'</span><span>)</span>\n<span>Cell</span> <span>=</span> <span>namedtuple</span><span>(</span><span>'Cell'</span><span>,</span> <span>'acc value parent_index'</span><span>)</span>\n\n<span>def</span> <span>lis_signature</span><span>(</span><span>xs</span><span>):</span>\n    <span>tops</span> <span>=</span> <span>[</span><span>-</span><span>inf</span><span>]</span>\n    <span>layers</span> <span>=</span> <span>[[</span><span>PreCell</span><span>(</span><span>-</span><span>inf</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>),</span> <span>PreCell</span><span>(</span><span>inf</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>)]]</span>\n    <span>for</span> <span>x</span> <span>in</span> <span>xs</span><span>:</span>\n        <span>i</span> <span>=</span> <span>bisect_left</span><span>(</span><span>tops</span><span>,</span> <span>x</span><span>)</span>\n        <span>tops</span><span>[</span><span>i</span><span>:</span><span>i</span><span>+</span><span>1</span><span>]</span> <span>=</span> <span>[</span><span>x</span><span>]</span>\n        <span>if</span> <span>i</span> <span>==</span> <span>len</span><span>(</span><span>layers</span><span>):</span>\n            <span>layers</span> <span>+=</span> <span>[[</span><span>PreCell</span><span>(</span><span>-</span><span>inf</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)]]</span>\n        <span>j</span> <span>=</span> <span>bisect_left</span><span>(</span><span>layers</span><span>[</span><span>i</span><span>-</span><span>1</span><span>],</span> <span>PreCell</span><span>(</span><span>-</span><span>x</span><span>,</span> <span>inf</span><span>,</span> <span>inf</span><span>))</span>\n        <span>c</span> <span>=</span> <span>layers</span><span>[</span><span>i</span><span>-</span><span>1</span><span>][</span><span>-</span><span>1</span><span>].</span><span>acc</span> <span>-</span> <span>layers</span><span>[</span><span>i</span><span>-</span><span>1</span><span>][</span><span>j</span><span>-</span><span>1</span><span>].</span><span>acc</span> <span>+</span> <span>layers</span><span>[</span><span>i</span><span>][</span><span>-</span><span>1</span><span>].</span><span>acc</span>\n        <span>layers</span><span>[</span><span>i</span><span>]</span> <span>+=</span> <span>[</span><span>PreCell</span><span>(</span><span>-</span><span>x</span><span>,</span> <span>c</span><span>,</span> <span>j</span><span>)]</span>\n    <span>return</span> <span>[[</span><span>Cell</span><span>(</span><span>c</span><span>,</span> <span>-</span><span>x</span><span>,</span> <span>j</span><span>)</span> <span>for</span> <span>x</span><span>,</span> <span>c</span><span>,</span> <span>j</span> <span>in</span> <span>layer</span><span>]</span> <span>for</span> <span>layer</span> <span>in</span> <span>layers</span><span>]</span>\n\n<span>def</span> <span>lis_count</span><span>(</span><span>xs</span><span>):</span>\n    <span>return</span> <span>lis_signature</span><span>(</span><span>xs</span><span>)[</span><span>-</span><span>1</span><span>][</span><span>-</span><span>1</span><span>].</span><span>acc</span>\n</code></pre></div></div>\n\n<p>และถึงแม้ว่าจำนวนวิธีที่แตกต่างกันจะมีขนาดใหญ่โตแบบเอกซ์โพเนนเชียล แต่หนึ่งในมุมมองที่น่าสนใจต่อปัญหาประเภทที่มีเซตคำตอบใหญ่จนไม่สามารถไล่เขียนครบทุกวิธีได้ คือการเลือกเขียนเฉพาะบางวิธีที่แตกต่างกัน ณ ดัชนีต่างๆ ที่เราสนใจ ซึ่งเราควรทำตรงนี้ให้ได้เร็ว เช่น เร็ว $O(n)$ ต่อการไล่เขียนหนึ่งวิธีที่เป็นไปได้เมื่อมีการคำนวณคุณลักษณะของอาเรย์ตั้งต้นเก็บไว้ก่อนแล้ว โค้ดต่อไปนี้เป็นหนึ่งในวิธีไล่ดัชนีของลำดับย่อยจากหลังมาหน้าให้ไม่ซ้ำกัน</p>\n\n<div><div><pre><code><span>def</span> <span>lis_index</span><span>(</span><span>xs</span><span>,</span> <span>index</span><span>=</span><span>0</span><span>):</span>\n    <span>assert</span> <span>0</span> <span>&lt;=</span> <span>index</span> <span>&lt;</span> <span>lis_count</span><span>(</span><span>xs</span><span>)</span>\n    <span>signature</span> <span>=</span> <span>lis_signature</span><span>(</span><span>xs</span><span>)</span>\n    <span>parent_index</span> <span>=</span> <span>0</span>\n    <span>ys</span> <span>=</span> <span>[]</span>\n    <span>for</span> <span>layer</span> <span>in</span> <span>reversed</span><span>(</span><span>signature</span><span>[</span><span>1</span><span>:]):</span>\n        <span>index</span> <span>+=</span> <span>layer</span><span>[</span><span>parent_index</span><span>].</span><span>acc</span>\n        <span>locate_index</span> <span>=</span> <span>bisect_left</span><span>(</span><span>layer</span><span>,</span> <span>Cell</span><span>(</span><span>index</span><span>,</span> <span>inf</span><span>,</span> <span>inf</span><span>))</span>\n        <span>index</span> <span>-=</span> <span>layer</span><span>[</span><span>locate_index</span><span>-</span><span>1</span><span>].</span><span>acc</span>\n        <span>parent_index</span> <span>=</span> <span>layer</span><span>[</span><span>locate_index</span><span>].</span><span>parent_index</span> <span>-</span> <span>1</span>\n        <span>ys</span> <span>+=</span> <span>[</span><span>layer</span><span>[</span><span>locate_index</span><span>].</span><span>value</span><span>]</span>\n    <span>return</span> <span>ys</span><span>[::</span><span>-</span><span>1</span><span>]</span>\n</code></pre></div></div>\n\n<p>ป.ล. ขอบคุณ <a href=\"//twitter.com/public_lewcpe\">@lewcpe</a> ที่มาแนะนำโมดูล <code>bisect</code> ใน Python ทำให้ไม่ต้องกังวลเวลาจะเขียน<a href=\"//en.wikipedia.org/wiki/Binary_search_algorithm\">การค้นหาแบบทวิภาค</a>แล้ว 😂</p>","author":"","siteTitle":"neizod's speculation","siteHash":"939338c5557b1743f2c128736c6006e145dcabc81da9970f1c0dc8ae2feb0830","entryHash":"0212b004e6c1905e898540a5a39742df12449d6751e17178b91fc9e2e7f96b6a","category":"Thai"}