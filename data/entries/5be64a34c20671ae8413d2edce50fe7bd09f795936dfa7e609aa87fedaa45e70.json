{"title":"Useful React Hooks That You Can Use In Your Projects","link":"https://smashingmagazine.com/2021/11/useful-react-hooks/","date":1636711200000,"content":"<p>Hooks are simply functions that allow you to <strong>hook into</strong> or <strong>make use of</strong> React features. They were introduced at the <a href=\"https://www.youtube.com/watch?v=dpw9EHDh2bM\">React Conf 2018</a> to address three major problems of class components: wrapper hell, huge components, and confusing classes. Hooks give power to React functional components, making it possible to develop an entire application with it.</p>\n<p>The aforementioned problems of class components are connected and solving one without the other could introduce further problems. Thankfully, hooks solved all the problems simply and efficiently while creating room for more interesting features in React. Hooks do not replace already existing React concepts and classes, they merely provide an API to access them directly.</p>\n<p>The React team introduced several hooks in React 16.8. However, you could also use hooks from third-party providers in your application or even create a custom hook. In this tutorial, we’ll take a look at some useful hooks in React and how to use them. We’ll go through several code examples of each hook and also explore how you’d create a custom hook.</p>\n<p><strong>Note:</strong> <em>This tutorial requires a basic understanding of Javascript (ES6+) and React.</em></p>\nMotivation Behind Hooks\n<p>As stated earlier, hooks were created to solve three problems: wrapper hell, huge components, and confusing classes. Let’s take a look at each of these in more detail.</p>\n<h3>Wrapper Hell</h3>\n<p>Complex applications built with class components easily run into wrapper hell. If you examine the application in the React Dev Tools, you will notice deeply nested components. This makes it very difficult to work with the components or debug them. While these problems could be solved with <strong>higher-order components</strong> and <strong>render props</strong>, they require you to modify your code a bit. This could lead to confusion in a complex application. </p>\n<p>Hooks are easy to share, you don’t have to modify your components before reusing the logic.</p>\n<p>A good example of this is the use of the Redux <code>connect</code> Higher Order Component (HOC) to subscribe to the Redux store. Like all HOCs, to use the connect HOC, you have to export the component alongside the defined higher-order functions. In the case of <code>connect</code>, we’ll have something of this form.</p>\n<pre><code>export default connect(mapStateToProps, mapDispatchToProps)(MyComponent)</code></pre>\n\n<p>Where <code>mapStateToProps</code> and <code>mapDispatchToProps</code> are functions to be defined. </p>\n<p>Whereas in the Hooks era, one can easily achieve the same result neatly and succinctly by using the Redux <code>useSelector</code> and <code>useDispatch</code> hooks.</p>\n<h3>Huge Components</h3>\n<p>Class components usually contain side effects and stateful logic. As the application grows in complexity, it is common for the component to become messy and confusing. This is because the side effects are expected to be organized by <strong>lifecycle methods</strong> rather than functionality. While it is possible to split the components and make them simpler, this often introduces a higher level of abstraction.</p>\n<p>Hooks organize side effects by functionality and it is possible to split a component into pieces based on the functionality.</p>\n<h3>Confusing Classes</h3>\n<p>Classes are generally a more difficult concept than functions. React class-based components are verbose and a bit difficult for beginners. If you are new to Javascript, you could find functions easier to get started with because of their lightweight syntax as compared to classes. The syntax could be confusing; sometimes, it is possible to forget binding an event handler which could break the code.</p>\n<p>React solves this problem with functional components and hooks, allowing developers to focus on the project rather than code syntax.</p>\n<p>For instance, the following two React components will yield exactly the same result.</p>\n<pre><code>import React, { Component } from \"react\";\nexport default class App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      num: 0\n    };\n    this.incrementNumber = this.incrementNumber.bind(this);\n  }\n  incrementNumber() {\n    this.setState({ num: this.state.num + 1 });\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;{this.state.num}&lt;/h1&gt;\n        &lt;button onClick={this.incrementNumber}&gt;Increment&lt;/button&gt;\n      &lt;/div&gt;\n    );\n  }\n}</code></pre>\n\n<pre><code>import React, { useState } from \"react\";\nexport default function App() {\n  const [num, setNum] = useState(0);\n  function incrementNumber() {\n    setNum(num + 1);\n  }\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;{num}&lt;/h1&gt;\n      &lt;button onClick={incrementNumber}&gt;Increment&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</code></pre>\n\n<p>The first example is a class-based component while the second is a functional component. Although this is a simple example, notice how bogus the first example is compared to the second.</p>\nThe Hooks Convention And Rules\n<p>Before delving into the various hooks, it could be helpful to take a look at the convention and rules that apply to them. Here are some of the rules that apply to hooks.</p>\n<ol>\n<li>The naming convention of hooks should start with the prefix <code>use</code>. So, we can have <code>useState</code>, <code>useEffect</code>, etc. If you are using modern code editors like Atom and VSCode, the ESLint plugin could be a very useful feature for React hooks. The plugin provides useful warnings and hints on the best practices.</li>\n<li>Hooks must be called at the top level of a component, before the return statement. They can't be called inside a conditional statement, loop, or nested functions.</li>\n<li>Hooks must be called from a React function (inside a React component or another hook). It shouldn’t be called from a Vanilla JS function.</li>\n</ol>\nThe <code>useState</code> Hook\n<p>The <code>useState</code> hook is the most basic and useful React hook. Like other built-in hooks, this hook must be imported from <code>react</code> to be used in our application.</p>\n<pre><code>import {useState} from 'react'</code></pre>\n\n<p>To initialize the state, we must declare both the state and its updater function and pass an initial value.</p>\n<pre><code>const [state, updaterFn] = useState('')</code></pre>\n\n<p>We are free to call our state and updater function whatever we want but by convention, the first element of the array will be our state while the second element will be the updater function. It is a common practice to prefix our updater function with the prefix <strong>set</strong> followed by the name of our state in camel case form.</p>\n<p>For instance, let’s set a state to hold count values.</p>\n<pre><code>const [count, setCount] = useState(0)</code></pre>\n\n<p>Notice that the initial value of our <code>count</code> state is set to <code>0</code> and not an empty string. In other words, we can initialize our state to any kind of JavaScript variables, namely number, string, boolean, array, object, and even BigInt. There is a clear difference between setting states with the <code>useState</code> hook and class-based component states. It is noteworthy that the <code>useState</code> hook returns an array, also known as state variables and in the example above, we destructured the array into <code>state</code> and the <code>updater</code> function.</p>\n<h3>Rerendering Components</h3>\n<p>Setting states with the <code>useState</code> hook causes the corresponding component to rerender. However, this only happens if React detects a difference between the previous or old state and the new state. React does the state comparison using the Javascript <code>Object.is</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#description\">algorithm</a>. </p>\n<h3>Setting States With <code>useState</code></h3>\n<p>Our <code>count</code> state can be set to new state values by simply passing the new value to the <code>setCount</code> updater function as follows <code>setCount(newValue)</code>. </p>\n<p>This method works when we don't want to reference the previous state value. If we wish to do that, we need to pass a function to the <code>setCount</code> function.</p>\n<p>Assuming we want to add 5 to our <code>count</code> variable anytime a button is clicked, we could do the following.</p>\n<pre><code>import {useState} from 'react'\n\nconst CountExample = () =&gt; {\n  // initialize our count state\n  const [count, setCount] = useState(0)\n\n  // add 5 to to the count previous state\n  const handleClick = () =&gt;{\n    setCount(prevCount =&gt; prevCount + 5)\n  } \n  return(\n    &lt;div&gt;\n      &lt;h1&gt;{count} &lt;/h1&gt;\n      &lt;button onClick={handleClick}&gt;Add Five&lt;/button&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport default CountExample</code></pre>\n\n<p>In the code above, we first imported the <code>useState</code> hook from <code>react</code> and then initialized the <code>count</code> state with a default value of 0. We created an <code>onClick</code> handler to increment the value of <code>count</code> by 5 whenever the button is clicked. Then we displayed the result in an <code>h1</code> tag.</p>\n<h3>Setting Arrays And Object States</h3>\n<p>States for arrays and objects can be set in much the same way as other data types. However, if we wish to retain already existing values, we need to use the ES6 spread operator when setting states.</p>\n<p>The spread operator in Javascript is used to create a new object from an already existing object. This is useful here because <code>React</code> compares the states with the <code>Object.is</code> operation and then rerender accordingly.</p>\n<p>Let’s consider the code below for setting states on button click.</p>\n<pre><code>import {useState} from 'react'\n\nconst StateExample = () =&gt; {\n  //initialize our array and object states\n  const [arr, setArr] = useState([2, 4])\n  const [obj, setObj] = useState({num: 1, name: 'Desmond'})\n\n  // set arr to the new array values\n  const handleArrClick = () =&gt;{\n    const newArr = [1, 5, 7]\n    setArr([...arr, ...newArr])\n  } \n\n  // set obj to the new object values\n  const handleObjClick = () =&gt;{\n    const newObj = {name: 'Ifeanyi', age: 25}\n    setObj({...obj, ...newObj})\n  } \n\n  return(\n    &lt;div&gt;\n      &lt;button onClick ={handleArrClick}&gt;Set Array State&lt;/button&gt;\n      &lt;button onClick ={handleObjClick}&gt;Set Object State&lt;/button&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport default StateExample</code></pre>\n\n<p>In the above code, we created two states <code>arr</code> and <code>obj</code>, and initialized them to some array and object values respectively. We then created <code>onClick</code> handlers called <code>handleArrClick</code> and <code>handleObjClick</code> to set the states of the array and object respectively. When <code>handleArrClick</code> fires, we call <code>setArr</code> and use the ES6 spread operator to spread already existing array values and add <code>newArr</code> to it.</p>\n<p>We did the same thing for <code>handleObjClick</code> handler. Here we called <code>setObj</code>, spread the existing object values using the ES6 spread operator, and updated the values of <code>name</code> and <code>age</code>.</p>\n<h3>Async Nature Of <code>useState</code></h3>\n<p>As we have already seen, we set states with <code>useState</code> by passing a new value to the updater function. If the updater is called multiple times, the new values will be added to a queue and re-rendering is done accordingly using the JavaScript <code>Object.is</code> comparison.</p>\n<p>The states are updated asynchronously. This means that the new state is first added to a pending state and thereafter, the state is updated. So, you may still get the old state value if you access the state immediately it is set.</p>\n<p>Let’s consider the following example to observe this behavior.</p>\n\n\n<p>In the code above, we created a <code>count</code> state using the <code>useState</code> hook. We then created an <code>onClick</code> handler to increment the <code>count</code> state whenever the button is clicked.\nObserve that although the <code>count</code> state increased, as displayed in the <code>h2</code> tag, the previous state is still logged in the console. This is due to the async nature of the hook.</p>\n<p>If we wish to get the new state, we can handle it in a similar way we would handle async functions. Here is one way to do that.</p>\n\n\n<p>Here, we stored created <code>newCountValue</code> to store the updated count value and then set the <code>count</code> state with the updated value. Then, we logged the updated count value in the console.</p>\nThe <code>useEffect</code> Hook\n<p><code>useEffect</code> is another important React hook used in most projects. It does a similar thing to the class-based component’s <code>componentDidMount</code>, <code>componentWillUnmount</code>, and <code>componentDidUpdate</code> lifecycle methods. <code>useEffect</code> provides us an opportunity to write imperative codes that may have side effects on the application. Examples of such effects include logging, subscriptions, mutations, etc.</p>\n<p>The user can decide when the <code>useEffect</code> will run, however, if it is not set, the side effects will run on every rendering or rerendering.</p>\n<p>Consider the example below.</p>\n<pre><code>import {useState, useEffect} from 'react'\n\nconst App = () =&gt;{\n  const [count, setCount] = useState(0)\n  useEffect(() =&gt;{\n    console.log(count)\n  })\n\n  return(\n    &lt;div&gt;\n      ...\n    &lt;/div&gt;\n  )\n}</code></pre>\n\n<p>In the code above, we simply logged <code>count</code> in the <code>useEffect</code>. This will run after every render of the component.</p>\n<p>Sometimes, we may want to run the hook once (on the mount) in our component. We can achieve this by providing a second parameter to <code>useEffect</code> hook.</p>\n<pre><code>import {useState, useEffect} from 'react'\n\nconst App = () =&gt;{\n  const [count, setCount] = useState(0)\n  useEffect(() =&gt;{\n    setCount(count + 1)\n  }, [])\n\n  return(\n    &lt;div&gt;\n      &lt;h1&gt;{count}&lt;/h1&gt;\n      ...\n    &lt;/div&gt;\n  )\n}</code></pre>\n\n<p>The <code>useEffect</code> hook has two parameters, the first parameter is the function we want to run while the second parameter is an array of dependencies. If the second parameter is not provided, the hook will run continuously.</p>\n<p>By passing an empty square bracket to the hook’s second parameter, we instruct React to run the <code>useEffect</code> hook only once, on the mount. This will display the value <code>1</code> in the <code>h1</code> tag because the count will be updated once, from 0 to 1, when the component mounts.</p>\n<p>We could also make our side effect run whenever some dependent values change. This can be done by passing these values in the list of dependencies.</p>\n<p>For instance, we could make the <code>useEffect</code> to run whenever <code>count</code> changes as follows.</p>\n<pre><code>import { useState, useEffect } from \"react\";\nconst App = () =&gt; {\n  const [count, setCount] = useState(0);\n  useEffect(() =&gt; {\n    console.log(count);\n  }, [count]);\n  return (\n    &lt;div&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\nexport default App;</code></pre>\n\n<p>The <code>useEffect</code> above will run when either of these two conditions is met.</p>\n<ol>\n<li>On mount — after the component is rendered. </li>\n<li>When the value of <code>count</code> changes.</li>\n</ol>\n<p>On mount, the <code>console.log</code> expression will run and log <code>count</code> to 0. Once the <code>count</code> is updated, the second condition is met, so the <code>useEffect</code> runs again, this will continue whenever the button is clicked.</p>\n<p>Once we provide the second argument to <code>useEffect</code>, it is expected that we pass all the dependencies to it. If you have <code>ESLINT</code> installed, it will show a lint error if any dependency is not passed to the parameter list. This could also make the side effect behave unexpectedly, especially if it depends on the parameters that are not passed.</p>\n<h3>Cleaning Up The Effect</h3>\n<p><code>useEffect</code> also allows us to clean up resources before the component unmounts. This may be necessary to prevent memory leaks and make the application more efficient. To do this, we’d return the clean-up function at the end of the hook.</p>\n<pre><code>useEffect(() =&gt; {\n  console.log('mounted')\n\n  return () =&gt; console.log('unmounting... clean up here')\n})</code></pre>\n\n<p>The <code>useEffect</code> hook above will log <code>mounted</code> when the component is mounted. <em>Unmounting… clean up here</em> will be logged when the component unmounts. This can happen when the component is removed from the UI.</p>\n<p>The clean-up process typically follows the form below.</p>\n<pre><code>useEffect(() =&gt; {\n  //The effect we intend to make\n  effect\n\n  //We then return the clean up\n  return () =&gt; the cleanup/unsubscription\n})</code></pre>\n\n<p>While you may not find so many use cases for <code>useEffect</code> subscriptions, it is useful when dealing with subscriptions and timers. Particularly, when dealing with web sockets, you may need to unsubscribe from the network to save resources and improve performance when the component unmounts.</p>\n<h3>Fetching And Refetching Data With <code>useEffect</code></h3>\n<p>One of the commonest use cases of the <code>useEffect</code> hook is fetching and prefetching data from an API.</p>\n<p>To illustrate this, we’ll use fake user data I created from <code>JSONPlaceholder</code> to fetch data with the <code>useEffect</code> hook.</p>\n<pre><code>import { useEffect, useState } from \"react\";\nimport axios from \"axios\";\n\nexport default function App() {\n  const [users, setUsers] = useState([]);\n  const endPoint =\n    \"https://my-json-server.typicode.com/ifeanyidike/jsondata/users\";\n\n  useEffect(() =&gt; {\n    const fetchUsers = async () =&gt; {\n      const { data } = await axios.get(endPoint);\n      setUsers(data);\n    };\n    fetchUsers();\n  }, []);\n\n  return (\n    &lt;div className=\"App\"&gt;\n      {users.map((user) =&gt; (\n            &lt;div&gt;\n              &lt;h2&gt;{user.name}&lt;/h2&gt;\n              &lt;p&gt;Occupation: {user.job}&lt;/p&gt;\n              &lt;p&gt;Sex: {user.sex}&lt;/p&gt;\n            &lt;/div&gt;\n          ))}\n    &lt;/div&gt;\n  );\n}</code></pre>\n\n<p>In the code above, we created a <code>users</code> state using the <code>useState</code> hook. Then we fetched data from an API using Axios. This is an asynchronous process, and so we used the async/await function, we could have also used the dot then the syntax. Since we fetched a list of users, we simply mapped through it to display the data.</p>\n<p>Notice that we passed an empty parameter to the hook. This ensures that it is called just once when the component mounts.</p>\n<p>We can also <strong>refetch</strong> the data when some conditions change. We’ll show this in the code below.</p>\n<pre><code>import { useEffect, useState } from \"react\";\nimport axios from \"axios\";\n\nexport default function App() {\n  const [userIDs, setUserIDs] = useState([]);\n  const [user, setUser] = useState({});\n  const [currentID, setCurrentID] = useState(1);\n\n  const endPoint =\n    \"https://my-json-server.typicode.com/ifeanyidike/userdata/users\";\n\n  useEffect(() =&gt; {\n    axios.get(endPoint).then(({ data }) =&gt; setUserIDs(data));\n  }, []);\n\n  useEffect(() =&gt; {\n    const fetchUserIDs = async () =&gt; {\n      const { data } = await axios.get(`${endPoint}/${currentID}`});\n      setUser(data);\n    };\n\n    fetchUserIDs();\n  }, [currentID]);\n\n  const moveToNextUser = () =&gt; {\n    setCurrentID((prevId) =&gt; (prevId &lt; userIDs.length ? prevId + 1 : prevId));\n  };\n  const moveToPrevUser = () =&gt; {\n    setCurrentID((prevId) =&gt; (prevId === 1 ? prevId : prevId - 1));\n  };\n  return (\n    &lt;div className=\"App\"&gt;\n        &lt;div&gt;\n          &lt;h2&gt;{user.name}&lt;/h2&gt;\n          &lt;p&gt;Occupation: {user.job}&lt;/p&gt;\n          &lt;p&gt;Sex: {user.sex}&lt;/p&gt;\n        &lt;/div&gt;\n\n      &lt;button onClick={moveToPrevUser}&gt;Prev&lt;/button&gt;\n      &lt;button onClick={moveToNextUser}&gt;Next&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</code></pre>\n\n<p>Here we created two <code>useEffect</code> hooks. In the first one, we used the dot then syntax to get all users from our API. This is necessary to determine the number of users.</p>\n<p>We then created another <code>useEffect</code> hook to get a user based on the <code>id</code>. This <code>useEffect</code> will refetch the data whenever the id changes. To ensure this, we passed the <code>id</code> in the dependency list.</p>\n<p>Next, we created functions to update the value of our <code>id</code> whenever the buttons are clicked. Once the value of the <code>id</code> changes, the <code>useEffect</code> will run again and refetch the data.</p>\n<p>If we want, we can even clean up or cancel the promise-based token in Axios, we could do that with the clean-up method discussed above.</p>\n<pre><code>useEffect(() =&gt; {\n    const source = axios.CancelToken.source();\n    const fetchUsers = async () =&gt; {\n      const { data } = await axios.get(`${endPoint}/${num}`, {\n        cancelToken: source.token\n      });\n      setUser(data);\n    };\n    fetchUsers();\n\n    return () =&gt; source.cancel();\n  }, [num]);</code></pre>\n\n<p>Here, we passed the Axios’ token as a second parameter to <code>axios.get</code>. When the component unmounts we then canceled the subscription by calling the cancel method of the source object.</p>\nThe <code>useReducer</code> Hook\n<p>The <code>useReducer</code> hook is a very useful React hook that does a similar thing to the <code>useState</code> hook. According to the <a href=\"https://reactjs.org/docs/hooks-reference.html#usereducer\">React documentation</a>, this hook should be used to handle more complex logic than the <code>useState</code> hook. It’s worthy of note that the <code>useState</code> hook is internally implemented with the useReducer hook.</p>\n<p>The hook takes a reducer as an argument and can optionally take the initial state and an init function as arguments. </p>\n<pre><code>const [state, dispatch] = useReducer(reducer, initialState, init)</code></pre>\n\n<p>Here, <code>init</code> is a function and it is used whenever we want to create the initial state lazily. </p>\n<p>Let’s look at how to implement the <code>useReducer</code> hook by creating a simple to-do app as shown in the sandbox below.</p>\n\n\n<p>First off, we should create our reducer to hold the states.</p>\n<pre><code>export const ADD_TODO = \"ADD_TODO\";\nexport const REMOVE_TODO = \"REMOVE_TODO\";\nexport const COMPLETE_TODO = \"COMPLETE_TODO\";\n\nconst reducer = (state, action) =&gt; {\n  switch (action.type) {\n    case ADD_TODO:\n      const newTodo = {\n        id: action.id,\n        text: action.text,\n        completed: false\n      };\n      return [...state, newTodo];\n    case REMOVE_TODO:\n      return state.filter((todo) =&gt; todo.id !== action.id);\n    case COMPLETE_TODO:\n      const completeTodo = state.map((todo) =&gt; {\n        if (todo.id === action.id) {\n          return {\n            ...todo,\n            completed: !todo.completed\n          };\n        } else {\n          return todo;\n        }\n      });\n      return completeTodo;\n    default:\n      return state;\n  }\n};\nexport default reducer;</code></pre>\n\n<p>We created three constants corresponding to our action types. We could have used strings directly but this method is preferable to avoid typos.</p>\n<p>Then we created our reducer function. Like in <code>Redux</code>, the reducer must take the state and the action object. But unlike Redux, we don't need to initialize our reducer here. </p>\n<p>Furthermore, for a lot of state management use-cases, a <code>useReducer</code> along with the <code>dispatch</code> exposed via context can enable a larger application to fire actions, update <code>state</code> and listen to it.</p>\n<p>Then we used the <code>switch</code> statements to check the action type passed by the user. If the action type is <code>ADD_TODO</code>, we want to pass a new to-do and if it is <code>REMOVE_TODO</code>, we want to filter the to-dos and remove the one that corresponds to the <code>id</code> passed by the user. If it is <code>COMPLETE_TODO</code>, we want to map through the to-dos and toggle the one with the <code>id</code> passed by the user.</p>\n<p>Here is the <code>App.js</code> file where we implemented the <code>reducer</code>.</p>\n<pre><code>import { useReducer, useState } from \"react\";\nimport \"./styles.css\";\nimport reducer, { ADD_TODO, REMOVE_TODO, COMPLETE_TODO } from \"./reducer\";\nexport default function App() {\n  const [id, setId] = useState(0);\n  const [text, setText] = useState(\"\");\n  const initialState = [\n    {\n      id: id,\n      text: \"First Item\",\n      completed: false\n    }\n  ];\n\n  //We could also pass an empty array as the initial state\n  //const initialState = []\n\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const addTodoItem = (e) =&gt; {\n    e.preventDefault();\n    const newId = id + 1;\n    setId(newId);\n    dispatch({\n      type: ADD_TODO,\n      id: newId,\n      text: text\n    });\n    setText(\"\");\n  };\n  const removeTodo = (id) =&gt; {\n    dispatch({ type: REMOVE_TODO, id });\n  };\n  const completeTodo = (id) =&gt; {\n    dispatch({ type: COMPLETE_TODO, id });\n  };\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;h1&gt;Todo Example&lt;/h1&gt;\n      &lt;form className=\"input\" onSubmit={addTodoItem}&gt;\n        &lt;input value={text} onChange={(e) =&gt; setText(e.target.value)} /&gt;\n        &lt;button disabled={text.length === 0} type=\"submit\"&gt;+&lt;/button&gt;\n      &lt;/form&gt;\n      &lt;div className=\"todos\"&gt;\n        {state.map((todo) =&gt; (\n          &lt;div key={todo.id} className=\"todoItem\"&gt;\n            &lt;p className={todo.completed &amp;&amp; \"strikethrough\"}&gt;{todo.text}&lt;/p&gt;\n            &lt;span onClick={() =&gt; removeTodo(todo.id)}&gt;✕&lt;/span&gt;\n            &lt;span onClick={() =&gt; completeTodo(todo.id)}&gt;✓&lt;/span&gt;\n          &lt;/div&gt;\n        ))}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}</code></pre>\n\n<p>Here, we created a form containing an input element, to collect the user’s input, and a button to trigger the action. When the form is submitted, we dispatched an action of type <code>ADD_TODO</code>, passing a new id and to-do text. We created a new id by incrementing the previous id value by 1. We then cleared the input text box. To delete and complete to-do, we simply dispatched the appropriate actions. These have already been implemented in the reducer as shown above.</p>\n<p>However, the magic happens because we are using the <code>useReducer</code> hook. This hook accepts the reducer and the initial state and returns the state and the dispatch function. Here, the dispatch function serves the same purpose as the setter function for the <code>useState</code> hook and we can call it anything we want instead of <code>dispatch</code>.</p>\n<p>To display the to-do items, we simply mapped through the list of to-dos returned in our state object as shown in the code above.</p>\n<p>This shows the power of the <code>useReducer</code> hook. We could also achieve this functionality with the <code>useState</code> hook but as you can see from the example above, the <code>useReducer</code> hook helped us to keep things neater. <code>useReducer</code> is often beneficial when the state object is a complex structure and is updated in different ways as against a simple value-replace. Also, once these update functions get more complicated, <code>useReducer</code> makes it easy to hold all that complexity in a reducer function (which is a pure JS function) making it very easy to write tests for the reducer function alone.</p>\n<p>We could have also passed the third argument to the <code>useReducer</code> hook to create the initial state lazily. This means that we could calculate the initial state in an <code>init</code> function.</p>\n<p>For instance, we could create an <code>init</code> function as follows:</p>\n<pre><code>const initFunc = () =&gt; [\n  {\n      id: id,\n      text: \"First Item\",\n      completed: false\n    }\n]</code></pre>\n\n<p>and then pass it to our <code>useReducer</code> hook.</p>\n<pre><code>const [state, dispatch] = useReducer(reducer, initialState, initFunc)</code></pre>\n\n<p>If we do this, the <code>initFunc</code> will override the <code>initialState</code> we provided and the initial state will be calculated lazily.</p>\nThe <code>useContext</code> Hook\n<p>The React Context API provides a way to share states or data throughout the React component tree. The API has been available in React, as an experimental feature, for a while but it became safe to use in React 16.3.0. The API makes data sharing between components easy while eliminating prop drilling.</p>\n<p>While you can apply the React Context to your entire application, it is also possible to apply it to part of the application.</p>\n<p>To use the hook, you need to first create a context using <code>React.createContext</code> and this context can then be passed to the hook.</p>\n<p>To demonstrate the use of the <code>useContext</code> hook, let’s create a simple app that will increase font size throughout our application.</p>\n<p>Let’s create our context in <code>context.js</code> file.</p>\n<pre><code>import { createContext } from \"react\";\n\n//Here, we set the initial fontSize as 16.\nconst fontSizeContext = createContext(16);\nexport default fontSizeContext;</code></pre>\n\n<p>Here, we created a context and passed an initial value of <code>16</code> to it, and then exported the context. Next, let’s connect our context to our application.</p>\n<pre><code>import FontSizeContext from \"./context\";\nimport { useState } from \"react\";\nimport PageOne from \"./PageOne\";\nimport PageTwo from \"./PageTwo\";\nconst App = () =&gt; {\n  const [size, setSize] = useState(16);\n  return (\n    &lt;FontSizeContext.Provider value={size}&gt;\n      &lt;PageOne /&gt;\n      &lt;PageTwo /&gt;\n      &lt;button onClick={() =&gt; setSize(size + 5)}&gt;Increase font&lt;/button&gt;\n      &lt;button\n        onClick={() =&gt;\n          setSize((prevSize) =&gt; Math.min(11, prevSize - 5))\n        }\n      &gt;\n        Decrease font\n      &lt;/button&gt;\n    &lt;/FontSizeContext.Provider&gt;\n  );\n};\nexport default App;</code></pre>\n\n<p>In the above code, we wrapped our entire component tree with <code>FontSizeContext.Provider</code> and passed <code>size</code> to its value prop. Here, <code>size</code> is a state-created with the <code>useState</code> hook. This allows us to change the value prop whenever the <code>size</code> state changes. By wrapping the entire component with the <code>Provider</code>, we can access the context anywhere in our application.</p>\n<p>For instance, we accessed the context in <code>&lt;PageOne /&gt;</code> and <code>&lt;PageTwo /&gt;</code>. As a result of this, the font size will increase across these two components when we increase it from the <code>App.js</code> file. We can increase or decrease the font size from the buttons as shown above and once we do, the font size changes throughout the application.</p>\n<pre><code>import { useContext } from \"react\";\nimport context from \"./context\";\nconst PageOne = () =&gt; {\n  const size = useContext(context);\n  return &lt;p style={{ fontSize: `${size}px` }}&gt;Content from the first page&lt;/p&gt;;\n};\nexport default PageOne;</code></pre>\n\n<p>Here, we accessed the context using the <code>useContext</code> hook from our <code>PageOne</code> component. We then used this context to set our font-size property. A similar procedure applies to the <code>PageTwo.js</code> file.</p>\n<p>Themes or other higher-order app-level configurations are good candidates for contexts.</p>\n<h3>Using <code>useContext</code> And <code>useReducer</code></h3>\n<p>When used with the <code>useReducer</code> hook, <code>useContext</code> allows us to create our own state management system. We can create global states and easily manage them in our application.</p>\n<p>Let’s improve our to-do application using the context API.</p>\n<p>As usual, we need to create a <code>todoContext</code> in the <code>todoContext.js</code> file.</p>\n<pre><code>import { createContext } from \"react\";\nconst initialState = [];\nexport default createContext(initialState);</code></pre>\n\n<p>Here we created the context, passing an initial value of an empty array. Then we exported the context.</p>\n<p>Let’s refactor our <code>App.js</code> file by separating the to-do list and items.</p>\n<pre><code>import { useReducer, useState } from \"react\";\nimport \"./styles.css\";\nimport todoReducer, { ADD_TODO } from \"./todoReducer\";\nimport TodoContext from \"./todoContext\";\nimport TodoList from \"./TodoList\";\n\nexport default function App() {\n  const [id, setId] = useState(0);\n  const [text, setText] = useState(\"\");\n  const initialState = [];\n  const [todoState, todoDispatch] = useReducer(todoReducer, initialState);\n\n  const addTodoItem = (e) =&gt; {\n    e.preventDefault();\n    const newId = id + 1;\n    setId(newId);\n    todoDispatch({\n      type: ADD_TODO,\n      id: newId,\n      text: text\n    });\n    setText(\"\");\n  };\n  return (\n    &lt;TodoContext.Provider value={[todoState, todoDispatch]}&gt;\n        &lt;div className=\"app\"&gt;\n          &lt;h1&gt;Todo Example&lt;/h1&gt;\n          &lt;form className=\"input\" onSubmit={addTodoItem}&gt;\n            &lt;input value={text} onChange={(e) =&gt; setText(e.target.value)} /&gt;\n            &lt;button disabled={text.length === 0} type=\"submit\"&gt;\n              +\n            &lt;/button&gt;\n          &lt;/form&gt;\n          &lt;TodoList /&gt;\n        &lt;/div&gt;\n    &lt;/TodoContext.Provider&gt;\n  );\n}</code></pre>\n\n<p>Here, we wrapped our <code>App.js</code> file with the <code>TodoContext.Provider</code> then we passed the return values of our <code>todoReducer</code> to it. This makes the reducer’s state and <code>dispatch</code> function to be accessible throughout our application.</p>\n<p>We then separated the to-do display into a component <code>TodoList</code>. We did this without prop drilling, thanks to the Context API. Let’s take a look at the <code>TodoList.js</code> file.</p>\n<pre><code>import React, { useContext } from \"react\";\nimport TodoContext from \"./todoContext\";\nimport Todo from \"./Todo\";\nconst TodoList = () =&gt; {\n  const [state] = useContext(TodoContext);\n  return (\n    &lt;div className=\"todos\"&gt;\n      {state.map((todo) =&gt; (\n        &lt;Todo key={todo.id} todo={todo} /&gt;\n      ))}\n    &lt;/div&gt;\n  );\n};\nexport default TodoList;</code></pre>\n\n<p>Using array destructuring, we can access the state (leaving the dispatch function) from the context using the <code>useContext</code> hook. We can then map through the state and display the to-do items. We still extracted this in a <code>Todo</code> component. The ES6+ map function requires us to pass a unique key and since we need the specific to-do, we pass it alongside as well.</p>\n<p>Let’s take a look at the <code>Todo</code> component.</p>\n<pre><code>import React, { useContext } from \"react\";\nimport TodoContext from \"./todoContext\";\nimport { REMOVE_TODO, COMPLETE_TODO } from \"./todoReducer\";\nconst Todo = ({ todo }) =&gt; {\n  const [, dispatch] = useContext(TodoContext);\n  const removeTodo = (id) =&gt; {\n    dispatch({ type: REMOVE_TODO, id });\n  };\n  const completeTodo = (id) =&gt; {\n    dispatch({ type: COMPLETE_TODO, id });\n  };\n  return (\n    &lt;div className=\"todoItem\"&gt;\n      &lt;p className={todo.completed ? \"strikethrough\" : \"nostrikes\"}&gt;\n        {todo.text}\n      &lt;/p&gt;\n      &lt;span onClick={() =&gt; removeTodo(todo.id)}&gt;✕&lt;/span&gt;\n      &lt;span onClick={() =&gt; completeTodo(todo.id)}&gt;✓&lt;/span&gt;\n    &lt;/div&gt;\n  );\n};\nexport default Todo;</code></pre>\n\n<p>Again using array destructuring, we accessed the dispatch function from the context. This allows us to define the <code>completeTodo</code> and <code>removeTodo</code> function as already discussed in the <code>useReducer</code> section. With the <code>todo</code> prop passed from <code>todoList.js</code> we can display a to-do item. We can also mark it as completed and remove the to-do as we deem fit.</p>\n<p>It is also possible to nest more than one context provider in the root of our application. This means that we can use more than one context to perform different functions in an application.</p>\n<p>To demonstrate this, let’s add theming to the to-do example.</p>\n<p>Here’s what we’ll be building.</p>\n\n\n<p>Again, we have to create <code>themeContext</code>. To do this, create a <code>themeContext.js</code> file and add the following codes.</p>\n<pre><code>import { createContext } from \"react\";\nimport colors from \"./colors\";\nexport default createContext(colors.light);</code></pre>\n\n<p>Here, we created a context and passed <code>colors.light</code> as the initial value. Let’s define the colors with this property in the <code>colors.js</code> file.</p>\n<pre><code>const colors = {\n  light: {\n    backgroundColor: \"#fff\",\n    color: \"#000\"\n  },\n  dark: {\n    backgroundColor: \"#000\",\n    color: \"#fff\"\n  }\n};\nexport default colors;</code></pre>\n\n<p>In the code above, we created a <code>colors</code> object containing light and dark properties. Each property has <code>backgroundColor</code> and <code>color</code> object.</p>\n<p>Next, we create the <code>themeReducer</code> to handle the theme states.</p>\n<pre><code>import Colors from \"./colors\";\nexport const LIGHT = \"LIGHT\";\nexport const DARK = \"DARK\";\nconst themeReducer = (state, action) =&gt; {\n  switch (action.type) {\n    case LIGHT:\n      return {\n        ...Colors.light\n      };\n    case DARK:\n      return {\n        ...Colors.dark\n      };\n    default:\n      return state;\n  }\n};\nexport default themeReducer;</code></pre>\n\n<p>Like all reducers, the <code>themeReducer</code> takes the state and the action. It then uses the <code>switch</code> statement to determine the current action. If it’s of type <code>LIGHT</code>, we simply assign <code>Colors.light</code> props and if it’s of type <code>DARK</code>, we display <code>Colors.dark</code> props. We could have easily done this with the <code>useState</code> hook but we choose <code>useReducer</code> to drive the point home.</p>\n<p>Having set up the <code>themeReducer</code>, we can then integrate it in our <code>App.js</code> file.</p>\n<pre><code>import { useReducer, useState, useCallback } from \"react\";\nimport \"./styles.css\";\nimport todoReducer, { ADD_TODO } from \"./todoReducer\";\nimport TodoContext from \"./todoContext\";\nimport ThemeContext from \"./themeContext\";\nimport TodoList from \"./TodoList\";\nimport themeReducer, { DARK, LIGHT } from \"./themeReducer\";\nimport Colors from \"./colors\";\nimport ThemeToggler from \"./ThemeToggler\";\n\nconst themeSetter = useCallback(\n      theme =&gt; themeDispatch({type: theme}, \n    [themeDispatch]);\n\nexport default function App() {\n  const [id, setId] = useState(0);\n  const [text, setText] = useState(\"\");\n  const initialState = [];\n  const [todoState, todoDispatch] = useReducer(todoReducer, initialState);\n  const [themeState, themeDispatch] = useReducer(themeReducer, Colors.light);\n  const themeSetter = useCallback(\n    (theme) =&gt; {\n      themeDispatch({ type: theme });\n    },\n    [themeDispatch]\n  );\n  const addTodoItem = (e) =&gt; {\n    e.preventDefault();\n    const newId = id + 1;\n    setId(newId);\n    todoDispatch({\n      type: ADD_TODO,\n      id: newId,\n      text: text\n    });\n    setText(\"\");\n  };\n\n  return (\n    &lt;TodoContext.Provider value={[todoState, todoDispatch]}&gt;\n      &lt;ThemeContext.Provider\n        value={[\n          themeState,\n          themeSetter\n        ]}\n      &gt;\n        &lt;div className=\"app\" style={{ ...themeState }}&gt;\n          &lt;ThemeToggler /&gt;\n          &lt;h1&gt;Todo Example&lt;/h1&gt;\n          &lt;form className=\"input\" onSubmit={addTodoItem}&gt;\n            &lt;input value={text} onChange={(e) =&gt; setText(e.target.value)} /&gt;\n            &lt;button disabled={text.length === 0} type=\"submit\"&gt;\n              +\n            &lt;/button&gt;\n          &lt;/form&gt;\n          &lt;TodoList /&gt;\n        &lt;/div&gt;\n      &lt;/ThemeContext.Provider&gt;\n    &lt;/TodoContext.Provider&gt;\n  );\n}</code></pre>\n\n<p>In the above code, we added a few things to our already existing to-do application. We began by importing the <code>ThemeContext</code>, <code>themeReducer</code>, <code>ThemeToggler</code>, and <code>Colors</code>. We created a reducer using the <code>useReducer</code> hook, passing the <code>themeReducer</code> and an initial value of <code>Colors.light</code> to it. This returned the <code>themeState</code> and <code>themeDispatch</code> to us.</p>\n<p>We then nested our component with the provider function from the <code>ThemeContext</code>, passing the <code>themeState</code> and the <code>dispatch</code> functions to it. We also added theme styles to it by spreading out the <code>themeStates</code>. This works because the <code>colors</code> object already defined properties similar to what the JSX styles will accept.</p>\n<p>However, the actual theme toggling happens in the <code>ThemeToggler</code> component. Let’s take a look at it.</p>\n<pre><code>import ThemeContext from \"./themeContext\";\nimport { useContext, useState } from \"react\";\nimport { DARK, LIGHT } from \"./themeReducer\";\nconst ThemeToggler = () =&gt; {\n  const [showLight, setShowLight] = useState(true);\n  const [themeState, themeSetter] = useContext(ThemeContext);\n  const dispatchDarkTheme = () =&gt; themeSetter(DARK);\n  const dispatchLightTheme = () =&gt; themeSetter(LIGHT);\n  const toggleTheme = () =&gt; {\n    showLight ? dispatchDarkTheme() : dispatchLightTheme();\n    setShowLight(!showLight);\n  };\n  console.log(themeState);\n  return (\n    &lt;div&gt;\n      &lt;button onClick={toggleTheme}&gt;\n        {showLight ? \"Change to Dark Theme\" : \"Change to Light Theme\"}\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\nexport default ThemeToggler;</code></pre>\n\n<p>In this component, we used the <code>useContext</code> hook to retrieve the values we passed to the <code>ThemeContext.Provider</code> from our <code>App.js</code> file. As shown above, these values include the <code>ThemeState</code>, dispatch function for the light theme, and dispatch function for the dark theme. Thereafter, we simply called the dispatch functions to toggle the themes. We also created a state <code>showLight</code> to determine the current theme. This allows us to easily change the button text depending on the current theme.</p>\nThe <code>useMemo</code> Hook\n<p>The <code>useMemo</code> hook is designed to memoize expensive computations. Memoization simply means caching. It caches the computation result with respect to the dependency values so that when the same values are passed, <code>useMemo</code> will just spit out the already computed value without recomputing it again. This can significantly improve performance when done correctly. </p>\n<p>The hook can be used as follows:</p>\n<pre><code>const memoizedResult = useMemo(() =&gt; expensiveComputation(a, b), [a, b])</code></pre>\n\n<p>Let’s consider three cases of the <code>useMemo</code> hook.</p>\n<ol>\n<li><strong>When the dependency values, a and b remain the same.</strong><br />The <code>useMemo</code> hook will return the already computed memoized value without recomputation.</li>\n<li><strong>When the dependency values, a and b change.</strong><br />The hook will recompute the value.</li>\n<li><strong>When no dependency value is passed.</strong><br />The hook will recompute the value.</li>\n</ol>\n<p>Let’s take a look at an example to demonstrate this concept.</p>\n<p>In the example below, we’ll be computing the <strong>PAYE</strong> and <strong>Income after PAYE</strong> of a company’s employees with fake data from JSONPlaceholder.</p>\n<p>The calculation will be based on the personal income tax calculation procedure for Nigeria providers by PricewaterhouseCoopers available <a href=\"https://taxsummaries.pwc.com/nigeria/individual/sample-personal-income-tax-calculation\">here</a>.</p>\n<p>This is shown in the sandbox below.</p>\n\n\n<p>First, we queried the API to get the employees’ data. We also get data for each employee (with respect to their employee id).</p>\n<pre><code>const [employee, setEmployee] = useState({});\n  const [employees, setEmployees] = useState([]);\n  const [num, setNum] = useState(1);\n  const endPoint =\n    \"https://my-json-server.typicode.com/ifeanyidike/jsondata/employees\";\n  useEffect(() =&gt; {\n    const getEmployee = async () =&gt; {\n      const { data } = await axios.get(`${endPoint}/${num}`);\n      setEmployee(data);\n    };\n    getEmployee();\n  }, [num]);\n  useEffect(() =&gt; {\n    axios.get(endPoint).then(({ data }) =&gt; setEmployees(data));\n  }, [num]);</code></pre>\n\n<p>We used <code>axios</code> and the <code>async/await</code> method in the first <code>useEffect</code> and then the dot then syntax in the second. These two approaches work in the same way.</p>\n<p>Next, using the employee data we got from above, let’s calculate the relief variables:</p>\n<pre><code>const taxVariablesCompute = useMemo(() =&gt; {\n    const { income, noOfChildren, noOfDependentRelatives } = employee;\n\n    //supposedly complex calculation\n    //tax relief computations for relief Allowance, children relief, \n    // relatives relief and pension relief\n\n    const reliefs =\n      reliefAllowance1 +\n      reliefAllowance2 +\n      childrenRelief +\n      relativesRelief +\n      pensionRelief;\n    return reliefs;\n  }, [employee]);</code></pre>\n\n<p>This is a fairly complex calculation and so we had to wrap it in a <code>useMemo</code> hook to memoize or optimize it. Memoizing it this way will ensure that the calculation will not be recomputed if we tried to access the same employee again. </p>\n<p>Furthermore, using the tax relief values obtained above, we’d like to calculate the PAYE and income after PAYE.</p>\n<pre><code>const taxCalculation = useMemo(() =&gt; {\n    const { income } = employee;\n    let taxableIncome = income - taxVariablesCompute;\n    let PAYE = 0;\n\n    //supposedly complex calculation\n    //computation to compute the PAYE based on the taxable income and tax endpoints\n\n    const netIncome = income - PAYE;\n    return { PAYE, netIncome };\n  }, [employee, taxVariablesCompute]);</code></pre>\n\n<p>We performed tax calculation (a fairly complex calculation) using the above-computed tax variables and then memoized it with the <code>useMemo</code> hook.</p>\n<p>The complete code is available on <a href=\"https://gist.github.com/ifeanyidike/bc008cf6a28140199aeb74d7ecd90261\">here</a>.</p>\n<p>This follows the tax calculation procedure given <a href=\"https://taxsummaries.pwc.com/nigeria/individual/sample-personal-income-tax-calculation\">here</a>. We first computed the tax relief considering income, number of children, and number of dependent relatives. Then, we multiplied the taxable income by the PIT rates in steps. While the calculation in question is not entirely necessary for this tutorial, it is provided to show us why <code>useMemo</code> may be necessary. This is also a fairly complex calculation and so we may need to memorize it with <code>useMemo</code> as shown above.</p>\n<p>After calculating the values, we simply displayed the result.</p>\n<p>Note the following about the <code>useMemo</code> hook.</p>\n<ul>\n<li><code>useMemo</code> should be used only when it is necessary to optimize the computation. In other words, when recomputation is expensive.</li>\n<li>It is advisable to first write the calculation without memorization and only memorize it if it is causing performance issues.</li>\n<li>Unnecessary and irrelevant use of the <code>useMemo</code> hook may even compound the performance issues.</li>\n<li>Sometimes, too much memoization can also cause performance issues.</li>\n</ul>\nThe <code>useCallback</code> Hook\n<p><code>useCallback</code> serves the same purpose as <code>useMemo</code> but it returns a memoized callback instead of a memoized value. In other words, <code>useCallback</code> is the same as passing <code>useMemo</code> without a function call.</p>\n<p>For instance, consider the following codes below.</p>\n<pre><code>import React, {useCallback, useMemo} from 'react'\n\nconst MemoizationExample = () =&gt; {\n  const a = 5\n  const b = 7\n\n  const memoResult = useMemo(() =&gt; a + b, [a, b])\n  const callbackResult = useCallback(a + b, [a, b])\n\n  console.log(memoResult)\n  console.log(callbackResult)\n\n  return(\n    &lt;div&gt;\n      ...\n    &lt;/div&gt;\n  ) \n}\n\nexport default MemoizationExample</code></pre>\n\n<p>In the above example, both <code>memoResult</code> and <code>callbackResult</code> will give the same value of <code>12</code>. Here, <code>useCallback</code> will return a memoized value. However, we could also make it return a memoized callback by passing it as a function.</p>\n<p>The <code>useCallback</code> below will return a memoized callback.</p>\n<pre><code>...\n  const callbackResult = useCallback(() =&gt; a + b, [a, b])\n...</code></pre>\n\n<p>We can then trigger the callback when an action is performed or in a <code>useEffect</code> hook.</p>\n<pre><code>import {useCallback, useEffect} from 'react'\nconst memoizationExample = () =&gt; {\n  const a = 5\n  const b = 7\n  const callbackResult = useCallback(() =&gt; a + b, [a, b])\n  useEffect(() =&gt; {\n    const callback = callbackResult()\n    console.log(callback)   \n  })\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick= {() =&gt; console.log(callbackResult())}&gt;\n        Trigger Callback\n      &lt;/button&gt;\n    &lt;/div&gt;\n  )\n} \nexport default memoizationExample</code></pre>\n\n<p>In the above code, we defined a callback function using the <code>useCallback</code> hook. We then called the callback in a <code>useEffect</code> hook when the component mounts and also when a button is clicked.</p>\n<p>Both the <code>useEffect</code> and the button click yield the same result.</p>\n<p>Note that the concepts, do’s, and don’ts that apply to the <code>useMemo</code> hook also apply to the <code>useCallback</code> hook. We can recreate the <code>useMemo</code> example with <code>useCallback</code>. </p>\nThe <code>useRef</code> Hook\n<p><code>useRef</code> returns an object that can persist in an application. The hook has only one property, <code>current</code>, and we can easily pass an argument to it.</p>\n<p>It serves the same purpose a <code>createRef</code> used in class-based components. We can create a reference with this hook as follows:</p>\n<pre><code>const newRef = useRef('')</code></pre>\n\n<p>Here we created a new ref called <code>newRef</code> and passed an empty string to it.</p>\n<p>This hook is used mainly for two purposes:</p>\n<ol>\n<li>Accessing or manipulating the DOM, and</li>\n<li>Storing mutable states — this is useful when we don’t want the component to rerender when a value change.</li>\n</ol>\n<h3>Manipulating the DOM</h3>\n<p>When passed to a DOM element, the ref object points to that element and can be used to access its DOM attributes and properties.</p>\n<p>Here is a very simple example to demonstrate this concept.</p>\n<pre><code>import React, {useRef, useEffect} from 'react'\n\nconst RefExample = () =&gt; {\n  const headingRef = useRef('')\n  console.log(headingRef)\n  return(\n    &lt;div&gt;\n      &lt;h1 className='topheading' ref={headingRef}&gt;This is a h1 element&lt;/h1&gt;\n    &lt;/div&gt;\n  )\n}\nexport default RefExample</code></pre>\n\n<p>In the example above, we defined <code>headingRef</code> using the <code>useRef</code> hook passing an empty string. We then set the ref in the <code>h1</code> tag by passing <code>ref  = {headingRef}</code>. By setting this ref, we have asked the <code>headingRef</code> to point to our <code>h1</code> element. This means that we can access the properties of our <code>h1</code> element from the ref.</p>\n<p>To see this, if we check the value of <code>console.log(headingRef)</code>, we’ll get <code>{current: HTMLHeadingElement}</code> or <code>{current: h1}</code> and we can assess all the properties or attributes of the element. A similar thing applies to any other HTML element.</p>\n<p>For instance, we could make the text italic when the component mounts.</p>\n<pre><code>useEffect(() =&gt; {\n  headingRef.current.style.fontStyle = \"italic\";\n}, []);</code></pre>\n\n<p>We can even change the text to something else.</p>\n<pre><code>...\n    headingRef.current.innerHTML = \"A Changed H1 Element\";\n...</code></pre>\n\n<p>We can even change the background color of the parent container as well.</p>\n<pre><code>...\n    headingRef.current.parentNode.style.backgroundColor = \"red\";\n...</code></pre>\n\n<p>Any kind of DOM manipulation can be done here. Observe that <code>headingRef.current</code> can be read in the same way as  <code>document.querySelector('.topheading')</code>. </p>\n<p>One interesting use case of the <code>useRef</code> hook in manipulating the DOM element is to focus the cursor on the input element. Let’s quickly run through it.</p>\n<pre><code>import {useRef, useEffect} from 'react'\n\nconst inputRefExample = () =&gt; {\n  const inputRef = useRef(null)\n  useEffect(() =&gt; {\n    inputRef.current.focus()\n  }, [])\n\n  return(\n    &lt;div&gt;\n      &lt;input ref={inputRef} /&gt;\n      &lt;button onClick = {() =&gt; inputRef.current.focus()}&gt;Focus on Input &lt;/button&gt;\n    &lt;/div&gt;\n  )\n}\nexport default inputRefExample</code></pre>\n\n<p>In the above code, we created <code>inputRef</code> using the <code>useRef</code> hook and then asked it to point to the input element. We then made the cursor focus on the input ref when the component loads and when the button is clicked using <code>inputRef.current.focus()</code>. This is possible because <code>focus()</code> is an attribute of input elements and so the ref will be able to assess the methods.</p>\n<p>Refs created in a parent component can be assessed at the child component by forwarding it using <code>React.forwardRef()</code>. Let’s take a look at it.</p>\n<p>Let’s first create another component <code>NewInput.js</code> and add the following codes to it.</p>\n<pre><code>import { useRef, forwardRef } from \"react\";\nconst NewInput = forwardRef((props, ref) =&gt; {\n  return &lt;input placeholder={props.val} ref={ref} /&gt;;\n});\nexport default NewInput;</code></pre>\n\n<p>This component accepts <code>props</code> and <code>ref</code>. We passed the ref to its ref prop and <code>props.val</code> to its placeholder prop. Regular React components do not take a <code>ref</code> attribute. This attribute is available only when we wrap it with <code>React.forwardRef</code> as shown above.</p>\n<p>We can then easily call this in the parent component.</p>\n<pre><code>...\n&lt;NewInput val=\"Just an example\" ref={inputRef} /&gt;\n...</code></pre>\n\n<h3>Storing The Mutable States</h3>\n<p>Refs are not just used to manipulate DOM elements, they can also be used to store mutable values without re-rendering the entire component.</p>\n<p>The following example will detect the number of times a button is clicked without re-rendering the component.</p>\n<pre><code>import { useRef } from \"react\";\n\nexport default function App() {\n  const countRef = useRef(0);\n  const increment = () =&gt; {\n    countRef.current++;\n    console.log(countRef);\n  };\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;button onClick={increment}&gt;Increment &lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</code></pre>\n\n<p>In the code above, we incremented the <code>countRef</code> when the button is clicked and then logged it to the console. Although the value is incremented as shown in the console, we won’t be able to see any change if we try to assess it directly in our component. It will only update in the component when it re-renders.</p>\n<p>Note that while <code>useState</code> is asynchronous, <code>useRef</code> is synchronous. In other words, the value is available immediately after it is updated.</p>\nThe <code>useLayoutEffect</code> Hook\n<p>Like the <code>useEffect</code> hook, <code>useLayoutEffect</code> is called after the component is mounted and rendered. This hook fires after DOM mutation and it does so synchronously. Apart from getting called synchronously after DOM mutation, <code>useLayoutEffect</code> does the same thing as <code>useEffect</code>. </p>\n<p><code>useLayoutEffect</code> should only be used for performing DOM mutation or DOM-related measurement, otherwise, you should use the <code>useEffect</code> hook. Using the <code>useEffect</code> hook for DOM mutation functions may cause some performance issues such as flickering but <code>useLayoutEffect</code> handles them perfectly as it runs after the mutations have occurred.</p>\n<p>Let’s take a look at some examples to demonstrate this concept.</p>\n<ol>\n<li>We’ll be getting the width and height of the window on resize.</li>\n</ol>\n<pre><code>import {useState, useLayoutEffect} from 'react'\n\nconst ResizeExample = () =&gt;{\n  const [windowSize, setWindowSize] = useState({width: 0, height: 0})\n  useLayoutEffect(() =&gt; {\n    const resizeWindow = () =&gt; setWindowSize({\n      width: window.innerWidth,\n      height: window.innerHeight\n    })\n    window.addEventListener('resize', resizeWindow)\n    return () =&gt; window.removeEventListener('resize', resizeWindow)\n  }, [])\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;width: {windowSize.width}&lt;/p&gt;\n      &lt;p&gt;height: {windowSize.height}&lt;/p&gt;\n    &lt;/div&gt;\n  )\n}\nexport default ResizeExample</code></pre>\n\n<p>In the above code, we created a state <code>windowSize</code> with width and height properties. Then we set the state to the current window’s width and height respectively when the window is resized. We also cleaned up the code when it unmounts. The clean-up process is essential in <code>useLayoutEffect</code> to clean up the DOM manipulation and improve efficiency.</p>\n<ol>\n<li>Let’s blur a text with <code>useLayoutEffect</code>.</li>\n</ol>\n<pre><code>import { useRef, useState, useLayoutEffect } from \"react\";\n\nexport default function App() {\n  const paragraphRef = useRef(\"\");\n\n  useLayoutEffect(() =&gt; {\n    const { current } = paragraphRef;\n    const blurredEffect = () =&gt; {\n      current.style.color = \"transparent\";\n      current.style.textShadow = \"0 0 5px rgba(0,0,0,0.5)\";\n    };\n    current.addEventListener(\"click\", blurredEffect);\n    return () =&gt; current.removeEventListener(\"click\", blurredEffect);\n  }, []);\n\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;p ref={paragraphRef}&gt;This is the text to blur&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}</code></pre>\n\n<p>We used <code>useRef</code> and <code>useLayoutEffect</code> together in the above code. We first created a ref, <code>paragraphRef</code> to point to our paragraph. Then we created an on-click event listener to monitor when the paragraph is clicked and then blurred it using the style properties we defined. Finally, we cleaned up the event listener using <code>removeEventListener</code>.</p>\nThe <code>useDispatch</code> And <code>useSelector</code> Hooks\n<p><code>useDispatch</code> is a Redux hook for dispatching (triggering) actions in an application. It takes an action object as an argument and invokes the action. <code>useDispatch</code> is the hook’s equivalence to <code>mapDispatchToProps</code>. </p>\n<p>On the other hand, <code>useSelector</code> is a Redux hook for assessing Redux states. It takes a function to select the exact Redux reducer from the store and then returns the corresponding states.</p>\n<p>Once our Redux store is connected to a React application through the Redux provider, we can invoke the actions with <code>useDispatch</code> and access the states with <code>useSelector</code>. Every Redux action and state can be assessed with these two hooks. </p>\n<p>Note that these states ship with React Redux (a package that makes assessing the Redux store easy in a React application). They are not available in the core Redux library.</p>\n<p>These hooks are very simple to use. First, we have to declare the dispatch function and then trigger it.</p>\n<pre><code>import {useDispatch, useSelector} from 'react-redux'\nimport {useEffect} from 'react'\nconst myaction from '...'\n\nconst ReduxHooksExample = () =&gt;{\n  const dispatch = useDispatch()\n  useEffect(() =&gt; {\n    dispatch(myaction());\n    //alternatively, we can do this\n    dispatch({type: 'MY_ACTION_TYPE'})\n  }, [])       \n\n  const mystate = useSelector(state =&gt; state.myReducerstate)\n\n  return(\n    ...\n  )\n}\nexport default ReduxHooksExample</code></pre>\n\n<p>In the above code, we imported <code>useDispatch</code> and <code>useSelector</code> from <code>react-redux</code>. Then, in a <code>useEffect</code> hook, we dispatched the action. We could define the action in another file and then call it here or we could define it directly as shown in the <code>useEffect</code> call. </p>\n<p>Once we have dispatched the actions, our states will be available. We can then retrieve the state using the <code>useSelector</code> hook as shown. The states can be used in the same way we would use states from the <code>useState</code> hook.</p>\n<p>Let’s take a look at an example to demonstrate these two hooks.</p>\n<p>To demonstrate this concept, we have to create a Redux store, reducer, and actions. To simplify things here, we’ll be using the Redux Toolkit library with our fake database from JSONPlaceholder.</p>\n<p>We need to install the following packages to get started. Run the following bash commands.</p>\n<pre><code>npm i redux @reduxjs/toolkit react-redux axios</code></pre>\n\n<p>First, let’s create the <code>employeesSlice.js</code> to handle the reducer and action for our employees’ API.</p>\n<pre><code>import { createAsyncThunk, createSlice } from \"@reduxjs/toolkit\";\nimport axios from \"axios\";\nconst endPoint = \"https://my-json-server.typicode.com/ifeanyidike/jsondata/employees\";\n\nexport const fetchEmployees = createAsyncThunk(\"employees/fetchAll\", async () =&gt; {\n    const { data } = await axios.get(endPoint);\n    return data;\n});\n\nconst employeesSlice = createSlice({\n  name: \"employees\",\n  initialState: { employees: [], loading: false, error: \"\" },\n  reducers: {},\n  extraReducers: {\n    [fetchEmployees.pending]: (state, action) =&gt; {\n      state.status = \"loading\";\n    },\n    [fetchEmployees.fulfilled]: (state, action) =&gt; {\n      state.status = \"success\";\n      state.employees = action.payload;\n    },\n    [fetchEmployees.rejected]: (state, action) =&gt; {\n      state.status = \"error\";\n      state.error = action.error.message;\n    }\n  }\n});\nexport default employeesSlice.reducer;</code></pre>\n\n<p>This is the standard setup for the Redux toolkit. We used the <code>createAsyncThunk</code> to access the <code>Thunk</code> middleware to perform async actions. This allowed us to fetch the list of employees from the API. We then created the <code>employeesSlice</code> and returned, “loading”, “error”, and the employees’ data depending on the action types.</p>\n<p>Redux toolkit also makes setting up the store easy. Here is the store.</p>\n<pre><code>import { configureStore } from \"@reduxjs/toolkit\";\nimport { combineReducers } from \"redux\";\nimport employeesReducer from \"./employeesSlice\";\n\nconst reducer = combineReducers({\n  employees: employeesReducer\n});\n\nexport default configureStore({ reducer });;</code></pre>\n\n<p>Here, we used <code>combineReducers</code> to bundle the reducers and the <code>configureStore</code> function provided by Redux toolkit to set up the store.</p>\n<p>Let’s proceed to use this in our application.</p>\n<p>First, we need to connect Redux to our React application. Ideally, this should be done at the root of our application. I like to do it in the <code>index.js</code> file.</p>\n<pre><code>import React, { StrictMode } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport store from \"./redux/store\";\nimport { Provider } from \"react-redux\";\nimport App from \"./App\";\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n  &lt;Provider store={store}&gt;\n    &lt;StrictMode&gt;\n      &lt;App /&gt;\n    &lt;/StrictMode&gt;\n  &lt;/Provider&gt;,\n  rootElement\n);</code></pre>\n\n<p>Here, I’ve imported the store I created above and also <code>Provider</code> from <code>react-redux</code>.</p>\n<p>Then, I wrapped the entire application with the <code>Provider</code> function, passing the store to it. This makes the store accessible throughout our application.</p>\n<p>We can then proceed to use the <code>useDispatch</code> and <code>useSelector</code> hooks to fetch the data.</p>\n<p>Let’s do this in our <code>App.js</code> file.</p>\n<pre><code>import { useDispatch, useSelector } from \"react-redux\";\nimport { fetchEmployees } from \"./redux/employeesSlice\";\nimport { useEffect } from \"react\";\n\nexport default function App() {\n  const dispatch = useDispatch();\n  useEffect(() =&gt; {\n    dispatch(fetchEmployees());\n  }, [dispatch]);\n  const employeesState = useSelector((state) =&gt; state.employees);\n  const { employees, loading, error } = employeesState;\n\n  return (\n    &lt;div className=\"App\"&gt;\n      {loading ? (\n        \"Loading...\"\n      ) : error ? (\n        &lt;div&gt;{error}&lt;/div&gt;\n      ) : (\n        &lt;&gt;\n          &lt;h1&gt;List of Employees&lt;/h1&gt;\n          {employees.map((employee) =&gt; (\n            &lt;div key={employee.id}&gt;\n              &lt;h3&gt;{`${employee.firstName} ${employee.lastName}`}&lt;/h3&gt;\n            &lt;/div&gt;\n          ))}\n        &lt;/&gt;\n      )}\n    &lt;/div&gt;\n  );\n}</code></pre>\n\n<p>In the above code, we used the <code>useDispatch</code> hook to invoke the <code>fetchEmployees</code> action created in the <code>employeesSlice.js</code> file. This makes the employees state to be available in our application. Then, we used the <code>useSelector</code> hook to get the states. Thereafter, we displayed the results by mapping through the <code>employees</code>.</p>\nThe <code>useHistory</code> Hook\n<p>Navigation is very important in a React application. While you could achieve this in a couple of ways, React Router provides a simple, efficient and popular way to achieve dynamic routing in a React application. Furthermore, React Router provides a couple of hooks for assessing the state of the router and performing navigation on the browser but to use them, you need to first set up your application properly.</p>\n<p>To use any React Router hook, we should first wrap our application with <code>BrowserRouter</code>. We can then nest the routes with <code>Switch</code> and <code>Route</code>.</p>\n<p>But first, we have to install the package by running the following commands.</p>\n<pre><code>npm install react-router-dom</code></pre>\n\n<p>Then, we need to set up our application as follows. I like to do this in my <code>App.js</code> file.</p>\n<pre><code>import { BrowserRouter as Router, Switch, Route } from \"react-router-dom\";\nimport Employees from \"./components/Employees\";\nexport default function App() {\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;Router&gt;\n        &lt;Switch&gt;\n          &lt;Route path='/'&gt;\n            &lt;Employees /&gt;\n          &lt;/Route&gt;\n          ...\n        &lt;/Switch&gt;\n      &lt;/Router&gt;\n    &lt;/div&gt;\n  );\n}</code></pre>\n\n<p>We could have as many Routes as possible depending on the number of components we wish to render. Here, we have rendered only the <code>Employees</code> component. The <code>path</code> attribute tells React Router DOM the path of the component and can be assessed with query string or various other methods.</p>\n<p>The order matters here. The root route should be placed below the child route and so forth. To override this order, you need to include the <code>exact</code> keyword on the root route.</p>\n<pre><code>&lt;Route path='/' exact &gt;\n  &lt;Employees /&gt;\n&lt;/Route&gt;</code></pre>\n\n<p>Now that we have set up the router, we can then use the <code>useHistory</code> hook and other React Router hooks in our application.</p>\n<p>To use the <code>useHistory</code> hook, we need to first declare it as follows.</p>\n<pre><code>import {useHistory} from 'history'\nimport {useHistory} from 'react-router-dom'\n\nconst Employees = () =&gt;{\n  const history = useHistory()\n  ...\n}</code></pre>\n\n<p>If we log history to the console, we’ll see several properties associated with it. These include <code>block</code>, <code>createHref</code>, <code>go</code>, <code>goBack</code>, <code>goForward</code>, <code>length</code>, <code>listen</code>, <code>location</code>, <code>push</code>, <code>replace</code>. While all these properties are useful, you will most likely use <code>history.push</code> and <code>history.replace</code> more often than other properties.</p>\n<p>Let’s use this property to move from one page to another.</p>\n<p>Assuming we want to fetch data about a particular employee when we click on their names. We can use the <code>useHistory</code> hook to navigate to the new page where the employee’s information will be displayed.</p>\n<pre><code>function moveToPage = (id) =&gt;{\n  history.push(`/employees/${id}`)\n}</code></pre>\n\n<p>We can implement this in our <code>Employee.js</code> file by adding the following.</p>\n<pre><code>import { useEffect } from \"react\";\nimport { Link, useHistory, useLocation } from \"react-router-dom\";\n\nexport default function Employees() {\n  const history = useHistory();\n\n  function pushToPage = (id) =&gt; {\n    history.push(`/employees/${id}`)\n  }\n  ...\n  return (\n    &lt;div&gt;\n     ...\n        &lt;h1&gt;List of Employees&lt;/h1&gt;\n        {employees.map((employee) =&gt; (\n          &lt;div key={employee.id}&gt;\n            &lt;span&gt;{`${employee.firstName} ${employee.lastName} `}&lt;/span&gt;\n            &lt;button onClick={pushToPage(employee.id)}&gt; » &lt;/button&gt;\n          &lt;/div&gt;\n        ))}\n  &lt;/div&gt;\n  );\n}</code></pre>\n\n<p>In the <code>pushToPage</code> function, we used <code>history</code> from the <code>useHistory</code> hook to navigate to the employee’s page and pass the employee id alongside.</p>\nThe <code>useLocation</code> Hook\n<p>This hook also ships with React Router DOM. It is a very popular hook used to work with the query string parameter. This hook is similar to the <code>window.location</code> in the browser.</p>\n<pre><code>import {useLocation} from 'react'\n\nconst LocationExample = () =&gt;{\n  const location = useLocation()\n  return (\n    ...\n  )\n}\nexport default LocationExample</code></pre>\n\n<p>The <code>useLocation</code> hook returns the <code>pathname</code>, <code>search</code> parameter, <code>hash</code> and <code>state</code>. The most commonly used parameters include the <code>pathname</code> and <code>search</code> but you could equally use <code>hash</code>, and <code>state</code> a lot in your application.</p>\n<p>The location <code>pathname</code> property will return the path we set in our <code>Route</code> set up. While <code>search</code> will return the query search parameter if any. For instance, if we pass <code>'http://mywebsite.com/employee/?id=1'</code> to our query, the <code>pathname</code> would be <code>/employee</code> and the <code>search</code> would be <code>?id=1</code>.</p>\n<p>We can then retrieve the various search parameters using packages like query-string or by coding them.</p>\nThe <code>useParams</code> Hook\n<p>If we set up our Route with a URL parameter in its path attribute, we can assess those parameters as key/value pairs with the <code>useParams</code> hook.</p>\n<p>For instance, let’s assume that we have the following Route.</p>\n<pre><code>&lt;Route path='/employees/:id' &gt;\n  &lt;Employees /&gt;\n&lt;/Route&gt;</code></pre>\n\n<p>The Route will be expecting a dynamic id in place of <code>:id</code>.</p>\n<p>With the <code>useParams</code> hook, we can assess the id passed by the user, if any.</p>\n<p>For instance, assuming the user passes the following in function with <code>history.push</code>, </p>\n<pre><code>function goToPage = () =&gt; {\n  history.push(`/employee/3`)\n}</code></pre>\n\n<p>We can use the <code>useParams</code> hook to access this URL parameter as follows.</p>\n<pre><code>import {useParams} from 'react-router-dom'\n\nconst ParamsExample = () =&gt;{\n  const params = useParams()\n  console.log(params)  \n\n  return(\n    &lt;div&gt;\n      ...\n    &lt;/div&gt;\n  )\n}\nexport default ParamsExample</code></pre>\n\n<p>If we log <code>params</code> to the console, we’ll get the following object <code>{id: \"3\"}</code>. </p>\nThe <code>useRouteMatch</code> Hook\n<p>This hook provides access to the match object. It returns the closest match to a component if no argument is supplied to it.</p>\n<p>The match object returns several parameters including the <code>path</code> (the same as the path specified in Route), the <code>URL</code>, <code>params</code> object, and <code>isExact</code>.</p>\n<p>For instance, we can use <code>useRouteMatch</code> to return components based on the route.</p>\n<pre><code>import { useRouteMatch } from \"react-router-dom\";\nimport Employees from \"...\";\nimport Admin from \"...\"\n\nconst CustomRoute = () =&gt; {\n  const match = useRouteMatch(\"/employees/:id\");\n  return match ? (\n    &lt;Employee /&gt; \n  ) : (\n    &lt;Admin /&gt;\n  );\n};\nexport default CustomRoute;</code></pre>\n\n<p>In the above code, we set a route’s path with <code>useRouteMatch</code> and then rendered the <code>&lt;Employee /&gt;</code> or <code>&lt;Admin /&gt;</code> component depending on the route selected by the user.</p>\n<p>For this to work, we still need to add the route to our <code>App.js</code> file.</p>\n<pre><code>...\n  &lt;Route&gt;\n    &lt;CustomRoute /&gt;\n  &lt;/Route&gt;\n...</code></pre>\n\nBuilding A Custom Hook\n<p>According to the React documentation, <a href=\"https://reactjs.org/docs/hooks-custom.html\">building a custom hook allows us to extract a logic into a reusable function</a>. However, you need to make sure that all the rules that apply to React hooks apply to your custom hook. Check the rules of React hook at the top of this tutorial and ensure that your custom hook complies with each of them.</p>\n<p>Custom hooks allow us to write functions once and reuse them whenever they are needed and hence obeying the DRY principle. </p>\n<p>For instance, we could create a custom hook to get the scroll position on our page as follows.</p>\n<pre><code>import { useLayoutEffect, useState } from \"react\";\n\nexport const useScrollPos = () =&gt; {\n  const [scrollPos, setScrollPos] = useState({\n    x: 0,\n    y: 0\n  });\n  useLayoutEffect(() =&gt; {\n    const getScrollPos = () =&gt;\n      setScrollPos({\n        x: window.pageXOffset,\n        y: window.pageYOffset\n      });\n    window.addEventListener(\"scroll\", getScrollPos);\n    return () =&gt; window.removeEventListener(\"scroll\", getScrollPos);\n  }, []);\n  return scrollPos;\n};\n</code></pre>\n\n<p>Here, we defined a custom hook to determine the scroll position on a page. To achieve this, we first created a state, <code>scrollPos</code>, to store the scroll position. Since this will be modifying the DOM, we need to use <code>useLayoutEffect</code> instead of <code>useEffect</code>. We added a scroll event listener to capture the x and y scroll positions and then cleaned up the event listener. Finally, we returned to the scroll position.</p>\n<p>We can use this custom hook anywhere in our application by calling it and using it just as we would use any other state.</p>\n<pre><code>import {useScrollPos} from './Scroll'\n\nconst App = () =&gt;{\n  const scrollPos = useScrollPos()\n  console.log(scrollPos.x, scrollPos.y)\n  return (\n    ...\n  )\n}\nexport default App</code></pre>\n\n<p>Here, we imported the custom hook <code>useScrollPos</code> we created above. Then we initialized it and then logged the value to our console. If we scroll on the page, the hook will show us the scroll position at every step of the scroll.</p>\n<p>We can create custom hooks to do just about anything we can imagine in our app. As you can see, we simply need to use the inbuilt React hook to perform some functions. We can also use third-party libraries to create custom hooks but if we do so, we will have to install that library to be able to use the hook.</p>\nConclusion\n<p>In this tutorial, we took a good look at some useful React hooks you will be using in most of your applications. We examined what they present and how to use them in your application. We also looked at several code examples to help you understand these hooks and apply them to your application.</p>\n<p>I encourage you to try these hooks in your own application to understand them more.</p>\n<h3>Resources From The React Docs</h3>\n<ul>\n<li><a href=\"https://reactjs.org/docs/hooks-faq.html\">Hooks FAQ</a></li>\n<li><a href=\"https://redux-toolkit.js.org/api/createAsyncThunk\">Redux Toolkit</a></li>\n<li><a href=\"https://reactjs.org/docs/hooks-state.html\">Using the State Hook</a></li>\n<li><a href=\"https://reactjs.org/docs/hooks-effect.html\">Using the Effect Hook</a></li>\n<li><a href=\"https://reactjs.org/docs/hooks-reference.html\">Hooks API Reference</a></li>\n<li><a href=\"https://react-redux.js.org/api/hooks\">React Redux Hooks</a></li>\n<li><a href=\"https://reactrouter.com/web/api/Hooks\">React Router Hooks</a></li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"5be64a34c20671ae8413d2edce50fe7bd09f795936dfa7e609aa87fedaa45e70","category":"Tech"}