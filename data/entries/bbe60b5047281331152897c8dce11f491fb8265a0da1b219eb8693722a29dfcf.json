{"title":"A Deep Dive Into The Wonderful World Of SVG Displacement Filtering","link":"https://smashingmagazine.com/2021/09/deep-dive-wonderful-world-svg-displacement-filtering/","date":1630492200000,"content":"<p>Even today, the magic, wicked realm of <a href=\"https://www.w3.org/TR/filter-effects-1/\">SVG Filter Effects</a> is largely uncharted territory. The art of SVG filtering is still surrounded by an aura of alchemy: you have to bravely dive into a dark world of inconsistencies, your dedication will repeatedly be tested by buggy implementations and nerve-wracking side effects, and you must learn complicated incantations. But, once mastered, it gives you unprecedented power — a means to switch the total appearance of elements and websites by the snap of a finger.</p>\n<p>In this article, we’ll be diving into one of the most spectacular filter effects: <a href=\"https://www.w3.org/TR/filter-effects-1/#feDisplacementMapElement\">the SVG <code>feDisplacementMap</code> filter primitive</a>. In order to make it all easier to digest, I’ve divided the article into three parts in which we’ll be exploring:</p>\n<ol>\n<li><a href=\"#a-short-primer-on-displacement-filtering\">how the <code>feDisplacementMap</code> works</a>, i.e. how to apply it and how to control its output in a predictable manner;</li>\n<li>we’ll then explore <a href=\"#exploring-different-maps-in-action\">methods to create fancy displacement maps in SVG</a> (slightly more interesting as we will start playing with JavaScript);</li>\n<li>and finally, we’ll take a look at some of the <a href=\"#animation\">methods to animate the filter and create dramatic visual effects</a>.</li>\n</ol>\n<p>As this will be a rather long read, the impatient ones may want to <a href=\"https://codepen.io/collection/29810b72a14667a46ce7b667378b2f25?grid_type=grid&amp;cursor=ZD0xJm89MSZwPTEmdj03\">check out the demos we’re going to encounter</a> before continuing. All the demos in this article have been optimized for the latest versions of the three major browser engines.</p>\n<p>To get the most out of this article, you should already have a basic understanding of SVG filters. If you are a filter novice, you may want to take a short detour to <a href=\"https://tympanus.net/codrops/2019/01/15/svg-filters-101/\">Sara Soueidan’s introduction</a> or head over on to <a href=\"https://www.smashingmagazine.com/2015/05/why-the-svg-filter-is-awesome/\">my humble take on the subject</a> first.</p>\n<p>Be warned though: not applied properly, <strong>SVG Filters can hurt the performance of your site drastically</strong>. Always test extensively if you roll out one of the techniques described here.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f2c7d1d1-de5b-41de-83f5-494cf96695de/1-demos-thumbs.png\" /></p>\nA Short Primer On Displacement Filtering\n<p>So what’s a displacement filter? A displacement operation can visually distort any graphic it is applied to. You can create warp effects, twirls or ripples like you would do with a <a href=\"https://helpx.adobe.com/photoshop-elements/using/distort-filters.html\">Photoshop distortion filter</a>. Displacement filtering is an important tool in <a href=\"https://www.youtube.com/watch?v=tjSaKnsyJJQ\">VFX</a>, and most likely you already saw <a href=\"https://www.youtube.com/watch?v=XNHl5Dbw3Mw&amp;t=0s\">some displacement mapping operations</a> on film and TV, created with a VFX tool like After Effects or GiantRed.</p>\n<p>To achieve a distortion effect the filter needs two images as input:</p>\n<ul>\n<li>The actual source graphic should be distorted (from now on just \"source\");</li>\n<li>The \"displacement map\" (from now on just \"map\"). This map contains information on how we want the source to be distorted.</li>\n</ul>\n<p>Most of the time, a map will be some Bitmap image, but in the next part, I will demonstrate how to use SVG images or fragments as an input.</p>\n<p>Let’s see what happens when we use an image of Barcelona’s famous <a href=\"https://sagradafamilia.org/en/\">La Sagrada Familia</a> to \"distort\" the Mona Lisa:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a2318e6f-c446-411e-b139-d7b9bfbf2d1c/2-sagrada-to-mona.png\" /></p>\n<ol>\n<li>The first filter primitive is <code>feImage</code> which holds a reference to the map (there are other filter primitives that can be used as an input. You will find several fascinating demos out there where <a href=\"https://codepen.io/smashingmag/pen/MWoyJqR\"><code>feTurbulence</code> is used as displacement map</a>, but in this article, we will mostly focus on <code>feImage</code>).</li>\n<li>This feImage is then fed into a <code>feDisplacementMap</code> primitive where the actual distortion happens:<ul>\n<li>A positive or negative <code>scale</code> attribute defines the strength of the distortion.</li>\n<li>The purpose of <code>xChannelSelector</code> and <code>yChannelSelector</code> is to determine which of the input image’s four-color channels (red, green, blue, alpha) should be applied to which axis for distortion. Both attributes default to the map’s alpha channel (which means if you’re using a map without alpha channels and omit these attributes, you’ll see nothing more than a diagonal shift of the source).</li>\n</ul>\n</li>\n</ol>\n<p>We then apply the filter with CSS:</p>\n<pre><code>.filtered {\n  filter: url(#displacement-filter);\n}\n</code></pre>\n\n<p>It may be fun to play around distorting images this way but it is unpredictable how the result will look and most of the time it’s not aesthetically pleasing at all. Is there a way to get pixel-perfect control over the output? Here’s what the <a href=\"https://drafts.fxtf.org/filter-effects/#elementdef-fedisplacementmap\">spec says</a>:</p>\n<blockquote>This filter primitive uses the pixels values from the image from in2 to spatially displace the image from in. This is the transformation to be performed:<br /><br />P'(x,y) ← P( x + scale <em> (XC(x,y) - .5), y + scale </em> (YC(x,y) - .5))<br /><br />The displacement map, in2, defines the inverse of the mapping performed.</blockquote>\n\n<p>OK, looks complicated at a first glance, but it is actually pretty easy to understand when broken down:</p>\n<ul>\n<li><code>P'(x,y)</code> stands for the coordinates of a pixel in the result;</li>\n<li><code>X</code> and <code>Y</code> are the coordinates of this pixel in the unfiltered source;</li>\n<li><code>XC</code> and <code>YC</code> are the normalized <code>(1/255)</code> RGB color values of the given pixel in the map;</li>\n<li>Finally, the result of the operation must be inverted (which basically means every <code>+</code> in the formula must be replaced by a <code>-</code>).</li>\n</ul>\n<p>We will run some simple experiments to verify our formula by feeding primitive bitmaps into a filter, consisting of only one single color. Let’s say the map is filled with <code>rgb(51, 51, 51)</code>, how would we expect the coordinates of a source pixel at <code>x=100 / y=100</code> to be transformed when fed into a displacement primitive with a scale value of 100?</p>\n<blockquote>X: 100 - 100 <em> (51/255 - .5) = 130<br /><br />Y: 100 - 100 </em> (51/255 - .5) = 130</blockquote>\n\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2cda0fda-2142-4b69-959d-82439baef15d/3-identitymap.png\" /></p>\n<p>To scale an image equally in all directions, the color values must gradually decline from a maximum at one edge to a minimum at the opposite edge. We will use red for <code>X</code> and blue for <code>Y</code> from now on, but in the end, it doesn’t matter which color you chose for <code>x-</code> and <code>yChannelSelector</code>.</p>\n<ol>\n<li>In your favorite Image editor, open a new document;</li>\n<li>Set the background color of the document to black;</li>\n<li>Create a new layer and fill it with a left to right gradient from <code>rgb(255, 0, 0)</code> to <code>rgba(255, 0, 0, 0)</code>;</li>\n<li>Add a second layer and add a top to bottom gradient from <code>rgb (0, 0, 255)</code> to <code>rgba(0, 0, 255, 0)</code>;</li>\n<li>Set the blending mode for this layer to <code>screen</code>.</li>\n</ol>\n<p>Et voilà, you’ve built an <a href=\"images-in-article/identitymap.jpg\">absolute map</a>! This map will serve as a solid foundation for all kinds of image distortions:</p>\n<ul>\n<li>By applying Photoshop-like distortion filters to this map, we are able to use these effects in CSS filters!</li>\n<li>We can control the scaling of the x- and y-axis independently by altering the transparency of the blue or red gradient.</li>\n<li>It is possible to \"mask\" parts of the map with a \"neutral\" color (<code>rgb(127, 0 ,127)</code> or <code>#7F007F</code>) to prevent the corresponding parts in the image from displacing.</li>\n</ul>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/36ac3b4c-7b5f-4940-9cfc-f33c9f607772/4-maptester.png\" /></p>\nThe Problem With Jagged Edges\n<p>You may have noticed the pixelated edges that sometimes appear in the output image. Especially source material with high contrast, e.g. typography or vector artwork, is prone to this effect.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b86024a8-2f3b-40b4-8d49-550cf9424f7c/5-jaggededges.png\" /></p>\n<p>This is caused by several reasons:</p>\n<ul>\n<li><strong>The filter will take the source image as a bitmap:</strong><br />If there exist antialiased edges in the source, the filter will not \"re-initialize\" them after displacing the source. Any pixel will be transformed to its new location, that’s it.</li>\n<li><strong>Rounding errors:</strong><br />Maybe a pixel from <code>100,100</code> must be shifted to <code>83.276, 124.217</code>. The filter must somehow map these coordinates to non-decimal pixel values.</li>\n<li><strong>Gaps after displacement:</strong><br />Maybe two neighboring pixels, say at coordinates <code>x1:100</code>, <code>x2:101</code> are shifted to different locations, maybe <code>x1:207.4</code>, <code>x2: 211.3</code>. How will the filter fill the space in between? Hint: not at all. The spec clearly states:</li>\n</ul>\n<blockquote>“Sometimes filter primitives result in undefined pixels. For example, filter primitive <code>feOffset</code> can shift an image down and to the right, leaving undefined pixels at the top and left. In these cases, the undefined pixels are set to transparent black.”<br /><br />— <a href=\"https://drafts.fxtf.org/filter-effects/#FilterPrimitivesOverviewIntro\">Filter Effects Module Level 1</a>, W3C</blockquote>\n\n<p>My weapon of choice to fix this issue is to add a slight blur, then increase the contrast with a <code>feConvolveMatrix</code>. Not perfect, but good enough for most situations. <a href=\"https://codepen.io/smashingmag/pen/PojNWwW\">Here’s a demo on CodePen</a>:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/07682702-4439-4ed5-94ab-425347e7ac2a/6-zoom.png\" /></p>\n<ol>\n<li>Insert a <code>feImage</code> primitive with a reference to the <code>absolutemap</code>;</li>\n<li>Create the \"magnifying glass\", an SVG containing a circle filled with a radial gradient, starting at <code>rgba(127, 0, 127, 0)</code> and ending at <code>rgba(127, 0, 127, 1)</code>;</li>\n<li>Insert a second <code>feImage</code> with a reference to the \"magnifying glass\";</li>\n<li>Merge both images into an feMerge primitive and make the result the <code>feDisplacementMap</code>’s <code>in2</code>. As you may have noticed we’re using a negative scale factor here to make sure the image will be scaled down outside and is displayed at its normal size inside the \"magnifying glass\";</li>\n<li>Add some JavaScript so that the <code>x</code> and <code>y</code> attributes of the feImage referencing the \"magnifying glass\" match the mouse position.</li>\n</ol>\nGenerating Arbitrary Maps With Blurred Paths\n<p>A totally different way to build an SVG displacement map is by making use of extremely thick blurred bezier paths instead of gradients. <a href=\"https://codepen.io/smashingmag/pen/OJgNWzO\">Here’s a little app that lets you change the bezier anchor points in a map created this way</a>.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/84d94081-6591-4451-86b1-7e767f2bafc2/7-beziermap.png\" /></p>\n<p>It’s possible to create some pretty rad maps this way, but you should keep in mind that blurring has an impact on rendering performance. Firefox even has a <a href=\"https://codepen.io/smashingmag/pen/qBjZRpO\">threshold of 100px</a> on how much blurring is allowed.</p>\nAnimation\n<p>By now we learned everything about the main principles behind displacement filtering and how to create displacement maps in SVG. We are ready for the fun part: how to set everything into motion.</p>\n<p>SVG filters can be animated and transitioned. A big problem is the fact that filter values referencing a URL will not be interpolated, but swapped out immediately without any transition in-between, a behavior that is in line with the <a href=\"https://www.w3.org/TR/filter-effects-1/#interpolation-of-filters\">spec</a>. Can be ok in some situations, but boring most of the time. We want animated twirls, ripples, warps, and morphs!</p>\n<p>When thinking of animated maps, the first thing that comes to mind is an animated gif or WebP. Well, animated images will work in every browser <em>somehow</em>. But performance varies greatly from <em>quite</em> bad to <em>extremely</em> bad. And then there are platform-related limitations: e. g. Blink is not able to apply this animated displacement filter to elements that contain other animated elements. And we didn’t talk about file size yet. Instead we will focus on the two most reliable animation techniques IMHO: <a href=\"https://css-tricks.com/lodge/svg/23-animating-svg-smil/\">SMIL</a> (yes, <a href=\"https://groups.google.com/a/chromium.org/g/blink-dev/c/5o0yiO440LM/m/YGEJBsjUAwAJ\">SMIL still is</a> a thing <a href=\"https://browser-unplugged.net/blog/waapi.en.html\">these days</a>) and JavaScript.</p>\n<p>A filter will usually be constructed from a variety of different primitives and every attribute that was added to a node, like <code>x</code>, <code>y</code>, <code>width</code>, <code>height</code> or <code>scale</code> can be animated with SMIL.</p>\nA Simple Glitch Effect\n<p>Here’s a very simple example: making use of an animated feFlood primitive to create a basic glitch effect:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/36ce33bf-04e3-4d29-b40e-6b0e5bc7586c/8-horizontalmap.png\" /></p>\n<p>This effect can be leveraged even more by throwing masks, blurs, and some colors into the mix. Here’s <a href=\"https://codepen.io/smashingmag/pen/ZEyWLXP\">a pimped-up version of the effect</a> using the same techniques, but in a more advanced way.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c459b700-97a0-455b-8d60-c1bd5f59a3b4/9-jelly.png\" /></p>\n<p>You may have noticed that depending on your browser and CPU, the performance of these demos can vary drastically. It’s a disappointing fact that <strong>SVG Filters are still not optimized for performance</strong>. Your GPU will accelerate some simple primitives (e. g. color operations), but when you build a compound filter chaining and merging many primitives you will quickly find framerates dropping and fans going up — especially in WebKit and Firefox. Browser vendors have a lot of topics on their to-do lists and SVG Filter Effects don’t have the highest priority there, especially as they still are not found that often out in the wild.</p>\n<p>This doesn’t mean that you can’t use animated SVG Filters now, but you should apply them in a responsible way: preferably limit the dimensions of the animated paint area to the smallest possible rectangle, limit the number of iterations to the minimum, be careful with blurs and blending operations and test test test on many browsers and devices.</p>\n<p>A good use case for animated filter effects are small, locally constrained animations applied to UI elements. Below is a demonstration of how the animated <code>feImage</code> effect from above can be used to spice up a rather boring progress bar:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a4ddf1d2-76a1-4020-8e4b-a31453fbed13/10-blurredfeflood.png\" /></p>\nA Glitch Transition Between Elements\n<ul>\n<li>Create 2 different SVGs for each channel in our map. For each color create a grid of rectangles with randomly varying color intensity.</li>\n<li>Create 2 different <code>feImage</code> primitives. URL-encode each SVG, then put it into the <code>href</code>-attribute of each <code>feImage</code>.</li>\n<li>Add SMIL animations for <code>width</code>, <code>height</code>, and <code>y</code> attributes.</li>\n<li>Insert a <code>feBlend</code> and blend both <code>feImages</code> into a single output.</li>\n<li>Add some colored <code>feDropShadows</code> for a cool split-color effect.</li>\n<li>Blend everything, then feed it into a <code>feDisplacementmap</code>.</li>\n<li>Animate the <code>scale</code> attribute with SMIL.</li>\n<li>Feel free to experiment by changing forms (e. g. use circles instead of rects), applying different timings, adding blur effects, and more.</li>\n</ul>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c0bc6504-d6ab-4a92-a363-f7666310fa1f/11-animatedglitch.png\" /></p>\nAnimating The Map Itself\n<p>So far we have learned that animating filter attributes with SMIL can help us to achieve really cool visual effects. On the other hand, we already saw how SVG fragments can be used as a displacement map. As SVGs are animatable with JavaScript, SMIL and CSS, it would seem obvious that we can apply animations directly to an SVG map right?</p>\n<p>Unfortunately, SMIL and CSS animations in SVG images used\nas input for <code>feImage</code> will not run when the SVG or fragment is URL\nencoded. We will need to write some JavaScript for a reliable solution and take into account that two different approaches for Webkit and Blink/Quantum browsers are necessary. In a first step, let’s see how the \"ideal\" way of animating a map will look:</p>\n<ul>\n<li>Create the SVG fragment containing your map;</li>\n<li>Reference it from the <code>feImage</code> that controls your <code>feDisplacementMap</code>’s <code>in2</code>;</li>\n<li>Feel free to animate everything in your fragment with JavaScript as you like. Roll your own script or use your favorite <a href=\"https://dev.to/priteshbhoi/10-best-javascript-animation-libraries-to-use-in-2021-bd9\">library</a>.</li>\n</ul>\n<p>\"This sounds too easy. Where’s the catch?\" Of course, you are right. The method described above is the <em>ideal</em> path, the way things <em>should</em> work but, here’s a strange matter of fact: It will <em>not</em> work anywhere but Webkit. In order for our animation to run in Blink and Firefox, we must implement a rather hacky solution and you won’t like it:</p>\n<ul>\n<li>Create the SVG fragment containing your map.</li>\n<li>In every frame of your animation, change all the values of every animated attribute.</li>\n<li>In every frame of your animation create a new URL encoded string containing a \"snapshot\" of the fragment and write it into the feImages <code>href</code> attribute.</li>\n</ul>\n<p>You’re probably thinking: \"This is ugly! I don’t like it and you are a despicable person!\". I feel your pain. The front end is a hostile habitat and sometimes we must do abhorrent things to survive (fun fact: the \"ugly\" method performs better in Blink than the \"pure\" method in Webkit will).</p>\nLet’s Rock!\n<p>Let’s solve a real-world problem with this approach: here’s what happens to “The Rock” when we apply these two simple displacement maps:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a1c685d5-6554-49b1-b11d-3ef5faa77655/12-rippl.png\" /></p>\n<h3>2. Using Animejs’ Grid Animation</h3>\n<p>Animejs’ staggering and “grid” properties can help you create really cool typographic effects. This effect was created by <a href=\"https://codepen.io/smashingmag/pen/LYLNxLp\">animating a grid of circles</a>:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/5a7809dd-2bc3-40d8-9a4a-cf3db2cde315/13-pool.png\" /></p>\n<h3>3. A \"Waving Flag\" Menu</h3>\n<p>An unconventional way of swapping a second-level submenu. <a href=\"https://codepen.io/smashingmag/pen/OJgNWpj\">The fade-in effect</a> is achieved by moving a striped map horizontally:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a7add41d-cb32-4edf-a5d3-9e6854846833/14-wave.png\" /></p>\n<p>Please note that <strong>the demos shown above are highly experimental</strong> and mainly intended to demonstrate the concept of animated displacement maps. If you want to use any of these techniques in a live project, always take my <a href=\"#performance-recommendations\">earlier recommendations</a> to heart. And forgive me for not going into detail on every example — it simply would exceed the scope of this article.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"bbe60b5047281331152897c8dce11f491fb8265a0da1b219eb8693722a29dfcf","category":"Tech"}