{"title":"AWS Lambda Functions Powered by AWS Graviton2 Processor – Run Your Functions on Arm and Get Up to 34% Better Price Performance","link":"https://aws.amazon.com/blogs/aws/aws-lambda-functions-powered-by-aws-graviton2-processor-run-your-functions-on-arm-and-get-up-to-34-better-price-performance/","date":1632950350000,"content":"<p>Many of our customers (such as <a href=\"https://www.formula1.com/\">Formula One</a>, <a href=\"https://www.honeycomb.io/\">Honeycomb</a>, <a href=\"https://www.intuit.com/\">Intuit</a>, <a href=\"https://www.smugmug.com/\">SmugMug</a>, and <a href=\"https://www.snap.com/\">Snap Inc.</a>) use the Arm-based <a href=\"https://aws.amazon.com/ec2/graviton/\">AWS Graviton2</a> processor for their workloads and enjoy better price performance. Starting today, you can get the same benefits for your <a href=\"https://aws.amazon.com/lambda/\">AWS Lambda</a> functions. You can now configure new and existing functions to run on <strong>x86</strong> or <strong>Arm/Graviton2 </strong>processors.</p> \n<p>With this choice, you can save money in two ways. First, your functions run more efficiently due to the Graviton2 architecture. Second, you pay less for the time that they run. In fact, Lambda functions powered by Graviton2 are designed to deliver <strong>up to 19 percent better performance</strong> at <strong>20 percent lower cost</strong>.</p> \n<p>With Lambda, you are charged based on the number of <strong>requests</strong> for your functions and the <strong>duration</strong> (the time it takes for your code to execute) with <a href=\"https://aws.amazon.com/blogs/aws/new-for-aws-lambda-1ms-billing-granularity-adds-cost-savings/\">millisecond granularity</a>. For functions using the Arm/Graviton2 architecture, duration charges are <strong>20 percent lower</strong> than the current pricing for x86. The same 20 percent reduction also applies to duration charges for functions using <a href=\"https://aws.amazon.com/blogs/aws/new-provisioned-concurrency-for-lambda-functions/\">Provisioned Concurrency</a>.</p> \n<p>In addition to the price reduction, functions using the Arm architecture benefit from the performance and security built into the Graviton2 processor. Workloads using multithreading and multiprocessing, or performing many I/O operations, can experience lower execution time and, as a consequence, even lower costs. This is particularly useful now that you can use <a href=\"https://aws.amazon.com/blogs/aws/new-for-aws-lambda-functions-with-up-to-10-gb-of-memory-and-6-vcpus/\">Lambda functions with up to 10 GB of memory and 6 vCPUs</a>. For example, you can get better performance for web and mobile backends, microservices, and data processing systems.</p> \n<p>If your functions don’t use architecture-specific binaries, including in their dependencies, you can switch from one architecture to the other. This is often the case for many functions using interpreted languages such as Node.js and Python or functions compiled to Java bytecode.</p> \n<p>All <a href=\"https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html\">Lambda runtimes</a> built on top of <a href=\"https://aws.amazon.com/amazon-linux-2/\">Amazon Linux 2</a>, including the <a href=\"https://docs.aws.amazon.com/lambda/latest/dg/runtimes-custom.html\">custom runtime</a>, are supported on Arm, with the exception of Node.js 10 that has reached <a href=\"https://docs.aws.amazon.com/lambda/latest/dg/runtime-support-policy.html\">end of support</a>. If you have binaries in your function packages, you need to rebuild the function code for the architecture you want to use. Functions packaged as container images need to be built for the architecture (x86 or Arm) they are going to use.</p> \n<p>To measure the difference between architectures, you can create two <a href=\"https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html\">versions</a> of a function, one for x86 and one for Arm. You can then send traffic to the function via an <a href=\"https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html\">alias</a> using weights to distribute traffic between the two versions. In <a href=\"https://aws.amazon.com/cloudwatch/\">Amazon CloudWatch</a>, performance metrics are collected by function versions, and you can look at key indicators (such as duration) using <a href=\"https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Statistic\">statistics</a>. You can then compare, for example, average and <a href=\"https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Statistics-definitions.html\">p99</a> duration between the two architectures.</p> \n<p>You can also use function versions and weighted aliases to control the rollout in production. For example, you can deploy the new version to a small amount of invocations (such as 1 percent) and then increase up to 100 percent for a complete deployment. During rollout, you can lower the weight or set it to zero if your metrics show something suspicious (such as an increase in errors).</p> \n<p>Let’s see how this new capability works in practice with a few examples.</p> \n<p><span><b>Changing Architecture for Functions with No Binary </b><b><u>Dependencies</u></b><br /> </span>When there are no binary dependencies, changing the architecture of a Lambda function is like flipping a switch. For example, some time ago, I built a quiz app with a Lambda function. With this app, you can ask and answer questions using a web API. I use an <a href=\"http://aws.amazon.com/apigateway\">Amazon API Gateway</a> <a href=\"https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html\">HTTP API</a> to trigger the function. Here’s the Node.js code including a few sample questions at the beginning:</p> \n<pre><code>const questions = [\n  {\n    question:\n      \"Are there more synapses (nerve connections) in your brain or stars in our galaxy?\",\n    answers: [\n      \"More stars in our galaxy.\",\n      \"More synapses (nerve connections) in your brain.\",\n      \"They are about the same.\",\n    ],\n    correctAnswer: 1,\n  },\n  {\n    question:\n      \"Did Cleopatra live closer in time to the launch of the iPhone or to the building of the Giza pyramids?\",\n    answers: [\n      \"To the launch of the iPhone.\",\n      \"To the building of the Giza pyramids.\",\n      \"Cleopatra lived right in between those events.\",\n    ],\n    correctAnswer: 0,\n  },\n  {\n    question:\n      \"Did mammoths still roam the earth while the pyramids were being built?\",\n    answers: [\n      \"No, they were all exctint long before.\",\n      \"Mammooths exctinction is estimated right about that time.\",\n      \"Yes, some still survived at the time.\",\n    ],\n    correctAnswer: 2,\n  },\n];\n\nexports.handler = async (event) =&gt; {\n  console.log(event);\n\n  const method = event.requestContext.http.method;\n  const path = event.requestContext.http.path;\n  const splitPath = path.replace(/^\\/+|\\/+$/g, \"\").split(\"/\");\n\n  console.log(method, path, splitPath);\n\n  var response = {\n    statusCode: 200,\n    body: \"\",\n  };\n\n  if (splitPath[0] == \"questions\") {\n    if (splitPath.length == 1) {\n      console.log(Object.keys(questions));\n      response.body = JSON.stringify(Object.keys(questions));\n    } else {\n      const questionId = splitPath[1];\n      const question = questions[questionId];\n      if (question === undefined) {\n        response = {\n          statusCode: 404,\n          body: JSON.stringify({ message: \"Question not found\" }),\n        };\n      } else {\n        if (splitPath.length == 2) {\n          const publicQuestion = {\n            question: question.question,\n            answers: question.answers.slice(),\n          };\n          response.body = JSON.stringify(publicQuestion);\n        } else {\n          const answerId = splitPath[2];\n          if (answerId == question.correctAnswer) {\n            response.body = JSON.stringify({ correct: true });\n          } else {\n            response.body = JSON.stringify({ correct: false });\n          }\n        }\n      }\n    }\n  }\n\n  return response;\n};</code></pre> \n<p>To start my quiz, I ask for the list of question IDs. To do so, I use <a href=\"https://curl.se/\">curl</a> with an HTTP GET on the <code>/questions</code> endpoint:</p> \n<div> \n <pre><code>$ curl https://&lt;api-id&gt;.execute-api.us-east-1.amazonaws.com/questions\n[\n  \"0\",\n  \"1\",\n  \"2\"\n]</code></pre> \n</div> \n<div></div> Then, I ask more information on a question by adding the ID to the endpoint:\n<p></p> \n<div> \n <pre><code>$ curl https://&lt;api-id&gt;.execute-api.us-east-1.amazonaws.com/questions/1\n{\n  \"question\": \"Did Cleopatra live closer in time to the launch of the iPhone or to the building of the Giza pyramids?\",\n  \"answers\": [\n    \"To the launch of the iPhone.\",\n    \"To the building of the Giza pyramids.\",\n    \"Cleopatra lived right in between those events.\"\n  ]\n}</code></pre> \n</div> \n<p>I plan to use this function in production. I expect many invocations and look for options to optimize my costs. In the <a href=\"https://console.aws.amazon.com/lambda/home\">Lambda console</a>, I see that this function is using the <code>x86_64</code> architecture.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/26/lambda-arm-architecture-settings-1.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/26/lambda-arm-architecture-settings-1-1024x169.png\" /></a></p> \n<p>Because this function is not using any binaries, I switch architecture to <code>arm64</code> and benefit from the lower pricing.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/09/06/lambda-arm-change-architecture.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/09/06/lambda-arm-change-architecture-1024x706.png\" /></a></p> \n<p>The change in architecture doesn’t change the way the function is invoked or communicates its response back. This means that the integration with the API Gateway, as well as integrations with other applications or tools, are not affected by this change and continue to work as before.</p> \n<p>I continue my quiz with no hint that the architecture used to run the code has changed in the backend. I answer back to the previous question by adding the number of the answer (starting from zero) to the question endpoint:</p> \n<div> \n <pre><code>$ curl https://&lt;api-id&gt;.execute-api.us-east-1.amazonaws.com/questions/1/0\n{\n  \"correct\": true\n}</code></pre> \n</div> \n<p>That’s correct! Cleopatra lived closer in time to the launch of the iPhone than the building of the Giza pyramids. While I am digesting this piece of information, I realize that I completed the migration of the function to Arm and optimized my costs.</p> \n<p><span><strong>Changing Architecture for Functions Packaged Using Container Images<br /> </strong></span>When we introduced the <a href=\"https://aws.amazon.com/blogs/aws/new-for-aws-lambda-container-image-support/\">capability to package and deploy Lambda functions using container images</a>, I did a demo with a Node.js function generating a PDF file with the <a href=\"https://github.com/foliojs/pdfkit\">PDFKit</a> module. Let’s see how to migrate this function to Arm.</p> \n<p>Each time it is invoked, the function creates a new PDF mail containing random data generated by the <a href=\"https://github.com/marak/Faker.js/\">faker.js</a> module. The output of the function is using the syntax of the Amazon API Gateway to return the PDF file using <a href=\"https://aws.amazon.com/blogs/compute/handling-binary-data-using-amazon-api-gateway-http-apis/\">Base64 encoding</a>. For convenience, I replicate the code (<code>app.js</code>) of the function here:</p> \n<pre><code>const PDFDocument = require('pdfkit');\nconst faker = require('faker');\nconst getStream = require('get-stream');\n\nexports.lambdaHandler = async (event) =&gt; {\n\n    const doc = new PDFDocument();\n\n    const randomName = faker.name.findName();\n\n    doc.text(randomName, { align: 'right' });\n    doc.text(faker.address.streetAddress(), { align: 'right' });\n    doc.text(faker.address.secondaryAddress(), { align: 'right' });\n    doc.text(faker.address.zipCode() + ' ' + faker.address.city(), { align: 'right' });\n    doc.moveDown();\n    doc.text('Dear ' + randomName + ',');\n    doc.moveDown();\n    for(let i = 0; i &lt; 3; i++) {\n        doc.text(faker.lorem.paragraph());\n        doc.moveDown();\n    }\n    doc.text(faker.name.findName(), { align: 'right' });\n    doc.end();\n\n    pdfBuffer = await getStream.buffer(doc);\n    pdfBase64 = pdfBuffer.toString('base64');\n\n    const response = {\n        statusCode: 200,\n        headers: {\n            'Content-Length': Buffer.byteLength(pdfBase64),\n            'Content-Type': 'application/pdf',\n            'Content-disposition': 'attachment;filename=test.pdf'\n        },\n        isBase64Encoded: true,\n        body: pdfBase64\n    };\n    return response;\n};</code></pre> \n<p>To run this code, I need the <code>pdfkit</code>, <code>faker</code>, and <code>get-stream</code> <a href=\"https://www.npmjs.com/\">npm</a> modules. These packages and their versions are described in the <code>package.json</code> and <code>package-lock.json</code> files.</p> \n<p>I update the <code>FROM</code> line in the <code>Dockerfile</code> to use an <a href=\"https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-create-from-base\">AWS base image for Lambda</a> for the Arm architecture. Given the chance, I also update the image to use Node.js 14 (I was using Node.js 12 at the time). This is the only change I need to switch architecture.</p> \n<div> \n <pre><code>FROM public.ecr.aws/lambda/nodejs:14-arm64\nCOPY app.js package*.json ./\nRUN npm install\nCMD [ \"app.lambdaHandler\" ]</code></pre> \n</div> \n<p>For the next steps, I follow <a href=\"https://aws.amazon.com/blogs/aws/new-for-aws-lambda-container-image-support/\">the post I mentioned previously</a>. This time I use <code>random-letter-arm</code> for the name of the container image and for the name of the Lambda function. First, I build the image:</p> \n<div> \n <pre><code>$ docker build -t random-letter-arm .</code></pre> \n</div> \n<p>Then, I inspect the image to check that it is using the right architecture:</p> \n<div> \n <pre><code>$ docker inspect random-letter-arm | grep Architecture\n\n\"Architecture\": \"arm64\",</code></pre> \n</div> \n<p>To be sure the function works with the new architecture, I run the container locally.</p> \n<div> \n <pre><code>$ docker run -p 9000:8080 random-letter-arm:latest</code></pre> \n</div> \n<p>Because the container image includes the <a href=\"https://docs.aws.amazon.com/lambda/latest/dg/images-test.html\">Lambda Runtime Interface Emulator</a>, I can test the function locally:</p> \n<div> \n <pre><code>$ curl -XPOST \"http://localhost:9000/2015-03-31/functions/function/invocations\" -d '{}'</code></pre> \n</div> \n<p>It works! The response is a JSON document containing a base64-encoded response for the API Gateway:</p> \n<div> \n <pre><code>{\n    \"statusCode\": 200,\n    \"headers\": {\n        \"Content-Length\": 2580,\n        \"Content-Type\": \"application/pdf\",\n        \"Content-disposition\": \"attachment;filename=test.pdf\"\n    },\n    \"isBase64Encoded\": true,\n    \"body\": \"...\"\n}</code></pre> \n</div> \n<p>Confident that my Lambda function works with the <code>arm64</code> architecture, I create a new <a href=\"https://aws.amazon.com/ecr/\">Amazon Elastic Container Registry</a> repository using the <a href=\"https://aws.amazon.com/cli/\">AWS Command Line Interface (CLI)</a>:</p> \n<div> \n <pre><code>$ aws ecr create-repository --repository-name random-letter-arm --image-scanning-configuration scanOnPush=true</code></pre> \n</div> \n<p>I tag the image and push it to the repo:</p> \n<div> \n <pre><code>$ docker tag random-letter-arm:latest 123412341234.dkr.ecr.us-east-1.amazonaws.com/random-letter-arm:latest\n$ aws ecr get-login-password | docker login --username AWS --password-stdin 123412341234.dkr.ecr.us-east-1.amazonaws.com\n$ docker push 123412341234.dkr.ecr.us-east-1.amazonaws.com/random-letter-arm:latest</code></pre> \n</div> \n<p>In the Lambda console, I create the <code>random-letter-arm</code> function and select the option to create the function from a container image.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/20/lambda-arm-container-image.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/20/lambda-arm-container-image-1024x212.png\" /></a></p> \n<p>I enter the function name, browse my ECR repositories to select the <code>random-letter-arm</code> container image, and choose the <strong>arm64</strong> architecture.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/09/06/lambda-arm-container-image-settings.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/09/06/lambda-arm-container-image-settings-1024x492.png\" /></a></p> \n<p>I complete the creation of the function. Then, I add the API Gateway as a trigger. For simplicity, I leave the authentication of the API open.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/23/lambda-arm-container-image-trigger.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/23/lambda-arm-container-image-trigger-1024x457.png\" /></a></p> \n<p>Now, I click on the API endpoint a few times and download some PDF mails generated with random data:</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/20/lambda-arm-demo-files.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/20/lambda-arm-demo-files-1024x689.png\" /></a></p> \n<p>The migration of this Lambda function to Arm is complete. The process will differ if you have specific dependencies that do not support the target architecture. The ability to <a href=\"https://docs.aws.amazon.com/lambda/latest/dg/images-test.html\">test your container image locally</a> helps you find and fix issues early in the process.</p> \n<p><span><strong>Comparing Different Architectures with Function Versions and Aliases<br /> </strong></span>To have a function that makes some meaningful use of the CPU, I use the following Python code. It computes all <a href=\"https://en.wikipedia.org/wiki/Prime_number\">prime numbers</a> up to a limit passed as a parameter. I am not using the best possible algorithm here, that would be <a href=\"https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\">the sieve of Eratosthenes</a>, but it’s a good compromise for an efficient use of memory. To have more visibility, I add the architecture used by the function to the response of the function.</p> \n<pre><code>import json\nimport math\nimport platform\nimport timeit\n\ndef primes_up_to(n):\n    primes = []\n    for i in range(2, n+1):\n        is_prime = True\n        sqrt_i = math.isqrt(i)\n        for p in primes:\n            if p &gt; sqrt_i:\n                break\n            if i % p == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\ndef lambda_handler(event, context):\n    start_time = timeit.default_timer()\n    N = int(event['queryStringParameters']['max'])\n    primes = primes_up_to(N)\n    stop_time = timeit.default_timer()\n    elapsed_time = stop_time - start_time\n\n    response = {\n        'machine': platform.machine(),\n        'elapsed': elapsed_time,\n        'message': 'There are {} prime numbers &lt;= {}'.format(len(primes), N)\n    }\n    \n    return {\n        'statusCode': 200,\n        'body': json.dumps(response)\n    }</code></pre> \n<p>I create two function versions using different architectures.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/23/lambda-arm-function-versions.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/23/lambda-arm-function-versions-1024x253.png\" /></a></p> \n<p>I use a weighted alias with <strong>50%</strong> weight on the x86 version and <strong>50%</strong> weight on the Arm version to distribute invocations evenly. When invoking the function through this alias, the two versions running on the two different architectures are executed with the same probability.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/23/lambda-arm-function-alias.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/23/lambda-arm-function-alias-1024x243.png\" /></a></p> \n<p>I create an API Gateway trigger for the function alias and then generate some load using a few terminals on my laptop. Each invocation computes prime numbers up to one million. You can see in the output how two different architectures are used to run the function.</p> \n<div> \n <pre><code>$ while True\n  do\n    curl https://&lt;api-id&gt;.execute-api.us-east-1.amazonaws.com/default/prime-numbers\\?max\\=1000000\n  done\n\n{\"machine\": \"aarch64\", \"elapsed\": 1.2595275060011772, \"message\": \"There are 78498 prime numbers &lt;= 1000000\"}\n{\"machine\": \"aarch64\", \"elapsed\": 1.2591725109996332, \"message\": \"There are 78498 prime numbers &lt;= 1000000\"}\n{\"machine\": \"x86_64\", \"elapsed\": 1.7200910530000328, \"message\": \"There are 78498 prime numbers &lt;= 1000000\"}\n{\"machine\": \"x86_64\", \"elapsed\": 1.6874686619994463, \"message\": \"There are 78498 prime numbers &lt;= 1000000\"}\n{\"machine\": \"x86_64\", \"elapsed\": 1.6865161940004327, \"message\": \"There are 78498 prime numbers &lt;= 1000000\"}\n{\"machine\": \"aarch64\", \"elapsed\": 1.2583248640003148, \"message\": \"There are 78498 prime numbers &lt;= 1000000\"}\n...</code></pre> \n</div> \n<p>During these executions, <a href=\"https://docs.aws.amazon.com/lambda/latest/dg/monitoring-metrics.html\">Lambda sends metrics to CloudWatch</a> and the function version (<code>ExecutedVersion</code>) is stored as one of the dimensions.</p> \n<p>To better understand what is happening, I create a <a href=\"https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Dashboards.html\">CloudWatch dashboard</a> to monitor the p99 duration for the two architectures. In this way, I can compare the performance of the two environments for this function and make an informed decision on which architecture to use in production.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/23/lambda-arm-function-dashboard.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/23/lambda-arm-function-dashboard-1024x555.png\" /></a></p> \n<p>For this particular workload, functions are running much faster on the Graviton2 processor, providing a better user experience and much lower costs.</p> \n<p><span><strong>Comparing Different Architectures with Lambda Power Tuning<br /> </strong></span>The <a href=\"https://github.com/alexcasalboni/aws-lambda-power-tuning\">AWS Lambda Power Tuning</a> open-source project, created by my friend <a href=\"https://twitter.com/alex_casalboni/\">Alex Casalboni</a>, runs your functions using different settings and suggests a configuration to minimize costs and/or maximize performance. The project has <a href=\"https://twitter.com/alex_casalboni/status/1430558856908783616\">recently been updated to let you compare two results on the same chart</a>. This comes in handy to compare two versions of the same function, one using x86 and the other Arm.</p> \n<p>For example, this chart compares x86 and Arm/Graviton2 results for the function computing prime numbers I used earlier in the post:</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/26/lambda-arm-power-tuning-1.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/08/26/lambda-arm-power-tuning-1-1024x529.png\" /></a></p> \n<p>The function is using a single thread. In fact, the lowest duration for both architectures is reported when memory is configured with 1.8 GB. Above that, Lambda functions have access to more than 1 vCPU, but in this case, the function can’t use the additional power. For the same reason, costs are stable with memory up to 1.8 GB. With more memory, costs increase because there are no additional performance benefits for this workload.</p> \n<p>I look at the chart and configure the function to use 1.8 GB of memory and the Arm architecture. The Graviton2 processor is clearly providing better performance and lower costs for this compute-intensive function.</p> \n<p><span><strong>Availability and Pricing<br /> </strong></span>You can use Lambda Functions powered by Graviton2 processor today in US East (N. Virginia), US East (Ohio), US West (Oregon), Europe (Frankfurt), Europe (Ireland), EU (London), Asia Pacific (Mumbai), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo).</p> \n<p>The following runtimes running on top of <a href=\"https://aws.amazon.com/amazon-linux-2/\">Amazon Linux 2</a> are supported on Arm:</p> \n<ul> \n <li>Node.js 12 and 14</li> \n <li>Python 3.8 and 3.9</li> \n <li>Java 8 (<code>java8.al2</code>) and 11</li> \n <li>.NET Core 3.1</li> \n <li>Ruby 2.7</li> \n <li><a href=\"https://docs.aws.amazon.com/lambda/latest/dg/runtimes-custom.html\">Custom Runtime</a> (<code>provided.al2</code>)</li> \n</ul> \n<p>You can manage Lambda Functions powered by Graviton2 processor using <a href=\"https://aws.amazon.com/serverless/sam/\">AWS Serverless Application Model (SAM)</a> and <a href=\"https://aws.amazon.com/cdk/\">AWS Cloud Development Kit (AWS CDK)</a>. Support is also available through many <a href=\"https://aws.amazon.com/lambda/partners/\">AWS Lambda Partners</a> such as <a href=\"https://antstack.io/blog/introducing-aws-lambda-functions-powered-by-aws-graviton-2-processors/\">AntStack</a>, <a href=\"https://blog.checkpoint.com/2021/09/29/how-aws-gravitron2-makes-serverless-workload-performance-cost-and-security-more-effective/\">Check Point</a>, <a href=\"https://cloudwiry.com/lambda-functions-aws-graviton2/\">Cloudwiry</a>, <a href=\"https://www.contino.io/\">Contino</a>, <a href=\"https://coralogix.com/\">Coralogix</a>, <a href=\"https://www.datadoghq.com/blog/aws-graviton2-lambda-monitoring/\">Datadog</a>, <a href=\"https://lumigo.io/blog/graviton-based-lambda-functions-what-it-means-for-you/\">Lumigo</a>, <a href=\"https://www.pulumi.com/blog/aws-lambda-functions-powered-by-graviton2/\">Pulumi</a>, <a href=\"https://medium.com/slalom-build/savings-in-aws-lambda-functions-powered-by-aws-graviton2-processors-b9ba1d84ea7e\">Slalom</a>, <a href=\"https://www.sumologic.com/blog/monitor-aws-lambda-functions-graviton2/\">Sumo Logic</a>, <a href=\"https://blog.thundra.io/a-performance-perspective-for-graviton-based-lambda-functions\">Thundra</a>, and <a href=\"https://www.xerris.com/graviton2lambda/\">Xerris</a>.</p> \n<p>Lambda functions using the Arm/Graviton2 architecture provide up to <strong>34 percent price performance</strong> improvement. The 20 percent reduction in duration costs also applies when using <a href=\"https://aws.amazon.com/blogs/aws/new-provisioned-concurrency-for-lambda-functions/\">Provisioned Concurrency</a>. You can further reduce your costs by up to 17 percent with <a href=\"https://aws.amazon.com/savingsplans/compute-pricing/\">Compute Savings Plans</a>. Lambda functions powered by Graviton2 are included in the <a href=\"https://aws.amazon.com/free/\">AWS Free Tier</a> up to the existing limits. For more information, see the <a href=\"https://aws.amazon.com/lambda/pricing/\">AWS Lambda pricing</a> page.</p> \n<p>You can find help to optimize your workloads for the <a href=\"https://aws.amazon.com/ec2/graviton/\">AWS Graviton2 processor</a> in the <a href=\"https://github.com/aws/aws-graviton-getting-started\">Getting started with AWS Graviton</a> repository.</p> \n<p><strong><a href=\"https://aws.amazon.com/lambda/\">Start running your Lambda functions on Arm today.</a> </strong></p> \n<p>— <a href=\"https://twitter.com/danilop\">Danilo</a></p>","author":"Danilo Poccia","siteTitle":"AWS News Blog","siteHash":"6093e072e4117ec22616e844cb857d03ca62c57a411a8affc77cb5e8b6b15bf6","entryHash":"f03f4ebfe6e3cc308e4714eb88ca544982a7acb3d73d761945d0ed456715f825","category":"Tech"}