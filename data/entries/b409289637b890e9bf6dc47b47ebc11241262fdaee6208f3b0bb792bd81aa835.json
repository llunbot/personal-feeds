{"title":"Getting Started With Webpack","link":"https://smashingmagazine.com/2021/06/getting-started-webpack/","date":1622800800000,"content":"<p>In the early days when <a href=\"https://en.wikipedia.org/wiki/Modular_programming\">modularity</a> was introduced in JavaScript, there was no native support for running modules within the browser. Support for <a href=\"https://en.wikipedia.org/wiki/Modular_programming\">modular programming</a> was being implemented in <a href=\"https://nodejs.org/en/\">Node.js</a> using the <a href=\"https://en.wikipedia.org/wiki/CommonJS\">CommonJS blueprint</a> and it was being adopted by those using JavaScript for building server-side applications.</p>\n<p>It also had prospects for <strong>large web applications</strong> as developers could avoid <a href=\"https://www.zendesk.com/blog/keep-javascript-libraries-from-colliding/\">namespace collisions</a> and build a more maintainable codebases by writing code in a more modular pattern. But there was still a challenge: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules\">modules</a> couldn’t be used <em>within</em> web browsers, where JavaScript was usually executed.</p>\n<p>To solve this problem, module bundlers such as <a href=\"https://webpack.js.org/\">webpack</a>, <a href=\"https://parceljs.org/\">Parcel</a>, <a href=\"https://rollupjs.org/\">Rollup</a> and also <a href=\"https://developers.google.com/closure/compiler\">Google’s Closure Compiler</a> were written to create optimized bundles of your code for your end-user's browser to download and execute.</p>\nWhat Does It Mean To “Bundle” Your Code?\n<p><em>Bundling code</em> refers to combining and optimizing multiple modules into one or more <strong>production-ready bundles</strong>. The bundle mentioned here can be understood better as the end product of the entire bundling process.</p>\n<p>In this article, we will be focusing on <a href=\"https://webpack.js.org/\">webpack</a>, a tool written by <a href=\"https://github.com/sokra\">Tobias Koppers</a>, which over time has grown to become a major tool within the JavaScript toolchain, often used in large and small projects.</p>\n<p><strong>Note:</strong> <em>To benefit from this article, it’s a good idea to be familiar with <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules\">JavaScript modules</a>. You will also need</em> <a href=\"https://www.nodejs.org\"><em>Node</em></a> <em>installed on your local machine, so you can install and use webpack locally.</em></p>\nWhat Is webpack?\n<p><a href=\"https://webpack.js.org/\">webpack</a> is a highly extensible and configurable <strong>static module bundler</strong> for JavaScript applications. With its extensible nature, you can plug in external loaders and plugins to achieve your end goal. </p>\n<p>As shown in the illustration below, webpack goes through your application from a <strong>root entry point</strong>, builds a dependency graph comprising of dependencies that act directly or indirectly on the root file and produces optimized bundles of the combined modules.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/5b9eda26-9041-4d59-a5d7-f2ddf660b950/webpack-dependency-graph.png\" /></p>\n<p>To understand how webpack works, we need to understand some terminology that it uses (check <a href=\"https://webpack.js.org/glossary/\">webpack Glossary</a>. This terminology is often used in this article, and it’s also frequently referenced in <a href=\"https://webpack.js.org/\">webpack’s documentation</a>.</p>\n<ul>\n<li><strong>Chunk</strong><br />A <em>chunk</em> refers to the code extracted from modules. This code will be stored in a <em>chunk file</em>. Chunks are commonly used when performing code-splitting with webpack.</li>\n<li><strong>Modules</strong><br /><em>Modules</em> are broken-down parts of your application which you import to perform a specific task or function. Webpack supports modules created using the <a href=\"https://webpack.js.org/api/module-methods/#es6-recommended\">ES6</a>, <a href=\"https://webpack.js.org/api/module-methods/#commonjs\">CommonJS</a> and <a href=\"https://webpack.js.org/api/module-methods/#amd\">AMD</a> syntax.</li>\n<li><strong>Assets</strong><br />The term <em>assets</em> is frequently used within webpack and other bundlers in general. It refers to the <strong>static files</strong> bundled during the build process. These files could be anything from images to fonts or even video files. As you read further down the article, you will see how we use loaders to work with different asset types.</li>\n</ul>\n<p><strong>Recommended reading</strong>: <em><a href=\"https://www.smashingmagazine.com/2017/02/a-detailed-introduction-to-webpack/\">Webpack - A Detailed Introduction</a></em></p>\n\n<p>Once we’ve understood what webpack is and what terminology it uses, let’s see how they apply in putting together a configuration file for a demo project.</p>\n<p><strong>Note</strong>: <em>You will also need <a href=\"https://webpack.js.org/api/cli/\"><code>webpack-cli</code></a> installed to use webpack on your machine. If not installed, you will be prompted from your terminal to install it.</em></p>\nwebpack Configuration Files\n<p>Apart from using the <a href=\"https://www.npmjs.com/package/webpack-cli\">webpack-cli</a> from a terminal, you can also use webpack in your project via a configuration file. But with the recent versions of webpack, we can use it in our project <em>without</em> a configuration file. We can use <code>webpack</code> as a value of one of the commands in our <code>package.json</code> file — without any flag. This way, webpack will assume your project’s entry point file lives in the <code>src</code> directory. It will bundle the entry file and output it to the <code>dist</code> directory.</p>\n<p>An example is the sample <code>package.json</code> file below. Here, we use webpack to bundle the application without a configuration file:</p>\n<pre><code>{\n  \"name\" : \"Smashing Magazine\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n      \"build\" : \"webpack\"\n  },\n  \"dependencies\" : {\n    \"webpack\": \"^5.24.1\"\n  }\n}</code></pre>\n\n<p>When running it the build command in the file above, webpack will bundle the file in the <code>src/index.js</code> directory and output it in a <code>main.js</code> file in a <code>dist</code> directory. webpack is, however, much more flexible than that. We can <strong>change the entry point</strong>, adjust the output point and refine many other default behaviors by editing a configuration file with the <code>-- config</code> flag. </p>\n<p>An example is the modified build command from the <code>package.json</code> file above:</p>\n<pre><code>\"build\" : \"webpack --config webpack.config.js\"</code></pre>\n\n<p>Above, we added the <code>--config</code> flag and specified a <code>webpack.config.js</code> as the file having the new webpack configuration. </p>\n<p>The <code>webpack.config.js</code> file doesn’t exist yet though. So we need to create it in our application directory and paste the following code below into the file.</p>\n<pre><code># webpack.config.js\n\nconst path = require(\"path\")\n\nmodule.exports = {\n  entry : \"./src/entry\",\n  output : {\n    path: path.resolve(__dirname, \"dist\"),\n    filename: \"output.js\"\n  }\n}\n</code></pre>\n\n<p>The file above still configures webpack to bundle your JavaScript file, but now we can define a <strong>custom entry</strong> and output file paths rather than the default path used by webpack.</p>\n<p>A few things to note about a webpack configuration file:</p>\n<ul>\n<li>A webpack configuration file is a JavaScript file, written as a JavaScript <a href=\"https://nodejs.org/api/modules.html#modules_modules_commonjs_modules\">CommonJS module</a>. </li>\n<li>A webpack configuration file <strong>exports an object</strong> with several properties. Each of these properties is used as an option to configure webpack when bundling your code. An example is the <code>mode</code> option:<ul>\n<li><a href=\"https://webpack.js.org/configuration/mode/\"><code>mode</code></a><br />In configuration, this option is used to set the <code>NODE_ENV</code> value during bundling. It can either have a <code>production</code> or <code>development</code> value. When not specified, it will <strong>default</strong> to <code>none</code>. It’s also important to note that webpack bundles your assets <em>differently</em> based on the <code>mode</code> value. For example, webpack automatically caches your bundles in development mode to optimize and reduce the bundle time. Refer to the <a href=\"https://webpack.js.org/configuration/mode/\">mode section</a> of the <a href=\"https://webpack.js.org/guides/getting-started/\">webpack documentation</a> to see a changelog of the options automatically applied in each mode.</li>\n</ul>\n</li>\n</ul>\nwebpack Concepts\n<p>When configuring webpack either via the <a href=\"https://webpack.js.org/api/cli/\">CLI</a> or through a configuration file, there are <strong>four main concepts</strong> that are applied as <em>options</em>. The next section of this article focuses on these concepts and applies them when building the configuration for a demo web application.</p>\n<p>Please note that the concepts explained below share some similarities with other module bundlers. For example, when using <a href=\"https://rollupjs.org/guide/en/#configuration-files\">Rollup</a> with a <a href=\"https://rollupjs.org/guide/en/#configuration-files\">configuration file</a>, you can define an <a href=\"https://rollupjs.org/guide/en/#configuration-files\">input</a> field to specify the entry point of the dependency graph, an <a href=\"https://rollupjs.org/guide/en/#configuration-files\">output</a> object configuring how and where the produced chunks are placed, and also a <a href=\"https://rollupjs.org/guide/en/#configuration-files\">plugins</a> object for adding external plugins.</p>\n<h3>Entry</h3>\n<p>The <em>entry</em> field in your configuration file contains the path to the file from where webpack starts building a <strong>dependency graph</strong>. From this entry file, webpack will proceed to other modules which depend directly or indirectly on the entry point. </p>\n<p>Your configuration’s entry point can be a <a href=\"https://webpack.js.org/concepts/entry-points/#single-entry-shorthand-syntax\">Single Entry</a> type with a <strong>single</strong> file value, similar to the example below:</p>\n<pre><code># webpack.configuration.js\n\nmodule.exports = {\n  mode:  \"development\",\n  entry : \"./src/entry\" \n}\n</code></pre>\n\n<p>The entry point can also be a <strong>multi-main entry type</strong> having an array containing the path to several entry files, similar to the example below:</p>\n<pre><code># webpack.configuration.js\n\nconst webpack = require(\"webpack\")\n\nmodule.exports = {\n  mode: \"development\",\n  entry: [ './src/entry', './src/entry2' ],\n}\n</code></pre>\n\n<h3>Output</h3>\n<p>Just as the name implies, a configuration’s <em>output</em> field is where the created bundle will live. This field comes in handy when you have several modules in place. Rather than using the name generated by webpack, you can <strong>specify your own filename</strong>.</p>\n<pre><code># webpack.configuration.js\n\nconst webpack = require(\"webpack\");\nconst path = require(\"path\");\n\nmodule.exports = {\n  mode: \"development\",\n  entry: './src/entry',\n  output: {\n    filename: \"webpack-output.js\",\n    path: path.resolve(__dirname, \"dist\"),\n  }\n}\n</code></pre>\n\n<h3>Loaders</h3>\n<p>By default, webpack only understands JavaScript files within your application. However, webpack treats every file imported as a module as a <strong>dependency</strong>, and adds it to the dependency graph. To process static resources such as images, CSS files, JSON files or even your data stored in CSV, webpack uses <a href=\"https://webpack.js.org/concepts/loaders/\">loaders</a> to “load” these files into the bundle.</p>\n<p>Loaders are flexible enough to be used for a lot of things, from transpiling your ES code, to handling your application’s styles or even linting your code with ESLint.</p>\n<p>There are <strong>three ways to use loaders</strong> within your application. One of them is through the <em>inline</em> method by directly importing it in the file. For example, to minimize image size, we can use the <code>image-loader</code> loader in the file directly as shown below:</p>\n<pre><code>// main.js\n\nimport ImageLoader from 'image-loader'</code></pre>\n\n<p>Another preferred option to use loaders is via your webpack configuration file. This way, you can do more with loaders, such as <strong>specifying the file types</strong> you want to apply the loaders to. To do this, we create a <code>rules</code> array and specify the loaders in an object, each having a test field with a regex expression matching the assets we want to apply the loaders to.</p>\n<p>For examples, with <code>image-loader</code> imported directly in the previous example, we can use it in the webpack configuration file with the most basic options from the <a href=\"https://github.com/vanwagonet/img-loader\">documentation</a>. This will look like this:</p>\n<pre><code># webpack.config.js\n\nconst webpack = require(\"webpack\")\nconst path = require(\"path\")\nconst merge = require(\"webpack-merge\")\n\nmodule.exports = {\n  mode: \"development\",\n  entry: './src/entry',\n  output: {\n    filename: \"webpack-output.js\",\n    path: path.resolve(__dirname, \"dist\"),\n  },\n  module: {\n    rules: [\n    {\n      test: /\\.(jpe?g|png|gif|svg)$/i,\n      use: [\n        'img-loader'\n        ]\n    }\n   ]\n  }\n}\n</code></pre>\n\n<p>Take a closer look at the <code>test</code> field in the object that contains the <code>image-loader</code> above. We can spot the regex expression that matches all image files: either <code>jp(e)g</code>, <code>png</code>, <code>gif</code> and <code>svg</code> format.</p>\n<p>The last method of using Loaders is via the CLI with the <code>--module-bind</code> flag. </p>\n<p>The <a href=\"https://github.com/webpack-contrib/awesome-webpack#loaders\">awesome-webpack</a> readme contains an <strong>exhaustive list of loaders</strong> that you can use with webpack, each grouped into categories of operations that they perform. Below are just a few loaders that you might find handy in your application:</p>\n<ul>\n<li><a href=\"https://github.com/herrstucki/responsive-loader\"><strong>Responsive-loader</strong></a>\nYou will find this loader very helpful when adding images to fit your responsive site or app. It creates multiple images of various sizes from a single image and returns a <code>srcset</code> matching the images for use at appropriate display screen sizes.</li>\n<li><a href=\"https://github.com/babel/babel-loader\"><strong>Babel-loader</strong></a><br />This is used for transpiling your JavaScript code from modern ECMA syntax to ES5. </li>\n<li><a href=\"https://github.com/samsarahq/graphql-loader\"><strong>GraphQL-Loader</strong></a><br />If you are a GraphQL enthusiast, you’ll find this loader quite helpful as it loads your <code>.graphql</code> files containing your GraphQL schema, queries, and mutations — along with the option to enable validation.</li>\n</ul>\n<h3>Plugins</h3>\n<p>The use of <em>plugins</em> allows webpack compiler to <strong>perform tasks on chunks</strong> produced from the bundled modules. Although webpack is not a <a href=\"https://www.smashingmagazine.com/2016/06/harness-machines-productive-task-runners/\">task runner</a>, with plugins, we can perform some custom actions which the loaders could not perform when the code was being bundled.</p>\n<p>An example of a webpack plugin is the <em>ProgressPlugin</em> built-in to webpack. It provides a way to customize the progress which is printed out in the console during compilation.</p>\n<pre><code># webpack.config.js\n\nconst webpack = require(\"webpack\")\nconst path = require(\"path\")\nconst merge = require(\"webpack-merge\")\n\nconst config = {\n  mode: \"development\",\n  entry: './src/entry',\n  output: {\n    filename: \"webpack-output.js\",\n    path: path.resolve(__dirname, \"dist\"),\n  },\n  module: {\n    rules: [\n    {\n      test: /\\.(jpe?g|png|gif|svg)$/i,\n      use: [\n        'img-loader'\n        ]\n    }\n   ]\n  },\n  plugins: [ \n        new webpack.ProgressPlugin({\n          handler: (percentage, message ) =&gt; {\n            console.info(percentage, message);\n          },\n        })\n    ]\n}\n\nmodule.exports = config\n</code></pre>\n\n<p>With the Progress plugin in the configuration above, we provided a <strong>handler function</strong> that will print out the compilation percentage and message to the console during the compilation process. </p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/64da04a3-fec7-4add-8bbc-24fba7f6fbfb/webpack-progress-plugin.png\" /></p>\n<p>Below are a few plugins from the <a href=\"https://github.com/webpack-contrib/awesome-webpack#loaders\">awesome-webpack</a> readme which you will find handy in your webpack application.</p>\n<ul>\n<li><a href=\"https://www.npmjs.com/package/offline-plugin\"><strong>Offline-plugin</strong></a><br />This plugin utilizes <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers\">service workers</a> first or the <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Using_the_application_cache\">AppCache</a> where available to provide an offline experience for webpack managed projects.</li>\n<li><a href=\"https://www.npmjs.com/package/purgecss-webpack-plugin\"><strong>Purgecss-webpack-plugin</strong></a><br />This plugin comes in handy when trying to optimize your webpack project as it removes unused CSS within your application during compilation.  </li>\n</ul>\n<p>At this point, we have our first webpack configuration for a relatively small application fully set up. Let’s further consider how we can do certain things with webpack in our application.</p>\nHandling Multiple Environments\n<p>In your application, you might need to configure webpack differently for either a <strong>development or production environment</strong>. For example, you might not want webpack to output minor warning logs each time a new deployment is made to your continuous integration pipeline in your production environment.</p>\n<p>There are <a href=\"https://webpack.js.org/configuration/configuration-types/\">several ways</a> to achieve that, as recommended by webpack and the community. One way is to <strong>convert your configuration file</strong> to export a function that returns an object. This way, current environment will be passed into the function by the webpack compiler as its first parameter, and other option as the second parameter. </p>\n<p>This method of handling your webpack environment will come in handy if there are a few operations you’d like to perform differently based on the current environment. However, for larger applications with more complex configurations, you could end up with a configuration packed with plenty of conditional statements.</p>\n<p>The code snippet below shows an example of how to handle a <code>production</code> and <code>development</code> environment in the same file using the <code>functions</code> method.</p>\n<pre><code>// webpack.config.js\n\nmodule.exports = function (env, args) {\n  return {\n   mode : env.production ? 'production' : 'development',\n  entry: './src/entry',\n  output: {\n    filename: \"webpack-output.js\",\n    path: path.resolve(__dirname, \"dist\"),\n  },\n  plugins: [ \n       env.development &amp;&amp; ( \n          new webpack.ProgressPlugin({\n            handler: (percentage, message ) =&gt; {\n                console.info(percentage, message);\n            },\n        })\n      )\n    ]\n  }\n}\n</code></pre>   \n\n<p>Going through the exported function in the code snippet above, you’ll see how the <code>env</code> parameter passed into the function is being used with a ternary operator to switch values. It’s first used to set the webpack mode, then it’s also used to enable the <a href=\"https://webpack.js.org/plugins/progress-plugin/\">ProgressPlugin</a> only in development mode.  </p>\n<p>Another more elegant way to handle your <em>production</em> and <em>development</em> environment is to create <strong>different configuration files</strong> for the two environments. Once we’ve done that, we can use them with different commands in the <code>package.json</code> scripts when bundling the application. Take a look at the snippet below:</p>\n<pre><code>{\n  \"name\" : \"smashing-magazine\", \n  \"main\" : \"index.js\"\n  \"scripts\" : {\n    \"bundle:dev\" : \"webpack --config webpack.dev.config.js\",\n    \"bundle:prod\" : \"webpack --config webpack.prod.config.js\"\n  },\n  \"dependencies\" : {\n    \"webpack\": \"^5.24.1\"\n  }\n}</code></pre>\n\n<p>In the <code>package.json</code> above, we have <strong>two script commands</strong>, each using a different configuration file written to handle a specific environment when bundling the application’s assets. Now you can bundle your application using <code>npm run bundle:dev</code> in development mode, or <code>npm run bundle:prod</code> when creating a production-ready bundle.</p>\n<p>Using the second approach, you <strong>avoid conditional statements</strong> introduced when returning your configuration object from a function. However, now you also have to maintain multiple configuration files.</p>\nSplitting Configuration File\n<p>At this point, our webpack configuration file is at 38 lines of code (LOC). This is quite fine for a demo application with a single loader and a single plugin.  </p>\n<p>For a larger application though, our webpack configuration file will definitely be <em>much</em> longer, having several loaders and plugins with their custom options each. To keep the configuration file clean and readable, we can <strong>split the configuration into smaller objects</strong> across multiple files then use the <a href=\"https://www.npmjs.com/package/webpack-merge\">webpack-merge</a> package to merge the configuration objects into one base file.</p>\n<p>To apply it to our webpack project, we can split the single configuration file into three smaller files: one for loaders, one for plugins, and the last file as the base configuration file where we put the two other files together.</p>\n<p>Create a <code>webpack.plugin.config.js</code> file and paste the code below into it to use the plugins with additional options. </p>\n<pre><code>// webpack.plugin.config.js\nconst webpack = require('webpack')\n\nconst plugin = [\n  new webpack.ProgressPlugin({\n          handler: (percentage, message ) =&gt; {\n            console.info(percentage, message);\n          },\n  })\n]\n\nmodule.exports = plugin</code></pre>\n\n<p>Above, we have a single plugin which we extracted from the <code>webpack.configuration.js</code> file.</p>\n<p>Next, create a <code>webpack.loader.config.js</code> file with the code below for the webpack loaders.</p>\n<pre><code>// webpack.loader.config.js\n\nconst loader = {\n module: {\n    rules: [\n    {\n      test: /\\.(jpe?g|png|gif|svg)$/i,\n      use: [\n        'img-loader'\n        ]\n    }\n  ]\n  }\n}</code></pre>\n\n<p>In the code block above, we moved the webpack <code>img-loader</code> into a separate file.</p>\n<p>Finally, create a <code>webpack.base.config.js</code> file where the base input and output configuration for the webpack application will be kept alongside the two created files above.</p>\n<pre><code>// webpack.base.config.js\nconst path = require(\"path\")\nconst merge = require(\"webpack-merge\")\n\nconst plugins = require('./webpack.plugin.config')\nconst loaders = require('./webpack.loader.config')\n\nconst config = merge(loaders, plugins, {\n  mode: \"development\",\n  entry: './src/entry',\n  output: {\n    filename: \"webpack-output.js\",\n    path: path.resolve(__dirname, \"dist\"),\n  }\n});\n\nmodule.exports = config\n</code></pre>\n\n<p>Taking a glance at the webpack file above, you can observe how compact it is in comparison to the original <code>webpack.config.js</code> file. Now the three main parts of the configuration have been broken into smaller files and can be used individually.</p>\nOptimizing Large Builds\n<p>As you keep working on your application over a period of time, your application will definitely grow larger in features and size. As this happens, new files will be created, old files will be modified or refactored, and new external packages will be installed — all leading to an <strong>increase in the bundle size</strong> emitted by webpack.</p>\n<p>By default, webpack automatically tries to optimize bundles on your behalf if your configuration mode is set to <code>production</code>. For example, one technique that webpack applies by default (starting with webpack 4+) to optimize and reduce your bundle size is <a href=\"https://www.smashingmagazine.com/2021/05/tree-shaking-reference-guide/\">Tree-Shaking</a>. Essentially, it’s an optimization technique used to remove unused code. At a simple level during bundling, the import and export statements are used to <strong>detect unused modules</strong> before removing them from the emitted bundles.</p>\n<p>You can also <em>manually</em> optimize your application bundle by adding an <code>optimization</code> object with certain fields into your configuration file. The <a href=\"https://webpack.js.org/configuration/optimization/\">optimization section</a> of the webpack documentation contains a full list of fields you can use in the <code>optimization</code> object to, well, optimize your application. Let’s consider one out of the 20 documented fields.</p>\n<ul>\n<li><code>minimize</code><br />This boolean field is used to instruct webpack to minimize the bundle size. By default, webpack will try to achieve this using <a href=\"https://www.npmjs.com/package/terser-webpack-plugin\">TerserPlugin</a>, a code minification package shipped with webpack.</li>\n</ul>\n<blockquote>Minification applies to minimizing your code by removing unnecessary data from the code which in turn reduces the code size produced after the process.</blockquote>\n\n<p>We can also use other preferred minifiers by adding a <code>minimizer</code> array field within the <code>optimization</code> object. An example is the use of <a href=\"https://www.npmjs.com/package/uglifyjs-webpack-plugin\">Uglifyjs-webpack-plugin</a> below.</p>\n<pre><code>// webpack.config.js\nconst Uglify = require(\"uglifyjs-webpack-plugin\")\n\nmodule.exports = {\n    optimization {\n      minimize : true,\n      minimizer : [\n        new Uglify({\n          cache : true,\n          test: /\\.js(\\?.*)?$/i,\n       })\n    ]\n  } \n }</code></pre>\n\n<p>Above, <code>uglifyjs-webpack-plugin</code> is being used as a minifier with two quite important options. First, enabling <code>cache</code> means that Uglify will only minify existing files when they are new changes, and the <code>test</code> option specifies the specific file types we want to minify.</p>\n<p><strong>Note:</strong> <em>The <a href=\"https://www.npmjs.com/package/uglifyjs-webpack-plugin\">uglifyjs-webpack-plugin</a> gives a comprehensive list of the options available for use when minifying your code with it.</em></p>\n<h3>A Little Optimization Demo</h3>\n<p>Let’s manually try to optimize a demo application by applying some fields in a larger project to see the difference. Although we won’t dive deep into optimizing the application, we’ll see the difference in bundle sizes between when running webpack in <code>development</code> mode, versus when in <code>production</code> mode.</p>\n<p>For this demo, we’ll use a desktop application built with <a href=\"https://www.electronjs.org/\">Electron</a> that also uses <a href=\"https://reactjs.org/\">React.js</a> for its UI — all bundled together with webpack. Electron and React.js sound like a pretty heavy combination and might likely generate a bigger bundle.</p>\n<p><strong>Note</strong>: <em>If you are learning about</em> <a href=\"https://www.electronjs.org/\"><em>Electron</em></a> <em>for the first time,</em> <a href=\"https://www.smashingmagazine.com/2020/07/desktop-apps-electron-vue-javascript/\"><em>this article</em></a> <em>gives a good insight into what</em> <a href=\"https://www.electronjs.org/\"><em>Electron</em></a> <em>is and how you can use it for building cross-platform desktop applications.</em></p>\n<p>To try out the demo locally, clone the application from the GitHub <a href=\"https://github.com/vickywane/webpack-react-demo.git\">repository</a> and install the dependencies using the commands below.</p>\n<div>\n<pre><code># clone repository\ngit clone <a href=\"https://github.com/vickywane/webpack-react-demo.git\">https://github.com/vickywane/webpack-react-demo.git</a>\n\n# change directory\ncd demo-electron-react-webpack\n\n# install dependencies\nnpm install</code></pre>\n</div>\n\n<p>The desktop application is fairly simple with a single page styled using <a href=\"https://www.styled-components.com/\">styled-components</a>. When the desktop application is launched with the <code>yarn start</code> command, the single page displays a list of images fetched from a CDN, as shown below.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d7f86ad4-6064-4abc-b7b1-ee6a04d7ff07/demo-application.png\" /></p>\n<p>Let’s create a <strong>development bundle</strong> of this application first without any manual optimization to analyze the final bundle size.</p>\n<p>Running <code>yarn build:dev</code> from a terminal in the project directory will create the development bundle. Plus, it will print out the following statistics to your terminal:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/e6a3e81c-a7aa-4154-92a9-c2e9b2c7237b/development-logs.png\" /></p>\n<p>The command will show us the statistics of the entire compilation and the emitted bundles.</p>\n<p>Take note of the <code>mainRenderer.js</code> chunk is at 1.11 Mebibyte (approx 1.16 MB). The <code>mainRenderer</code> is the entry point for the Electron application.</p>\n<p>Next, let’s add <a href=\"https://www.npmjs.com/package/uglifyjs-webpack-plugin\">uglifyjs-webpack-plugin</a> as an installed plugin in the <code>webpack.base.config.js</code> file for code minification. </p>\n<pre><code>// webpack.base.config.js\nconst Uglifyjs = require(\"uglifyjs-webpack-plugin\")\n\nmodule.exports = {\n  plugins : [\n    new Uglifyjs({\n      cache : true\n    })\n  ]\n}\n</code></pre>  \n\n<p>Lastly, let’s run bundle the application with webpack in <code>production</code> mode. Running <code>yarn build:prod</code> command from your terminal will output the data below to your terminal.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8d3a8aca-0092-4a27-88ce-d3f05ba62715/production-logs.png\" /></p>\n<p>Take a note of the <code>mainRenderer</code> chunk this time. It has dropped to a whopping 182 Kibibytes (approximately 186 KB), and that’s more than 80% of the <code>mainRenderer</code> chunk size emitted previously!</p>\n<p>Let’s further visualize the emitted bundles using the <a href=\"https://www.npmjs.com/package/webpack-bundle-analyzer\">webpack-bundler-analyzer</a>. Install the plugin using the <code>yarn add webpack-bundle-analyzer</code> command and modify the <code>webpack.base.config.js</code> file to contain the code below which adds the plugin.</p>\n<pre><code>// webpack.base.config.js\nconst Uglifyjs = require(\"uglifyjs-webpack-plugin\");\nconst BundleAnalyzerPlugin = require(\"webpack-bundle-analyzer\");\n  .BundleAnalyzerPlugin;\n\nconst config = {\n  plugins: [\n    new Uglifyjs({\n      cache : true\n    }),\n    new BundleAnalyzerPlugin(),\n  ]\n};\n\nmodule.exports = config;\n</code></pre>\n\n<p>Run <code>yarn build:prod</code> from your terminal for the application to be re-bundled. By default, <a href=\"https://github.com/webpack-contrib/webpack-bundle-analyzer\">webpack-bundle-analyzer</a> will start an HTTP server that serves the visualized overview of the bundles in your browser.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/3b976d5a-fc8e-4aa0-9bf6-cc4fe856a655/bundle-analyzer.png\" /></p>\n<p>From the image above, we can see a <strong>visual representation</strong> of the emitted bundle and file sizes within the bundle. In the visual, we can observe that in the folder <code>node_modules</code>, the biggest file is the <code>react-dom.production.min.js</code>, followed by <code>stylis.min.js</code>.</p>\n<p>Using the file sizes visualized by the analyzer, we’ll have a better idea of what installed package is contributing the major portion of the bundle. We can then look for ways to optimize it or replace it with a lighter package. </p>\n<p><strong>Note:</strong> <em>The webpack-analyzer-plugin</em> <a href=\"https://www.npmjs.com/package/webpack-bundle-analyzer\"><em>documentation</em></a> <em>lists other means available for displaying the analysis created from your emitted bundles.</em></p>\nwebpack Community\n<p>One of the strengths of webpack has been the <strong>large community</strong> of developers behind it and this has been of great use to developers trying webpack out for the first time. Just like this article, there are several articles, guides and resources with the documentation that serves as a great guide when using webpack.</p>\n<p>For example, <a href=\"https://webpack.js.org/guides/build-performance/\">Build Performance guide from webpack’s blog</a> contains tips on optimizing your webpack builds and <a href=\"https://slack.engineering/keep-webpack-fast-a-field-guide-for-better-build-performance/\">Slack's case study</a>  (although a bit old) explains how webpack was optimized at <a href=\"https://slack.Ncom/intl/en-ng/\">Slack</a>. </p>\n<p>Several community resources explain parts of webpack’s documentation, providing you with sample demo projects to show how features of webpack are being used. An example is an article on <a href=\"https://blog.bitsrc.io/revolutionizing-micro-frontends-with-webpack-5-module-federation-and-bit-99ff81ceb0\">Webpack 5 Module Federation</a> which explains how webpack’s new <a href=\"https://webpack.js.org/concepts/module-federation/\">Module Federation</a> feature is used in a React application.</p>\nSummary\n<p>After seven years of its existence, webpack has truly proved itself to be an important part of the JavaScript toolchain used by a large number of projects. This article only gives a glimpse into the things one can achieve with webpack’s flexible and extensible nature.</p>\n<p>The next time you need to choose a module bundler for your application, hopefully you will better understand some core concepts of Webpack, the problem it solves, and also the steps of setting up your configuration files.</p>\n<h3>Further Reading on SmashingMag:</h3>\n<ul>\n<li><a href=\"https://www.smashingmagazine.com/2017/02/a-detailed-introduction-to-webpack/\">Webpack - A Detailed Introduction</a></li>\n<li><a href=\"https://www.smashingmagazine.com/2019/06/pwa-webpack-workbox/\">Build A PWA With Webpack And Workbox</a></li>\n<li><a href=\"https://www.smashingmagazine.com/2020/05/typescript-modern-react-projects-webpack-babel/\">Setting TypeScript For Modern React Projects Using Webpack</a></li>\n<li><a href=\"https://www.smashingmagazine.com/2016/06/harness-machines-productive-task-runners/\">How To Harness The Machines: Being Productive With Task Runners</a></li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"b409289637b890e9bf6dc47b47ebc11241262fdaee6208f3b0bb792bd81aa835","category":"Tech"}