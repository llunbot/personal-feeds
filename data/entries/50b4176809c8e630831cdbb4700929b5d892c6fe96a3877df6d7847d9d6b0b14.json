{"title":"Wilson Lin on FastRender: a browser built by thousands of parallel agents","link":"https://simonwillison.net/2026/Jan/23/fastrender/#atom-entries","date":1769203570000,"content":"<p>Last week Cursor published <a href=\"https://cursor.com/blog/scaling-agents\">Scaling long-running autonomous coding</a>, an article describing their research efforts into coordinating large numbers of autonomous coding agents. One of the projects mentioned in the article was <a href=\"https://github.com/wilsonzlin/fastrender\">FastRender</a>, a web browser they built from scratch using their agent swarms. I wanted to learn more so I asked Wilson Lin, the engineer behind FastRender, if we could record a conversation about the project. That 47 minute video is <a href=\"https://www.youtube.com/watch?v=bKrAcTf2pL4\">now available on YouTube</a>. I've included some of the highlights below.</p>\r\n\r\n \r\n\r\n<p>See my <a href=\"https://simonwillison.net/2026/Jan/19/scaling-long-running-autonomous-coding/\">previous post</a> for my notes and screenshots from trying out FastRender myself.</p>\r\n\r\n\r\n<h4>What FastRender can do right now</h4>\r\n<p>We started the conversation with a demo of FastRender loading different pages (<a href=\"https://www.youtube.com/watch?v=bKrAcTf2pL4&amp;t=195s\">03:15</a>). The JavaScript engine isn't working yet so we instead loaded <a href=\"https://github.com/wilsonzlin/fastrender\">github.com/wilsonzlin/fastrender</a>, <a href=\"https://en.wikipedia.org/\">Wikipedia</a> and <a href=\"https://cnn.com\">CNN</a> - all of which were usable, if a little slow to display.</p>\r\n<p>JavaScript had been disabled by one of the agents, which decided to add a feature flag! <a href=\"https://www.youtube.com/watch?v=bKrAcTf2pL4&amp;t=242s\">04:02</a></p>\r\n<blockquote>\r\n<p>JavaScript is disabled right now. The agents made a decision as they were currently still implementing the engine and making progress towards other parts... they decided to turn it off or put it behind a feature flag, technically.</p>\r\n</blockquote>\r\n<h4>From side-project to core research</h4>\r\n<p>Wilson started what become FastRender as a personal side-project to explore the capabilities of the latest generation of frontier models - Claude Opus 4.5, GPT-5.1, and GPT-5.2. <a href=\"https://www.youtube.com/watch?v=bKrAcTf2pL4&amp;t=56s\">00:56</a></p>\r\n<blockquote>\r\n<p>FastRender was a personal project of mine from, I'd say, November. It was an experiment to see how well frontier models like Opus 4.5 and back then GPT-5.1 could do with much more complex, difficult tasks.</p>\r\n</blockquote>\r\n<p>A browser rendering engine was the ideal choice for this, because it's both <em>extremely</em> ambitious and complex but also well specified. And you can visually see how well it's working! <a href=\"https://www.youtube.com/watch?v=bKrAcTf2pL4&amp;t=117s\">01:57</a></p>\r\n<blockquote>\r\n<p>As that experiment progressed, I was seeing better and better results from single agents that were able to actually make good progress on this project. And at that point, I wanted to see, well, what's the next level? How do I push this even further?</p>\r\n</blockquote>\r\n<p>Once it became clear that this was an opportunity to try multiple agents working together it graduated to an official Cursor research project, and available resources were amplified.</p>\r\n<p>The goal of FastRender was never to build a browser to compete with the likes of Chrome. <a href=\"https://www.youtube.com/watch?v=bKrAcTf2pL4&amp;t=2512s\">41:52</a></p>\r\n<blockquote>\r\n<p>We never intended for it to be a production software or usable, but we wanted to observe behaviors of this harness of multiple agents, to see how they could work at scale.</p>\r\n</blockquote>\r\n<p>The great thing about a browser is that it has such a large scope that it can keep serving experiments in this space for many years to come. JavaScript, then WebAssembly, then WebGPU... it could take many years to run out of new challenges for the agents to tackle.</p>\r\n<h4>Running thousands of agents at once</h4>\r\n<p>The most interesting thing about FastRender is the way the project used multiple agents working in parallel to build different parts of the browser. I asked how many agents were running at once: <a href=\"https://www.youtube.com/watch?v=bKrAcTf2pL4&amp;t=324s\">05:24</a></p>\r\n<blockquote>\r\n<p>At the peak, when we had the stable system running for one week continuously, there were approximately 2,000 agents running concurrently at one time. And they were making, I believe, thousands of commits per hour.</p>\r\n</blockquote>\r\n<p>The project has <a href=\"https://github.com/wilsonzlin/fastrender/commits/main/\">nearly 30,000 commits</a>!</p>\r\n<p>How do you run 2,000 agents at once? They used <em>really big machines</em>. <a href=\"https://www.youtube.com/watch?v=bKrAcTf2pL4&amp;t=356s\">05:56</a></p>\r\n<blockquote>\r\n<p>The simple approach we took with the infrastructure was to have a large machine run one of these multi-agent harnesses. Each machine had ample resources, and it would run about 300 agents concurrently on each. This was able to scale and run reasonably well, as agents spend a lot of time thinking, and not just running tools.</p>\r\n</blockquote>\r\n<p>At this point we switched to a live demo of the harness running on one of those big machines (<a href=\"https://www.youtube.com/watch?v=bKrAcTf2pL4&amp;t=392s\">06:32</a>). The agents are arranged in a tree structure, with planning agents firing up tasks and worker agents then carrying them out. <a href=\"https://www.youtube.com/watch?v=bKrAcTf2pL4&amp;t=434s\">07:14</a></p>\r\n<p><img src=\"https://static.simonwillison.net/static/2026/wilson-lin-agents.jpg\" alt=\"Terminal window showing a tmux session running &quot;grind-swarm&quot; task manager with RUNNING status. Header shows &quot;grind-swarm – 45:54:15&quot; with stats &quot;planners: 9 (0 done) | tasks: 111 working, 0 pending, 232 done | 12900.9M↑ 514.1M↓&quot;. Task list includes: p1 Root (main), p2 CSS selector matching performance + bloom filter integration, p3 CSS stylesheet parsing semantics &amp; at-rule handling, p4 Custom properties (@property) + var() resolution + incremental recompute/invalidation, p37 CSS at-rule artifact integration, p50 Selector engine correctness &amp; spec coverage, p51 Computed-value + property coverage across css-cascade, p105 Style sharing / computed style caching in fastrender-style, p289 CSS cascade layers (@layer) global ordering, w5 Fix workspace lockfile drift, w7 Implement computed-style snapshot sharing, w15 Fix css-properties namespace handling, w17 (Stretch) Enable bloom fast-reject in HTML quirks mode, w18 Refactor css-properties stylesheet parsing. Activity log shows shell commands including cargo check, git status, git push origin main, and various test runs. Bottom status bar shows &quot;grind-css0:target/release/grind-swarm*&quot; and &quot;streamyard.com is sharing your screen&quot; notification with timestamp &quot;12:02 22-Jan-26&quot;.\" /></p>\r\n<blockquote>\r\n<p>This cluster of agents is working towards building out the CSS aspects of the browser, whether that's parsing, selector engine, those features. We managed to push this even further by splitting out the browser project into multiple instructions or work streams and have each one run one of these harnesses on their own machine, so that was able to further parallelize and increase throughput.</p>\r\n</blockquote>\r\n<p>But don't all of these agents working on the same codebase result in a huge amount of merge conflicts? Apparently not: <a href=\"https://www.youtube.com/watch?v=bKrAcTf2pL4&amp;t=501s\">08:21</a></p>\r\n<blockquote>\r\n<p>We've noticed that most commits do not have merge conflicts. The reason is the harness itself is able to quite effectively split out and divide the scope and tasks such that it tries to minimize the amount of overlap of work. That's also reflected in the code structure—commits will be made at various times and they don't tend to touch each other at the same time.</p>\r\n</blockquote>\r\n<p>This appears to be the key trick for unlocking benefits from parallel agents: if planning agents do a good enough job of breaking up the work into non-overlapping chunks you can bring hundreds or even thousands of agents to bear on a problem at once.</p>\r\n<p>Surprisingly, Wilson found that GPT-5.1 and GPT-5.2 were a better fit for this work than the coding specialist GPT-5.1-Codex: <a href=\"https://www.youtube.com/watch?v=bKrAcTf2pL4&amp;t=1048s\">17:28</a></p>\r\n<blockquote>\r\n<p>Some initial findings were that the instructions here were more expansive than merely coding. For example, how to operate and interact within a harness, or how to operate autonomously without interacting with the user or having a lot of user feedback. These kinds of instructions we found worked better with the general models.</p>\r\n</blockquote>\r\n<p>I asked what the longest they've seen this system run without human intervention: <a href=\"https://www.youtube.com/watch?v=bKrAcTf2pL4&amp;t=1108s\">18:28</a></p>\r\n<blockquote>\r\n<p>So this system, once you give an instruction, there's actually no way to steer it, you can't prompt it, you're going to adjust how it goes. The only thing you can do is stop it. So our longest run, all the runs are basically autonomous. We don't alter the trajectory while executing. [...]</p>\r\n<p>And so the longest at the time of the post was about a week and that's pretty close to the longest. Of course the research project itself was only about three weeks so you know we probably can go longer.</p>\r\n</blockquote>\r\n<h4>Specifications and feedback loops</h4>\r\n<p>An interesting aspect of this project design is feedback loops. For agents to work autonomously for long periods of time they need as much useful context about the problem they are solving as possible, combined with effective feedback loops to help them make decisions.</p>\r\n<p>The FastRender repo <a href=\"https://github.com/wilsonzlin/fastrender/tree/19bf1036105d4eeb8bf3330678b7cb11c1490bdc/specs\">uses git submodules to include relevant specifications</a>, including csswg-drafts, tc39-ecma262 for JavaScript, whatwg-dom, whatwg-html and more. <a href=\"https://www.youtube.com/watch?v=bKrAcTf2pL4&amp;t=846s\">14:06</a></p>\r\n<blockquote>\r\n<p>Feedback loops to the system are very important. Agents are working for very long periods continuously, and without guardrails and feedback to know whether what they're doing is right or wrong it can have a big impact over a long rollout. Specs are definitely an important part—you can see lots of comments in the code base that AI wrote referring specifically to specs that they found in the specs submodules.</p>\r\n</blockquote>\r\n<p>GPT-5.2 is a vision-capable model, and part of the feedback loop for FastRender included taking screenshots of the rendering results and feeding those back into the model:\r\n<a href=\"https://www.youtube.com/watch?v=bKrAcTf2pL4&amp;t=983s\">16:23</a></p>\r\n<blockquote>\r\n<p>In the earlier evolution of this project, when it was just doing the static renderings of screenshots, this was definitely a very explicit thing we taught it to do. And these models are visual models, so they do have that ability. We have progress indicators to tell it to compare the diff against a golden sample.</p>\r\n</blockquote>\r\n<p>The strictness of the Rust compiler helped provide a feedback loop as well: <a href=\"https://www.youtube.com/watch?v=bKrAcTf2pL4&amp;t=952s\">15:52</a></p>\r\n<blockquote>\r\n<p>The nice thing about Rust is you can get a lot of verification just from compilation, and that is not as available in other languages.</p>\r\n</blockquote>\r\n<h4>The agents chose the dependencies</h4>\r\n<p>We talked about the <a href=\"https://github.com/wilsonzlin/fastrender/blob/19bf1036105d4eeb8bf3330678b7cb11c1490bdc/Cargo.toml\">Cargo.toml dependencies</a> that the project had accumulated, almost all of which had been selected by the agents themselves.</p>\r\n<p>Some of these, like <a href=\"https://skia.org/\">Skia</a> for 2D graphics rendering or <a href=\"https://github.com/harfbuzz/harfbuzz\">HarfBuzz</a> for text shaping, were obvious choices. Others such as <a href=\"https://github.com/DioxusLabs/taffy\">Taffy</a> felt like they might go against the from-scratch goals of the project, since that library implements CSS flexbox and grid layout algorithms directly. This was not an intended outcome. <a href=\"https://www.youtube.com/watch?v=bKrAcTf2pL4&amp;t=1673s\">27:53</a></p>\r\n<blockquote>\r\n<p>Similarly these are dependencies that the agent picked to use for small parts of the engine and perhaps should have actually implemented itself. I think this reflects on the importance of the instructions, because I actually never encoded specifically the level of dependencies we should be implementing ourselves.</p>\r\n</blockquote>\r\n<p>The agents vendored in Taffy and <a href=\"https://github.com/wilsonzlin/fastrender/commits/main/vendor/taffy\">applied a stream of changes</a> to that vendored copy.\r\n<a href=\"https://www.youtube.com/watch?v=bKrAcTf2pL4&amp;t=1878s\">31:18</a></p>\r\n<blockquote>\r\n<p>It's currently vendored. And as the agents work on it, they do make changes to it. This was actually an artifact from the very early days of the project before it was a fully fledged browser... it's implementing things like the flex and grid layers, but there are other layout methods like inline, block, and table, and in our new experiment, we're removing that completely.</p>\r\n</blockquote>\r\n<p>The inclusion of QuickJS despite the presence of a home-grown ecma-rs implementation has a fun origin story:\r\n<a href=\"https://www.youtube.com/watch?v=bKrAcTf2pL4&amp;t=2115s\">35:15</a></p>\r\n<blockquote>\r\n<p>I believe it mentioned that it pulled in the QuickJS because it knew that other agents were working on the JavaScript engine, and it needed to unblock itself quickly. [...]</p>\r\n<p>It was like, eventually, once that's finished, let's remove it and replace with the proper engine.</p>\r\n</blockquote>\r\n<p>I love how similar this is to the dynamics of a large-scale human engineering team, where you could absolutely see one engineer getting frustrated at another team not having delivered yet and unblocking themselves by pulling in a third-party library.</p>\r\n<h4>Intermittent errors are OK, actually</h4>\r\n<p>Here's something I found really surprising: the agents were allowed to introduce small errors into the codebase as they worked! <a href=\"https://www.youtube.com/watch?v=bKrAcTf2pL4&amp;t=2382s\">39:42</a></p>\r\n<blockquote>\r\n<p>One of the trade-offs was: if you wanted every single commit to be a hundred percent perfect, make sure it can always compile every time, that might be a synchronization bottleneck. [...]</p>\r\n<p>Especially as you break up the system into more modularized aspects, you can see that errors get introduced, but small errors, right? An API change or some syntax error, but then they get fixed really quickly after a few commits. So there's a little bit of slack in the system to allow these temporary errors so that the overall system can continue to make progress at a really high throughput. [...]</p>\r\n<p>People may say, well, that's not correct code. But it's not that the errors are accumulating. It's a stable rate of errors. [...] That seems like a worthwhile trade-off.</p>\r\n</blockquote>\r\n<p>If you're going to have thousands of agents working in parallel optimizing for throughput over correctness turns out to be a strategy worth exploring.</p>\r\n<h4>A single engineer plus a swarm of agents in January 2026</h4>\r\n<p>The thing I find most interesting about FastRender is how it demonstrates the extreme edge of what a single engineer can achieve in early 2026 with the assistance of a swarm of agents.</p>\r\n<p>FastRender may not be a production-ready browser, but it represents over a million lines of Rust code, written in a few weeks, that can already render real web pages to a usable degree.</p>\r\n<p>A browser really is the ideal research project to experiment with this new, weirdly shaped form of software engineering.</p>\r\n<p>I asked Wilson how much mental effort he had invested in browser rendering compared to agent co-ordination. <a href=\"https://www.youtube.com/watch?v=bKrAcTf2pL4&amp;t=694s\">11:34</a></p>\r\n<blockquote>\r\n<p>The browser and this project were co-developed and very symbiotic, only because the browser was a very useful objective for us to measure and iterate the progress of the harness. The goal was to iterate on and research the multi-agent harness—the browser was just the research example or objective.</p>\r\n</blockquote>\r\n<p>FastRender is effectively using a full browser rendering engine as a \"hello world\" exercise for multi-agent coordination!</p><p><em>You are only seeing the long-form articles from my blog. Subscribe to <a href=\"https://simonwillison.net/atom/everything/\">/atom/everything/</a> to get all of my posts, or take a look at my <a href=\"https://simonwillison.net/about/#subscribe\">other subscription options</a>.</em></p>","author":"Simon Willison","siteTitle":"Simon Willison’s Weblog","siteHash":"1b599216bd27a00f15d67a3ed9719c64148630c70244b6dd8e743f17cb45527e","entryHash":"50b4176809c8e630831cdbb4700929b5d892c6fe96a3877df6d7847d9d6b0b14","category":"Tech"}