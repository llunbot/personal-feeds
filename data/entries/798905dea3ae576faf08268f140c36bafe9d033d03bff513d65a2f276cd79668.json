{"title":"A smoother HCP Terraform workspace experience","link":"https://www.hashicorp.com/blog/a-smoother-hcp-terraform-workspace-experience","date":1739379600000,"content":"<p>HCP Terraform allows organizations to scale the management of their cloud infrastructure. However, onboarding multiple teams with unique requirements and workflows introduces its own set of challenges. This blog post will demonstrate how you can automate your HCP Terraform workspace setup by using the TFE provider and building an onboarding module.</p>\n\n<h2>A common scenario</h2>\n\n<p>To illustrate a common scenario, imagine a tech company. We’ll call them “HashiCups”. Their <a href=\"https://www.hashicorp.com/resources/what-is-a-platform-team-and-why-do-we-need-them\">platform team</a> has successfully built their initial cloud landing zones using HCP Terraform. </p>\n\n<blockquote>\n<p><strong>Cloud landing zone:</strong> A pre-configured, secure, and scalable environment that serves as a foundation for deploying and managing cloud resources.</p>\n</blockquote>\n\n<p>Now they’re ready to make their first attempt at on-boarding an application team to HCP Terraform, with many more teams to follow. They realize that manually creating and configuring workspaces for each team is time-consuming and prone to errors. They need an automated onboarding process that's not only efficient but also scalable and consistent.</p>\n\n<p>They’ve decided they’re going to add another abstraction layer to codify and automate the onboarding setup for HCP Terraform workspaces, teams and processes. They’ll do this using Terraform as the engine once again, with the <a href=\"https://registry.terraform.io/providers/hashicorp/tfe/latest\">TFE provider</a>.</p>\n\n<p>With this provider they can build a reusable Terraform module (we’ll call it the “workspace onboarding module”) that encapsulates best practices for workspace creation, permission management, and team onboarding. This approach should allow HashiCups to scale effortlessly as they bring more teams into their infrastructure as code ecosystem.</p>\n\n<h2>Onboarding the first team</h2>\n\n<p>The HashiCups platform team will start their onboarding process by having a meeting with the application team. To prepare for this meeting, they’ll review their objectives.</p>\n\n<p>The platform team has two main objectives here:</p>\n\n<ol>\n<li>Get the application team up and running as quickly as possible.</li>\n<li>Create and test their reusable onboarding pattern (which is codified in a Terraform module) so that they can iron out any issues before they offer it to other teams.</li>\n</ol>\n\n<p>Based on these objectives, in their first meeting, they will ask:</p>\n\n<ul>\n<li>If the team is familiar with workspaces in HCP Terraform and provide an overview if necessary.</li>\n<li>What their environment landscape looks like (the promotion path i.e. path from dev&gt;test&gt;prod).</li>\n<li>Who should be permitted to change infrastructure configuration, and if those permissions depend on the environment.</li>\n</ul>\n\n<h3>What is an HCP Terraform workspace?</h3>\n\n<p>In HCP Terraform, a <a href=\"https://developer.hashicorp.com/terraform/cloud-docs/workspaces\">workspace</a> is a fundamental concept that is used to organize infrastructure as code, so it makes sense to start the meeting reviewing what workspaces are and what’s the impact on the team’s IaC code.</p>\n\n<p>An HCP Terraform workspace is an isolated environment where a specific team or working group can manage a specific set of infrastructure resources. Each workspace maintains its own state file, which is important for tracking the current state of your infrastructure and ensuring that Terraform can accurately plan and apply changes to it. It provides a collaborative space for teams to manage infrastructure as code, with capabilities such as version control integration, secure state management, and role-based access control.</p>\n\n<h3>Workspace scoping recommendations</h3>\n\n<p>Our recommended practice is that you structure your HCP Terraform setup so that each workspace corresponds to a specific: </p>\n\n<ul>\n<li>Business unit</li>\n<li>Application name</li>\n<li>Infrastructure layer</li>\n<li>Promotion path environment (i.e. dev&gt;test&gt;prod)</li>\n<li>and/or region </li>\n</ul>\n\n<p>Some example workspace names for a simple application following this recommendation could include:</p>\n\n<ul>\n<li>bu1-billing-prod-us-east</li>\n<li>bu1-billing-staging-us-east</li>\n</ul>\n\n<p>For more complex scenarios, teams will need to divide their workspaces into even smaller scopes. If they have a large number of resources to deploy that becomes harder to manage and decipher. For example:</p>\n\n<ul>\n<li>bu2-orders-networking-prod-us-east</li>\n<li>bu2-orders-compute-prod-us-east</li>\n<li>bu2-orders-db-prod-us-east</li>\n<li>bu2-orders-networking-staging-us-east</li>\n<li>bu2-orders-compute-staging-us-east</li>\n<li>bu2-orders-db-staging-us-east</li>\n</ul>\n\n<p>The main takeaway here is you can delineate your workspace scopes according to how you think you should isolate each environment to ensure three things: </p>\n\n<ol>\n<li>Adequately limiting the potential impact or 'blast radius' of any change-related failures</li>\n<li>Preventing performance degradations from affecting other workspaces</li>\n<li>Accommodating different infrastructure sizing and configuration needs for development, testing, and production scenarios</li>\n</ol>\n\n<h3>The requirements</h3>\n\n<p>After asking the questions listed earlier and building a general understanding of workspaces and how they can be scoped, the HashiCups platform team has gotten a set of requirements from the application team. </p>\n\n<p>The application team explained that they use a 3-environment landscape (development, staging and production), which will translate into three workspaces. Through meetings with other stakeholders, such as security, operations leadership, and platform team leadership (sometimes these best-practice-building groups are called a “center of cloud excellence (CCoE)”), the platform team has an additional set of requirements for HCP Terraform workspace default settings:</p>\n\n<ol>\n<li>Each application team should have a group that is responsible for workspace administration and another group that has the necessary permissions to use the workspaces.</li>\n<li>Powerful data removal commands like <code>terraform destroy</code> should not be allowed for production. Only development and staging environments.</li>\n<li>Technical leadership has decided on workspace naming conventions. Each name will have only two pieces of information: An application identifier, followed by an environment identifier (<code>&lt;application&gt;-&lt;environment&gt;</code>), and the workspace name must be in lowercase.</li>\n<li>Generally the environment used by the end users must use the <code>prod</code> environment identifier.</li>\n</ol>\n\n<p>After completing the discovery process,the platform team can now create the first version of the  workspace onboarding module.</p>\n\n<h2>Making the onboarding pattern reusable</h2>\n\n<p>The workspace onboarding module will generate the workspaces needed for the first application team. Rather than hardcoding their team-specific requirements into the workspace, the onboarding module will have empty variable fields so that any team in the organization can use the same module to customize workspaces for their own specific needs. For example, while the first team had 3 environments, some teams have 2 environments, and some teams have more than 3 environments. The number of environments generated will need to be a variable field in the module.</p>\n\n<h3>Create the variable definitions</h3>\n\n<p>The first file we’ll create is the <code>variables.tf</code> file, where we’ll define four <a href=\"https://developer.hashicorp.com/terraform/language/values/variables\">variables</a>:</p>\n\n<ul>\n<li><code>application_id</code>, to hold the application (unique) identifier.</li>\n<li><code>admin_team_name</code>, to hold the name of the (pre-existing) HCP Terraform team representing the application administrators.</li>\n<li><code>user_team_name</code>, to hold the name of the (pre-existing) HCP Terraform team representing the application infrastructure engineers (or developers).</li>\n<li><code>environment_names</code>, to hold the list of environment names (dev, prod, etc.) in this application’s environment landscape.</li>\n</ul>\n\n<p>The <code>environment_names</code> variable also needs a validation block to ensure that there is an environment named <code>prod</code>, as per the organization’s requirements.</p>\n<pre><code>variable \"environment_names\" {\n  description = \"A list of environment names\"\n  type        = list(string)\n\n  validation {\n    condition     = contains([for env in var.environment_names : lower(env)], \"prod\")\n    error_message = \"The list of environment names must contain 'prod'.\"\n  }\n}\n\nvariable \"admin_team_name\" {\n  description = \"The name of the team for the workspace administrators\"\n  type        = string\n}\n\nvariable \"user_team_name\" {\n  description = \"The name of the team for the workspace users\"\n  type        = string\n}\n\nvariable \"application_id\" {\n  description = \"The identifier of the application\"\n  type        = string\n}</code></pre><h3>Create the workspaces</h3>\n\n<p>The next step is creating the <code>main.tf</code> file, where admins will define the workspaces and team permissions. When creating the workspace for the <code>prod</code> environment, the team configures it so that destroy plans aren’t allowed, as per the organization’s requirements. They’ll also use string interpolation to name the workspace according to the organization’s naming convention. See how this looks in the configuration below.</p>\n<pre><code>resource \"tfe_workspace\" \"workspace\" {\n  for_each = toset(var.environment_names)\n\n  name               = \"${lower(var.application_id)}-${lower(each.value)}\"\n  description        = \"Workspace for the ${each.value} environment of application ${var.application_id}\"\n  allow_destroy_plan = each.value == \"prod\" ? false : true\n\n}\n\ndata \"tfe_team\" \"admin_team\" {\n  name = var.admin_team_name\n}\n\ndata \"tfe_team\" \"user_team\" {\n  name = var.user_team_name\n}\n\nresource \"tfe_team_access\" \"admin_team_access\" {\n  for_each = toset(var.environment_names)\n\n  workspace_id = tfe_workspace.workspace[each.value].id\n  team_id      = data.tfe_team.admin_team.id\n  access       = \"admin\"\n}\n\nresource \"tfe_team_access\" \"user_team_access\" {\n  for_each = toset(var.environment_names)\n\n  workspace_id = tfe_workspace.workspace[each.value].id\n  team_id      = data.tfe_team.user_team.id\n  access       = \"write\"\n}</code></pre><p>Note that this example is using data sources to fetch information about the <code>admin_team</code> and the <code>user_team</code>. An alternative would be to accept the team ID instead of the team name as an input variable. Using the team ID as an input variable can simplify the code and make it more efficient in terms of data processing. However, it may also make it less intuitive for a human to understand the input at a glance.</p>\n\n<h3>Make outputs available</h3>\n\n<p>One of the key principles in infrastructure as code is composition. Composition in the context of IaC and Terraform refers to the practice of building complex configurations by combining smaller, reusable components. This approach enables modular, scalable, and maintainable infrastructure definitions.</p>\n\n<p>To enable composition with modules, the team needs to share information using <a href=\"https://developer.hashicorp.com/terraform/language/values/outputs\">outputs</a>. In this case, they made the IDs of the workspaces created for the application team available, as well as the IDs of the admin and user teams in the <code>outputs.tf</code> file:</p>\n<pre><code>output \"workspace_ids\" {\n  description = \"The IDs of the created workspaces\"\n  value       = { for k, v in tfe_workspace.workspace : k =&gt; v.id }\n}\n\noutput \"admin_team_ids\" {\n  description = \"The IDs of the admin teams\"\n  value       = data.tfe_team.admin_team.id\n}\n\noutput \"user_team_ids\" {\n  description = \"The IDs of the user teams\"\n  value       = data.tfe_team.user_team.id\n}</code></pre><p>For a more in-depth discussion about outputs in Terraform, have a look at this discussion from HashiConf 2024: <a href=\"https://youtu.be/BKtvWiggY7Q?si=KTF_-C1u-OSB_M5v&amp;t=779\">Meet the experts: Terraform module design</a>. </p>\n\n<h3>Module tests</h3>\n\n<p>At this point, the team has a working module, but it’s still missing an important component: <a href=\"https://developer.hashicorp.com/terraform/language/tests\">Terraform tests</a>. These tests are necessary to ensure that as engineers improve the module they do not introduce bugs or break existing functionality.</p>\n\n<p>Terraform tests live under the <code>tests</code> directory in the module code repository.</p>\n\n<h4>Test setup</h4>\n\n<p>The first step when writing a test suite is to ensure that the prerequisites are available. In this case, the prerequisites are the HCP Terraform teams for the workspace administrators and the workspace users.</p>\n\n<p>To define the prerequisites, the platform team will create the file <code>tests/testing/setup/main.tf</code> with the following content:</p>\n<pre><code>resource \"tfe_team\" \"admin_team\" {\n  name = \"admins-test\"\n}\n\nresource \"tfe_team\" \"user_team\" {\n  name = \"users-test\"\n}</code></pre><h4>Test suite</h4>\n\n<p>The next step is to write the test suite. The platform team will create tests that ensure that the validation code on the <code>environment_names</code> variable works as expected.</p>\n\n<p>To define the test suite, they’ll create the file <code>tests/environment_landscape_validation.tftest.hcl</code> with the following content:</p>\n<pre><code>provider \"tfe\" {\n  organization = \"\"\n}\n\nvariables {\n  admin_team_name = \"admins-test\"\n  user_team_name  = \"users-test\"\n  application_id  = \"my-app\"\n}\n\nrun \"setup\" {\n\n  module {\n    source = \"./tests/testing/setup\"\n  }\n}\n\nrun \"invalid_environment_landscape_missing_prod_name\" {\n\n  command = plan\n\n  variables {\n    environment_names = [\"dev\", \"staging\"]\n    admin_team_name   = var.admin_team_name\n    user_team_name    = var.user_team_name\n    application_id    = var.application_id\n  }\n\n  expect_failures = [var.environment_names]\n\n}\n\nrun \"invalid_environment_landscape_incorrect_prod_name\" {\n\n  command = plan\n\n  variables {\n    environment_names = [\"dev\", \"staging\", \"production\"]\n    admin_team_name   = var.admin_team_name\n    user_team_name    = var.user_team_name\n    application_id    = var.application_id\n  }\n\n  expect_failures = [var.environment_names]\n\n}\n\nrun \"valid_environment_landscape\" {\n\n  command = plan\n\n  variables {\n    environment_names = [\"dev\", \"staging\", \"prod\"]\n    admin_team_name   = var.admin_team_name\n    user_team_name    = var.user_team_name\n    application_id    = var.application_id\n  }\n\n}\n\nrun \"workspace_name_in_lowercase\" {\n\n  command = plan\n\n  variables {\n    environment_names = [\"Dev\", \"Staging\", \"Prod\"]\n    admin_team_name   = var.admin_team_name\n    user_team_name    = var.user_team_name\n    application_id    = \"My-App\"\n  }\n\n  assert {\n    condition     = alltrue([for ws in tfe_workspace.workspace : lower(ws.name) == ws.name])\n    error_message = \"All workspace names must be in lowercase.\"\n  }\n}</code></pre><p>The test suite above does the following:</p>\n\n<ol>\n<li>Provides a valid TFE provider configuration to use.</li>\n<li>Ensures that the test prerequisites are present.</li>\n<li>Validates that passing an invalid environment landscape is detected and fails the <code>plan</code> operation. An invalid environment landscape is either missing the <code>prod</code> environment or is using an incorrect name such as <code>production</code>.</li>\n<li>Validates that passing a valid environment landscape is successful.</li>\n<li>Validates that passing an application ID and/or environment names with capitalized letters still result in the workspace name being in all lowercase.</li>\n<li>Tears down the test prerequisites.</li>\n</ol>\n\n<h4>Running the test suite</h4>\n\n<p>Executing the test suite requires access to HCP Terraform. Prior to running the test suite, the platform team will need to generate an API token with permissions to create teams and make it available to their execution environment. Here is an example of how to do this on Linux:</p>\n\n<pre><code>export TFE_TOKEN=&lt;replace with the API token&gt;\n</code></pre>\n\n<p>Executing the test suite is easy from the command line:</p>\n\n<pre><code>terraform test\n</code></pre>\n\n<p>Terraform will discover the available tests and execute them, reporting on the results:</p>\n<pre><code>tests/invalid_environment_landscape.tftest.hcl... in progress\n  run \"setup\"... pass\n  run \"invalid_environment_landscape_missing_prod_name\"... pass\n  run \"invalid_environment_landscape_incorrect_prod_name\"... pass\n  run \"valid_environment_landscape\"... pass\n  run \"workspace_name_in_lowercase\"... pass\ntests/invalid_environment_landscape.tftest.hcl... tearing down\ntests/invalid_environment_landscape.tftest.hcl... pass\n\nSuccess! 5 passed, 0 failed.</code></pre><h4>Provide documentation and examples</h4>\n\n<p>When developing a Terraform module, it is highly recommended to include two essential files: a comprehensive documentation file and a detailed changelog.</p>\n\n<p>The documentation file, named <code>README.md</code>, serves as a valuable resource for users of the module, providing clear instructions on its purpose, usage, input variables, outputs, and any specific requirements or dependencies. This documentation ensures that other team members or future maintainers can quickly understand and effectively utilize the module without extensive reverse engineering.</p>\n\n<p>Equally important is the changelog file, named <code>CHANGELOG.md</code>, which records all notable changes and version increments for the module over time. The changelog acts as a historical record, allowing users to track modifications, understand the evolution of the module, and make informed decisions about upgrades. Together, these files significantly enhance the module's usability, maintainability, and overall quality, fostering better collaboration and reducing potential issues arising from lack of information or miscommunication.</p>\n\n<p>Example <code>README.md</code> file:</p>\n<pre><code># Terraform Workspaces Module\n\n## Description\n\nThis module configures one or more workspaces for an application team, with one workspace corresponding to one SDLC environment. It uses the TFE provider to create workspaces in HCP Terraform.\n\n## Usage\n\n```hcl\nmodule \"workspaces\" {\n  source            = \"path/to/your/module\"\n  environment_names = [\"dev\", \"staging\", \"prod\"]\n  admin_team_name   = \"admin-team\"\n  user_team_name    = \"user-team\"\n  application_id    = \"my-app\"\n}\n```\n\n## Inputs\n\n| Name              | Description                                      | Type        | Default     | Required |\n|-------------------|--------------------------------------------------|-------------|-------------|----------|\n| environment_names | A list of environment names                      | list(string)| n/a         | yes      |\n| admin_team_name   | The name of the team for the workspace administrators | string      | n/a         | yes      |\n| user_team_name    | The name of the team for the workspace users     | string      | n/a         | yes      |\n| application_id    | The identifier of the application                | string      | n/a         | yes      |\n\n\n## Outputs\n\n| Name                | Description                              |\n|---------------------|------------------------------------------|\n| workspace_ids       | The IDs of the created workspaces        |\n| admin_team_ids      | The IDs of the admin teams               |\n| user_team_ids       | The IDs of the user teams                |</code></pre><p>Example <code>CHANGELOG.md</code> file:</p>\n<pre><code># Changelog\n\n## [1.0.0] - 2025-01-XX\n### Added\n- Initial version of the Terraform module.\n- Added support for creating workspaces in Terraform Cloud using the TFE provider.\n- Added variables for environment names, admin team name, user team name and application ID.\n- Added validation to ensure the environment names list contains \"prod\".\n- Added outputs for workspace IDs, admin team IDs, and user team IDs.\n- Added tests to validate the environment names and workspace name formatting.</code></pre><h2>Recap and possible enhancements</h2>\n\n<p>Using an example scenario and company, this blog post has shown how to gather requirements to automate the creation of workspaces for an application team and translate those requirements into a reusable Terraform module, complete with code, documentation, and automated tests. Once created, the module should be published and used by future teams adopting HCP Terraform. You can learn more about publishing your module in this tutorial: <a href=\"https://developer.hashicorp.com/terraform/tutorials/modules/module-private-registry-share\">Share modules in the private registry</a>.</p>\n\n<p>We intentionally used a simplified scenario to keep the post to a reasonable length and easy to understand, but some readers may argue that certain important aspects were omitted, and they’d be right. Let’s cover those aspects and flag them as potential enhancements to the example solution:</p>\n\n<ul>\n<li>Introduce <a href=\"https://developer.hashicorp.com/terraform/cloud-docs/projects\">HCP Terraform projects</a></li>\n<li>Configure <a href=\"https://developer.hashicorp.com/terraform/cloud-docs/workspaces/settings/notifications\">workspace notifications</a></li>\n<li>Use <a href=\"https://developer.hashicorp.com/terraform/cloud-docs/workspaces/dynamic-provider-credentials\">dynamic provider credentials</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=-dmzfQndOtk\">Module lifecycle management</a></li>\n</ul>\n\n<p><strong>HCP Terraform projects</strong> are used to group together multiple related workspaces and simplify configuration by allowing RBAC, variable sets, policy sets to be configured at the project level, rather than at the workspace level, easing the management burden.</p>\n\n<p>It generally makes sense to create an HCP Terraform project per application team, and in our scenario, we could update the module to create a project and register all workspaces under it.</p>\n\n<p>You can learn more about using HCP Terraform projects in this tutorial: <a href=\"https://developer.hashicorp.com/terraform/tutorials/cloud/projects\">Organize workspaces with projects</a>.</p>\n\n<p><strong>Workspace notifications</strong> enable HCP Terraform to send notifications about run progress and other significant events to external systems, such as Slack, Microsoft Teams, or via email. Each workspace can have its own notification settings, allowing up to 20 different notification destinations per workspace.</p>\n\n<p>In our scenario, the platform team could update the module to configure workspace notifications that trigger on the following events:</p>\n\n<ul>\n<li>Workspace events\n\n<ul>\n<li>Drift (HCP Terraform detected a configuration drift)</li>\n<li>Check failure (HCP Terraform detected one or more failed continuous validation checks), if your code includes checks.</li>\n</ul></li>\n<li>Run events\n\n<ul>\n<li>Needs attention (a plan has changes and HCP Terraform requires user input to continue).</li>\n<li>Errored (a run terminated early due to an error or cancellation)</li>\n</ul></li>\n</ul>\n\n<p><strong>Dynamic provider credentials</strong> in HCP Terraform represent a significant advancement in security and access management. This feature allows Terraform to automatically generate short-lived credentials for cloud providers on-demand, rather than relying on long-term, static access keys. When a Terraform operation is initiated, HCP Terraform requests temporary credentials from the cloud provider that are valid only for the duration of the specific task.</p>\n\n<p>This approach substantially improves the security posture by minimizing the exposure window of access credentials, reducing the risk of unauthorized access if credentials are compromised. Additionally, it eliminates the need to manage and manually rotate long-term access keys, decreasing administrative overhead and the potential for human error in credential management.</p>\n\n<p>You can learn more about using dynamic provider credentials in this tutorial: <a href=\"https://developer.hashicorp.com/terraform/tutorials/cloud/dynamic-credentials\">Authenticate providers with dynamic credentials</a>. </p>\n\n<p><strong>Module lifecycle management</strong> is a systematic approach to control and maintain Terraform modules from rollout to retirement, provide module status visibility, and improve communication across teams. Key aspects of module lifecycle management include:</p>\n\n<ul>\n<li><strong>Version control</strong>: Modules are tracked in version control systems to maintain history and allow collaboration between modules maintainers.</li>\n<li><strong>Testing</strong>: Writing and executing tests for your module code lets you check if everything works correctly before publishing a new version.</li>\n<li><strong>Publishing new versions</strong>: Releasing an updated copy of your module in a <a href=\"https://developer.hashicorp.com/terraform/registry/private\">private registry</a> with new features or fixes, similar to releasing a new version of an application.</li>\n<li><strong>Deprecation handling</strong>: The ability to mark modules as deprecated and communicate when modules should no longer be used.</li>\n</ul>\n\n<p>The module in this post is designed to onboard a new application team, but it could, with minor changes, also apply to shared services maintained by a platform team: The <code>application_id</code> variable could be renamed <code>shared_service_id</code> and this would be the start of a good foundation for shared services. As a platform team engineer, you can create a module to not only speed up the onboarding of new teams but also solve onboarding for shared services that your team manages.</p>\n\n<h2>Additional resources</h2>\n\n<ul>\n<li><a href=\"https://developer.hashicorp.com/terraform/tutorials/automation/tfe-provider-run-triggers\">Automate HCP Terraform workflows</a></li>\n<li>Try <a href=\"https://www.hashicorp.com/en/products/terraform?utm_source=hashicorp.com&amp;utm_medium=referral&amp;utm_campaign=26Q1_WW_hcp-signups-from-blogs&amp;utm_content=a-smoother-hcp-terraform-workspace-experience&amp;utm_offer=signup\">HCP Terraform’s free tier</a> which includes up to 500 resources per month.</li>\n</ul>\n","author":"Emmanuel Rousselle","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"798905dea3ae576faf08268f140c36bafe9d033d03bff513d65a2f276cd79668","category":"Tech"}