{"title":"Managing Shared State In Vue 3","link":"https://smashingmagazine.com/2021/06/managing-shared-state-vue3/","date":1622716200000,"content":"<p>State can be hard. When we start a simple Vue project, it can be simple to just keep our working state on a particular component:</p>\n<pre><code>setup() {\n  let books: Work[] = reactive([]);\n\n  onMounted(async () =&gt; {\n    // Call the API\n    const response = await bookService.getScienceBooks();\n    if (response.status === 200) {\n      books.splice(0, books.length, ...response.data.works);\n    }\n  });\n\n  return {\n    books\n  };\n},\n</code></pre>\n\n<p>When your project is a single page of showing data (perhaps to sort or filter it), this can be compelling. But in this case, this component will get data on every request. What if you want to keep it around? That’s where state management comes into play. As network connections are often expensive and occasionally unreliable, it would be better to keep this state around as you navigate through an application.</p>\n<p>Another issue is communicating between components. While you can use events and props to communicate with direct children-parents, handling simple situations like error handling and busy flags can be difficult when each of your views/pages are independent. For example, imagine that you had a top-level control was wired up to show error and loading animation:</p>\n<pre><code>// App.vue\n&lt;template&gt;\n  &lt;div class=\"container mx-auto bg-gray-100 p-1\"&gt;\n    &lt;router-link to=\"/\"&gt;&lt;h1&gt;Bookcase&lt;/h1&gt;&lt;/router-link&gt;\n    &lt;div class=\"alert\" v-if=\"error\"&gt;{{ error }}&lt;/div&gt;\n    &lt;div class=\"alert bg-gray-200 text-gray-900\" v-if=\"isBusy\"&gt;\n      Loading...\n    &lt;/div&gt;\n    &lt;router-view :key=\"$route.fullPath\"&gt;&lt;/router-view&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n\n<p>Without an effective way to handle this state, it might suggest a publish/subscribe system, but in fact sharing data is more straightforward in many cases. If want to have shared state, how do you go about it? Let’s look at some common ways to do this.</p>\n<p><strong>Note</strong>: <em>You’ll find the code for this section in the “main” branch of the <a href=\"https://github.com/smashingmagazine/SmashingBookcase\">example project on GitHub</a>.</em></p>\nShared State In Vue 3\n<p>Since moving to Vue 3, I’ve migrated completely to using the Composition API. For the article, I’m also using TypeScript though that’s not required for examples I’m showing you. While you can share state any way you want, I’m going to show you several techniques that I find the most commonly used patterns. Each has it’s own pros and cons, so don’t take anything I talk about here as dogma.</p>\n<p>The techniques include:</p>\n<ul>\n  <li><a href=\"#factories\">Factories</a>,</li>\n  <li><a href=\"#shared-singletons\">Shared Singletons</a>,</li>\n  <li><a href=\"#vuex4\">Vuex 4</a>,</li>\n  <li><a href=\"#vuex5\">Vuex 5</a>.</li>\n</ul>\n\n<p><strong>Note</strong>: <em>Vuex 5, as of the writing of this article, it’s in the RFC (Request for Comments) stage so I want to get you ready for where Vuex is going, but right now there is not a working version of this option.</em></p>\n<p>Let’s dig in...</p>\n<h3>Factories</h3>\n<p><strong>Note</strong>: <em>The code for this section is in the “Factories” branch of the example project on <a href=\"https://github.com/smashingmagazine/SmashingBookcase/tree/Factories\">GitHub</a>.</em></p>\n<p>The factory pattern is just about creating an instance of the state you care about. In this pattern, you return a function that is much like the <strong>start</strong> function in the Composition API. You’d create a scope and build the components of what you’re looking for. For example:</p>\n<pre><code>export default function () {\n\n  const books: Work[] = reactive([]);\n\n  async function loadBooks(val: string) {\n      const response = await bookService.getBooks(val, currentPage.value);\n      if (response.status === 200) {\n        books.splice(0, books.length, ...response.data.works);\n      }\n  }\n\n  return {\n    loadBooks,\n    books\n  };\n}\n</code></pre>\n\n<p>You could ask for just the parts of the factory created objects you need like so:</p>\n<pre><code>// In Home.vue\n  const { books, loadBooks } = BookFactory();\n</code></pre>\n\n<p>If we add an <code>isBusy</code> flag to show when the network request happens, the above code doesn’t change, but you could decide where you are going to show the <code>isBusy</code>:</p>\n<pre><code>export default function () {\n\n  const books: Work[] = reactive([]);\n  const isBusy = ref(false);\n\n  async function loadBooks(val: string) {\n    isBusy.value = true;\n    const response = await bookService.getBooks(val, currentPage.value);\n    if (response.status === 200) {\n      books.splice(0, books.length, ...response.data.works);\n    }\n  }\n\n  return {\n    loadBooks,\n    books,\n    isBusy\n  };\n}\n</code></pre>\n\n<p>In another view (vue?) you could just ask for the isBusy flag without having to know about how the rest of the factory works:</p>\n<pre><code>// App.vue\nexport default defineComponent({\n  setup() {\n    const { isBusy } = BookFactory();\n    return {\n      isBusy\n    }\n  },\n})\n</code></pre>\n\n<p>But you may have noticed an issue; every time we call the factory, we’re getting a new instance of all the objects. There are times when you want to have a factory return new instances, but in our case we’re talking about sharing the state, so we need to move the creation outside the factory:</p>\n<pre><code>const books: Work[] = reactive([]);\nconst isBusy = ref(false);\n\nasync function loadBooks(val: string) {\n  isBusy.value = true;\n  const response = await bookService.getBooks(val, currentPage.value);\n  if (response.status === 200) {\n    books.splice(0, books.length, ...response.data.works);\n  }\n}\n\nexport default function () {\n return {\n    loadBooks,\n    books,\n    isBusy\n  };\n}\n</code></pre>\n\n<p>Now the factory is giving us a shared instance, or a singleton if you prefer. While this pattern works, it can be confusing to return a function that doesn’t create a new instance every time.</p>\n<p>Because the underlying objects are marked as <code>const</code> you shouldn’t be able to replace them (and break the singleton nature). So this code should complain:</p>\n<pre><code>// In Home.vue\n  const { books, loadBooks } = BookFactory();\n\n  books = []; // Error, books is defined as const\n</code></pre>\n\n<p>So it can be important to make sure mutable state can be updated (e.g. using <code>books.splice()</code> instead of assigning the books).</p>\n<p>Another way to handle this is to use shared instances.</p>\n<h3>Shared Instances</h3>\n<p><em>The code for this section is in the “SharedState” branch of the example project on <a href=\"https://github.com/smashingmagazine/SmashingBookcase/tree/SharedState\">GitHub</a>.</em></p>\n<p>If you’re going to be sharing state, might as well be clear about the fact that the state is a singleton. In this case, it can just be imported as a static object. For example, I like to create an object that can be imported as a reactive object:</p>\n<pre><code>export default reactive({\n\n  books: new Array&lt;Work&gt;(),\n  isBusy: false,\n\n  async loadBooks() {\n    this.isBusy = true;\n    const response = await bookService.getBooks(this.currentTopic, this.currentPage);\n    if (response.status === 200) {\n      this.books.splice(0, this.books.length, ...response.data.works);\n    }\n    this.isBusy = false;\n  }\n});\n</code></pre>\n\n<p>In this case, you just import the object (which I’m calling a store in this example):</p>\n<pre><code>// Home.vue\nimport state from \"@/state\";\n\nexport default defineComponent({\n  setup() {\n\n    // ...\n\n    onMounted(async () =&gt; {\n      if (state.books.length === 0) state.loadBooks();\n    });\n\n    return {\n      state,\n      bookTopics,\n    };\n  },\n});\n</code></pre>\n\n<p>Then it becomes easy to bind to the state:</p>\n<pre><code>&lt;!-- Home.vue --&gt;\n&lt;div class=\"grid grid-cols-4\"&gt;\n  &lt;div\n    v-for=\"book in state.books\"\n    :key=\"book.key\"\n    class=\"border bg-white border-grey-500 m-1 p-1\"\n  &gt;\n  &lt;router-link :to=\"{ name: 'book', params: { id: book.key } }\"&gt;\n    &lt;BookInfo :book=\"book\" /&gt;\n  &lt;/router-link&gt;\n&lt;/div&gt;\n</code></pre>\n\n<p>Like the other patterns, you get the benefit that you can share this instance between views:</p>\n<pre><code>// App.vue\nimport state from \"@/state\";\n\nexport default defineComponent({\n  setup() {\n    return {\n      state\n    };\n  },\n})\n</code></pre>\n\n<p>Then this can bind to what is the same object (whether it is a parent of the <code>Home.vue</code> or another page in the router):</p>\n<pre><code>&lt;!-- App.vue --&gt;\n  &lt;div class=\"container mx-auto bg-gray-100 p-1\"&gt;\n    &lt;router-link to=\"/\"&gt;&lt;h1&gt;Bookcase&lt;/h1&gt;&lt;/router-link&gt;\n    &lt;div class=\"alert bg-gray-200 text-gray-900\"   \n         v-if=\"state.isBusy\"&gt;Loading...&lt;/div&gt;\n    &lt;router-view :key=\"$route.fullPath\"&gt;&lt;/router-view&gt;\n  &lt;/div&gt;\n</code></pre>\n\n<p>Whether you use the factory pattern or the shared instance, they both have a common issue: mutable state. You can have accidental side effects of bindings or code changing state when you don’t want them to. In a trivial example like I’m using here, it isn’t complex enough to worry about. But as you’re building larger and larger apps, you will want to think about state mutation more carefully. That’s where Vuex can come to the rescue.</p>\n<h3>Vuex 4</h3>\n<p><em>The code for this section is in the “Vuex4” branch of the example project on <a href=\"https://github.com/smashingmagazine/SmashingBookcase/tree/Vuex4\">GitHub</a>.</em></p>\n<p>Vuex is state manager for Vue. It was built by the core team though it is managed as a separate project. The purpose of Vuex is to separate the state from the actions you want to do to the state. All changes of state has to go through Vuex which means it is more complex, but you get protection from accidental state change.</p>\n<p>The idea of Vuex is to provide a predictable flow of state management. Views flow to Actions which, in turn, use Mutations to change State which, in turn, updates the View. By limiting the flow of state change, you should have fewer side effects that change the state of your applications; therefore be easier to build larger applications. Vuex has a learning curve, but with that complexity you get predictability.</p>\n<p>Additionally, Vuex does support development-time tools (via the Vue Tools) to work with the state management including a feature called time-travel. This allows you to view a history of the state and move back and forward to see how it affects the application.</p>\n<p>There are times, too, when Vuex is important too.</p>\n<p>To add it to your Vue 3 project, you can either add the package to the project:</p>\n<pre><code>&gt; npm i vuex\n</code></pre>\n\n<p>Or, alternatively you can add it by using the Vue CLI:</p>\n<pre><code>&gt; vue add vuex\n</code></pre>\n\n<p>By using the CLI, it will create a starting point for your Vuex store, otherwise you’ll need to wire it up manually to the project. Let’s walk through how this works.</p>\n<p>First, you’ll need a state object that is created with Vuex’s createStore function:</p>\n<pre><code>import { createStore } from 'vuex'\n\nexport default createStore({\n  state: {},\n  mutations: {},\n  actions: {},\n  getters: {}\n});\n</code></pre>\n\n<p>As you can see, the store requires several properties to be defined. State is just a list of the data you want to give your application access to:</p>\n<pre><code>import { createStore } from 'vuex'\n\nexport default createStore({\n  state: {\n    books: [],\n    isBusy: false\n  },\n  mutations: {},\n  actions: {}\n});\n</code></pre>\n\n<p>Note that the state shouldn’t use <strong>ref</strong> or <strong>reactive</strong> wrappers. This data is the same kind of share data that we used with Shared Instances or Factories. This store will be a singleton in your application, therefore the data in state is also going to be shared.</p>\n<p>Next, let’s look at actions. Actions are operations that you want to enable that involve the state. For example:</p>\n<pre><code>  actions: {\n    async loadBooks(store) {\n      const response = await bookService.getBooks(store.state.currentTopic,\n      if (response.status === 200) {\n        // ...\n      }\n    }\n  },\n</code></pre>\n\n<p>Actions are passed an instance of the store so that you can get at the state and other operations. Normally, we’d destructure just the parts we need:</p>\n<pre><code>  actions: {\n    async loadBooks({ state }) {\n      const response = await bookService.getBooks(state.currentTopic,\n      if (response.status === 200) {\n        // ...\n      }\n    }\n  },\n</code></pre>\n\n<p>The last piece of this are Mutations. Mutations are functions that can mutate state. Only mutations can affect state. So, for this example, we need mutations that change change the state:</p>\n<pre><code>  mutations: {\n    setBusy: (state) =&gt; state.isBusy = true,\n    clearBusy: (state) =&gt; state.isBusy = false,\n    setBooks(state, books) {\n      state.books.splice(0, state.books.length, ...books);\n    }\n },\n</code></pre>\n\n<p>Mutation functions always pass in the state object so that you can mutate that state. In the first two examples, you can see that we’re explicitly setting the state. But in the third example, we’re passing in the state to set. Mutations always take two parameters: state and the argument when calling the mutation.</p>\n<p>To call a mutation, you’d use the <strong>commit</strong> function on the store. In our case, I’ll just add it to the destructuring:</p>\n<pre><code>  actions: {\n    async loadBooks({ state, commit }) {\n      commit(\"setBusy\");\n      const response = await bookService.getBooks(state.currentTopic, \n      if (response.status === 200) {\n        commit(\"setBooks\", response.data);\n      }\n      commit(\"clearBusy\");\n    }\n  },\n</code></pre>\n\n<p>What you’ll see here is how <strong>commit</strong> requires the name of the action. There are tricks to make this not just use magic strings, but I’m going to skip that for now. This use of magic strings is one of the limitations of using Vuex.</p>\n<p>While using commit may seem like an unnecessary wrapper, remember that Vuex is not going to let you mutate state except inside the mutation, therefore only calls through <strong>commit</strong> will. </p>\n<p>You can also see that the call to <strong>setBooks</strong> takes a second argument. This is the second argument that is calling the mutation. If you were to need more information, you’d need to pack it into a single argument (another limitation of Vuex currently). Assuming you needed to insert a book into the books list, you could call it like this:</p>\n<pre><code>commit(\"insertBook\", { book, place: 4 }); // object, tuple, etc.\n</code></pre>\n\n<p>Then you could just destructure into the pieces you need:</p>\n<pre><code>mutations: {\n  insertBook(state, { book, place }) =&gt; // ...    \n}\n</code></pre>\n\n<p>Is this elegant? Not really, but it works.</p>\n<p>Now that we have our action working with mutations, we need to be able to use the Vuex store in our code. There are really two ways to get at the store. First, by registering the store with application (e.g. main.ts/js), you’ll have access to a centralized store that you have access to everywhere in your application:</p>\n<pre><code>// main.ts\nimport store from './store'\n\ncreateApp(App)\n  .use(store)\n  .use(router)\n  .mount('#app')\n</code></pre>\n\n<p>Note that this isn’t adding Vuex, but your actual store that you’re creating. Once this is added, you can just call <code>useStore</code> to get the store object:</p>\n<pre><code>import { useStore } from \"vuex\";\n\nexport default defineComponent({\n  components: {\n    BookInfo,\n  },\n  setup() {\n    const store = useStore();\n    const books = computed(() =&gt; store.state.books);\n    // ...\n  </code></pre>\n\n<p>This works fine, but I prefer to just import the store directly:</p>\n<pre><code>import store from \"@/store\";\n\nexport default defineComponent({\n  components: {\n    BookInfo,\n  },\n  setup() {\n    const books = computed(() =&gt; store.state.books);\n    // ...\n  </code></pre>\n\n<p>Now that you have access to the store object, how do you use it? For state, you’ll need to wrap them with computed functions so that changes will be propagated to your bindings:</p>\n<pre><code>export default defineComponent({\n  setup() {\n\n    const books = computed(() =&gt; store.state.books);\n\n    return {\n      books\n    };\n  },\n});\n</code></pre>\n\n<p>To call actions, you will need to call the <strong>dispatch</strong> method:</p>\n<pre><code>export default defineComponent({\n  setup() {\n\n    const books = computed(() =&gt; store.state.books);\n\n    onMounted(async () =&gt; await store.dispatch(\"loadBooks\"));\n\n    return {\n      books\n    };\n  },\n});\n</code></pre>\n\n<p>Actions can have parameters that you add after the name of the method. Lastly, to change state, you’ll need to call commit just like we did inside the Actions. For example, I have a paging property in the store, and then I can change the state with <strong>commit</strong>:</p>\n<pre><code>const incrementPage = () =&gt;\n  store.commit(\"setPage\", store.state.currentPage + 1);\nconst decrementPage = () =&gt;\n  store.commit(\"setPage\", store.state.currentPage - 1);\n</code></pre>\n\n<p>Note, that calling it like this would throw an error (because you can’t change state manually):</p>\n<pre><code>const incrementPage = () =&gt; store.state.currentPage++;\n  const decrementPage = () =&gt; store.state.currentPage--;\n</code></pre>\n\n<p>This is the real power here, we’d want control where state is changed and not have side effects that produce errors further down the line in development.</p>\n<p>You may be overwhelmed with number of moving pieces in Vuex, but it can really help manage state in larger, more complex projects. I would not say you need it in every case, but there will be large projects where it helps you overall.</p>\n<p>The big problem with Vuex 4 is that working with it in a TypeScript project leaves a lot to be desired. You can certainly make TypeScript types to help development and builds, but it requires a lot of moving pieces.</p>\n<p>That’s where Vuex 5 is meant to simplify how Vuex works in TypeScript (and in JavaScript projects in general). Let’s see how that will work once it’s released next.</p>\n<h3>Vuex 5</h3>\n<p><strong>Note</strong>: <em>The code for this section is in the “Vuex5” branch of the example project on <a href=\"https://github.com/smashingmagazine/SmashingBookcase/tree/Vuex5\">GitHub</a>.</em></p>\n<p>At the time of this article, Vuex 5 isn’t real. It’s a RFC (Request for Comments). It’s a plan. It’s a starting point for discussion. So a lot of what I may explain here likely will change somewhat. But to prepare you for the change in Vuex, I wanted to give you a view of where it’s going. Because of this the code associated with this example doesn’t build.</p>\n<p>The basic concepts of how Vuex works have been somewhat unchanged since it’s inception. With the introduction of Vue 3, Vuex 4 was created to mostly allow Vuex to work in new projects. But the team is trying to look at the real pain-points with Vuex and solve them. To this end they are planning some important changes:</p>\n<ul>\n<li>No more mutations: actions can mutate state (and possibly anyone).</li>\n<li>Better TypeScript support.</li>\n<li>Better multi-store functionality.</li>\n</ul>\n<p>So how would this work? Let’s start with creating the store:</p>\n<pre><code>export default createStore({\n  key: 'bookStore',\n  state: () =&gt; ({\n    isBusy: false,\n    books: new Array&lt;Work&gt;()\n  }),\n  actions: {\n    async loadBooks() {\n      try {\n        this.isBusy = true;\n        const response = await bookService.getBooks();\n        if (response.status === 200) {\n          this.books = response.data.works;\n        }\n      } finally {\n        this.isBusy = false;\n      }\n    }\n  },\n  getters: {\n    findBook(key: string): Work | undefined {\n      return this.books.find(b =&gt; b.key === key);\n    }\n  }\n});\n</code></pre>\n\n<p>First change to see is that every store now needs it own key. This is to allow you to retrieve multiple stores. Next you’ll notice that the state object is now a factory (e.g. returns from a function, not created on parsing). And there is no mutations section any more. Lastly, inside the actions, you can see we’re accessing state as just properties on the <code>this</code> pointer. No more having to pass in state and commit to actions. This helps not only in simplifying development, but also makes it easier to infer types for TypeScript.</p>\n<p>To register Vuex into your application, you’ll register Vuex instead of your global store:</p>\n<pre><code>import { createVuex } from 'vuex'\n\ncreateApp(App)\n  .use(createVuex())\n  .use(router)\n  .mount('#app')\n</code></pre>\n\n<p>Finally, to use the store, you’ll import the store then create an instance of it:</p>\n<pre><code>import bookStore from \"@/store\";\n\nexport default defineComponent({\n  components: {\n    BookInfo,\n  },\n  setup() {\n    const store = bookStore(); // Generate the wrapper\n    // ...\n  </code></pre>\n\n<p>Notice that what is returned from the store is a factory object that returns thsi instance of the store, no matter how many times you call the factory. The returned object is just an object with the actions, state and getters as first class citizens (with type information):</p>\n<pre><code>onMounted(async () =&gt; await store.loadBooks());\n\nconst incrementPage = () =&gt; store.currentPage++;\nconst decrementPage = () =&gt; store.currentPage--;\n</code></pre>\n\n<p>What you’ll see here is that state (e.g. <code>currentPage</code>) are just simple properties. And actions (e.g. <code>loadBooks</code>) are just functions. The fact that you’re using a store here is a side effect. You can treat the Vuex object as just an object and go about your work. This is a significant improvement in the API.</p>\n<p>Another change that’s important to point out is that you could also generate your store using a Composition API-like syntax:</p>\n<pre><code>export default defineStore(\"another\", () =&gt; {\n\n  // State\n  const isBusy = ref(false);\n  const books = reactive(new Array≷Work&gt;());\n\n  // Actions\n  async function loadBooks() {\n    try {\n      this.isBusy = true;\n      const response = await bookService.getBooks(this.currentTopic, this.currentPage);\n      if (response.status === 200) {\n        this.books = response.data.works;\n      }\n    } finally {\n      this.isBusy = false;\n    }\n  }\n\n  findBook(key: string): Work | undefined {\n    return this.books.find(b =&gt; b.key === key);\n  }\n\n  // Getters\n  const bookCount = computed(() =&gt; this.books.length);\n\n  return {\n    isBusy,\n    books,\n    loadBooks,\n    findBook,\n    bookCount\n  }\n});\n</code></pre>\n\n<p>This allows you to build your Vuex object just like you would your views with the Composition API and arguably it’s simpler.</p>\n<p>One main drawback in this new design is that you lose the non-mutability of the state. There are discussions happening around being able to enable this (for development only, just like Vuex 4) but there isn’t consensus how important this is. I personally think it’s a key benefit for Vuex, but we’ll have to see how this plays out.</p>\nWhere Are We?\n<p>Managing shared state in single page applications is a crucial part of development for most apps. Having a game plan on how you want to go about it in Vue is an important step in designing your solution. In this article, I’ve shown you several patterns for managing shared state including what’s coming for Vuex 5. Hopefully you’ll now have the knowledge to make the right decision for you own projects.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"c58eff1f18be93cdbc76c38e678516b1eb7595a2c600ec0274b4abcb8f668e66","category":"Tech"}