{"title":"Terraform 1.1 Improves Refactoring and the Cloud CLI Experience","link":"https://www.hashicorp.com/blog/terraform-1-1-improves-refactoring-and-the-cloud-cli-experience","date":1638997200000,"content":"<p>We’re excited to announce the release of HashiCorp Terraform 1.1, now immediately <a href=\"https://www.terraform.io/downloads.html\">available for download</a> as well as for use in <a href=\"https://app.terraform.io/signup/account\">HashiCorp Terraform Cloud</a>. Terraform is widely adopted as the standard for multi-cloud provisioning and automation, for individuals and for teams at any scale. This release marks a milestone in delivering new ways to easily and safely refactor as part of your Day 2 operations, as well as an improved command-line interface (CLI) experience for <a href=\"https://www.terraform.io/cloud\">Terraform Cloud</a> and <a href=\"https://www.terraform.io/docs/enterprise/index.html\">Terraform Enterprise</a> users.</p>\n<h2><a href=\"#easier-and-safer-refactoring-with-moved-statements\">»</a><a></a>Easier and Safer Refactoring with <code>moved</code> Statements</h2>\n<p>As a team’s infrastructure grows in both quantity and complexity, its Terraform configuration can often become unmanageable. When this happens, practitioners might want to do some refactoring, such as splitting a single module into multiple modules — whether it be modules within a single configuration or shared modules across multiple configurations. Terraform 1.1 introduces a new mechanism for refactoring using <code>moved</code> statements within a module’s own source code, enabling users to plan, preview, and validate multiple refactoring actions simultaneously.</p>\n<h3><a href=\"#refactoring-with-terraform-state-mv\">»</a><a></a>Refactoring with <code>terraform state mv</code></h3>\n<p>Prior to this release, refactoring tasks required <code>terraform state mv</code> commands via the CLI, along with corresponding changes to configuration. This process was often difficult and awkward, as well as potentially risky. Not only did users need to worry about updating their configuration, but also needed to update state without actually destroying and recreating infrastructure.</p>\n<p>Additionally, directly refactoring modules was not possible for module authors and Terraform Cloud users. For module authors, refactoring a module required releasing a new major version to indicate a breaking change, along with a guide for end users to manually update state. For Terraform Cloud and Enterprise users, refactoring within core Terraform Cloud workflows wasn’t feasible, as users need to be able to create a plan based on configuration changes. This often led users with admin access on the workspace to switch to local state with the CLI to make out-of-band and risky changes.</p>\n<h3><a href=\"#refactoring-with-moved-statements\">»</a><a></a>Refactoring with <code>moved</code> Statements</h3>\n<p>Terraform 1.1 introduces a new mechanism to safely refactor Terraform modules and configurations — all as part of creating a <em>plan</em>. These <code>moved</code> statements are written into a module’s source code, which allows Terraform to combine state updates with the configuration changes during the plan phase.</p>\n<p>These <code>moved</code> statements can be used to:</p>\n<ul>\n<li>Rename a resource</li>\n<li>Enable <code>count</code> or <code>for_each</code> for a resource</li>\n<li>Rename a module call</li>\n<li>Enable <code>count</code> or <code>for_each</code> for a module call</li>\n<li>Split one module into multiple modules</li>\n</ul>\n<p>Since these actions are declared in the configuration, Terraform will explain the changes as part of the plan output, so users can then validate and apply multiple actions at once. This allows for much easier and safer refactoring, without requiring users to touch state. This new mechanism also allows module authors and Terraform Cloud users to refactor within their workflows — no out-of-band or manual tasks required.</p>\n<h2><a href=\"#an-improved-cli-experience-for-terraform-cloud-and-enterprise\">»</a><a></a>An Improved CLI Experience for Terraform Cloud and Enterprise</h2>\n<p>Terraform Cloud and Enterprise practitioners use  three core workflows, either in isolation or jointly:</p>\n<ul>\n<li><a href=\"https://www.terraform.io/docs/cloud/run/ui.html\">UI/VCS-driven workflows</a></li>\n<li><a href=\"https://www.terraform.io/docs/cloud/run/cli.html\">CLI-driven workflows</a></li>\n<li><a href=\"https://www.terraform.io/docs/cloud/run/api.html\">API-driven workflows</a></li>\n</ul>\n<p>Each of these workflows represent ways that users trigger and manage <a href=\"https://www.terraform.io/docs/cloud/run/index.html\">runs</a>, along with other remote operations.</p>\n<p>With the release of Terraform 1.1, we wanted to focus on enhancing the CLI-driven workflow by introducing a new integration with Terraform Cloud and Terraform Enterprise. This new way of connecting to Terraform Cloud is declared as a <code>cloud</code> block within the <code>terraform</code> settings block, and allows for new functionality, improved error messages, and an overall better practitioner experience.</p><pre><code>terraform {\n  cloud {\n    organization = \"my-org\"\n    workspaces {\n      tags = [\"networking\"]\n    }\n  }\n}</code></pre><h3><a href=\"#how-is-the-new-cloud-integration-different\">»</a><a></a>How is the New Cloud Integration Different?</h3>\n<p>Prior to this release, users would connect to Terraform Cloud by declaring a <code>remote</code> backend in their backend configuration. While this integration worked, the overall developer experience and functionality left room for improvement. In terms of functionality, this new integration allows users to pass input variables using the <code>-var</code> flags (along with the other methods of supplying <a href=\"https://www.terraform.io/docs/cloud/workspaces/variables.html\">variables</a>), as well as managing workspaces via <a href=\"https://www.hashicorp.com/blog/new-workspace-tags-for-terraform-cloud\">workspace tags</a> — all from the CLI. For improving the developer experience, we focused on three things:</p>\n<ol>\n<li>Improving error messages and CLI prompts</li>\n<li>Clarifying remote state storage versus remote operations</li>\n<li>Helping users better understand Terraform Cloud workspaces</li>\n</ol>\n<h3><a href=\"#improving-error-messages-and-cli-prompts\">»</a><a></a>Improving Error Messages and CLI Prompts</h3>\n<p>Firstly, the new Terraform Cloud integration comes with more useful error messages to help users quickly understand and resolve issues. The existing <code>remote</code> backend often confused users with generic responses pointing to backend issues without context on how to find the culprit and fix the problem. This has been replaced with actionable help output that’s more applicable to Terraform Cloud users.</p><img src=\"https://www.datocms-assets.com/2885/1639004387-improved-error-message.png\" /><p>Additionally, we’ve added context-rich prompts to help users quickly onboard and migrate state, whether from a local Terraform project, an Amazon S3 backend, or the existing <code>remote</code> backend.</p><img src=\"https://www.datocms-assets.com/2885/1639004409-cli-prompt.png\" /><p>That leads us to the next point: what is a <code>remote</code> backend, and how is Terraform Cloud different?</p>\n<h3><a href=\"#clarifying-remote-state-storage-versus-remote-operations\">»</a><a></a>Clarifying Remote State Storage Versus Remote Operations</h3>\n<p>This new integration offers a much simpler answer to that question. Remote backends define where Terraform state is stored, such as on local disk or in another storage service (such as S3). Terraform Cloud provides both state storage <em>and</em> an execution environment for remote operations. This new integration clarifies this by making a native integration (rather than an all-purpose <code>remote</code> backend) within the <code>terraform</code> top-level settings block. Now, all backends refer only to where state can be stored, and Terraform Cloud and Enterprise have a baked-in presence where users can define things like workspace tags and names for managing runs.</p>\n<h3><a href=\"#helping-users-better-understand-terraform-cloud-workspaces\">»</a><a></a>Helping Users Better Understand Terraform Cloud Workspaces</h3>\n<p>Lastly, we wanted to help users better understand Terraform Cloud workspaces. In Terraform Cloud, a workspace contains everything Terraform needs to manage a collection of infrastructure — including execution context, stored values for input variables, state versioning, run history, and more. Workspaces are flexible and are not associated with a particular configuration, but rather with a Terraform Cloud organization.</p>\n<p>In this way, Terraform Cloud workspaces behave like completely separate working directories, and are typically named by both the set of resources they contain as well as the deployment environments they provision (for example, <code>networking-prod-east</code>). With the <code>workspace</code> block in the new <code>cloud</code> block, users can add workspace tags (such as <code>prod</code>) and their workspace in the Terraform Cloud UI will reflect exactly what’s in the configuration. Previously, <code>remote</code> backend users could use only workspace names and prefixes, which made the mental model more confusing than necessary. Additionally, expressions like <code>${terraform.workspace}</code> will now refer to the Terraform Cloud workspace name in all workflows (CLI, API, or VCS-driven runs).</p>\n<p>To learn how to seamlessly migrate your existing backend to the new Terraform Cloud integration, <a href=\"https://www.terraform.io/docs/cli/cloud/index.html\">see the documentation</a>. Or <a href=\"https://www.terraform.io/cloud\">sign-up for a free Terraform Cloud account</a> for remote state storage, remote runs, state versioning, and more.</p>\n<h2><a href=\"#getting-started-with-terraform-1-1\">»</a><a></a>Getting Started with Terraform 1.1</h2>\n<ul>\n<li><a href=\"https://www.terraform.io/downloads.html\">Download the Terraform 1.1 release</a></li>\n<li><a href=\"https://www.terraform.io/cloud\">Sign up for a free Terraform Cloud account </a></li>\n<li>Review the <a href=\"https://www.terraform.io/docs/cli/cloud/index.html\">Using Terraform Cloud with Terraform CLI</a> documentation.</li>\n<li>Explore <a href=\"https://learn.hashicorp.com/terraform\">our HashiCorp Learn tutorials</a>, including the new <a href=\"https://learn.hashicorp.com/tutorials/terraform/move-config\">Use Configuration to Move Resources</a> and <a href=\"https://learn.hashicorp.com/tutorials/terraform/migrate-remote-s3-backend-tfc\">Migrate State from S3 to Terraform Cloud</a> tutorials.</li>\n</ul>\n<p>For more details, please see <a href=\"https://github.com/hashicorp/terraform/blob/v1.1/CHANGELOG.md\">the full HashiCorp Terraform 1.1 changelog</a>. This release wouldn't have been possible without all of the great community feedback we've received via GitHub issues and elsewhere. Thank you!</p>","author":"Korinne Alpers","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"841c00e2ebdd0c75d31a7c8d1db9264656419d19843d8088e45372dfb3a1192c","category":"Tech"}