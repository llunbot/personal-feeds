{"title":"The View Transitions API And Delightful UI Animations (Part 2)","link":"https://smashingmagazine.com/2024/01/view-transitions-api-ui-animations-part2/","date":1704189600000,"content":"<p>Last time we met, <a href=\"https://www.smashingmagazine.com/2023/12/view-transitions-api-ui-animations-part1/\">I introduced you to the <strong>View Transitions API</strong></a>. We started with a simple default crossfade transition and applied it to different use cases involving elements on a page transitioning between two states. One of those examples took the basic idea of adding products to a shopping cart on an e-commerce site and creating a visual transition that indicates an item added to the cart.</p>\n<p>The View Transitions API is still considered an experimental feature that’s currently supported only in Chrome at the time I’m writing this, but I’m providing that demo below as well as a video if your browser is unable to support the API.</p>\n<p><img src=\"https://files.smashing.media/articles/view-transitions-api-ui-animations-part2/1-diagram-page-element-transitions.jpg\" /></p>\n<p>Those diagrams illustrate (1) the origin page, (2) the destination page, (3) the type of transition, and (4) the transition elements. The following is a closer look at the transition elements, i.e., the elements that receive the transition and are tracked by the API.</p>\n<p><img src=\"https://files.smashing.media/articles/view-transitions-api-ui-animations-part2/2-diagramming-transition-between-two-product-pages.png\" /></p>\n<p>So, what we’re working with are two transition elements: a <strong>header</strong> and a <strong>card component</strong>. We will configure those together one at a time.</p>\n<h3>Header Transition Elements</h3>\n<p>The default crossfade transition between the pages has already been set, so let’s start by registering the header as a <em>transition element</em> by assigning it a <code>view-transition-name</code>. First, let’s take a peek at the HTML:</p>\n<div>\n<pre><code>&lt;div class=\"header__wrapper\"&gt;\n  &lt;!-- Link back arrow --&gt;\n  &lt;a class=\"header__link header__link--dynamic\" href=\"/\"&gt;\n    &lt;svg ...&gt;&lt;!-- ... --&gt;&lt;/svg&gt;\n  &lt;/a&gt;\n  &lt;!-- Page title --&gt;\n  &lt;h1 class=\"header__title\"&gt;\n    &lt;a href=\"/\" class=\"header__link-logo\"&gt;\n      &lt;span class=\"header__logo--deco\"&gt;Vinyl&lt;/span&gt;Emporium &lt;/a&gt;\n  &lt;/h1&gt;\n  &lt;!-- ... --&gt;\n&lt;/div&gt;\n</code></pre>\n</div>\n\n<p>When the user navigates between the homepage and an item details page, the arrow in the header appears and disappears — depending on which direction we’re moving — while the title moves slightly to the right. We can use <code>display: none</code> to handle the visibility.</p>\n<pre><code>/* Hide back arrow on the homepage */\n.home .header__link--dynamic {\n    display: none;\n}\n</code></pre>\n\n<p>We’re actually registering <em>two</em> transition elements within the header: the arrow (<code>.header__link--dynamic</code>) and the title (<code>.header__title</code>). We use the <code>view-transition-name</code> property on both of them to define the names we want to call those elements in the transition:</p>\n<pre><code>@supports (view-transition-name: none) {\n  .header__link--dynamic {\n    view-transition-name: header-link;\n  }\n  .header__title {\n    view-transition-name: header-title;\n  }\n}\n</code></pre>\n\n<p>Note how we’re wrapping all of this in a CSS <code>@supports</code> query so it is scoped to browsers that actually support the View Transitions API. So far, so good!</p>\n<p><img src=\"https://files.smashing.media/articles/view-transitions-api-ui-animations-part2/3-diagramming-transition-between-product-pages.png\" /></p>\n<p>To do that, let’s start by defining our transition elements and assign transition names to the elements we’re transitioning between the product image (<code>.product__image--deco</code>) and the product disc behind the image (<code>.product__media::before</code>).</p>\n<pre><code>@supports (view-transition-name: none) {\n  .product__image--deco {\n    view-transition-name: product-lp;\n  }\n .product__media::before {\n    view-transition-name: flap;\n  }\n  ::view-transition-group(product-lp) {\n    animation-duration: 0.25s;\n    animation-timing-function: ease-in;\n  }\n  ::view-transition-old(product-lp),\n  ::view-transition-new(product-lp) {\n    /* Removed the crossfade animation */\n    mix-blend-mode: normal;\n    animation: none;\n  }\n}\n</code></pre>\n\n<p>Notice how we had to remove the crossfade animation from the product image’s old (<code>::view-transition-old(product-lp)</code>) and new (<code>::view-transition-new(product-lp)</code>) states. So, for now, at least, the album disc changes instantly the moment it’s positioned back behind the album image. </p>\n<p>But doing this messed up the transition between our global header navigation and product details pages. Navigating from the item details page back to the homepage results in the album disc remaining visible until the view transition finishes rather than running when we need it to.</p>\n<p><img src=\"https://files.smashing.media/articles/view-transitions-api-ui-animations-part2/4-diagramming-app-routes.png\" /></p>\n<p>Let’s configure the router to match that structure. Each route gets a <a href=\"https://reactrouter.com/en/main/route/loader\"><code>loader</code></a> function to handle page data.</p>\n<div>\n<pre><code>import { createBrowserRouter, RouterProvider } from \"react-router-dom\";\nimport Category, { loader as categoryLoader } from \"./pages/Category\";\nimport Details, { loader as detailsLoader } from \"./pages/Details\";\nimport Layout from \"./components/Layout\";\n\n/* Other imports */\n\nconst router = createBrowserRouter([\n  {\n    /* Shared layout for all routes */\n    element: &lt;Layout /&gt;,\n    children: [\n      {\n        /* Homepage is going to load a default (first) category */\n        path: \"/\",\n        element: &lt;Category /&gt;,\n        loader: categoryLoader,\n      },\n      {\n      /* Other categories */\n        path: \"/:category\",\n        element: &lt;Category /&gt;,\n        loader: categoryLoader,\n      },\n      {\n        /* Item details page */\n        path: \"/:category/product/:slug\",\n        element: &lt;Details /&gt;,\n        loader: detailsLoader,\n      },\n    ],\n  },\n]);\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(\n  &lt;React.StrictMode&gt;\n    &lt;RouterProvider router={router} /&gt;\n  &lt;/React.StrictMode&gt;\n);\n</code></pre>\n</div>\n\n<p>With this, we have established the routing structure for the app:</p>\n<ul>\n<li>Homepage (<code>/</code>);</li>\n<li>Category page (<code>/:category</code>);</li>\n<li>Product details page (<code>/:category/product/:slug</code>).</li>\n</ul>\n<p>And depending on which route we are on, the app renders a <code>Layout</code> component. That’s all we need as far as setting up the routes that we’ll use to transition between views. Now, we can start working on our first transition: between two category pages.</p>\n<h3>Transition Between Category Pages</h3>\n<p>We’ll start by implementing the transition between category pages. The transition performs a crossfade animation between views. The only part of the UI that does not participate in the transition is the bottom border of the category filter menu, which provides a visual indication for the active category filter and moves between the formerly active category filter and the currently active category filter that we will eventually register as a transition element.</p>\n<p><img src=\"https://files.smashing.media/articles/view-transitions-api-ui-animations-part2/5-diagramming-ui-transition-navigating-between-category-views.png\" /></p>\n<p>Since we’re using react-router, we get its web-based routing solution, <a href=\"https://github.com/remix-run/react-router/tree/main/packages/react-router-dom\">react-router-dom</a>, baked right in, giving us access to the DOM bindings — or router components we need to keep the UI in sync with the current route as well as a component for navigational links. That’s also where we gain access to the View Transitions API implementation.</p>\n<p>Specifically, we will use the component for navigation links (<code>Link</code>) with the <code>unstable_viewTransition</code> prop that tells the react-router to run the View Transitions API when switching page contents.</p>\n<div>\n<pre><code>import { Link, useLocation } from \"react-router-dom\";\n/* Other imports */\n\nconst NavLink = ({ slug, title, id }) =&gt; {\n  const { pathname } = useLocation();\n  /* Check if the current nav link is active */\n  const isMatch = slug === \"/\" ? pathname === \"/\" : pathname.includes(slug);\n  return (\n    &lt;li key={id}&gt;\n      &lt;Link\n        className={isMatch ? \"nav__link nav__link--current\" : \"nav__link\"}\n        to={slug}\n        unstable_viewTransition\n      &gt;\n        {title}\n      &lt;/Link&gt;\n    &lt;/li&gt;\n  );\n};\n\nconst Nav = () =&gt; {\n  return \n    &lt;nav className={\"nav\"}&gt;\n      &lt;ul className=\"nav__list\"&gt;\n        {categories.items.map((item) =&gt; (\n          &lt;NavLink {...item} /&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/nav&gt;\n  );\n};\n</code></pre>\n</div>\n\n<p>That is literally all we need to register and run the default crossfading view transition! That’s again because react-router-dom is giving us access to the View Transitions API and does the heavy lifting to abstract the process of setting transitions on elements and views.</p>\n<h3>Creating The Transition Elements</h3>\n<p>We only have one UI element that gets its own transition and a name for it, and that’s the visual indicator for the actively selected product category filter in the app’s navigation. While the app transitions between category views, it runs another transition on the active indicator that moves its position from the origin category to the destination category.</p>\n<p>I know that I had earlier described that visual indicator as a bottom border, but we’re actually going to establish it as a standard HTML horizontal rule (<code>&lt;hr&gt;</code>) element and conditionally render it depending on the current route. So, basically, the <code>&lt;hr&gt;</code> element is fully removed from the DOM when a view transition is triggered, and we re-render it in the DOM under whatever <code>NavLink</code> component represents the current route.</p>\n<p>We want this transition only to run if the navigation is visible, so we’ll use the <code>react-intersection-observer</code> helper to check if the element is visible and, if it is, assign it a <code>viewTransitionName</code> in an inline style.</p>\n<div>\n<pre><code>import { useInView } from \"react-intersection-observer\";\n/* Other imports */\n\nconst NavLink = ({ slug, title, id }) =&gt; {\n  const { pathname } = useLocation();\n  const isMatch = slug === \"/\" ? pathname === \"/\" : pathname.includes(slug);\n  return (\n    &lt;li key={id}&gt;\n      &lt;Link\n        ref={ref}\n        className={isMatch ? \"nav__link nav__link--current\" : \"nav__link\"}\n        to={slug}\n        unstable_viewTransition\n      &gt;\n        {title}\n      &lt;/Link&gt;\n      {isMatch &amp;&amp; (\n        &lt;hr\n          style={{\n            viewTransitionName: inView ? \"marker\" : \"\",\n          }}\n          className=\"nav__marker\"\n        /&gt;\n      )}\n    &lt;/li&gt;\n  );\n};\n</code></pre>\n</div>\n\n<p><img src=\"https://files.smashing.media/articles/view-transitions-api-ui-animations-part2/6-transitioning-between-two-product-views.png\" /></p>\n<p>First, let’s take a look at our <code>Card</code> component used in the category views. Once again, <code>react-router-dom</code> makes our job relatively easy, thanks to the <code>unstable_useViewTransitionState</code> hook. The hook accepts a URL string and returns <code>true</code> if there is an active page transition to the target URL, as well as if the transition is using the View Transitions API.</p>\n<p>That’s how we’ll make sure that our active image remains a transition element when navigating between a category view and a product view.</p>\n<div>\n<pre><code>import { Link, unstable_useViewTransitionState } from \"react-router-dom\";\n/* Other imports */\n\nconst Card = ({ author, category, slug, id, title }) =&gt; {\n  /* We'll use the same URL value for the Link and the hook */\n  const url = <code>/${category}/product/${slug}</code>;\n\n  /* Check if the transition is running for the item details pageURL */\n  const isTransitioning = unstable_useViewTransitionState(url);\n\n  return (\n    &lt;li className=\"card\"&gt;</code>\n      <code>&lt;Link unstable_viewTransition to={url} className=\"card__link\"&gt;</code>\n        <code>&lt;figure className=\"card__figure\"&gt;</code>\n          <code>&lt;img</code>\n            <code>className=\"card__image\"</code>\n            <code>style=}}</code>\n              <code>/* Apply the viewTransitionName if the card has been clicked on */</code>\n              <code>viewTransitionName: isTransitioning ? \"item-image\" : \"\",</code>\n            <code>}}</code>\n            <code>src={<code>/assets/$&amp;#123;category&amp;#125;/${id}-min.jpg</code>}</code>\n            <code>alt=\"\"</code>\n          <code>/&gt;</code>\n         <code>{/* ... */}</code>\n        <code>&lt;/figure&gt;</code>\n        <code>&lt;div className=\"card__deco\" /&gt;</code>\n      <code>&lt;/Link&gt;</code>\n    <code>&lt;/li&gt;</code>\n  <code>);</code>\n<code>};</code>\n\n<code>export default Card;\n</code></pre>\n</div>\n\n<p>We know which image in the product view is the transition element, so we can apply the <strong><code>viewTransitionName</code></strong> directly to it rather than having to guess:</p>\n<div>\n<pre><code>import {\n  Link,\n  useLoaderData,\n  unstable_useViewTransitionState,\n} from \"react-router-dom\";\n/* Other imports */\n\nconst Details = () =&gt; {\n  const data = useLoaderData();\n  const { id, category, title, author } = data;\n  return (\n    &lt;&gt;\n      &lt;section className=\"item\"&gt;\n        {/* ... */}\n        &lt;article className=\"item__layout\"&gt;\n          &lt;div&gt;\n              &lt;img</code>\n                <code>style={{viewTransitionName: \"item-image\"}}</code>\n                <code>className=\"item__image\"</code>\n                <code>src={<code>/assets/${category}/${id}-min.jpg</code>}</code>\n                <code>alt=\"\"</code>\n              <code>/&gt;</code>\n          <code>&lt;/div&gt;</code>\n          <code>{/* ... */}</code>\n        <code>&lt;/article&gt;</code>\n      <code>&lt;/section&gt;</code>\n    <code>&lt;/&gt;</code>\n  <code>);</code>\n<code>};</code>\n\n<code>export default Details;\n</code></pre>\n</div>\n\n<p>We’re on a good track but have two issues that we need to tackle before moving on to the final transitions.</p>\n<p>One is that the <code>Card</code> component’s image (<code>.card__image</code>) contains some CSS that applies a fixed one-to-one <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/aspect-ratio\">aspect ratio</a> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit\">centering</a> for maintaining consistent dimensions no matter what image file is used. Once the user clicks on the <code>Card</code> — the <code>.card-image</code> in a category view — it becomes an <code>.item-image</code> in the product view and should transition into its original state, devoid of those extra styles.</p>\n<pre><code>\n/* Card component image */\n.card__image {\n  object-fit: cover;\n  object-position: 50% 50%;\n  aspect-ratio: 1;\n  /* ... */\n}\n\n/* Product view image */\n.item__image {\n /* No aspect-ratio applied */\n /* ... */\n}\n</code></pre>\n\n<p><img src=\"https://files.smashing.media/articles/view-transitions-api-ui-animations-part2/7-image-transitioning-fromp-default-state-to-larger-state.png\" /></p>\n<p>Jake has <a href=\"https://developer.chrome.com/docs/web-platform/view-transitions/#working-with-frameworks\">recommended using React’s <code>flushSync</code> function</a> to make this work. The function <a href=\"https://react.dev/reference/react-dom/flushSync\">forces synchronous and immediate DOM update</a><a href=\"https://react.dev/reference/react-dom/flushSync\">s</a> inside a given callback. It’s meant to be used sparingly, but it’s okay to use it for running the View Transition API as the target component re-renders.</p>\n<div>\n<pre><code>// Assigns view-transition-name to the image before transition runs\nconst [isImageTransition, setIsImageTransition] = React.useState(false);\n\n// Applies fixed-positioning and full-width image styles as transition runs\nconst [isFullImage, setIsFullImage] = React.useState(false);\n\n/* ... */\n\n// State update function, which triggers the DOM update we want to animate\nconst toggleImageState = () =&gt; setIsFullImage((state) =&gt; !state);\n\n// Click handler function - toggles both states.\nconst handleZoom = async () =&gt; {\n  // Run API only if available.\n  if (document.startViewTransition) {\n    // Set image as a transition element.\n    setIsImageTransition(true);\n    const transition = document.startViewTransition(() =&gt; {\n      // Apply DOM updates and force immediate re-render while.\n      // View Transitions API is running.\n      flushSync(toggleImageState);\n    });\n    await transition.finished;\n    // Cleanup\n    setIsImageTransition(false);\n  } else {\n    // Fallback \n    toggleImageState();\n  }\n};\n\n/* ... */\n</code></pre>\n</div>\n\n<p>With this in place, all we really have to do now is toggle class names and view transition names depending on the state we defined in the previous code.</p>\n<div>\n<pre><code>import React from \"react\";\nimport { flushSync } from \"react-dom\";\n\n/* Other imports */\n\nconst Details = () =&gt; {\n  /* React state, click handlers, util functions... */\n\n  return (\n    &lt;&gt;\n      &lt;section className=\"item\"&gt;\n        {/* ... */}\n        &lt;article className=\"item__layout\"&gt;\n          &lt;div&gt;</code>\n            <code>&lt;button</code> <code>onClick={handleZoom}</code> <code>className=\"item__toggle\"&gt;</code>\n              <code>&lt;img</code>\n                <code>style={{</code>\n                  <code>viewTransitionName:</code>\n                    <code>isTransitioning || isImageTransition ? \"item-image\" : \"\",</code>\n                <code>}}</code>\n                <code>className={</code>\n                  <code>isFullImage</code>\n                    <code>? \"item__image item__image--active\"</code>\n                    <code>: \"item__image\"</code>\n                <code>}</code>\n                <code>src={<code>/assets/${category}/${id}-min.jpg</code>}</code>\n                <code>alt=\"\"</code>\n              <code>/&gt;</code>\n            <code>&lt;/button&gt;</code>\n          <code>&lt;/div&gt;</code>\n          <code>{/* ... */}</code>\n        <code>&lt;/article&gt;</code>\n      <code>&lt;/section&gt;</code>\n      <code>&lt;aside</code>\n        <code>className={</code>\n          <code>isFullImage ? \"item__overlay item__overlay--active\" : \"item__overlay\"</code>\n        <code>}</code>\n      <code>/&gt;</code>\n    <code>&lt;/&gt;</code>\n  <code>);</code>\n<code>};\n</code></pre>\n</div>\n\n<p>We are applying <code>viewTransitionName</code> directly on the image’s <code>style</code> attribute. We could have used boolean variables to toggle a CSS class and set a <code>view-transition-name</code> in CSS instead. The only reason I went with inline styles is to show both approaches in these examples. You can use whichever approach fits your project!</p>\n<p>Let’s round this out by refining styles for the overlay that sits behind the image when it is expanded:</p>\n<pre><code>.item__overlay--active {\n  z-index: 2;\n  display: block;\n  background: rgba(0, 0, 0, 0.5);\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n}\n\n.item__image--active {\n  cursor: zoom-out;\n  position: absolute;\n  z-index: 9;\n  top: 50%;\n  left: 50%;\n  transform: translate3d(-50%, -50%, 0);\n  max-width: calc(100vw - 4rem);\n  max-height: calc(100vh - 4rem);\n}\n</code></pre>\n\n<h3>Demo</h3>\n<p>The following demonstrates only the code that is directly relevant to the View Transitions API so that it is easier to inspect and use. If you want access to the full code, feel free to get it in <a href=\"https://github.com/codeAdrian/museum-of-digital-wonders\">this GitHub repo</a>.</p>\n<ul>\n<li><a href=\"https://museum-of-digital-wonders.vercel.app/illustration\">Open Live Demo 2</a></li>\n</ul>\nConclusion\n<p>We did a lot of work with the View Transitions API in the second half of this brief two-part article series. Together, we implemented full-view transitions in two different contexts, one in a more traditional multi-page application (i.e., website) and another in a single-page application using React.</p>\n<p>We started with transitions in a MPA because the process requires fewer dependencies than working with a framework in a SPA. We were able to set the default crossfade transition between two pages — a category page and a product page — and, in the process, we learned how to set view transition names on elements <em>after</em> the transition runs to prevent naming conflicts.</p>\n<p>From there, we applied the same concept in a SPA, that is, an application that contains one page but many views. We took a React app for a “Museum of Digital Wonders” and applied transitions between full views, such as navigating between a category view and a product view. We got to see how react-router — and, by extension, react-router-dom — is used to define transitions bound to specific routes. We used it not only to set a crossfade transition between category views and between category and product views but also to set a view transition name on UI elements that also transition in the process.</p>\n<p>The View Transitions API is powerful, and I hope you see that after reading this series and following along with the examples we covered together. What used to take a hefty amount of JavaScript is now a somewhat trivial task, and the result is a smoother user experience that irons out the process of moving from one page or view to another.</p>\n<p>That said, the <strong>View Transitions API’s power and simplicity need the same level of care and consideration for accessibility as any other transition or animation on the web</strong>. That includes things like being mindful of user motion preferences and resisting the temptation to put transitions on everything. There’s a fine balance that comes with making accessible interfaces, and motion is certainly included.</p>\n<h3>References</h3>\n<ul>\n<li><a href=\"https://drafts.csswg.org/css-view-transitions-1/\">CSS View Transitions Module Level 1 Specification</a> (W3C)</li>\n<li><a href=\"https://github.com/WICG/view-transitions/blob/main/explainer.md\">View Transitions API Explainer</a> (GitHub repo)</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API\">View Transitions API</a> (MDN)</li>\n<li>“<a href=\"https://developer.chrome.com/docs/web-platform/view-transitions/\">Smooth And Simple Transitions With The View Transitions API</a>,” Jake Archibald</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"6b2ea2214a098ad4402ee3fe3630c998364be7b50b93e8bb4c169dc1e396f99d","category":"Tech"}