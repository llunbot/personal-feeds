{"title":"CSS Scroll Snapping Aligned With Global Page Layout: A Full-Width Slider Case Study","link":"https://smashingmagazine.com/2023/12/css-scroll-snapping-aligned-global-page-layout-case-study/","date":1702461600000,"content":"<p>You know what’s perhaps the “cheapest” way to make a slider of images, right? You set up a container, drop a bunch of inline image elements in it, then set <code>overflow-x: auto</code> on it, allowing us to swipe through them. The same idea applies nicely to a group of cards, too.</p>\n<p><img src=\"https://files.smashing.media/articles/css-scroll-snapping-aligned-global-page-layout-case-study/1-snap-start-css.jpeg\" /></p>\n<p>But we’ll go deeper than scroll snapping. The thing with sliders is that it can be difficult to instruct them on where to “snap.” For example, what if we want to configure the slider in such a way that images always snap at the left (or inline-start) edge when swiping right to left?</p>\n<p><img src=\"https://files.smashing.media/articles/css-scroll-snapping-aligned-global-page-layout-case-study/2-snap-action-css.jpeg\" /></p>\n<p>But that’s not even the “tricky” part we’re looking at. Say we are working within an existing page layout where the main container of the page has a set amount of padding applied to it. In this case, the slider should always begin at the inline starting edge of the inside of the container, and when scrolling, each image should snap to the edge rather than scroll past it.</p>\n<p>Simply drop the slider in the layout container, right? It’s not as straightforward as you might think. If you notice in the illustrations, the slider is <em>outside</em> the page’s main container because we need it to go full-width. We do that in order to allow the images to scroll fully edge-to-edge and overflow the main body.</p>\n<p>Our challenge is to make sure the slider snaps into place consistent with the page layout’s spacing, indicated by the dashed blue lines in the drawings. The green area represents the page container’s padding, and we want images to snap right at the blue line.</p>\nThe Basic Layout\n<p>Let’s start with some baseline HTML that includes a header and footer, each with an inner <code>.container</code> element that’s used for the page’s layout. Our slider will sit in between the header and footer but lack the same inner <code>.container</code> that applies padding and width to it so that the images scroll the full width of the page.</p>\n<pre><code>&lt;header&gt;\n  &lt;div class=\"container\"&gt;\n    &lt;!-- some contained header with some nav items --&gt;\n  &lt;/div&gt;\n&lt;/header&gt;\n&lt;main&gt;\n  &lt;section class=\"slider\"&gt;\n    &lt;!-- our slider --&gt;\n  &lt;/section&gt;\n  &lt;section class=\"body-text\"&gt;\n    &lt;div class=\"container\"&gt;\n      &lt;!-- some contained text --&gt;\n    &lt;/div&gt;\n  &lt;/section&gt;\n&lt;/main&gt;\n&lt;footer&gt;\n  &lt;div class=\"container\"&gt;\n    &lt;!-- a contained footer --&gt;\n  &lt;/div&gt;\n&lt;/footer&gt;\n</code></pre>\n\nCreating The Container\n<p>In contrast to the emphasis I’ve put on scroll snapping for this demo, the real power in creating the slider does not actually start with scroll snapping. The trick to create something like this starts with the layout <code>.container</code> elements inside the header and footer. We’ll set up a few CSS variables and configure the <code>.container</code>’s properties, such as its width and padding.</p>\n<p>The following bit of CSS defines a set of variables that are used to control the maximum width and padding of a container element. The <code>@media</code> rules are used to apply different values to these properties depending on the viewport’s width.</p>\n<pre><code>\n:root {\n  --c-max-width: 100%;\n  --c-padding: 10px;\n\n  @media screen and (min-width: 768px) {\n    --c-max-width: 800px;\n    --c-padding: 12px;\n  }\n  @media screen and (min-width: 1000px) {\n    --c-max-width: 940px;\n    --c-padding: 24px;\n  }\n  @media screen and (min-width: 1200px) {\n    --c-max-width: 1200px;\n    --c-padding: 40px;\n  }\n}\n</code></pre>\n\n<p>The first couple of lines of the <code>:root</code> element’s ruleset define two CSS custom properties: <code>--c-max-width</code> and <code>--c-padding</code>. These properties are used to control the layout <code>.container</code>’s maximum width and padding.</p>\n<p>Next up, we have our <code>@media</code> rules. These apply different values to the -<code>-c-max-width</code> and <code>--c-padding</code> properties depending on the screen size. For example, the first <code>@media</code> rule updates the value of <code>--c-max-width</code> from <code>100%</code> to <code>800px</code>, as well as the <code>--c-padding</code> from <code>10px</code> to <code>12px</code> when the screen width is at least <code>768px</code>.</p>\n<p>Those are the variables. We then set up the style rules for the container, which we’ve creatively named <code>.container</code>, and apply those variables to it. The <code>.container</code>’s maximum width and inline padding are assigned to the also creatively-named <code>-c-max-width</code> and <code>--c-padding</code> variables. This opens up our container’s variables at a root level so that they can easily be accessed by other elements when we need them.</p>\n<p>I am using pixels in these examples because I want this tutorial to be about the actual technique instead of using different sizing units. Also, please note that I will be using CSS nesting for the demos, as <a href=\"https://caniuse.com/css-nesting\">it is supported in every major browser</a> at the time I’m writing this.</p>\n\n\n\nThe Scroll-Snapping\n<p>Let’s work on the scroll-snapping part of this slider. The first thing we’re going to do is update the HTML with the images. Remember that this slider is outside of the <code>.container</code> (we’ll take care of that later).</p>\n<pre><code>&lt;header&gt;\n  &lt;!-- .container --&gt;\n&lt;/header\n\n&lt;section class=\"slider\"&gt;\n  &lt;div&gt;\n    &lt;img src=\"...\" alt=\"\"&gt;\n  &lt;/div&gt;\n  &lt;div&gt;\n    &lt;img src=\"...\" alt=\"\"&gt;\n  &lt;/div&gt;\n  &lt;div&gt;\n    &lt;img src=\"...\" alt=\"\"&gt;\n  &lt;/div&gt;\n  &lt;!-- etc. --&gt;\n&lt;/section&gt;\n\n&lt;footer&gt;\n  &lt;!-- .container --&gt;\n&lt;/footer&gt;\n</code></pre>\n\n<p>Now we have a a group of divs that are direct children of the <code>.slider</code>. And those, in turn, each contain one image element. With this intact, it’s time for us to style this as an actual slider. Flexbox is an efficient way to change the display behavior of the <code>.slider</code>’s divs so that they flow in the inline direction rather than stacking vertically as they naturally would as block-level elements. Using Flexbox also gives us access to the <code>gap</code> property to space things out a bit.</p>\n<pre><code>.slider {\n  display: flex;\n  gap: 24px;\n}\n</code></pre>\n\n<p>Now we can let the images overflow the <code>.slider</code> in the horizontal, or inline, direction:</p>\n<pre><code>.slider {\n  display: flex;\n  gap: 24px;\n  overflow-x: auto;\n}\n</code></pre>\n\n<p>Before we apply scroll snapping, we ought to configure the divs so that the images are equally sized. A slider is so much better to use when the images are visually consistent rather than having a mix of portrait and landscape orientations, creating a jagged flow. We can use the <code>flex</code> property on the child divs, which is shorthand for the <code>flex-shrink</code>, <code>flex-grow</code>, and <code>flex-basis</code> properties:</p>\n<pre><code>.slider {\n  display: flex;\n  gap: 24px;\n  overflow-x: auto;\n\n  &gt; * {\n    flex: 0 0 300px;\n  }\n}\n</code></pre>\n\n<p>This way, the divs are only as big as the content they contain and will not exceed a width of <code>300px</code>. But! In order to contain the images in the space, we will set them to take up the full <code>100%</code> width of the divs, slap an <code>aspect-ratio</code> on them to maintain proportions, then use the <code>object-fit</code> property to to <code>cover</code> the div’s dimensions.</p>\n<pre><code>.slider {\n  display: flex;\n  gap: 24px;\n  overflow-x: auto;\n\n  &gt; * {\n    flex: 0 0 300px;\n  }\n\n  &amp; img {\n    aspect-ratio: 3 / 4;\n    object-fit: cover;\n    width: 100%;\n  }\n}\n</code></pre>\n\n<p>With this in place, we can now turn to scroll snapping:</p>\n<pre><code>.slider {\n  display: flex;\n  gap: 24px;\n  overflow-x: auto;\n  scroll-snap-type: x mandatory;\n\n  &gt; * {\n    flex: 0 0 300px;\n    scroll-snap-align: start;\n  }\n\n  /*\n}\n</code></pre>\n\n<p>Here’s what’s up:</p>\n<ul>\n<li><strong>We’re using the <code>scroll-snap-type</code> property on the <code>.slider</code> container</strong> to initialize scroll snapping in the horizizontal (<code>x</code>) direction. The <code>mandatory</code> keyword means we’re forcing the slider to snap on items in the container instead of allowing it to scroll at will and land wherever it wants.</li>\n<li><strong>We’re using the <code>scroll-snap-align</code> property on the divs</strong> to set the snapping on the item’s <code>start</code>-ing edge (or “right” edge in a typical horizontal left-to-right writing mode).</li>\n</ul>\n<p>Good so far? Here’s what we’ve made up to this point:</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/MWLRxXE\">Cheap Slider, Scroll Snapped [forked]</a> by <a href=\"https://codepen.io/geoffgraham\">Geoff Graham</a>.</p>\nCalculating The Offset Size\n<p>Now that we have all of our pieces in place, it’s time to create the exact snapping layout we want. We already know what the maximum width of the page’s layout <code>.container</code> is because we set it up to change at different breakpoints with the variables we registered at the beginning. In other words, the <code>.container</code>’s width will never exceed the value of <code>--c-max-width</code>. We also know the container always has a padding equal to the value of <code>--c-padding</code>.</p>\n<p>Again, our slider is <em>outside</em> of the <code>.container</code>, and yet, we want the scroll-snapped images to align with those values for a balanced page layout. Let’s create a new CSS variable, but this time scoped to the <code>.slider</code> and set it up to calculate the space between the viewport and the inside of the <code>.container</code> element.</p>\n<div>\n<pre><code>.slider {\n  --offset-width: calc(((100% - (min(var(--c-max-width), 100%) + (var(--c-padding) * 2))) / 2) + (var(--c-padding) * 2)\n  );\n}\n</code></pre>\n</div>\n\n<p>That is a lot of math! First, we’re calculating the minimum value of either the <code>.container</code> element’s <code>max-width</code> or <code>100%</code>, whichever is smaller, then increasing this minimum value with padding on the <code>.slider</code>. This result is then subtracted from <code>100%</code>. From this, we get the total amount of space that is available to offset either side of the <code>.slider</code> to align with the layout <code>.container</code>.</p>\n<p>We then divide this number by <code>2</code> to get the offset width for each specific side. And finally, we add the <code>.container</code>’s inline padding to the offset width so that the <code>.slider</code> is offset from the inside edges of the container rather than the outside edges. In the demo, I have used the universal selector (<code>*</code>) and its pseudos to <a href=\"https://css-tricks.com/international-box-sizing-awareness-day/\">measure the <code>box-sizing</code> of all elements by the <code>border-box</code></a> so that we are working inside the .<code>slider</code>’s borders rather than outside of it.</p>\n<pre><code>*, *::before, *::after {\n  box-sizing: border-box;\n}\n</code></pre>\n\nSome Minor Cleanup\n<p>If you think that our code is becoming a bit too chaotic, we can certainly improve it a bit. When I run into these situations, I sometimes like to organize things into multiple custom properties just for easy reading. For example, we could combine the inline paddings that are scoped to the <code>:root</code> and update the slider’s <code>--offset-width</code> variable with a <code>calc()</code> function that’s a bit easier on the eyes.</p>\n<div>\n<pre><code>:root {\n  /* previous container custom properties */\n\n   --c-padding-inline: calc(var(--c-padding) * 2);\n}\n\n.slider {\n  --offset-width: calc(((100% - (min(var(--c-max-width), 100%) + var(--c-padding-inline))) / 2) + var(--c-padding-inline));\n\n  /* etc. */\n}\n</code></pre>\n</div>\n\n<p>That’s a smidge better, right?</p>\nAligning The Slider With The Page Layout\n<p>We have a fully-functioning scroll scroll-snapping container at this point! The last thing for us to do is apply padding to it that aligns with the layout <code>.container</code>. As a reminder, the challenge is for us to respect the page layout’s padding even though the <code>.slider</code> is a full-width element outside of that container.</p>\n<p>This means we need to apply our newly-created <code>--offset-width</code> variable to the <code>.slider</code>. We’ve already scoped the variable to the <code>.slider</code>, so all we really need is to apply it to the right properties. Here’s what that looks like:</p>\n<div>\n<pre><code>.slider {\n  --offset-width: calc(\n    ((100% - (min(var(--c-max-width), 100%) + (var(--c-padding) * 2))) / 2) + (var(--c-padding) * 2)\n  );\n\n  padding-inline: var(--offset-width);\n  scroll-padding-inline-start: var(--offset-width);\n\n  /* etc. */\n  }\n</code></pre>\n</div>\n\n<p>The <code>padding-inline</code> and <code>scroll-padding-inline-start</code> properties are used to offset the slider from the left and right sides of its container and to ensure that the slider is always fully visible when the user scrolls.</p>\n<ul>\n<li><strong><code>padding-inline</code></strong><br />This sets spacing inside the <code>.slider</code>’s inline edges. A nice thing about using this logical property instead of a physical property is that we can apply the padding in both directions in one fell swoop, as there is no physical property shorthand that combines <code>padding-left</code> and <code>padding-right</code>. This way, the <code>.slider</code>’s internal inline spacing matches that of the <code>.container</code> in a single declaration.</li>\n<li><strong><code>scroll-padding-inline-start</code></strong><br />This sets the scroll padding at the start of the slider’s inline dimension. This scroll padding is equal to the amount of space that is added to the left (i.e., inline start) side of the <code>.slider</code>’s content during the scroll.</li>\n</ul>\n<p>Now that the <code>padding-inline</code> and <code>scroll-padding-inline-start</code> properties are both set to the value of the <code>--offset-width</code> variable, we can ensure that the slider is perfectly aligned with the start of our container and snaps with the start of that container when the user scrolls.</p>\n<p>We could take all of this a step further by setting the gap of our slider items to be the same as our padding gap. We’re really creating a flexible system here:</p>\n<pre><code>.slider {\n  --gap: var(--c-padding);\n  gap: var(--gap);\n}\n</code></pre>\n\n<p>Personally, I would scope this into a new custom property of the slider itself, but it’s more of a personal preference. The full demo can be <a href=\"https://codepen.io/utilitybend/pen/MWZBrew\">found on CodePen</a>. I added a toggle in the demo so you can easily track the maximum width and paddings while resizing.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/xxMeBJa\">Full width scroll snap that snaps to the container [forked]</a> by <a href=\"https://codepen.io/utilitybend\">utilitybend</a>.</p>\n<p>But we don’t have to stop here! We can do all sorts of calculations with our custom properties. Maybe instead of adding a fixed width to the <code>.slider</code>’s flex children, we want to always display three images at a time inside of the container:</p>\n<pre><code>.slider {\n  --gap: var(--c-padding);\n  --flex-width: calc((100% - var(--gap) * 2) / 3);\n\n  /* Previous scroll snap code */\n\n  &gt; * {\n    flex: 0 0 var(--flex-width);\n    scroll-snap-align: start;\n  }\n}\n</code></pre>\n\n<p>That <code>--flex-width</code> custom property takes <code>100%</code> of the container the slider is in and subtracts it by two times the <code>--gap</code>. And, because we want <em>three</em> items in view at a time, we divide that result by <code>3</code>.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/WNPWmgo\">Updated scroll container with 3 items fitted in container [forked]</a> by <a href=\"https://codepen.io/utilitybend\">utilitybend</a>.</p>\nWhy Techniques Like This Are Important\n<p>The best thing about using custom properties to handle calculations is that they are <strong>lighter</strong> and <strong>more performant</strong> than attempting to handle them in JavaScript. It takes some getting used to, but I believe that we should use these kinds of calculations a lot more often. Performance is such an important feature. Even seemingly minor optimizations like this can add up and really make a difference to the overall end-user experience.</p>\n<p>And, as we’ve seen, we can plug in variables from other elements into the equation and use them to conform an element to the properties of another element. That’s exactly what we did to conform the <code>.slider</code>’s inner padding to the padding of a <code>.container</code> that is completely independent of the slider. That’s the power of CSS variables — <strong>reusability</strong> and <strong>modularity</strong> that can improve how elements interact within and outside other elements.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"1092ada2f00a9cc7d8a9baede3a287151c4e5daf2fd8c2fd70cb3ad1193020b4","category":"Tech"}