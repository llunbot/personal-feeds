{"title":"Introducing Karpenter – An Open-Source High-Performance Kubernetes Cluster Autoscaler","link":"https://aws.amazon.com/blogs/aws/introducing-karpenter-an-open-source-high-performance-kubernetes-cluster-autoscaler/","date":1638233144000,"content":"<p>Today we are announcing that <a href=\"https://karpenter.sh/\">Karpenter</a> is ready for production. Karpenter is an open-source, flexible, high-performance Kubernetes cluster autoscaler built with AWS. It helps improve your application availability and cluster efficiency by rapidly launching right-sized compute resources in response to changing application load. Karpenter also provides just-in-time compute resources to meet your application’s needs and will soon automatically optimize a cluster’s compute resource footprint to reduce costs and improve performance.</p> \n<p>Before Karpenter, Kubernetes users needed to dynamically adjust the compute capacity of their clusters to support applications using <a href=\"https://docs.aws.amazon.com/autoscaling/ec2/userguide/AutoScalingGroup.html\">Amazon EC2 Auto Scaling groups</a> and the <a href=\"https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler\">Kubernetes Cluster Autoscaler</a>. Nearly half of Kubernetes customers on AWS report that configuring cluster auto scaling using the Kubernetes Cluster Autoscaler is challenging and restrictive.</p> \n<p>When Karpenter is installed in your cluster, Karpenter observes the aggregate resource requests of unscheduled pods and makes decisions to launch new nodes and terminate them to reduce scheduling latencies and infrastructure costs. Karpenter does this by observing events within the Kubernetes cluster and then sending commands to the underlying cloud provider’s compute service, such as Amazon EC2.</p> \n<p><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/11/23/2021-karpenter-diagram.png\" /></p> \n<p>Karpenter is an open-source project licensed under the <a href=\"https://github.com/awslabs/karpenter/blob/main/LICENSE\">Apache License 2.0</a>. It is designed to work with any Kubernetes cluster running in any environment, including all major cloud providers and on-premises environments. We welcome contributions to build additional cloud providers or to improve core project functionality. If you find a bug, have a suggestion, or have something to contribute, please engage with us on <a href=\"https://github.com/awslabs/karpenter/issues\">GitHub</a>.</p> \n<p><strong><u>Getting Started with Karpenter on AWS</u></strong><br /> To get started with Karpenter in any Kubernetes cluster, ensure there is some compute capacity available, and install it using the Helm charts provided in the public repository. Karpenter also requires permissions to provision compute resources on the provider of your choice.</p> \n<p>Once installed in your cluster, the default Karpenter provisioner will observe incoming Kubernetes pods, which cannot be scheduled due to insufficient compute resources in the cluster and automatically launch new resources to meet their scheduling and resource requirements.</p> \n<p>I want to show a quick start using Karpenter in an Amazon EKS cluster based on <a href=\"https://karpenter.sh/docs/getting-started/\">Getting Started with Karpenter on AWS</a>. It requires the installation of <a href=\"https://aws.amazon.com/cli/\">AWS Command Line Interface</a> (AWS CLI), <a href=\"https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/\">kubectl</a>, <a href=\"https://docs.aws.amazon.com/eks/latest/userguide/eksctl.html\">eksctl</a>, and <a href=\"https://helm.sh/docs/intro/install/\">Helm</a> (the package manager for Kubernetes). After setting up these tools, create a cluster with <code>eksctl</code>. This example configuration file specifies a basic cluster with one initial node.</p> \n<pre><code>cat &lt;&lt;EOF &gt; cluster.yaml\n---\napiVersion: eksctl.io/v1alpha5\nkind: ClusterConfig\nmetadata:\n  name: eks-karpenter-demo\n  region: us-east-1\n  version: \"1.20\"\nmanagedNodeGroups:\n  - instanceType: m5.large\n    amiFamily: AmazonLinux2\n    name: eks-kapenter-demo-ng\n    desiredCapacity: 1\n    minSize: 1\n    maxSize: 5\nEOF\n$ eksctl create cluster -f cluster.yaml</code></pre> \n<p>Karpenter itself can run anywhere, including on <a href=\"https://docs.aws.amazon.com/eks/latest/userguide/worker.html\">self-managed node groups</a>, <a href=\"https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html\">managed node groups</a>, or <a href=\"https://aws.amazon.com/fargate/\">AWS Fargate</a>. Karpenter will provision EC2 instances in your account.</p> \n<p>Next, you need to create necessary <a href=\"https://aws.amazon.com/iam/\">AWS Identity and Access Management</a> (IAM) resources using the <a href=\"https://karpenter.sh/docs/getting-started/cloudformation.yaml\">AWS CloudFormation template</a> and <a href=\"https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html\">IAM Roles for Service Accounts</a> (IRSA) for the Karpenter controller to get permissions like launching instances following the <a href=\"https://karpenter.sh/docs/getting-started/\">documentation</a>. You also need to install the Helm chart to deploy Karpenter to your cluster.</p> \n<pre><code>$ helm repo add karpenter https://charts.karpenter.sh\n$ helm repo update\n$ helm upgrade --install --skip-crds karpenter karpenter/karpenter --namespace karpenter \\\n  --create-namespace --set serviceAccount.create=false --version 0.5.0 \\\n  --set controller.clusterName=eks-karpenter-demo\n  --set controller.clusterEndpoint=$(aws eks describe-cluster --name eks-karpenter-demo --query \"cluster.endpoint\" --output json) \\\n  --wait # for the defaulting webhook to install before creating a Provisioner</code></pre> \n<p>Karpenter provisioners are a Kubernetes resource that enables you to configure the behavior of Karpenter in your cluster. When you create a default provisioner, without further customization besides what is needed for Karpenter to provision compute resources in your cluster, Karpenter automatically discovers node properties such as instance types, zones, architectures, operating systems, and purchase types of instances. You don’t need to define these spec:requirements if there is no explicit business requirement.</p> \n<pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: karpenter.sh/v1alpha5\nkind: Provisioner\nmetadata:\nname: default\nspec:\n#Requirements that constrain the parameters of provisioned nodes. \n#Operators { In, NotIn } are supported to enable including or excluding values\n  requirements:\n    - key: node.k8s.aws/instance-type #If not included, all instance types are considered\n      operator: In\n      values: [\"m5.large\", \"m5.2xlarge\"]\n    - key: \"topology.kubernetes.io/zone\" #If not included, all zones are considered\n      operator: In\n      values: [\"us-east-1a\", \"us-east-1b\"]\n    - key: \"kubernetes.io/arch\" #If not included, all architectures are considered\n      values: [\"arm64\", \"amd64\"]\n    - key: \" karpenter.sh/capacity-type\" #If not included, the webhook for the AWS cloud provider will default to on-demand\n      operator: In\n      values: [\"spot\", \"on-demand\"]\n  provider:\n    instanceProfile: KarpenterNodeInstanceProfile-eks-karpenter-demo\n  ttlSecondsAfterEmpty: 30  \nEOF</code></pre> \n<p>The <code>ttlSecondsAfterEmpty</code> value configures Karpenter to terminate empty nodes. If this value is disabled, nodes will never scale down due to low utilization. To learn more, see <a href=\"https://karpenter.sh/docs/provisioner-crd/\">Provisioner custom resource definitions (CRDs)</a> on the Karpenter site.</p> \n<p>Karpenter is now active and ready to begin provisioning nodes in your cluster. Create some pods using a deployment, and watch Karpenter provision nodes in response.</p> \n<pre><code>$ kubectl create deployment --name inflate \\\n          --image=public.ecr.aws/eks-distro/kubernetes/pause:3.2</code></pre> \n<p>Let’s scale the deployment and check out the logs of the Karpenter controller.</p> \n<pre><code>$ kubectl scale deployment inflate --replicas 10\n$ kubectl logs -f -n karpenter $(kubectl get pods -n karpenter -l karpenter=controller -o name)\n2021-11-23T04:46:11.280Z        INFO    controller.allocation.provisioner/default       Starting provisioning loop      {\"commit\": \"abc12345\"}\n2021-11-23T04:46:11.280Z        INFO    controller.allocation.provisioner/default       Waiting to batch additional pods        {\"commit\": \"abc123456\"}\n2021-11-23T04:46:12.452Z        INFO    controller.allocation.provisioner/default       Found 9 provisionable pods      {\"commit\": \"abc12345\"}\n2021-11-23T04:46:13.689Z        INFO    controller.allocation.provisioner/default       Computed packing for 10 pod(s) with instance type option(s) [m5.large]  {\"commit\": \" abc123456\"}\n2021-11-23T04:46:16.228Z        INFO    controller.allocation.provisioner/default       Launched instance: i-01234abcdef, type: m5.large, zone: us-east-1a, hostname: ip-192-168-0-0.ec2.internal    {\"commit\": \"abc12345\"}\n2021-11-23T04:46:16.265Z        INFO    controller.allocation.provisioner/default       Bound 9 pod(s) to node ip-192-168-0-0.ec2.internal  {\"commit\": \"abc12345\"}\n2021-11-23T04:46:16.265Z        INFO    controller.allocation.provisioner/default       Watching for pod events {\"commit\": \"abc12345\"}</code></pre> \n<p>The provisioner’s controller listens for Pods changes, which launched a new instance and bound the provisionable Pods into the new nodes.</p> \n<p>Now, delete the deployment. After 30 seconds (<code>ttlSecondsAfterEmpty = 30</code>), Karpenter should terminate the empty nodes.</p> \n<pre><code>$ kubectl delete deployment inflate\n$ kubectl logs -f -n karpenter $(kubectl get pods -n karpenter -l karpenter=controller -o name)\n2021-11-23T04:46:18.953Z        INFO    controller.allocation.provisioner/default       Watching for pod events {\"commit\": \"abc12345\"}\n2021-11-23T04:49:05.805Z        INFO    controller.Node Added TTL to empty node ip-192-168-0-0.ec2.internal {\"commit\": \"abc12345\"}\n2021-11-23T04:49:35.823Z        INFO    controller.Node Triggering termination after 30s for empty node ip-192-168-0-0.ec2.internal {\"commit\": \"abc12345\"}\n2021-11-23T04:49:35.849Z        INFO    controller.Termination  Cordoned node ip-192-168-116-109.ec2.internal   {\"commit\": \"abc12345\"}\n2021-11-23T04:49:36.521Z        INFO    controller.Termination  Deleted node ip-192-168-0-0.ec2.internal    {\"commit\": \"abc12345\"}</code></pre> \n<p>If you delete a node with kubectl, Karpenter will gracefully cordon, drain, and shut down the corresponding instance. Under the hood, Karpenter adds a finalizer to the node object, which blocks deletion until all pods are drained, and the instance is terminated.</p> \n<p><strong><u>Things to Know</u></strong><br /> Here are a couple of things to keep in mind about Kapenter features:</p> \n<p><strong>Accelerated Computing</strong>: Karpenter works with all kinds of Kubernetes applications, but it performs particularly well for use cases that require rapid provisioning and deprovisioning large numbers of diverse compute resources quickly. For example, this includes batch jobs to train machine learning models, run simulations, or perform complex financial calculations. You can leverage custom resources of nvidia.com/gpu, amd.com/gpu, and aws.amazon.com/neuron for use cases that require accelerated EC2 instances.</p> \n<p><strong>Provisioners Compatibility</strong>: Kapenter provisioners are designed to work alongside static capacity management solutions like Amazon EKS managed node groups and EC2 Auto Scaling groups. You may choose to manage the entirety of your capacity using provisioners, a mixed model with both dynamic and statically managed capacity, or a fully static approach. We recommend not using Kubernetes Cluster Autoscaler at the same time as Karpenter because both systems scale up nodes in response to unschedulable pods. If configured together, both systems will race to launch or terminate instances for these pods.</p> \n<p><strong><u>Join our Karpenter Community</u></strong><br /> Karpenter’s community is open to everyone. Give it a try, and join our <a href=\"https://github.com/awslabs/karpenter/blob/main/WORKING_GROUP.md\">working group meeting</a> for future releases that interest you. As I said, we welcome <a href=\"https://github.com/awslabs/karpenter/blob/main/CONTRIBUTING.md\">any contributions</a> such as bug reports, new features, corrections, or additional documentation.</p> \n<p>To learn more about Karpenter, see the <a href=\"https://karpenter.sh/docs/\">documentation</a> and <a href=\"https://youtu.be/3f0Tv7IiQQw?t=19028\">demo video</a> from AWS Container Day.</p> \n<p>– <a href=\"https://twitter.com/channyun\">Channy</a></p>","author":"Channy Yun","siteTitle":"AWS News Blog","siteHash":"6093e072e4117ec22616e844cb857d03ca62c57a411a8affc77cb5e8b6b15bf6","entryHash":"012789cb9db484fcb988a374bf6524a6f72b2a7875d0283ae1b20034ecdf90d7","category":"Tech"}