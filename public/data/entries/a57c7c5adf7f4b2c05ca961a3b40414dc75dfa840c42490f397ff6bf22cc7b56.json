{"title":"ElementInternals and Form-Associated Custom Elements","link":"https://webkit.org/blog/13711/elementinternals-and-form-associated-custom-elements/","date":1675716716000,"content":"<p>In <a href=\"https://webkit.org/blog/13703/release-notes-for-safari-technology-preview-162/\">Safari Technology Preview 162</a> we enabled the support for <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ElementInternals\"><code>ElementInternals</code></a> and the form-associated custom elements by default. <a href=\"https://webkit.org/blog/7027/introducing-custom-elements/\">Custom elements</a> is a feature which lets web developers create reusable components by defining their own HTML elements without relying on a JavaScript framework. <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ElementInternals\"><code>ElementInternals</code></a> is a new addition to custom elements API, which allows developers to manage a custom element’s internal states such as default ARIA role or ARIA label as well as having custom elements participate in form submissions and validations.</p>\n<h2>Default ARIA for Custom Elements</h2>\n<p>To use <code>ElementInternals</code> with a custom element, call <code>this.attachInternals()</code> in a custom element constructor just the same way we’d call <code>attachShadow()</code> as follows:</p>\n<pre><code><span>class</span> <span>SomeButtonElement</span> <span>extends</span> <span>HTMLElement</span> {\n    #<span>internals</span>;\n    #<span>shadowRoot</span>;\n    <span>constructor</span>()\n    {\n        <span>super</span>();\n        <span>this</span>.#<span>internals</span> <span>=</span> <span>this</span>.<span>attachInternals</span>();\n        <span>this</span>.#<span>internals</span>.<span>ariaRole</span> <span>=</span> <span>'button'</span>;\n        <span>this</span>.#<span>shadowRoot</span> <span>=</span> <span>this</span>.<span>attachShadow</span>({<span>mode</span><span>:</span> <span>'closed'</span>});\n        <span>this</span>.#<span>shadowRoot</span>.<span>innerHTML</span> <span>=</span> <span>'&lt;slot&gt;&lt;/slot&gt;'</span>;\n    }\n}\n<span>customElements</span>.<span>define</span>(<span>'some-button'</span>, <span>SomeButtonElement</span>);\n</code></pre>\n<p>Here, <code>#internals</code> and <code>#shadowRoot</code> are <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields\">private member fields</a>. The above code will define a simple custom element whose <a href=\"https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles\">ARIA role</a> is <code>button</code> by default. Achieving the same effect without using <code>ElementInternals</code> required sprouting ARIA content attribute on the custom element itself like this:</p>\n<pre><code><span>class</span> <span>SomeButtonElement</span> <span>extends</span> <span>HTMLElement</span> {\n    #<span>shadowRoot</span>;\n    <span>constructor</span>()\n    {\n        <span>super</span>();\n        <span>this</span>.#<span>shadowRoot</span> <span>=</span> <span>this</span>.<span>attachShadow</span>({<span>mode</span><span>:</span> <span>'closed'</span>});\n        <span>this</span>.#<span>shadowRoot</span>.<span>innerHTML</span> <span>=</span> <span>'&lt;slot&gt;&lt;/slot&gt;'</span>;\n        <span>this</span>.<span>setAttribute</span>(<span>'role'</span>, <span>'button'</span>);\n    }\n}\n<span>customElements</span>.<span>define</span>(<span>'some-button'</span>, <span>SomeButtonElement</span>);\n</code></pre>\n<p>This code is problematic for a few reasons. For one, it’s surprising for an element to automatically add content attributes on itself since no built-in element does this. But more importantly, the above code prevents users of this custom element to override ARIA role like this because the constructor will override the role content attribute upon upgrades:</p>\n<pre><code><span>&lt;<span>some-button</span> <span>role</span>=<span>\"switch\"</span>&gt;</span><span>&lt;/<span>some-button</span>&gt;</span>\n</code></pre>\n<p>Using <code>ElementInternals</code>’s <code>ariaRole</code> property as done above, this example works seamlessly. <code>ElementInternals</code> similarly allows specifying the default values of other ARIA features such as <a href=\"https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-label\">ARIA label</a>.</p>\n<h2>Participating in Form Submission</h2>\n<p><code>ElementInternals</code> also adds the capability for custom elements to participate in a form submission. To use this feature of custom elements, we must declare that a custom element is associated with forms as follows:</p>\n<pre><code><span>class</span> <span>SomeButtonElement</span> <span>extends</span> <span>HTMLElement</span> {\n    <span>static</span> <span>formAssociated</span> <span>=</span> <span>true</span>;\n    <span>static</span> <span>observedAttributes</span> <span>=</span> [<span>'value'</span>];\n    #<span>internals</span>;\n    <span>constructor</span>()\n    {\n        <span>super</span>();\n        <span>this</span>.#<span>internals</span> <span>=</span> <span>this</span>.<span>attachInternals</span>();\n        <span>this</span>.#<span>internals</span>.<span>ariaRole</span> <span>=</span> <span>'button'</span>;\n    }\n    <span>attributeChangedCallback</span>(<span>name</span>, <span>oldValue</span>, <span>newValue</span>)\n    {\n        <span>this</span>.#<span>internals</span>.<span>setFormValue</span>(<span>newValue</span>);\n    }\n}\n<span>customElements</span>.<span>define</span>(<span>'some-button'</span>, <span>SomeButtonElement</span>);\n</code></pre>\n<p>With the above definition of a <code>some-button</code> element, <code>some-button</code> will submit the value of the <code>value</code> attribute specified on the element for the <code>name</code> attribute specified on the same element. E.g., if we had a markup like <code>&lt;some-element name=\"some-key\" value=\"some-value\"&gt;&lt;/some-element&gt;</code>, we would submit <code>some-key=``some-value</code>.</p>\n<h2>Participating in Form Validation</h2>\n<p>Likewise, <code>ElementInternals</code> adds the capability for custom elements to participate in form validation. In the following example, <code>some-text-field</code> is designed to require a minimum of two characters in the <code>input</code> element inside its shadow tree. When there are less than two characters, it reports a validation error to the user using the browser’s native UI using <code>setValidity()</code> and <code>reportValidity()</code>:</p>\n<pre><code><span>class</span> <span>SomeTextFieldElement</span> <span>extends</span> <span>HTMLElement</span> {\n    <span>static</span> <span>formAssociated</span> <span>=</span> <span>true</span>;\n    #<span>internals</span>;\n    #<span>shadowRoot</span>;\n    <span>constructor</span>()\n    {\n        <span>super</span>();\n        <span>this</span>.#<span>internals</span> <span>=</span> <span>this</span>.<span>attachInternals</span>();\n        <span>this</span>.#<span>shadowRoot</span> <span>=</span> <span>this</span>.<span>attachShadow</span>({<span>mode</span><span>:</span> <span>'closed'</span>, <span>delegatesFocus</span><span>:</span> <span>true</span>});\n        <span>this</span>.#<span>shadowRoot</span>.<span>innerHTML</span> <span>=</span> <span>'&lt;input autofocus&gt;'</span>;\n        <span>const</span> <span>input</span> <span>=</span> <span>this</span>.#<span>shadowRoot</span>.<span>firstChild</span>;\n        <span>input</span>.<span>addEventListener</span>(<span>'change'</span>, () <span>=</span><span>&gt;</span> {\n            <span>this</span>.#<span>internals</span>.<span>setFormValue</span>(<span>input</span>.<span>value</span>);\n            <span>this</span>.<span>updateValidity</span>(<span>input</span>.<span>value</span>);\n        });\n    }\n    <span>updateValidity</span>(<span>newValue</span>)\n    {\n        <span>if</span> (<span>newValue</span>.<span>length</span> <span>&gt;</span><span>=</span> <span>2</span>) {\n            <span>this</span>.#<span>internals</span>.<span>setValidity</span>({ });\n            <span>return</span>;\n        }\n        <span>this</span>.#<span>internals</span>.<span>setValidity</span>({<span>tooShort</span><span>:</span> <span>true</span>}, \n            <span>'value is too short'</span>, <span>this</span>.#<span>shadowRoot</span>.<span>firstChild</span>);\n        <span>this</span>.#<span>internals</span>.<span>reportValidity</span>();\n    }\n}\n<span>customElements</span>.<span>define</span>(<span>'some-text-field'</span>, <span>SomeTextFieldElement</span>);\n</code></pre>\n<p>With this setup, <code>:invalid</code> pseudo class will automatically apply to the element when the number of characters user typed is less than 2.</p>\n<h2>Form-Associated Custom Element Callbacks</h2>\n<p>In addition, form-associated custom elements provide the following set of new custom element reaction callbacks:</p>\n<ul>\n<li><code>formAssociatedCallback(form)</code> – Called when the associated form element changes to <code>form</code>. <code>ElementInternals.form</code> returns the associated from element.</li>\n<li><code>formResetCallback()</code> – Called when the form is being reset. (e.g. user pressed <code>input[type=reset]</code> button). Custom element should clear whatever value set by the user.</li>\n<li><code>formDisabledCallback(isDisabled)</code> – Called when the disabled state of the element changes.</li>\n<li><code>formStateRestoreCallback(state, reason)</code> – Called when the browser is trying to restore element’s state to <code>state</code> in which case <code>reason</code> is “restore”, or when the browser is trying to fulfill autofill on behalf of user in which case <code>reason</code> is “autocomplete”. In the case of “restore”, <code>state</code> is a string, <code>File</code>, or <code>FormData</code> object previously set as the second argument to <code>setFormValue</code>.</li>\n</ul>\n<p>Let’s take a look at <code>formStateRestoreCallback</code> as an example. In the following example, we store <code>input.value</code> as state whenever the value of input element inside the shadow tree changes (second argument to <code>setFormValue</code>). When the user navigates away to some other page and comes back to this page, browser can restore this state via <code>formStateRestoreCallback</code>. Note that WebKit currently has a limitation that only string can be used for the state, and  “autocomplete” is not supported yet.</p>\n<pre><code><span>class</span> <span>SomeTextFieldElement</span> <span>extends</span> <span>HTMLElement</span> {\n    <span>static</span> <span>formAssociated</span> <span>=</span> <span>true</span>;\n    #<span>internals</span>;\n    #<span>shadowRoot</span>;\n    <span>constructor</span>()\n    {\n        <span>super</span>();\n        <span>this</span>.#<span>internals</span> <span>=</span> <span>this</span>.<span>attachInternals</span>();\n        <span>this</span>.#<span>shadowRoot</span> <span>=</span> <span>this</span>.<span>attachShadow</span>({<span>mode</span><span>:</span> <span>'closed'</span>, <span>delegatesFocus</span><span>:</span> <span>true</span>});\n        <span>this</span>.#<span>shadowRoot</span>.<span>innerHTML</span> <span>=</span> <span>'&lt;input autofocus&gt;'</span>;\n        <span>const</span> <span>input</span> <span>=</span> <span>this</span>.#<span>shadowRoot</span>.<span>querySelector</span>(<span>'input'</span>);\n        <span>input</span>.<span>addEventListener</span>(<span>'change'</span>, () <span>=</span><span>&gt;</span> {\n            <span>this</span>.#<span>internals</span>.<span>setFormValue</span>(<span>input</span>.<span>value</span>, <span>input</span>.<span>value</span>);\n        });\n    }\n    <span>formStateRestoreCallback</span>(<span>state</span>, <span>reason</span>)\n    {\n        <span>this</span>.#<span>shadowRoot</span>.<span>querySelector</span>(<span>'input'</span>).<span>value</span> <span>=</span> <span>state</span>;\n    }\n}\n<span>customElements</span>.<span>define</span>(<span>'some-text-field'</span>, <span>SomeTextFieldElement</span>);\n</code></pre>\n<p>In summary, <code>ElementInternals</code> and form-associated custom elements provide an exciting new way of writing reusable component that participates in form submission and validation. <code>ElementInternals</code> also provides the ability to specify the default value of ARIA role and other ARIA properties for a custom element. We’re excited to bring these features together to web developers.</p>","author":"","siteTitle":"Blog – WebKit","siteHash":"7f8dbea0b8f53db2e11a2faa08c6dca9954c01638d09a2ce585b77a60d10f7a1","entryHash":"a57c7c5adf7f4b2c05ca961a3b40414dc75dfa840c42490f397ff6bf22cc7b56","category":"Tech"}