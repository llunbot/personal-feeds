{"title":"สิ่งที่น่าสนใจจากเรื่อง Goodbye Microservices จาก 100+ เหลือ 1 service","link":"https://www.somkiat.cc/note-goodbye-microservices/","date":1747051962000,"content":"<p><img width=\"150\" height=\"150\" src=\"https://www.somkiat.cc/wp-content/uploads/2025/05/architecture-v-1-150x150.png\" alt=\"\" loading=\"lazy\" srcset=\"https://www.somkiat.cc/wp-content/uploads/2025/05/architecture-v-1-150x150.png 150w, https://www.somkiat.cc/wp-content/uploads/2025/05/architecture-v-1-75x75.png 75w\" /></p>\n<p>จากการอ่านการสรุปเรื่อง <strong><a href=\"https://web.facebook.com/photo/?fbid=708571645011487&amp;set=a.181398527728804\" target=\"_blank\">สิ่งที่น่าสนใจจากเรื่อง Goodbye Microservices จาก 100+ เหลือ 1 service</a></strong><br />มีหลายสิ่งอย่างที่น่าสนใจเกี่ยวกับการตัดสินใจ<br />ในการเลือกวิธีการแก้ไขปัญหา<br />ว่าเข้าใชเหตุผลอะไรในการตัดสินใจ<br />ซึ่งแต่ที่ละการตัดสินใจ มันมีปัจจัยเยอะมาก ๆ (needs and constraints)<br />ทำให้วิธีการเดียวกัน เอาไปใช้แบบ copy-and-paste ไม่ได้<br />กับอีกปัญหาหนึ่งของอีกทีมหรืออีกบริษัท<br />ดังนั้นถ้าเราเจอปัญหาลักษณะนี้ เราจะตัดสินใจอย่างไรกันบ้าง ?<br />ตรงนี้สำคัญกว่ามาก ๆ</p>\n\n\n\n<span></span>\n\n\n\n<p><strong>เริ่มต้นของทุกระบบคือ Simple architecture</strong></p>\n\n\n\n<p>ในการจะ integrate กับระบบต่าง ๆ  <br />คงไม่อยากให้ระบบของเราผูกมัดกับระบบข้างนอก หรือ 3-party มากนัก (loose coupling)<br />จึงมักจะมีการนำ queue/worker มาใช้งานเสมอ<br />โดยมีทั้งฝั่งขาเข้า และ ขาออก ด้วย<br />แสดงขาออกดังรูป</p>\n\n\n\n<figure><a href=\"https://www.somkiat.cc/wp-content/uploads/2025/05/architecture-v-1-1.png\"><img src=\"https://www.somkiat.cc/wp-content/uploads/2025/05/architecture-v-1-1.png\" alt=\"\" width=\"582\" height=\"301\" /></a></figure>\n\n\n\n<p>ซึ่งช่วยลดปัญหาเรื่องของการผูกมัดลงไป<br />แต่ปัญหาต่อมาคือ การรวมศูนย์ของการทำงานของ Destination worker<br />ต้องส่งข้อมูลไปยังปลายทางหลายที่ แถมเรียงลำดับกันอีก !!<br />โดยแต่ละที่มีปัญหาที่แตกต่างกันไป ทำให้ส่งไม่ได้<br />จึงต้องแก้ไขด้วยการ retry ของ message หรือ event นั้นใหม่ (retry events)<br />แถมจากข้อมูลพบว่า การ retry message/event มากกว่า ข้อมูลที่ส่งได้อีก !!</p>\n\n\n\n<p>ในการโครงสร้างแบบนี้<br />ถ้ามีการทำงานที่ช้าใน event/message หนึ่ง ๆ แล้วจะส่งผลแบบลูกโซ่นั่นเอง<br />ถึงแม้ว่าจะ scale worker แล้ว <br />ก็ไม่ได้ช่วยให้รองรับได้มากเท่าไร และไม่ตอบโจทย์</p>\n\n\n\n<p><strong>มาถึงตรงนี้น่าสนใจมาก ๆ   ถ้าเป็นเราเอง จะเลือกแนวทางการแก้ไขปัญหาอย่างไร ?</strong></p>\n\n\n\n<p>เป็น <a href=\"https://www.architecturalkatas.com/\" target=\"_blank\">Architectural Kata</a> ที่น่าสนใจ =&gt; <a href=\"https://www.oreilly.com/content/how-to-set-up-and-run-your-own-architectural-katas/\" target=\"_blank\">How to set up and run your own Architectural Katas</a><br />ว่าเราจะคิด หรือ เลือกวิธีการใดบ้าง มาแก้ไขปัญหานี้<br />เช่น</p>\n\n\n\n<ul>\n<li>เปลี่ยนการทำงานของ worker ไป จาก sequeucial ไปเป็น parallel</li>\n\n\n\n<li>แยก worker ตาม target หรือ destination ไปเลย</li>\n\n\n\n<li>แยก queue ตามแต่ละ target หรือ destination</li>\n\n\n\n<li>แยก process ของการ retry ไปอีก queue หรือ อีก worker</li>\n</ul>\n\n\n\n<p>จะสังเกตได้ว่า เราสามารถคิดได้หลายแนวทางมาก ๆ<br />แต่นี่เป็นเพียงของคนภายนอก<br />ที่ไม่ได้มีความรู้และเข้าใจในราายละเอียด ในข้อจำกัด และ สภาพของทีม<br />รวมทั้งความรู้และประสบการณ์ ทั้งดีและไม่ดี<br />ซึ่งมีส่วนต่อการตัดสินใจทั้งหมด</p>\n\n\n\n<p><strong>จากบทความต้นทาง ทีมพัฒนาเลือกตาม business condition</strong></p>\n\n\n\n<p>คือต้องส่งข้อมูลไปยังปลายทางให้เร็วที่สุด หรือ near-realtime กันเลย<br />ดังนั้นการรอ หรือ ช้า เป็นสิ่งที่ยอมรับไม่ได้<br />ดังนั้นแนวทางที่เลือกสำหรับการแก้ไขปัญหาคอขวดคือ</p>\n\n\n\n<ul>\n<li>แยก queue ตาม target หรือ destination</li>\n\n\n\n<li>แยก worker ตาม queue</li>\n\n\n\n<li>สร้าง router มาเพิ่ม เพื่อแยกว่าจะส่ง request ไปยัง queue อะไรบ้าง (1-to-many)</li>\n</ul>\n\n\n\n<p>แสดงดังรูป</p>\n\n\n\n<figure><a href=\"https://www.somkiat.cc/wp-content/uploads/2025/05/architecture-v-2.jpg\"><img src=\"https://www.somkiat.cc/wp-content/uploads/2025/05/architecture-v-2.jpg\" alt=\"\" width=\"535\" height=\"287\" /></a></figure>\n\n\n\n<p>ทำการเพิ่มมาอีก 1 process หรือ อีก 1 hop ก็ว่ากันไป<br />ผลที่ได้คือ แยกการส่งของแต่ละ target หรือ destination <br />ทำให้ปัญหาที่เกิดขึ้นจาก target หรือ destination  หนึ่ง จะไม่กระทบส่วนอื่น ๆ  แล้ว</p>\n\n\n\n<p>มาถึงตรงนี้น่าจะคุ้น ๆ  ว่ามันคือ Pub/Sub pattern นั่นเอง</p>\n\n\n\n<p><strong>ปัญหาต่อมาที่เจอคือ Destination นั้นมีรูปแบบของ request ที่ส่งไปแตกต่างกันมาก</strong></p>\n\n\n\n<p>เนื่องจาก destination เริ่มมากขึ้น จาก 3 ไปเป็น 50 !!<br />ความหลากกลายของการ integrate หรือติดต่อสื่อสารมากขึ้น<br />ดังนั้นจาก code เดิมคือ worker ที่มี single repository<br />สำหรับทำการแปลง request ไปยังรูปแบบของแต่ละ Destination<br />ส่งผลให้เมื่อทำการแก้ไขแล้ว กระทบส่วนอื่น ๆ อีก (Side-effect from change)<br />ยิ่งกว่านั้น test ตรงหนึ่งพัง พังกันไปหมดเลย !!<br />เปลี่ยนเรื่องหนึ่ง ๆ ไม่น่าจะกระทบที่อื่นหรือไม่ ?<br />เป็นปัญหาลูกโซ่อีกแล้ว</p>\n\n\n\n<p><strong>มาถึงตรงนี้น่าสนใจอีกแล้ว   ถ้าเป็นเราเอง จะเลือกแนวทางการแก้ไขปัญหาอย่างไร ?</strong></p>\n\n\n\n<p>ปัญหาที่เกิดจากการเปลี่ยนแปลงทั้งการทำงานหลัก และ การทดสอบ<br />เราจะเลือกวิธีการแก้ไขอย่างไรบ้าง ? เช่น</p>\n\n\n\n<ul>\n<li>ทำการ test เพิ่ม ทั้ง manual และ automated เพื่อสร้างความมั่นใจให้กับระบบ</li>\n\n\n\n<li>จัดการ code ให้เป็น monular ที่ดี ไม่ให้เรียกใช้งานแบบจ้ามไปข้ามมา เพื่อลดผลกระทบ</li>\n\n\n\n<li>แยก repo ของแต่ละ Destination ไปเลย</li>\n\n\n\n<li>แยก repo และ service กันไปเลย</li>\n</ul>\n\n\n\n<p><strong>จากบทความต้นทาง ทีมพัฒนาเลือกแยก repo ตาม Destination</strong> (1 repo == 1 service)</p>\n\n\n\n<p>ช่วยแก้ไขปัญหาผลกระทบการแก้ไข code ของแต่ละ Destination<br />ช่วยให้ทีมพัฒนาและทดสอบได้ง่ายและสะดวกขึ้นมาก</p>\n\n\n\n<p><strong>แต่ผลที่ตามมาคือ จำนวน repo มากขึ้น</strong><br />จาก 1 repo มาเป็น 50 repo<br />ซึ่งแน่นอนว่ามี code ที่ให้งานร่วมกันแน่นอน<br />จึงสร้าง shared library ขึ้นมา เพื่อให้ทุก repo นำไปใช้งาน (re-use)<br />และทำให้สร้าง destination ใหม่ ง่ายและเร็วขึ้นอย่างมาก (improve development productivity)</p>\n\n\n\n<p><strong>จาก shared library นี่เอง ก่อนให้เกิดปัญหา คือ</strong><br />ถ้าทำการเปลี่ยนแปลงแล้ว<br />จะกระทบกับทุก ๆ  service หรือ repo ทันที !!<br />ซึ่งใช้เวลาและคนเยอะมาก ๆ ในการแก้ไขกระทบ<br />ทั้ง code และ test<br />รวมทั้งต้อง re-deploy ทุก ๆ service หรือส่วนที่เกี่ยวข้องใหม่ทั้งหมด</p>\n\n\n\n<p>หนักกว่านั้น มีการกำหนด version ของ shared library ที่ใช้งานด้วย<br />พบว่าแต่ละ service/repo ใช้ต่าง version กันอีก<br />ทั้ง ๆ ที่ใช้ destination เดียวกัน !!</p>\n\n\n\n<p><strong>ยังไม่พอ ในการ scaling service ก็มีปัญหา</strong><br />เนื่องจากแต่ละ service มีรูปแบบของ load ที่ต่างกัน<br />ต้องจัดการอย่างเหมาะสม ตาม CPU และ Memory usage<br />โดยมีส่วนของ Auto-scaling มาดูแลส่วนนี้</p>\n\n\n\n<p><strong>เมื่อเวลาผ่านไป พบว่าเมื่อมี destination เพิ่มเข้ามาเรื่อย ๆ อย่างต่อเนื่อง ปัญหาก็มากขึ้น</strong></p>\n\n\n\n<p>ทั้งจำนวน repo<br />ทั้งจำนวน service<br />ทั้งจำนวน queue<br />ทั้ง operation ต่าง ๆ</p>\n\n\n\n<p>จึงเป็นเหตุผลว่า กลับมารวมกันเป็น Single repo หรือ Monolith กันดีกว่านั่นเอง<br />แต่ไม่ได้รวม code ตรง ๆ นะ ใช้ Monorepo<br />และได้ตกลงกันว่า shared library หรือ dependency ที่มีอยู่<br />จะใช้ version เดียวกันในทุก ๆ  destination</p>\n\n\n\n<p><strong>ในส่วนของการทดสอบก็ปรับปรุงเช่นกัน</strong><br />แยกออกไปตาม destination ไม่ให้กระทบกัน<br />มีการ record request ที่ส่งไปยัง destination เอาไว้<br />เพื่อใช้ในการทดสอบ ช่วยลดเวลาการทดสอบไปได้เยอะมาก<br />เครื่องมือที่ใช้คือ <a href=\"https://github.com/flickr/yakbak\" target=\"_blank\">yakbak</a><br />และ request-response เหล่านี้จะถูกบันทึก และ checkin ไว้ใน repo เสมอ</p>\n\n\n\n<p><strong>ในส่วนของ Queue ก็ไม่ได้เอาทิ้งไป</strong><br />แต่ได้สร้างเป็น single service สำหรับจัดการเรื่องของ queue แทน<br />ช่วยลดปัญหาต่าง ๆ ลงไป</p>\n\n\n\n<figure><a href=\"https://www.somkiat.cc/wp-content/uploads/2025/05/architecture-v-3.png\"><img src=\"https://www.somkiat.cc/wp-content/uploads/2025/05/architecture-v-3-1024x259.png\" alt=\"\" width=\"490\" height=\"124\" /></a></figure>\n\n\n\n<p></p>\n\n\n\n<p><strong><em>อ่านมาถึงตรงนี้ก็แปลกใจว่า ทำไมเพิ่งมาตกลงและปรับปรุงกัน !!<br />มันคือประสบการณ์ล้วน ๆ<br />แต่อย่างที่บอก เราไม่มีรายละเอียดอะไรเลย<br />อ่านและศึกษา เรียนรู้จากความผิดพลาด</em></strong></p>\n\n\n\n<p>ลองดูว่า ถ้าเราอยู่ในสถานการณ์ หรือ ปัญหารูปแบบนี้<br />แล้วใช้เงื่อนไข หรือ ข้อจำกัดขององค์กรของเรา<br />เราจะตัดสินใจกันอย่างไร ?</p>\n\n\n\n<p>สุดท้าย ทุก ๆ การตัดสินใจ อย่าลืมเขียน <strong><a href=\"https://adr.github.io/\" target=\"_blank\">Architectual Decision Record</a></strong> ไว้ด้วยเสมอ</p>\n\n\n\n<p><strong>Reference Websites</strong></p>\n\n\n\n<ul>\n<li><a href=\"https://segment.com/blog/goodbye-microservices/#ditchingmicroservicesandqueues\" target=\"_blank\">Goodbye Microservices: From 100s of problem children to 1 superstar</a></li>\n</ul>\n","author":"somkiat","siteTitle":"cc :: somkiat","siteHash":"3a23a5a4389e1e40c6fbb16520a8cc20df5b3591c25145ce72aaa18b19e48201","entryHash":"94c699a7e341168876775bf7c936f3d92db771262aa90c916dc2688c1cdf3627","category":"Thai"}