{"title":"Using SWR React Hooks With Next.js’ Incremental Static Regeneration (ISR)","link":"https://smashingmagazine.com/2021/09/useswr-react-hook-library-incremental-static-regeneration-nextjs/","date":1631183400000,"content":"<p>If you’ve ever used <a href=\"https://www.smashingmagazine.com/2021/04/incremental-static-regeneration-nextjs/\">Incremental Static Regeneration (ISR) with Next.js</a>, you may have found yourself sending stale data to the client. This occurs when you are revalidating the page on the server. For some websites this works, but for others (such as <a href=\"https://scrapbook.hackclub.com\">Hack Club’s Scrapbook</a>, a site built by <a href=\"https://github.com/lachlanjc\">@lachlanjc</a> that I help maintain), the user expects the data to be kept up to date. </p>\n<p>The first solution that comes to mind may be to simply server side render the pages, ensuring that the client is always sent the most up to date data. However, fetching large chunks of data before rendering can slow down the initial page load. The solution used in Scrapbook was to use the SWR library of React hooks to <strong>update the cached page from the server with client side data fetching</strong>. This approach ensures that users still have a good experience, that the site is fast and that the data is kept up to date.</p>\nMeet SWR\n<p>SWR is a React Hooks library built by Vercel, the name comes from the term <a href=\"https://tools.ietf.org/html/rfc5861\">stale-while-revalidate</a>. As the name suggests, your client will be served stale/old data whilst the most up to date data is being fetched (revalidating) through SWR on the client side. SWR does not just revalidate the data once, however, you can configure SWR to revalidate the data on an interval, when the tab regains focus, when a client reconnects to the Internet or programmatically.</p>\n<p>When paired with ISR and Next.js’ API routes, SWR can be used to create a <strong>responsive user experience</strong>. The client is first served the cached statically generated page (generated with <code>getStaticProps()</code>), in the background the server also begins the process of revalidating that page (read more <a href=\"https://www.smashingmagazine.com/2021/04/incremental-static-regeneration-nextjs/#fetching-data\">here</a>). This process feels fast for the client and they can now see the set of data, however it may be a touch out of date. Once the page is loaded, a fetch request is made to an Next.js API route of your’s which returns the same data as what was generated with <code>getStaticProps()</code>. When this request is completed (assuming it was successful), SWR will update the page with this new data. </p>\n<p>Let’s now look back at Scrapbook and <strong>how this helped solve the problem of having stale data on the page</strong>. The obvious thing is that now, the client gets an updated version. The more interesting thing, however, is the impact on the speed of our side. When we measure speed through Lighthouse, we get a speed index of <strong>1.5 seconds</strong> for the ISR + SWR variant of the site and <strong>5.8 seconds</strong> for the Server Side Rendering variant (plus a warning regarding initial server response time). That’s a pretty stark contrast between the two (and it was noticeable when loading the pages up as well). But there is also a tradeoff, on the Server Side Rendered page the user didn’t have the layout of the site change after a couple of seconds with new data coming in. Whilst I believe Scrapbook handles this update well, it’s an important consideration when designing your user’s experience.</p>\nWhere To Use SWR (And Where Not To)\n<p>SWR can be put in place in a variety of places, here are a couple of site categories where SWR would make a great fit:</p>\n<ul>\n<li><strong>Sites with live data that require updating at a rapid pace.</strong><br />Examples of such sites would be sports score sites and flight tracking. When building these sites, you’d look to use the revalidate on interval option with a low interval setting (one to five seconds). </li>\n<li><strong>Sites with a feed style of updates or posts that update in realtime.</strong><br />The classic example of this would be the news sites which have live blogs of events such as elections. Another example would be the aforementioned Scrapbook as well. In this case, you’d also likely want to use the revalidate on interval option but with a higher interval setting (thirty to sixty seconds) to save on data usage and prevent unnecessary API calls.</li>\n<li><strong>Sites with more passive data updates, that people keep open in the background a lot.</strong><br />Examples of these sites would be weather pages or in the 2020s COVID-19 case number pages. These pages don’t update as frequently and therefore don’t need the constant revalidation of the previous two examples. However, it would still enhance the user experience for the data to update. In these cases, I would recommend revalidating the date when the tab regains focus and when a client reconnects to the internet, that’ll mean if a person anxiously returns to the tap hoping there has only been a small increase in COVID cases they’ll get that data quickly.</li>\n<li><strong>Sites with small pieces of data that users can interact with.</strong><br />Think the Youtube Subscribe Button, when you click subscribe you want to see that count change and feel like you’ve made a difference. In these cases, you can revalidate the data programmatically using SWR to fetch the new count and update the displayed amount.</li>\n</ul>\n<p>One thing to note, is that these can all be applied with or without ISR.</p>\n<p>There are of course some places where you won’t want to use SWR or to use SWR without ISR. SWR isn’t much use if your data isn’t changing or changes very rarely and instead can clog up your network requests and use up mobile user’s data. SWR can work with pages requiring authentication, however you will want to use Server Side Rendering in these cases and not Incremental Static Regeneration.</p>\nUsing SWR With Next.js And Incremental Static Regeneration\n<p>Now we’ve explored the theory of this strategy, let’s explore how we put it into practise. For this we’re going to build a website that shows how many taxis are available in Singapore (where I live!) using <a href=\"https://data.gov.sg/dataset/taxi-availability\">this API</a> provided by the government.</p>\n<h3>Project Structure</h3>\n<p>Our project will work by having three files:</p>\n<ul>\n<li><code>lib/helpers.js</code></li>\n<li><code>pages/index.js</code> (our frontend file)</li>\n<li><code>pages/api/index.js</code> (our API file)</li>\n</ul>\n<p>Our helpers file will export a function (<code>getTaxiData</code>) that will fetch the data from the external API, and then return it in an appropriate format for our use. Our API file will import that function and will set it’s default export to a handler function that will call the <code>getTaxiData</code> function and then return it, this will mean sending a GET request to <code>/api</code> will return our data.</p>\n<p>We’ll need this ability for SWR to do client-side data fetching. Lastly, in our frontend file we’ll import <code>getTaxiData</code> and use it in <code>getStaticProps</code>, it’s data will be passed to the default export function of our frontend file which will render our React page. We do this all to prevent code duplication and ensure consistency in our data. What a mouthful, let’s get started on the programming now.</p>\n<h3>The Helpers File</h3>\n<p>We’ll begin by creating the <code>getTaxiData</code> function in <code>lib/helpers.js</code>:</p>\n<pre><code>export async function getTaxiData(){\n    let data = await fetch(\"https://api.data.gov.sg/v1/transport/taxi-availability\").then(r =&gt; r.json())\n    return {taxis: data.features.properties[0].taxi_count, updatedAt: data.features.properties[0].timestamp}\n}</code></pre>\n\n<h3>The API File</h3>\n<p>We’ll then build the handler function in <code>api/index.js</code> as well as importing the <code>getTaxiData</code> function:</p>\n<pre><code>import { getTaxiData } from '../../lib/helpers'\nexport default async function handler(req, res){\n    res.status(200).json(await getTaxiData())\n}</code></pre>\n\n<p>There isn’t anything here unique to SWR or ISR, besides the aforementioned project structure. That stuff starts now in <code>index.js</code>!</p>\n<h3>The Front-End File</h3>\n<p>The first thing we want to do is create our <code>getStaticProps</code> function! This function will import our <code>getTaxiData</code> function, use it and then return the data with some additional configuration.</p>\n<pre><code>export async function getStaticProps(){\n    const { getTaxiData } = require(\"../lib/helpers\")\n    return { props: (await getTaxiData()), revalidate: 1 }\n}</code></pre>\n\n<p>I’d like to focus on the revalidate key in our returned object. This key practically enables Incremental Static Regeneration. It tells your host that every one second regenerating the static page is an available option, that option is then triggered in the background when a client visits your page. You can read more about <a href=\"https://www.smashingmagazine.com/2021/04/incremental-static-regeneration-nextjs/\">Incremental Static Regeneration (ISR) here</a>.</p>\n<p>It’s now time to use SWR! Let’s import it first:</p>\n<pre><code>import  useSWR from 'swr'</code></pre>\n\n<p>We’re going to be using SWR in our React-rendering function, so let’s create that function:</p>\n<pre><code>export default function App(props){\n}</code></pre>\n\n<p>We’re receiving the props from <code>getStaticProps</code>. Now we’re ready to set up SWR:</p>\n<pre><code>const fetcher = (...args) =&gt; fetch(...args).then(res =&gt; res.json())\nconst { data } = useSWR(\"/api\", fetcher, {initialData: props, refreshInterval: 30000})</code></pre>\n\n<p>Let’s break this down. Firstly, we define the fetcher. This is required by SWR as an argument so that it knows how to fetch your data given that different frameworks etc. can have different set ups. In this case, I’m using the function provided on the SWR docs page. Then we call the <code>useSWR</code> hook, with three arguments: the path to fetch data from, the fetcher function and then an options object.</p>\n<p>In that <code>options</code> object, we’ve specified two things:</p>\n<ul>\n<li>the initial data</li>\n<li>the interval at which SWR should revalidate the data</li>\n</ul>\n<p>The initial data option is where we provide the data fetched from <code>getStaticProps</code> which ensures that data is visible from the start. Lastly, we use object destructuring to extract the data from the hook.</p>\n<p>To finish up, we’ll render that data with some very basic JSX:</p>\n<pre><code>return &lt;div&gt;As of {data.updatedAt}, there are {data.taxis} taxis available in Singapore!&lt;/div&gt;</code></pre>\n\n<p>And, we’ve done it! There we have a very barebones example of using SWR with Incremental Static Regeneration. (The source of our example is available <a href=\"https://github.com/sampoder/nextjs-isr-swr-example\">here</a>.)</p>\n<p>If you ever run into stale data with ISR, you know who to call: SWR.</p>\n<h4>Further Reading on SmashingMag</h4>\n<ul>\n<li><a href=\"https://www.smashingmagazine.com/2020/06/introduction-swr-react-hooks-remote-data-fetching/\">An Introduction To SWR: React Hooks For Remote Data Fetching</a>, Ibrahima Ndaw</li>\n<li><a href=\"https://www.smashingmagazine.com/2021/07/isr-dpr-explained/\">ISR vs DPR: Big Words, Quick Explanation</a>, Cassidy Williams</li>\n<li><a href=\"https://www.smashingmagazine.com/2021/07/global-local-styling-nextjs/\">Global vs. Local Styling In Next.js</a>, Alexander Dubovoj</li>\n<li><a href=\"https://www.smashingmagazine.com/2021/06/client-side-routing-next-js/\">Client-Side Routing In Next.js</a>, Adebiyi Adedotun Lukman</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"29bc8f5d3a1aa4b6f6963c79feb7a49978c491a4b3a7499e7137db219965db70","category":"Tech"}