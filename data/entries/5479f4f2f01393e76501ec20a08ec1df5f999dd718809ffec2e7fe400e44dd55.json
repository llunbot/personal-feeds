{"title":"Nomad JWT auth with GitHub Actions","link":"https://www.hashicorp.com/blog/nomad-jwt-auth-with-github-actions","date":1704906000000,"content":"<p>HashiCorp Nomad supports <a href=\"https://developer.hashicorp.com/nomad/api-docs/acl/auth-methods\">JWT authentication methods</a>, which allow users to authenticate into Nomad using tokens that can be verified via public keys. Primarily, JWT auth methods are used for machine-to-machine authentication, while <a href=\"https://developer.hashicorp.com/nomad/tutorials/single-sign-on\">OIDC auth methods</a> are used for human-to-machine authentication.</p>\n\n<p>This post explains how JWT authentication works and how to set it up in Nomad using a custom <a href=\"https://github.com/features/actions\">GitHub Action</a>. The GitHub Action will use built-in <a href=\"https://docs.github.com/en/actions/security-guides/automatic-token-authentication\">GitHub identity tokens</a> to obtain a short-lived Nomad token with limited permissions.</p>\n\n<h2>How JWT-based authentication works</h2>\n\n<p>The first step in JWT-based authentication is the <a href=\"https://jwt.io/introduction\">JSON Web Token (JWT)</a> itself. JWTs are encoded pieces of JSON that contain information about the identity of some workload or machine. JWT is a generic format, but for authentication, JWTs will sometimes conform to the more specific OIDC spec and include keys such as  “sub”, “iss”, or “aud”.</p>\n\n<p>This <a href=\"https://gist.github.com/mikenomitch/7e73eb63effd4c9a716db5a9ce7dfa9a\">example JWT</a> decodes to the following JSON:</p>\n<pre><code>{\n  \"jti\": \"eba60bec-a4e4-4787-9b16-20bed89d7092\",\n  \"sub\": \"repo:mikenomitch/nomad-gha-jwt-auth:ref:refs/heads/main:repository_owner:mikenomitch:job_workflow_ref:mikenomitch/nomad-gha-jwt-auth/.github/workflows/github-actions-demo.yml@refs/heads/main:repository_id:621402301\",\n  \"aud\": \"https://github.com/mikenomitch\",\n  \"ref\": \"refs/heads/main\",\n  \"sha\": \"1b568a7f1149e0699cbb89bd3e3ba040e26e5c0b\",\n  \"repository\": \"mikenomitch/nomad-gha-jwt-auth\",\n  \"repository_owner\": \"mikenomitch\",\n  \"repository_owner_id\": \"2732204\",\n  \"run_id\": \"5173139311\",\n  \"run_number\": \"31\",\n  \"run_attempt\": \"1\",\n  \"repository_visibility\": \"public\",\n  \"repository_id\": \"621402301\",\n  \"actor_id\": \"2732204\",\n  \"actor\": \"mikenomitch\",\n  \"workflow\": \"Nomad GHA Demo\",\n  \"head_ref\": \"\",\n  \"base_ref\": \"\",\n  \"event_name\": \"push\",\n  \"ref_type\": \"branch\",\n  \"workflow_ref\": \"mikenomitch/nomad-gha-jwt-auth/.github/workflows/github-actions-demo.yml@refs/heads/main\",\n  \"workflow_sha\": \"1b568a7f1149e0699cbb89bd3e3ba040e26e5c0b\",\n  \"job_workflow_ref\": \"mikenomitch/nomad-gha-jwt-auth/.github/workflows/github-actions-demo.yml@refs/heads/main\",\n  \"job_workflow_sha\": \"1b568a7f1149e0699cbb89bd3e3ba040e26e5c0b\",\n  \"runner_environment\": \"github-hosted\",\n  \"iss\": \"https://token.actions.githubusercontent.com\",\n  \"nbf\": 1685937407,\n  \"exp\": 1685938307,\n  \"iat\": 1685938007\n}</code></pre><p>(Note: If you ever want to decode or encode a JWT, <a href=\"jwt.io\">jwt.io</a> is a good tool.)</p>\n\n<p>This specific JWT contains information about a GitHub workflow, including an owner, a GitHub Action name, a repository, and a branch. That is because it was issued by GitHub and is an identity token, meaning it is supposed to be used to verify the identity of this workload. Each run in a GitHub Action can be provisioned with one of these JWTs. (More on how they can be used later in this blog post.)</p>\n\n<p>Importantly, aside from the information in the JSON, JWTs can be signed with a private key and verified with a public key. It is worth noting that while they are signed, their contents are still decodable by anybody, just not verified.</p>\n\n<p>The public keys for JWTs can sometimes be found at idiomatically well-known URLs, such as <a href=\"https://openid.net/specs/draft-jones-json-web-key-03.html\">JSON Web Key Sets (JWKs)</a> URLs. For example, these <a href=\"https://token.actions.githubusercontent.com/.well-known/jwks\">GitHub public keys</a> can be used to verify their identity tokens.</p>\n\n<h2>JWT authentication in Nomad</h2>\n\n<p>Nomad can use external JWT identity tokens to issue its own Nomad ACL tokens with the JWT auth method. In order to set this up, Nomad needs:</p>\n\n<ul>\n<li><a href=\"https://developer.hashicorp.com/nomad/api-docs/acl/roles\">Roles</a> and/or <a href=\"https://developer.hashicorp.com/nomad/api-docs/acl/policies\">policies</a> that define access based on identity</li>\n<li>An <a href=\"https://developer.hashicorp.com/nomad/api-docs/acl/auth-methods\">auth method</a> that tells Nomad to trust JWTs from a specific source</li>\n<li>A <a href=\"https://developer.hashicorp.com/nomad/api-docs/acl/binding-rules\">binding rule</a> that tells Nomad how to map information from that source into Nomad concepts, like <em>roles</em> and policies</li>\n</ul>\n<img src=\"https://www.datocms-assets.com/2885/1704906019-nomad-gh-actions-jwt.png\" alt=\"JWT\" /><p>Here’s how to set up an authentication in Nomad to achieve the following rule:</p>\n\n<blockquote>\n<p>I want any repo using an action called Nomad JWT Auth to get a Nomad ACL token that grants the action permissions for all the Nomad policies assigned to a specific role for their GitHub organization. Tokens should be valid for only one hour, and the action should be valid only for the main branch.</p>\n</blockquote>\n\n<p>That may seem like a lot, but with Nomad JWT authentication, it’s actually fairly simple.</p>\n\n<p>In older versions of Nomad, complex authentication like this was impossible. This forced administrators into using long-lived tokens with very high levels of permissions. If a token was leaked, admins would have to manually rotate all of their tokens stored in external stores. This made Nomad less safe and harder to manage. Now, tokens can be short-lived and after a one-time setup with identity-based rules, users don’t have to worry about managing Nomad tokens for external applications.</p>\n\n<h2>Setting up JWT authentication</h2>\n\n<p>To set up the authentication, start by <a href=\"https://developer.hashicorp.com/nomad/tutorials/access-control/access-control-create-policy\">creating a simple policy</a> that has write access to the namespace “app-dev” and another policy that has read access to the default namespace.</p>\n\n<p>Create a namespace called <em>app-dev</em>:</p>\n\n<pre><code>nomad namespace apply \"app-dev\"\n</code></pre>\n\n<p>Write a policy file called <code>app-developer.policy.hcl</code>:</p>\n<pre><code>namespace \"app-dev\" {\n  policy = \"write\"\n}\n</code></pre><p>Then create it with this CLI command:</p>\n\n<pre><code>nomad acl policy apply -description \"Access to app-dev namespace\" app-developer app-developer.policy.hcl \n</code></pre>\n\n<p>Write a policy file called <code>default-read.policy.hcl</code>:</p>\n<pre><code>namespace \"default\" {\n  policy = \"read\"\n}</code></pre><p>Then create it in the CLI:</p>\n\n<pre><code>nomad acl policy apply -description \"Read access to default namespace\" default-read default-read.policy.hcl \n</code></pre>\n\n<p>Next, <a href=\"https://developer.hashicorp.com/nomad/docs/commands/acl/role/create\">create roles</a> that have access to this policy. Often these roles are team-based, such as “engineering” or “ops”, but in this case, create a role with the name of “org-” then our Github organization’s name: mikenomitch. Repositories in this organization should be able to deploy to the “app-dev” namespace, and we should be able to set up a GitHub Action to deploy them on merge. </p>\n\n<p>Give this role access to the two new policies:</p>\n\n<pre><code>nomad acl role create -name=\"org-mikenomitch\" -policy=app-developer -policy=default-read\n</code></pre>\n\n<p>Now, create a file defining an auth method for GitHub in <code>auth-method.json</code>:</p>\n<pre><code>{\n  \"JWKSURL\": \"https://token.actions.githubusercontent.com/.well-known/jwks\",\n  \"ExpirationLeeway\": \"1h\",\n  \"ClockSkewLeeway\": \"1h\",\n  \"ClaimMappings\": {\n\t\"repository_owner\": \"repo_owner\",\n\t\"repository_id\": \"repo_id\",\n\t\"workflow\": \"workflow\",\n\t\"ref\": \"ref\"\n  }\n}</code></pre><p>Then create it with the CLI:</p>\n\n<pre><code>nomad acl auth-method create -name=\"github\" -type=\"JWT\" -max-token-ttl=\"1h\" -token-locality=global -config \"@auth-method.json\"\n</code></pre>\n\n<p>This tells Nomad to expect JWTs from GitHub, to verify them using the public key in JWKSURL, and to map key-value pairs found in the JWT to new names. This allows binding rules to be created using these values. A binding rule sets up the complex auth logic requirements stated in a block quote earlier in this post:</p>\n<pre><code>nomad acl binding-rule create \\\n  -description 'repo name mapped to role name, on main branch, for “Nomad JWT Auth workflow\"' \\\n  -auth-method 'github' \\\n  -bind-type 'role' \\\n  -bind-name 'org-${value.repo_owner}' \\\n  -selector 'value.workflow == \"Nomad JWT Auth\" and value.ref == \"refs/heads/main\"'</code></pre><p>The <code>selector</code> field tells Nomad to match JWTs only with certain values in the <code>ref</code>, and <code>workflow</code> fields. The <code>bind-type</code> and <code>bind-name</code> fields tell Nomad to allow JWTs that match this selector to be matched to specific roles. In this case, they refer to roles that have a name matching the GitHub organization name. If you wanted more granular permissions, you could match role names to repository IDs using the repo_id field.</p>\n\n<p>So, the JWTs for repositories in the <em>mikenomitch</em> organization are given an ACL token with the role <em>org-mikenomitch</em>, which in turn grants access to the <em>app-developer</em> and <em>default-read</em> policies.</p>\n\n<h2>Nomad auth with a custom GitHub Action</h2>\n\n<p>Now you’re ready to use a <a href=\"https://github.com/mikenomitch/nomad-jwt-auth/\">custom GitHub Action</a> to authenticate into Nomad. This will expose a short-lived Nomad token as an output, which can be used by another action that uses simple bash to deploy any files in the <code>./nomad-jobs</code>directory to Nomad.</p>\n\n<p>The code for this action is very simple, it just calls Nomad’s <code>/v1/acl/login</code> endpoint specifying the GitHub auth method and passes in the GitHub Action’s JWT as the login token. (<a href=\"https://github.com/mikenomitch/nomad-jwt-auth/blob/v0.1.0/src/main.ts#L16\">See the code</a>.)</p>\n\n<p>To use this action, just push to GitHub with the following file at <code>.github/workflows/github-actions-demo.yml</code></p>\n<pre><code>name: Nomad JWT Auth\n\non:\n  push:\n\tbranches:\n  \t- main\n  \t- master\n\nenv:\n  PRODUCT_VERSION: \"1.7.2\"\n  NOMAD_ADDR: \"https://my-nomad-addr:4646\"\n\njobs:\n  Nomad-JWT-Auth:\n\truns-on: ubuntu-latest\n\tpermissions:\n  \tid-token: write\n  \tcontents: read\n\tsteps:\n  \t- name: Checkout\n    \tuses: actions/checkout@v3\n  \t- name: Setup `nomad`\n    \tuses: lucasmelin/setup-nomad@v1\n    \tid: setup\n    \twith:\n      \t    version: ${{ env.PRODUCT_VERSION }}\n  \t- name: Auth Into Nomad\n    \tid: nomad-jwt-auth\n    \tuses: mikenomitch/nomad-jwt-auth@v0.1.0\n    \twith:\n      \t    url: ${{ env.NOMAD_ADDR }}\n      \t    caCertificate: ${{ secrets.NOMAD_CA_CERT }}\n    \tcontinue-on-error: true\n  \t- name: Deploy Jobs\n    \trun: for file in ./nomad-jobs/*; do NOMAD_ADDR=\"${{ env.NOMAD_ADDR }}\" NOMAD_TOKEN=\"${{ steps.nomad-jwt-auth.outputs.nomadToken }}\" nomad run -detach \"$file\"; done</code></pre><p>Now you have a simple CI/CD flow on GitHub Actions set up. This does not require manually managing tokens and is secured via identity-based rules and auto-expiring tokens.</p>\n\n<h2>Possibilities for JWT authentication in Nomad</h2>\n\n<p>With the JWT auth method, you can enable efficient workflows for tools like GitHub Actions, simplifying management of Nomad tokens for external applications. </p>\n\n<p>Machine-to-machine authentication is an important function in cloud infrastructure, yet implementing it correctly requires understanding several standards and protocols. Nomad’s introduction of JWT authentication methods provides the necessary building blocks to make setting up machine-to-machine auth simple. This auth method extends the authentication methods made available in Nomad 1.5, which introduced <a href=\"https://developer.hashicorp.com/nomad/tutorials/single-sign-on/sso-oidc-vault\">SSO and OIDC support</a>. As organizations move towards <a href=\"https://www.hashicorp.com/solutions/zero-trust-security\">zero trust security</a>, Nomad users now have more choices when implementing access to their critical infrastructure. </p>\n\n<p>To learn more about how HashiCorp provides a solid foundation for companies to safely migrate and secure their infrastructure, applications, and data as they move to a multi-cloud world, visit our <a href=\"https://www.hashicorp.com/solutions/zero-trust-security\">zero trust security</a> page.</p>\n\n<p>To try the feature described in this post, download the latest version of <a href=\"https://developer.hashicorp.com/nomad/downloads?_gl=1*1d23tgm*_ga*MTk0MDkyODQxNS4xNjgzODE1OTg0*_ga_P7S46ZYEKW*MTY4ODQxNjAxMS41My4xLjE2ODg0MTk0ODUuMTEuMC4w\">HashiCorp Nomad</a>.</p>\n","author":"Mike Nomitch","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"5479f4f2f01393e76501ec20a08ec1df5f999dd718809ffec2e7fe400e44dd55","category":"Tech"}