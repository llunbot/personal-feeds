{"title":"Deploy Consul cluster peering locally with Minikube","link":"https://www.hashicorp.com/blog/deploy-consul-cluster-peering-locally-with-minikube","date":1688572800000,"content":"<p>As you scale Kubernetes, you will often find yourself with multiple clusters running different services. <a href=\"https://developer.hashicorp.com/consul/docs/k8s/connect\">HashiCorp Consul’s service mesh on Kubernetes</a> helps register and manage requests between services from a single point of control. But how do you manage traffic between services across multiple Consul datacenters on different Kubernetes clusters? <a href=\"https://developer.hashicorp.com/consul/docs/connect/cluster-peering\">Cluster peering</a> connects Consul datacenters across multiple Kubernetes clusters using <a href=\"https://developer.hashicorp.com/consul/docs/enterprise/admin-partitions#default-admin-partition\">administrative partitions</a>, and offers one point of control to manage traffic across Kubernetes clusters.</p>\n\n<p>This post shows how to use <a href=\"https://minikube.sigs.k8s.io/docs/\">Minikube</a> to create multiple Kubernetes clusters in your local development environment to test Consul’s cluster peering and configure services across clusters. Testing locally allows you to verify configurations for services and the requests between services in Consul service mesh before applying changes to your production clusters. The post also dives into a <a href=\"https://github.com/joatmon08/consul-minikubes\">set of Bash scripts</a> to automate the creation and configuration of Kubernetes and Consul clusters that you can adapt for your own local testing environment.</p>\n\n<p>Note that your local development environment must support <a href=\"https://www.docker.com/products/docker-desktop/\">Docker</a> and offer sufficient resources to run multiple clusters. You can also use a driver that creates clusters in virtual machines. However, not all operating systems support virtual machine drivers. If you create a virtual machine with VirtualBox, you can <a href=\"https://github.com/joatmon08/consul-minikubes/blob/e57ba618e8ac73af424950aa8f9ed6c87e62c3cb/start.sh\">attach</a> a <a href=\"https://www.virtualbox.org/manual/ch06.html#network_hostonly\">host-only network</a> to each cluster and configure MetalLB to use that network.</p>\n\n<h2>Set up a Docker bridge network</h2>\n\n<p>By default, Minikube sets up each Kubernetes cluster on its own <a href=\"https://docs.docker.com/network/bridge/\">Docker bridge network</a>. This allows clusters to communicate with each other but does not reflect the scenario of external access to a Kubernetes service through a load balancer. Attach each Minikube virtual machine to a second bridge network. The load balancers run in the second network to simulate mesh gateways communicating over a public network..</p>\n\n<p>Create a network named <code>metallb</code> using Docker, with an IP address range of 172.28.0.0/16. Restrict the IP range for Minikube clusters to 172.28.0.0/24 to ensure you do not have overlapping IP addresses for each load balancer:</p>\n<pre><code>$ SUBNET=\"172.28.0.0/16\"\n$ IP_RANGE=\"172.28.0.0/24\"\n$ NETWORK_ID=$(docker network create metallb \\\n--subnet=${SUBNET} --ip-range=${IP_RANGE})</code></pre><p>Each load balancer in each cluster must have its own IP address range so they can route to each other.</p>\n\n<h2>Start Minikube with MetalLB</h2>\n\n<p>Consul’s cluster peering requires a <a href=\"https://developer.hashicorp.com/consul/docs/connect/gateways/mesh-gateway\">mesh gateway</a> to facilitate communication between datacenters on different Kubernetes clusters. The mesh gateways require a load balancer to facilitate inbound and outbound requests to services in each Kubernetes cluster. For the load balancer, this example uses <a href=\"https://metallb.universe.tf/\">MetalLB</a>, a Minikube addon, which creates a bare-metal load balancer for your cluster.</p>\n\n<p>Start Minikube with the MetalLB addon and set a profile to indicate a specific Kubernetes cluster, in this example <code>dc1</code>:</p>\n<pre><code>$ minikube start -p dc1 --driver=docker --addons=metallb</code></pre><p>Connect the cluster to the <code>metallb</code>network:</p>\n<pre><code>$ docker network connect metallb dc1</code></pre><p>After the Kubernetes cluster starts, configure the <code>ConfigMap</code> for MetalLB under <code>addresses</code> with an IP address range in the subnet you allocated to the Docker network. For example, you can set the third octet of the network to the number of the cluster:</p>\n<pre><code>echo \"apiVersion: v1\ndata:\n config: |\n   address-pools:\n   - name: default\n     protocol: layer2\n     addresses:\n     - 172.28.1.3-172.28.1.254\nkind: ConfigMap\nmetadata:\n name: config\n namespace: metallb-system\" | kubectl apply -f -</code></pre><p>MetalLB will use IP addresses from this range when you request a Kubernetes service with a load balancer. You will need to configure each Kubernetes cluster with its own profile and update MetalLB’s <code>ConfigMap</code> with an IP address range from the <code>metallb</code> network.</p>\n\n<h2>Install Consul and mesh gateways</h2>\n\n<p>Each Kubernetes cluster has its own Consul cluster and datacenter. Update the Helm values with a Consul datacenter to match the Minikube profile name. Set up TLS and enable mesh gateways for Consul cluster peering. By default, the Helm chart will create a Kubernetes service with a <code>LoadBalancer</code> type for the mesh gateway. Install Consul to the <code>consul</code> namespace:</p>\n<pre><code>echo \"global:\n name: consul\n datacenter: dc1\n\n tls:\n   enabled: true\n\n peering:\n   enabled: true\n\n acls:\n   manageSystemACLs: true\n\nconnectInject:\n enabled: true\n\nmeshGateway:\n enabled: true\" | helm install consul hashicorp/consul --create-namespace --namespace consul -f -\n</code></pre><p>After Consul runs, configure the mesh to peer through mesh gateways:</p>\n<pre><code>echo \"apiVersion: consul.hashicorp.com/v1alpha1\nkind: Mesh\nmetadata:\n name: mesh\nspec:\n peering:\n   peerThroughMeshGateways: true\" | kubectl apply --namespace consul -f -</code></pre><p>Update Consul’s proxies to access services through their local mesh gateway:</p>\n<pre><code>echo \"apiVersion: consul.hashicorp.com/v1alpha1\nkind: ProxyDefaults\nmetadata:\n name: global\nspec:\n meshGateway:\n   mode: local\" | kubectl apply --namespace consul -f -</code></pre><p>Repeat these configurations for each Kubernetes cluster you create through Minikube.</p>\n\n<h2>Set up cluster peering</h2>\n\n<p>Peer only the clusters that have services communicating with each other in production to maintain least-privilege. The <a href=\"https://github.com/joatmon08/consul-minikubes/blob/main/consul.sh#L16\">script</a> included in this post peers all clusters to each other for testing purposes. This example peers <code>dc1</code> to <code>dc2</code>.</p>\n\n<p>Configure <code>dc1</code> as the peering acceptor, which creates a peering token and sets the target peer to <code>dc2</code>:</p>\n<pre><code>echo \"apiVersion: consul.hashicorp.com/v1alpha1\nkind: PeeringAcceptor\nmetadata:\n name: dc2\nspec:\n peer:\n   secret:\n     name: peering-token-dc1-to-dc2\n     key: data\n     backend: kubernetes\" | kubectl --context dc1 apply --namespace consul -f -\n</code></pre><p>Extract the peering token and copy it to <code>dc2</code>:</p>\n<pre><code>kubectl --context dc1 --namespace consul \\\nget secret peering-token-dc1-to-dc2 --output yaml | \\\nkubectl --context dc2 --namespace consul apply -f -</code></pre><p>Set up <code>dc2</code> as the peering dialer, which initiates the peering request to <code>dc1</code>:</p>\n<pre><code>echo \"apiVersion: consul.hashicorp.com/v1alpha1\nkind: PeeringDialer\nmetadata:\n name: dc2\nspec:\n peer:\n   secret:\n     name: peering-token-dc1-to-dc2\n     key: data\n     backend: kubernetes\" | kubectl --context dc2 apply --namespace consul -f -</code></pre><p>Create a unique peering token for each pair of peered clusters.</p>\n\n<h2>Connecting services</h2>\n\n<p>For services to access other services in a peered cluster, export the service from one cluster to another:</p>\n<pre><code>echo \"apiVersion: consul.hashicorp.com/v1alpha1\nkind: ExportedServices\nmetadata:\n name: default\nspec:\n services:\n   - name: application\n     consumers:\n     - peer: dc1\" | kubectl --context dc2 apply -f -</code></pre><p>Add an intention to allow a service in the peered cluster (dc1) to access the service in the target cluster (dc2):</p>\n<pre><code>echo “apiVersion: consul.hashicorp.com/v1alpha1\nkind: ServiceIntentions\nmetadata:\n name: application-deny\nspec:\n destination:\n   name: application\n sources:\n  - name: *\n    action: deny\n  - name: web\n    action: allow\n    peer: dc1\" | kubectl --context dc2 apply -f -</code></pre><h2>Next steps for Consul cluster peering</h2>\n\n<p>Once you set up a local testing environment for cluster peering, you can run integration tests for services that need to connect across multiple Consul datacenters and Kubernetes clusters. For a fully automated local testing setup, check out <a href=\"https://github.com/joatmon08/consul-minikubes\">my repository</a> to configure Minikube and Consul across three clusters. Learn more about deploying in our  <a href=\"https://developer.hashicorp.com/consul/docs/k8s/connect/cluster-peering/tech-specs\">cluster peering for Kubernetes r documentation</a> and deploy an example to Kubernetes clusters on a cloud provider with our tutorial: <a href=\"https://developer.hashicorp.com/consul/tutorials/developer-mesh/cluster-peering\">Connect services between Consul datacenters with cluster peering</a>.</p>\n","author":"Rosemary Wang","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"3f8b90b9440d9a23014a68ef648fb0f06a6f41d471e845c7b9ef3eed7729c4c0","category":"Tech"}