{"title":"Introducing a Public Registry for AWS CloudFormation","link":"https://aws.amazon.com/blogs/aws/introducing-a-public-registry-for-aws-cloudformation/","date":1624317437000,"content":"<p><a href=\"https://aws.amazon.com/cloudformation/\">AWS CloudFormation</a> and the <a href=\"https://aws.amazon.com/cdk/\">AWS Cloud Development Kit (AWS CDK)</a> (<span>CDK</span>) provide scalable and consistent provisioning of <a href=\"https://aws.amazon.com/\">AWS</a> resources (for example, compute infrastructure, monitoring tools, databases, and more). We’ve heard from many customers that they’d like to benefit from the same consistency and scalability when provisioning resources from <a href=\"https://aws.amazon.com/partners/\">AWS Partner Network (APN)</a> members, third-party vendors, and open-source technologies, regardless of whether they are using <span>CloudFormation</span> templates or have adopted the <span>CDK</span> to define their cloud infrastructure.</p> \n<p>I’m pleased to announce a new public registry for <span>CloudFormation</span>, providing a searchable collection of extensions – resource types or modules – published by <span>AWS</span>, APN partners, third parties, and the developer community. The registry makes it easy to discover and provision these extensions in your <span>CloudFormation</span> templates and <span>CDK</span> applications in the same manner you use <span>AWS</span>-provided resources. Using extensions, you no longer need to create and maintain custom provisioning logic for resource types from third-party vendors. And, you are able to use a single infrastructure as code tool, <span>CloudFormation</span>, to provision and manage <span>AWS</span> and third-party resources, further simplifying the infrastructure provisioning process (the <span>CDK</span> uses <span>CloudFormation</span> under the hood).</p> \n<p><span><strong>Launch Partners</strong></span><br /> We’re excited to be joined by over a dozen APN Partners for the launch of the registry, with more than 35 extensions available for you to use today. Blog posts and announcements from the APN Partners who collaborated on this launch, along with <a href=\"https://aws.amazon.com/quickstart/?solutions-all.sort-by=item.additionalFields.sortDate&amp;solutions-all.sort-order=desc&amp;awsf.filter-tech-category=*all&amp;awsf.filter-industry=*all&amp;awsf.filter-content-type=*all\">AWS Quick Starts</a>, can be found below (some will be added in the next few days).</p> \n<ul> \n <li>MongoDB – <a href=\"http://www.mongodb.com/blog/post/deploy-manage-mongodb-atlas-aws-cloud-formation?utm_campaign=cloudformation&amp;utm_source=aws&amp;utm_medium=public_registry_blog\" target=\"_blank\">Deploy and Manage MongoDB Atlas from AWS CloudFormation</a></li> \n <li>Datadog – <a href=\"https://www.datadoghq.com/blog/monitoring-as-code-with-datadog-and-cloudformation/\" target=\"_blank\">Implement monitoring as code with Datadog and CloudFormation Registry</a></li> \n <li>Atlassian Opsgenie – <a href=\"https://community.atlassian.com/t5/Opsgenie-articles/Leveraging-Atlassian-s-Opsgenie-and-AWS-Cloudformation-Registry/ba-p/1728333\" target=\"_blank\">Leveraging Atlassian’s Opsgenie and AWS CloudFormation Registry to stay ahead of incidents</a></li> \n <li>Aqua Security – <a href=\"https://blog.aquasec.com/iac-automation-aws-cloudformation-registry\" target=\"_blank\">Aqua Security Launches on AWS Public CloudFormation Registry for IaC Automation</a></li> \n <li>Trend Micro – <a href=\"http://trendmicro.com/en_us/research/21/f/security-resources-now-on-aws-cloudformation-templates.html\" target=\"_blank\">Security Resources Now on AWS CloudFormation Templates</a></li> \n <li>FireEye – <a href=\"https://www.fireeye.com/partners/strategic-technology-partners/amazon-web-services-partnership/AWSCloudFormation.html\" target=\"_blank\">FireEye Gets You Started in The Cloud Faster with AWS CloudFormation</a></li> \n <li>Spot by NetApp – <a href=\"https://spot.io/blog/aws-cloudformation-public-registry/\" target=\"_blank\">Spot by NetApp joins AWS CloudFormation Public Registry</a></li> \n <li>JFrog – <a href=\"https://jfrog.com/blog/provision-artifactory-and-xray-to-aws-with-cloudformation\" target=\"_blank\">JFrog CloudFormation Modules Make Provisioning to AWS Easy and Secure</a></li> \n <li>Stackery – <a href=\"https://stackery.io/blog/public-modules-for-sharable-reusable-cloudformation/\" target=\"_blank\">Stackery announces the availability of Bastion modules on the CloudFormation Public Registry</a></li> \n <li>Check Point – <a href=\"https://blog.checkpoint.com/2021/06/21/cloudguard-integrates-with-aws-cloudformation-public-registry-at-launch/\" target=\"_blank\">CloudGuard Integrates with AWS CloudFormation Public Registry at launch</a></li> \n <li>Gremlin – <a href=\"https://www.gremlin.com/blog/announcing-gremlin-using-aws-cloudformation-public-registry\" target=\"_blank\">Use the AWS CloudFormation Registry to automate deploying the Gremlin agent to your AWS resources</a></li> \n <li>Iridium – <a href=\"https://www.iridium.com/?p=310242&amp;preview=1&amp;_ppp=64c505cadd\" target=\"_blank\">Getting Stacked with AWS CloudFormation Modules</a></li> \n <li>Sysdig – <a href=\"https://sysdig.com/blog/deploying-sysdig-new-aws-cloudformation-public-registry\" target=\"_blank\">Deploying Sysdig with the AWS CloudFormation Public Registry</a></li> \n <li>Snyk – <a href=\"https://snyk.io/blog/snyk-container-extension-aws-cloudformation-registry/\">Snyk Container is now an extension in the AWS CloudFormation Registry</a></li> \n <li>Splunk – Coming soon!</li> \n <li>AWS Quick Starts – <a href=\"https://aws.amazon.com/quickstart/architecture/cloudformation-resource-providers/\" target=\"_blank\">AWS Quick Starts announces AWS CloudFormation Resource Types for Kubernetes</a></li> \n</ul> \n<p><span><strong>Registries and Resource Types</strong></span><br /> In 2019, <span>CloudFormation</span> launched support for private registries. These enabled registration and use of resource providers (<span>Lambda</span> functions) in your account, including providers from <span>AWS</span> and third-party vendors. After you registered a provider you could use resource types, comprised of custom provisioning logic, from the provider in your <span>CloudFormation</span> templates. Resource types were uploaded by providers to an <a href=\"https://aws.amazon.com/s3/\">Amazon Simple Storage Service (Amazon S3)</a> bucket, and you used the types by referencing the relevant <span>S3</span> URL. The public registry provides consistency in the sourcing of resource types and modules, and you no longer need to use a collection of <a href=\"https://aws.amazon.com/s3/\">Amazon Simple Storage Service (Amazon S3)</a> buckets.</p> \n<p>Third-party resource types in the public registry also integrate with <a href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/detect-drift-stack.html\" target=\"_blank\">drift detection</a>. After creating a resource from a third-party resource type, <span>CloudFormation</span> will detect changes to the resource from its template configuration, known as configuration drift, just as it would with <span>AWS</span> resources. You can also use <a href=\"https://aws.amazon.com/config/\">AWS Config</a> to manage compliance for third-party resources consumed from the registry. The resource types are automatically tracked as Configuration items when you have configured <span>AWS Config</span> to record them, and used <span>CloudFormation</span> to create, update, and delete them. Whether the resource types you use are third-party or <span>AWS</span> resources, you can view configuration history for them, in addition to being able to write <span>AWS Config</span> rules to verify configuration best practices.</p> \n<p>The public registry also supports Type Configuration, enabling you to configure third-party resource types with API keys and OAuth tokens per account and region. Once set, the configuration is stored securely and can be updated. This also provides a centralized way to configure third-party resource types.</p> \n<p><span><strong> Publishing Extensions to the Public Registry</strong></span><br /> Extension publishers must be verified as <a href=\"https://aws.amazon.com/marketplace/\">AWS Marketplace</a> sellers, or as GitHub or BitBucket users, and extensions are validated against best practices. To publish extensions (resource types or modules) to the registry, you must first register in an <span>AWS</span> Region, using one of the mentioned account types.</p> \n<p>After you’ve registered, you next publish your extension to a private registry in the same Region. Then, you need to test that the extension meets publishing requirements. For a resource type extension, this means it must <a href=\"https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/resource-type-test.html\" target=\"_blank\">pass all the contract tests</a> defined for the type. Modules are subject to different requirements, and you can find more details <a href=\"https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/modules-structure.html#modules-structure-publishing-prereqs\" target=\"_blank\">in the documentation</a>. With testing complete, you can publish your extension to the public registry for your Region. <strong><a href=\"https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/publish-extension.html\" target=\"_blank\">See the user guide for detailed information on publishing extensions</a>.</strong></p> \n<p><span><strong>Using Extensions in the Public Registry<br /> </strong></span>I decided to try a couple of extensions related to Kubernetes, contributed by <a href=\"https://aws.amazon.com/quickstart\">AWS Quick Starts</a>, to make configuration changes to a cluster. Personally, I don’t have a great deal of experience with Kubernetes and its API so this was a great chance to examine how extensions could save me significant time and effort. During the process of writing this post I learned from others that using the Kubernetes API (the usual way to achieve the changes I had in mind) would normally involve effort even for those with more experience.</p> \n<p>For this example I needed a Kubernetes cluster, so I followed <a href=\"https://docs.aws.amazon.com/eks/latest/userguide/getting-started-console.html\" target=\"_blank\">this tutorial</a> to set one up in <a href=\"https://aws.amazon.com/eks/\">Amazon Elastic Kubernetes Service (EKS)</a>, using the <strong>Managed nodes – Linux</strong> node type. With my cluster ready, I want to make two configuration changes.</p> \n<p>First, I want to add a new namespace to the cluster. A namespace is a partitioning construct that lets me deploy the same set of resources to different namespaces in the same cluster without conflict thanks to the isolation namespaces provide. Second, I want to set up and use <a href=\"https://helm.sh/\" target=\"_blank\">Helm</a>, a package manager for Kubernetes. I’ll use Helm to install the <a href=\"https://github.com/kubernetes/kube-state-metrics\" target=\"_blank\">kube-state-metrics</a> package from the <a href=\"https://prometheus-community.github.io/helm-charts\">Prometheus helm-charts repository</a> for gathering cluster metrics. While I can use <span>CloudFormation</span> to provision clusters and compute resources, previously, to perform these two configuration tasks, I’d have had to switch to the API or various bespoke tool chains. With the registry, and these two extensions, I can now do everything using <span>CloudFormation</span> (and of course, as I mentioned earlier, I could also use the extensions with the <span>CDK</span>, which I’ll show later).</p> \n<p>Before using an extension, it needs to be activated in my account. While activation is easy to do for single accounts using the console, as we’ll see in a moment, if I were using <a href=\"https://aws.amazon.com/organizations/\">AWS Organizations</a> and wanted to activate various third-party extensions across my entire organization, or for a specific organization unit (OU), I could achieve this using <strong>Service-Managed StackSets</strong> in <span>CloudFormation</span>. Using the resource type <code>AWS::CloudFormation::TypeActivation</code> in a template submitted to a Service-Managed StackSet, I can target an entire <span>Organization</span>, or a particular OU, passing the Amazon Resource Name (ARN) identifying the third-party extension to be activated. Activation of extensions is also very easy to achieve (whether using <span>AWS Organizations</span> or not) using the <span>CDK</span> with just a few lines of code, again making use of the aforementioned <code>TypeActivation</code> resource type.</p> \n<p>To activate the extensions, I head to the <span>CloudFormation</span> console and click <strong>Public extensions</strong> from the navigation bar. This takes me to the <strong>Registry:Public extensions</strong> home page, where I switch to viewing third party resource type extensions.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/06/16/cfn_public_registry_3ptypes-2.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/06/16/cfn_public_registry_3ptypes-2.png\" /></a></p> \n<p>The extensions I want are <code>AWSQS::Kubernetes::Resource</code> and <code>AWSQS::Kubernetes::Helm</code>. The <code>Resource</code> extension is used to apply a manifest describing configuration changes to a cluster. In my case, the manifest requests a namespace be created. Clicking the name of the <code>AWSQS::Kubernetes::Resource</code> extension takes me to a page where I can view schema, configuration details, and versions for the extension.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/06/16/cfn_public_registry_resource-1.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/06/16/cfn_public_registry_resource-1.png\" /></a></p> \n<p>What happens if you deactivate an extension you’re using, or an extension is withdrawn by the publisher? If you deactivate an extension a stack depends on, any resources created from that extension won’t be affected, but you’ll be unable to perform further stack operations, such as Read, Update, Delete, and List (these will fail until the extension is re-activated). Publishers must request their extensions be withdrawn from the registry (there is no “delete” API). If the request is granted, customers who activated the extension prior to withdrawal can still perform Create/Read/Update/Delete/List operations, using what is effectively a snapshot of the extension in their account.</p> \n<p>Clicking <strong>Activate</strong> takes me to a page where I need to specify the ARN of an execution role that <span>CloudFormation</span> will assume when it runs the code behind the extension. I create a role following this <a href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/registry-public.html#registry-public-enable-execution-role\" target=\"_blank\">user guide topic</a>, but the basic trust relationship is below for reference.</p> \n<pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Service\": \"resources.cloudformation.amazonaws.com\"\n      },\n      \"Action\": \"sts:AssumeRole\"\n    }\n  ]\n}</code></pre> \n<p>I also add permissions for the resource types I’m using to my execution role. Details on the permissions needed for the types I chose can be found on GitHub, <a href=\"https://github.com/aws-quickstart/quickstart-helm-resource-provider/blob/main/execution-role.template.yaml\" target=\"_blank\">for Helm</a>, and <a href=\"https://github.com/aws-quickstart/quickstart-kubernetes-resource-provider/blob/main/execution-role.template.yaml\" target=\"_blank\">for Kubernetes</a> (note the GitHub examples include the trust relationship too).</p> \n<p>When activating an extension, I can elect to use the default name, which is how I will refer to the type in my templates or <span>CDK</span> applications, or I can enter a new name. The name chosen has to be unique within my account, so if I’ve enabled a version of an extension with its default name, and want to enable a different version, I must change the name. Once I’ve filled in the details, and chosen my versioning strategy (extensions use <a href=\"https://semver.org/\" target=\"_blank\">semantic versioning</a>, and I can elect to accept automatic updates for minor version changes, or to “lock” to a specific version) clicking <strong>Activate extension</strong> completes the process.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/06/17/cfn_public_registry_resource_enable.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/06/17/cfn_public_registry_resource_enable.png\" /></a></p> \n<p>That completes the process for the first extension, and I follow the same steps for the <code>AWSQS::Kubernetes::Helm</code> extension. Navigating to <strong>Activated extensions</strong> I can view a list of all my enabled extensions.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/06/16/cfn_public_registry_enabled_types-1.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/06/16/cfn_public_registry_enabled_types-1.png\" /></a></p> \n<p>I have one more set of permissions to update. Resource types make calls to the Kubernetes API on my behalf so I need to update the <code>aws-auth</code> ConfigMap for my cluster to reference the execution role I just used, otherwise the calls made by the resource types I’m using will fail. To do this, I run the command <code>kubectl edit cm aws-auth -n kube-system</code> at a command prompt. In the text editor that opens, I update the ConfigMap with a new group referencing my <code>CfnRegistryExtensionExecRole</code>, shown below (if you’re following along, be sure to change the account ID and role name to match yours).</p> \n<pre><code>apiVersion: v1\ndata:\n  mapRoles: |\n    - groups:\n      - system:bootstrappers\n      - system:nodes\n      rolearn: arn:aws:iam::111122223333:role/myAmazonEKSNodeRole\n      username: system:node:{{EC2PrivateDNSName}}\n    - groups:\n      - system:masters\n      rolearn: arn:aws:iam::111122223333:role/CfnRegistryExtensionExecRole\n      username: cfnresourcetypes\nkind: ConfigMap\nmetadata:\n  creationTimestamp: \"2021-06-04T20:44:24Z\"\n  name: aws-auth\n  namespace: kube-system\n  resourceVersion: \"6355\"\n  selfLink: /api/v1/namespaces/kube-system/configmaps/aws-auth\n  uid: dc91bfa8-1663-45d0-8954-1e841913b324</code></pre> \n<p>Now I’m ready to use the extensions to configure my cluster with a new namespace, Helm, and the kube-state-metrics package. I create a <span>CloudFormation</span> template that uses the extensions, adding parameters for the elements I want to specify when creating a stack: the name of the cluster to update, and the namespace name. The properties for the <code>KubeStateMetrics</code> resource reference the package I want Helm to install.</p> \n<pre><code>AWSTemplateFormatVersion: \"2010-09-09\"\nParameters:\n  ClusterName:\n    Type: String\n  Namespace:\n    Type: String\nResources:\n  KubeStateMetrics:\n    Type: AWSQS::Kubernetes::Helm\n    Properties:\n      ClusterID: !Ref ClusterName\n      Name: kube-state-metrics\n      Namespace: !GetAtt KubeNamespace.Name\n      Repository: https://prometheus-community.github.io/helm-charts\n      Chart: prometheus-community/kube-state-metrics\n  KubeNamespace:\n    Type: AWSQS::Kubernetes::Resource\n    Properties:\n      ClusterName: !Ref ClusterName\n      Namespace: default\n      Manifest: !Sub |\n        apiVersion: v1\n        kind: Namespace\n        metadata:\n          name: ${Namespace}\n          labels:\n            name: ${Namespace}</code></pre> \n<p>On the <strong>Stacks</strong> page of the <span>CloudFormation</span> console, I click <strong>Create stack</strong>, upload my template, and then give my stack a name and the values for my declared parameters.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/06/17/cfn-update-cluster-stack-1.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/06/17/cfn-update-cluster-stack-1.png\" /></a></p> \n<p>I click <strong>Next</strong> to proceed through the rest of the wizard, leaving other settings at their default values, and then <strong>Create stack</strong> to complete the process.</p> \n<p>Once stack creation is complete, I verify my changes using the <strong>kubectl</strong> command line tool. I first check that the new namespace, <strong>newsblog-sample-namespace</strong>, is present with the command <code>kubectl get namespaces</code>. I then run the <code>kubectl get all --namespace newsblog-sample-namespace</code> command to verify the <strong>kube-state-metrics</strong> package is installed.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/06/17/cfn_public_registry_final_output-1.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/06/17/cfn_public_registry_final_output-1.png\" /></a></p> \n<p>Extensions can also be used with the <span>AWS Cloud Development Kit (AWS CDK)</span>. To wrap up this exploration of using the new registry, I’ve included an example below of a <span>CDK</span> application snippet in TypeScript that achieves the same effect, using the same extensions, as the YAML template I showed earlier (I could also have written this using any of the languages supported by the <span>CDK</span> – C#, Java, or Python).</p> \n<pre><code>import {Stack, Construct, CfnResource} from '@aws-cdk/core';\nexport class UnoStack extends Stack {\n  constructor(scope: Construct, id: string) {\n    super(scope, id);\n    const clusterName = 'newsblog-cluster';\n    const namespace = 'newsblog-sample-namespace';\n\n    const kubeNamespace = new CfnResource(this, 'KubeNamespace', {\n      type: 'AWSQS::Kubernetes::Resource',\n      properties: {\n        ClusterName: clusterName,\n        Namespace: 'default',\n        Manifest: this.toJsonString({\n          apiVersion: 'v1',\n          kind: 'Namespace',\n          metadata: {\n            name: namespace,\n            labels: {\n              name: namespace,\n            }\n          },\n        }),\n      },\n    });\n    \n    new CfnResource(this, 'KubeStateMetrics', {\n      type: 'AWSQS::Kubernetes::Helm',\n      properties: {\n        ClusterID: clusterName,\n        Name: 'kube-state-metrics',\n        Namespace: kubeNamespace.getAtt('Name').toString(),\n        Repository: 'https://prometheus-community.github.io/helm-charts',\n        Chart: 'prometheus-community/kube-state-metrics',\n      },\n    });\n  }\n};</code></pre> \n<p>As mentioned earlier in this post, I don’t have much experience with the Kubernetes API, and Kubernetes in general. However, by making use of the resource types in the public registry, in conjunction with <span>CloudFormation</span>, I was able to easily configure my cluster using a familiar environment, without needing to resort to the API or bespoke tool chains.</p> \n<p><span><strong>Get Started with the <span>CloudFormation</span> Public Registry</strong></span><br /> Pricing for the public registry is the same as for the existing registry and private resource types. There is no additional charge for using native <span>AWS</span> resource types; for third-party resource types you will incur charges based on the number of handler operations (add, delete, list, etc.) you run per month. For details, see the <a href=\"https://aws.amazon.com/cloudformation/pricing/\" target=\"_blank\">AWS CloudFormation Pricing page</a>. The new public registry is available today in the US East (N. Virginia, Ohio), US West (Oregon, N. California), Canada (Central), Europe (Ireland, Frankfurt, London, Stockholm, Paris, Milan), Asia Pacific (Hong Kong, Mumbai, Osaka, Singapore, Sydney, Seoul, Tokyo), South America (Sao Paulo), Middle East (Bahrain), and Africa (Cape Town) <span>AWS</span> Regions.</p> \n<p><strong>For more information, see the <a href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/\" target=\"_blank\">AWS CloudFormation User Guide</a> and <a href=\"https://docs.aws.amazon.com/cloudformation-cli/latest/userguide\" target=\"_blank\">User Guide for Extension Development</a>, and start publishing or using extensions today!</strong></p> \n<a href=\"https://twitter.com/bellevuesteve\">— Steve</a>","author":"Steve Roberts","siteTitle":"AWS News Blog","siteHash":"6093e072e4117ec22616e844cb857d03ca62c57a411a8affc77cb5e8b6b15bf6","entryHash":"1898db45d066380398526f998eef607cfac7e6522ff8175c85d047d45a5eeb07","category":"Tech"}