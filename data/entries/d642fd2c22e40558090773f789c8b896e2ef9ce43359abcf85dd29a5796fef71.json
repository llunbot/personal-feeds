{"title":"Optimizing JavaScript Standard Library Functions in JSC","link":"https://webkit.org/blog/11934/optimizing-javascript-standard-library-functions-in-jsc/","date":1627496001000,"content":"<p>After three years working on JavaScriptCore (JSC), I recently had the opportunity to work on optimizing one of our standard library functions for the first time. I thought it’d be interesting to share what I learned about how they work in JSC and how we make them faster.</p>\n<h2>How are standard library functions implemented in JSC?</h2>\n<p>The JavaScript standard library functions include all the prototype functions for Array, Object, etc, and in this post we’ll look at <code>Function.prototype.toString</code>.</p>\n<p>In JSC, standard library functions can either be implemented in native code (C++) or in JavaScript. When using JavaScript, we can use a special syntax for operations that are not allowed for regular JavaScript programs. Standard library functions written in JavaScript can be called like any other JavaScript function, and will also run through the same optimizations in each of our tiers, including inlining. Meanwhile, standard library functions written in C++ require the VM to make calls to native code, which is more expensive, and while the implementation will be optimized by the C++ compiler, its internals are completely opaque to the caller JS function, so there can be no inlining. The reason I mention inlining is that it allows the caller to “see” inside the function body, which unlocks many further optimizations to be done beyond the function boundary, some of which we’ll see in this example.</p>\n<h2>Making standard library functions faster</h2>\n<p>Let’s start with a reduced test case to see how can we optimize <code>Function.prototype.toString</code>:</p>\n<pre><code><span>function</span> <span>f</span>() { <span>/* ... some code here ... */</span> }\n\n<span>function</span> <span>g</span>() {\n  <span>return</span> <span>f</span>.<span>toString</span>();\n}\n</code></pre>\n<p>When we call <code>g</code>, JSC will start by executing it in the interpreter (called LLInt), and if we continue calling it enough times it will eventually be promoted through the 3 compilers in JSC: the non-optimizing Baseline compiler and our optimizing DFG and FTL compilers. You can read more about our execution tiers on <a href=\"https://webkit.org/blog/3362/introducing-the-webkit-ftl-jit/\">this post</a> from back when the FTL was first introduced, but since then <a href=\"https://webkit.org/blog/5852/introducing-the-b3-jit-compiler/\">the FTL has gotten a new backend</a>.</p>\n<p>The first step before we run any code in any tier is to convert it from source code to bytecode (again, you can read a lot more about our bytecode <a href=\"https://webkit.org/blog/9329/a-new-bytecode-format-for-javascriptcore/\">here</a>). After that, our DFG and FTL compilers also have their own representation of the code, that we call an Intermediate Representation or IR for short. For this post I’ll take the liberty of using some pseudocode that is somewhere in between our initial bytecode and DFG IR. This way we can see some of the details that are only available in DFG but without exposing too much low level complexity that is not relevant for our example. Here’s what our pretend IR could look like for <code>g</code>:</p>\n<pre><code>function g():\n    f = Lookup(\"f\") // look for the variable \"f\" in the lexical scope\n    toString = Get(f, \"toString\") // access the \"toString\" property of `f`,\n                                  // respecting the semantics of JavaScript property\n                                  // lookup, including looking up the prototype, etc.\n    result = Call(toString, f) // call the toString function with `f` as `this`\n    Return(result) // return our result to the caller\n</code></pre>\n<h3>Caching</h3>\n<p>The first optimization implemented wasn’t specific to standard library functions at all: the result of calling toString on a function never changes, so we can cache it.</p>\n<p>Our implementation of <code>Function.prototype.toString</code> is written in C++ and has to handle a few special cases. One such case is when we are calling <code>toString</code> on a native function implemented in C++, but for the common case where it’s a regular JavaScript function, we have to look at the source code for the function. Since the source can’t be changed while it’s being executed, and the name of the function also cannot be changed, this result can be cached. This is completely transparent to our IR, which means we don’t have to change anything in the compiler and we already get a great speedup.</p>\n<h3>Speculation</h3>\n<p>When we start trying to optimize any JavaScript program we quickly face several challenges, since pretty much everything in JavaScript can be mutated at runtime, including our standard library functions. One way that modern JavaScript VMs get around these challenges is by <em>speculating</em> that certain facts about the program will not change during its execution, but since we can’t ever be sure of that, we need a way to fall back if our assumptions become invalid. We have <a href=\"https://webkit.org/blog/10308/speculation-in-javascriptcore/\">an amazing post</a> that goes deep into how we speculate in JSC, but for our current purposes all we need to know is that we can compile a function and say the code we generated is only valid so long as some assumptions are valid. This also isn’t specific to standard library functions, but it’ll be important later to see how all these optimizations interact with each other yielding more than the sum of their parts.</p>\n<p>In this case we can speculate that <code>f</code> will never change, for our example let’s assume that it’s always called with an object allocated at address <code>0x123456</code>. This is done through a mechanism called watchpoints, which is beyond the scope of this post, but the TL;DR is that this code will immediately become invalid if anyone assigns to <code>f</code>, which would produce a different result. Using other watchpoints we can also speculate that <code>f.toString</code> will always resolve to <code>Function.prototype.toString</code> which already leads to much better code:</p>\n<pre><code>function g():\n    f = 0x123456 // speculated value of Lookup(\"f\")\n    toString = Function.prototype.toString // speculated value of Get(f, \"toString\")\n    result = Call(toString, f)\n    Return(result)\n</code></pre>\n<h3>Intrinsics</h3>\n<p>Next, JSC has the concept of <em>intrinsics</em>. Intrinsics in JSC are when the compiler utilizes the knowledge that it’s calling a well known standard library function to emit optimized code inline. This is even more powerful than regular function inlining, since it can emit only the fast path inline and it works even if the standard library function was written in C++. In this case, the intrinsic tells us we are calling <code>Function.prototype.toString</code> and we can emit a new instruction, <code>FunctionToString</code>,  instead of the generic function call. Our new pseudo instruction will try to load the cached value we computed in our very first optimization, but for the slow case, where we don’t have cached value yet, it will still call the C++ implementation. Computing the <code>toString</code> for the first time requires some really complex code that we don’t want to emit inline for every call to <code>toString</code>. Our code with our new instruction might look like this:</p>\n<pre><code>function g():\n    f = 0x123456\n    result = FunctionToString(f)\n    Return(result)\n</code></pre>\n<p>And diving a little deeper, the implementation of our new <code>FunctionToString</code> instruction might look like the following:</p>\n<pre><code>function g():\n    f = 0x123456\n    result = Load(f, \"cachedToString\") // Load a specific property of the object,\n                                       // much faster since it's just a memory\n                                       // access, not a JS property access like Get\n    if (!result) {\n        // For the slow case where we don't have a cached value we just fallback\n        // to calling the C++ code\n        toString = Function.prototype.toString\n        result = Call(toString, f)\n    }\n    Return(result)\n</code></pre>\n<h3>Abstract Interpretation</h3>\n<p>The next step in speeding up our example is using our Abstract Interpreter (AI). The idea behind the AI is that it understands what our IR instructions will do to its operands at runtime, and if all of its operands are known (i.e. we proved they will always have the same value), we can try to compute the result of our instruction at compile time. In this case, since we already speculated that <code>f</code> will be <code>0x123456</code>, when we’re compiling our <code>FunctionToString</code> instruction we can try to load the <code>cachedToString</code> property from the object at <code>0x123456</code>. If that succeeds our generated code will look more like this:</p>\n<pre><code>function g():\n    result = \"function f() { /* … some code here .. */ }\"\n    Return(result)\n</code></pre>\n<p>That’s much better!</p>\n<h2>Recap</h2>\n<p>We can speed up the <code>f.toString()</code> call in our example by:</p>\n<ul>\n<li>Caching the result</li>\n<li>Speculating <code>f</code> will always be the same object</li>\n<li>Speculating that <code>f.toString</code> will always resolve to <code>Function.prototype.toString</code></li>\n<li>Adding an Intrinsic and a new instruction, <code>FunctionToString</code>, that loads the cached value directly whenever it’s available</li>\n<li>Teaching our abstract interpreter that if we already know which function we are stringifying, and its <code>toString</code> value has already been computed, we can just use the cached value as a constant.</li>\n</ul>\n<p>If you want to dive deeper into the actual implementation you can find the commit <a href=\"https://github.com/WebKit/WebKit/commit/83d39868d226e411832f378a4fa5c53579cc4a81\">here</a> and if you have any questions feel free to reach out to me on <a href=\"https://twitter.com/tadeuzagallo\">Twitter</a>.</p>","author":"","siteTitle":"Blog – WebKit","siteHash":"7f8dbea0b8f53db2e11a2faa08c6dca9954c01638d09a2ce585b77a60d10f7a1","entryHash":"d642fd2c22e40558090773f789c8b896e2ef9ce43359abcf85dd29a5796fef71","category":"Tech"}