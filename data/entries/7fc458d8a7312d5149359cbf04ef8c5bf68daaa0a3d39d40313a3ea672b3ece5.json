{"title":"A Simple Guide To Retrieval Augmented Generation Language Models","link":"https://smashingmagazine.com/2024/01/guide-retrieval-augmented-generation-language-models/","date":1706281200000,"content":"<p>Suppose you ask some AI-based chat app a reasonably simple, straightforward question. Let’s say that app is ChatGPT, and the question you ask is right in its wheelhouse, like, <em>“What is Langchain?”</em> That’s really a softball question, isn’t it? ChatGPT is powered by the same sort of underlying technology, so it ought to ace this answer.</p>\n<p>So, you type and eagerly watch the app spit out conversational strings of characters in real-time. But the answer is less than satisfying.</p>\n<p><img src=\"https://files.smashing.media/articles/guide-retrieval-augmented-generation-language-models/1-chatgpt-response.png\" /></p>\n<p>In fact, ask ChatGPT — or any other app powered by language models — any question about anything recent, and you’re bound to get some sort of response along the lines of, <em>“As of my last knowledge update…”</em> It’s like ChatGPT fell asleep Rumplestiltskin-style back in January 2022 and still hasn’t woken up. You know how people say, <em>“You’d have to be living under a rock not to know that”?</em> Well, ChatGPT took up residence beneath a giant chunk of granite two years ago.</p>\n<p>While many language models are trained on <a href=\"https://kili-technology.com/large-language-models-llms/9-open-sourced-datasets-for-training-large-language-models\">massive datasets</a>, data is still data, and data becomes stale. You might think of it like Googling “CSS animation,” and the top result is a <a href=\"https://www.smashingmagazine.com/2011/05/an-introduction-to-css3-keyframe-animations/\">Smashing Magazine article from 2011</a>. It might still be relevant, but it also might not. The only difference is that we can skim right past those instances in search results while ChatGPT gives us some meandering, unconfident answers we’re stuck with.</p>\n<p>There’s also the fact that <strong>language models are only as “smart” as the data used to train them</strong>. There are many techniques to improve language model’s performance, but what if language models could access real-world facts and data <em>outside</em> their training sets without extensive retraining? In other words, what if we could supplement the model’s existing training with accurate, timely data?</p>\n<p>This is exactly what <strong>Retrieval Augmented Generation (RAG)</strong> does, and the concept is straightforward: let language models fetch relevant knowledge. This could include recent news, research, new statistics, or any new data, really. With RAG, a large language model (LLM) is able to retrieve “fresh” information for more high-quality responses and fewer hallucinations.</p>\n<p>But what exactly does RAG make available, and where does it fit in a language chain? We’re going to learn about that and more in this article.</p>\nUnderstanding Semantic Search\n<p>Unlike keyword search, which relies on exact word-for-word matching, <strong>semantic search</strong> interprets a query’s “true meaning” and intent — it goes beyond merely matching keywords to produce more results that bear a relationship to the original query.</p>\n<p>For example, a semantic search querying “best budget laptops” would understand that the user is looking for “affordable” laptops without querying for that exact term. <strong>The search recognizes the contextual relationships between words.</strong></p>\n<p>This works because of <a href=\"https://www.deepset.ai/blog/the-beginners-guide-to-text-embeddings\">text embeddings</a> or mathematical representations of meaning that capture nuances. It’s an interesting process of feeding a query through an embedded model that, in turn, converts the query into a set of numeric vectors that can be used for matching and making associations.</p>\n<p><img src=\"https://files.smashing.media/articles/guide-retrieval-augmented-generation-language-models/2-text-embedding.png\" /></p>\n<p>The vectors represent meanings, and there are benefits that come with it, allowing semantic search to perform a number of useful functions, like <strong>scrubbing irrelevant words</strong> from a query, <strong>indexing information</strong> for efficiency, and <strong>ranking results</strong> based on a variety of factors such as relevance.</p>\n<p>Special databases optimized for speed and scale are a strict necessity when working with language models because you could be searching through billions of documents. With a semantic search implementation that includes test embedding, storing and querying high-dimensional embedding data is much more efficient, producing quick and efficient evaluations on queries against document vectors across large datasets.</p>\n<p>That’s the context we need to start discussing and digging into RAG.</p>\nRetrieval Augmented Generation\n<p>Retrieval Augmented Generation (RAG) is based on <a href=\"https://ai.meta.com/blog/retrieval-augmented-generation-streamlining-the-creation-of-intelligent-natural-language-processing-models/\">research produced by the Meta team</a> to advance the natural language processing capabilities of large language models. Meta’s research proposed combining retriever and generator components to make language models more intelligent and accurate for generating text in a human voice and tone, which is also commonly referred to as <strong>natural language processing</strong> (NLP).</p>\n<p>At its core, RAG seamlessly integrates retrieval-based models that fetch external information and generative model skills in producing natural language. <a href=\"https://huggingface.co/docs/transformers/model_doc/rag\">RAG models</a> outperform standard language models on knowledge-intensive tasks like answering questions by augmenting them with retrieved information; this also enables more well-informed responses.</p>\n<p><img src=\"https://files.smashing.media/articles/guide-retrieval-augmented-generation-language-models/3-diagramming-integration-retriever-generator-components.png\" /></p>\n<p>You may notice in the figure above that there are two core RAG components: a <strong>retriever</strong> and a <strong>generator</strong>. Let’s zoom in and look at how each one contributes to a RAG architecture. </p>\n<h3>Retriever</h3>\n<p>We already covered it briefly, but a <strong>retriever module</strong> is responsible for finding the most relevant information from a dataset in response to queries and makes that possible with the vectors produced by text embedding. In short, it receives the query and <em>retrieves</em> what it evaluates to be the most accurate information based on a store of semantic search vectors.</p>\n<p><img src=\"https://files.smashing.media/articles/guide-retrieval-augmented-generation-language-models/4-diagramming-flow-retreiver-module.png\" /></p>\n<p>Retrievers are models in and of themselves. But unlike language models, retrievers are not in the business of “training” or machine learning. They are more of an enhancement or an add-on that provides additional context for understanding and features for fetching that information efficiently.</p>\n<p>That means there are available options out there for different retrievers. You may not be surprised that <a href=\"https://openai.com/blog/new-and-improved-embedding-model\">OpenAI offers one</a>, given their ubiquity. There’s another <a href=\"https://txt.cohere.com/introducing-embed-v3/\">one provided by Cohere</a> as well as a slew of smaller options you can find <a href=\"https://huggingface.co/models?sort=trending&amp;search=embedding\">in the Hugging Face community</a>.</p>\n<h3>Generator</h3>\n<p>After the retriever finds relevant information, it needs to be passed back to the application and displayed to the user. Or what’s needed is a <strong>generator</strong> capable of <em>converting</em> the retrieved data into human-readable content.</p>\n<p><img src=\"https://files.smashing.media/articles/guide-retrieval-augmented-generation-language-models/5-diagramming-generator-flow-rag-based-system.png\" /></p>\n<p>What’s happening behind the scenes is the generator accepts the embeddings it receives from the retriever, mashes them together with the original query, and passes through the trained language model for an NLP pass on the way to becoming generated text.</p>\n<p>The entire tail end of that process involving the language model and NLP is a process in its own right and is something I have explained in greater detail in <a href=\"https://www.smashingmagazine.com/2023/10/overview-large-language-model-concepts-use-cases-tools/\">another Smashing Magazine article</a> if you are curious about what happens between the generator and final text output.</p>\nRAG Full View\n<p>Pulling everything together, a complete RAG flow goes like this:</p>\n<ol>\n<li>A query is made.</li>\n<li>The query is passed to the RAG model.</li>\n<li>The RAG model encodes the query into text embeddings that are compared to a dataset of information.</li>\n<li>The RAG’s retriever decides the most relevant information with its semantic search abilities and converts it into vector embeddings.</li>\n<li>The RAG’s retriever sends the parsed embeddings to the generator.</li>\n<li>The generator accepts the embeddings and combines them with the original query.</li>\n<li>The generator passes its work off to the language model to produce natural-sounding content presented to the user.</li>\n</ol>\n<p><img src=\"https://files.smashing.media/articles/guide-retrieval-augmented-generation-language-models/6-complete-rag-architecture.png\" /></p>\nLLM Hallucinations And Knowledge Limitations\n<p>We opened this article up by describing “hallucinations” in LLMs’ incorrect responses or something along the lines of <em>“I don’t know, but here’s what I do know.”</em> The LLM will “make stuff up” because it simply doesn’t have updated information to respond with.</p>\n<p>Let’s revisit the first query we used to kick off this article — <em>“What is LangChain?”</em> — and compare responses from the Vicuna and GPT-4 language models:</p>\n<p><img src=\"https://files.smashing.media/articles/guide-retrieval-augmented-generation-language-models/7-chat-responses-showing-hallucinations-vicuna-gpt4.png\" /></p>\n<p>Here’s the transcription for the second query using OpenAI’s GPT-4 for posterity:</p>\n<blockquote>“LangChain is a blockchain-based decentralized translation platform. It’s designed to connect translators and those seeking translation services directly without the need for intermediaries. This system uses artificial intelligence and blockchain technologies to provide high-quality, efficient translation services. LangChain also has a token-based economy, where users can earn and spend tokens within the LangChain ecosystem.”</blockquote>\n\n<p>Both Vicuna and GPT-4 refer to LangChain as a blockchain platform. Blockchain is a technology that stores data in a decentralized manner using chained blocks, so the models’ responses sound plausible given the “chain” in the name. However, LangChain is not actually a blockchain-based technology.</p>\n<p>This is a prime example demonstrating how LLMs will fabricate responses that may seem believable at first glance but are incorrect. LLMs are designed to predict the next “plausible” tokens in a sequence, whether those are words, subwords, or characters. They don’t inherently understand the full meaning of the text. Even the most advanced models struggle to avoid made-up responses, especially for niche topics they lack knowledge about.</p>\n<p>Let’s look at another example by querying: <em>“What is the most preferred framework used by developers for building applications leveraging large language models?”</em></p>\n<p><img src=\"https://files.smashing.media/articles/guide-retrieval-augmented-generation-language-models/8-vicuna-gpt4-responses.png\" /></p>\n<p>While Vicuna offers a couple of reasonable starting points for answering the question, the frameworks it refers to have limitations for efficiency and scalability in production-level applications that use LLMs. That could quite possibly send a developer down a bad path. And as bad as that is, look at the GPT-4 response that changes topics completely by focusing on LLVM, which has nothing to do with LLMs.</p>\n<p>What if we refine the question, but this time querying different language models? This time, we’re asking: “What is the go-to framework developed for developers to seamlessly integrate large language models into their applications, focusing on ease of use and enhanced capabilities?”</p>\n<p><img src=\"https://files.smashing.media/articles/guide-retrieval-augmented-generation-language-models/9-hallucinated-chats-gpt.png\" /></p>\n<p>Honestly, I was expecting the responses to refer to some current framework, like LangChain. However, the GPT-4 Turbo model suggests the “Hugging Face” transformer library, which I believe is a great place to experiment with AI development but is not a framework. If anything, it’s a place where you could conceivably find tiny frameworks to play with.</p>\n<p>Meanwhile, the GPT-3.5 Turbo model produces a much more confusing response, talking about <a href=\"https://openai.com/blog/openai-codex\">OpenAI</a> <a href=\"https://openai.com/blog/openai-codex\">Codex</a> as a framework, then as a language model. Which one is it?</p>\n<p>We could continue producing examples of LLM hallucinations and inaccurate responses and have fun with the results all day. We could also spend a lot of time identifying and diagnosing what causes hallucinations. But we’re here to talk about RAG and <em>how</em> to use it to prevent hallucinations from happening in the first place. The Master of Code Global blog has an <a href=\"https://masterofcode.com/blog/hallucinations-in-llms-what-you-need-to-know-before-integration\">excellent primer on the causes and types of LLM hallucinations</a> with lots of useful context if you are interested in diving deeper into the diagnoses.</p>\n<p><img src=\"https://files.smashing.media/articles/guide-retrieval-augmented-generation-language-models/10-llm-hallucinations.png\" /></p>\nIntegrating RAG With Language Models\n<p>OK, so we know that LLMs sometimes “hallucinate” answers. We know that hallucinations are often the result of outdated information. We also know that there is this thing called Retrieval Augmented Generation that supplements LLMs with updated information.</p>\n<p>But how do we connect RAG and LLMs together?</p>\n<p>Now that you have a good understanding of RAG and its benefits, we can dive into how to implement it yourself. This section will provide hands-on examples to show you how to code RAG systems and feed new data into your LLM.</p>\n<p>But before jumping right into the code, you’ll need to get a few key things set up: </p>\n<ul>\n<li><a href=\"https://huggingface.co/docs/hub/models-libraries\"><strong>Hugging Face</strong></a><br />We’ll use this library in two ways. First, to choose an embedding model from the model hub that we can use to encode our texts, and second, to get an access token so we can download the Llama-2 model. Sign up for a free Hugging Face in preparation for the work we’ll cover in this article.</li>\n<li><a href=\"https://ai.meta.com/llama/\"><strong>Llama-2</strong></a><br />Meta’s powerful LLM will be our generator model. <a href=\"https://ai.meta.com/resources/models-and-libraries/llama-downloads/\">Request access via Meta’s website</a> so we can integrate Llama-2 into our RAG implementation.</li>\n<li><a href=\"https://www.llamaindex.ai/\"><strong>LlamaIndex</strong></a><br />We’ll use this framework to load our data and feed it into Llama-2. </li>\n<li><a href=\"https://www.trychroma.com/\"><strong>Chroma</strong></a><br />We’ll use this embedding database for fast vector similarity search and retrieval. This is actually where we can store our index.</li>\n</ul>\n<p>With the key tools in place, we can walk through examples for each phase: ingesting data, encoding text, indexing vectors, and so on.</p>\n<h3>Install The Libraries</h3>\n<p>We need to install the RAG libraries we identified, which we can do by running the following commands in a new project folder:</p>\n<div>\n<pre><code># Install essential libraries for our project\n!pip install llama-index transformers accelerate bitsandbytes --quiet\n!pip install chromadb sentence-transformers pydantic==1.10.11 --quiet\n</code></pre>\n</div>\n\n<p>Next, we need to import specific modules from those libraries. There are quite a few that we want, like <strong>ChromaVectorStore</strong> and <strong>HuggingFaceEmbedding</strong> for vector indexing and embeddings capabilities, <strong>storageContext</strong> and <strong>chromadb</strong> to provide database and storage functionalities, and even more for computations, displaying outputs, loading language models, and so on. This can go in a file named <code>app.py</code> at the root level of your project.</p>\n<div>\n<pre><code>## app.py\n\n## Import necessary libraries\nfrom llama_index import VectorStoreIndex, download_loader, ServiceContext\nfrom llama_index.vector_stores import ChromaVectorStore\nfrom llama_index.storage.storage_context import StorageContext\nfrom llama_index.embeddings import HuggingFaceEmbedding\nfrom llama_index.response.notebook_utils import display_response\nimport torch\nfrom transformers import BitsAndBytesConfig\nfrom llama_index.prompts import PromptTemplate\nfrom llama_index.llms import HuggingFaceLLM\nfrom IPython.display import Markdown, display\nimport chromadb\nfrom pathlib import Path\nimport logging\nimport sys\n</code></pre>\n</div>\n\n<h3>Provide Additional Context To The Model</h3>\n<p>The data we will leverage for our language model is a research paper titled “<strong>Enhancing LLM Intelligence with ARM-RAG: Auxiliary Rationale Memory for Retrieval Augmented Generation</strong>” (<a href=\"https://arxiv.org/abs/2311.04177\">PDF</a>) that covers an advanced retrieval augmentation generation approach to improve problem-solving performance.</p>\n<p>We will use the <a href=\"https://llamahub.ai/l/file-pdf\"><code>download_loader()</code></a> module we imported earlier from <code>llama_index</code> to download the PDF file:</p>\n<div>\n<pre><code>PDFReader = download_loader(\"PDFReader\")\nloader = PDFReader()\ndocuments = loader.load_data(file=Path('/content/ARM-RAG.pdf'))\n</code></pre>\n</div>\n\n<p>Even though this demonstration uses a PDF file as a data source for the model, that is just one way to supply the model with data. For example, there is <a href=\"https://llamahub.ai/l/papers-arxiv\">Arxiv Papers Loader</a> as well as other loaders available in the <a href=\"https://llamahub.ai/\">LlamaIndex Hub</a>. But for this tutorial, we’ll stick with loading from a PDF. That said, I encourage you to try other ingestion methods for practice!</p>\n<p>Now, we need to download Llama-2, our open-source text generation model from Meta. If you haven’t already, please <a href=\"https://ai.meta.com/resources/models-and-libraries/llama-downloads/\">set up an account with Meta</a> and have your access token available with <code>read</code> permissions, as this will allow us to download Llama-2 from Hugging Face.</p>\n<pre><code># huggingface api token for downloading llama2\nhf_token = \"YOUR Access Token\"\n</code></pre>\n\n<p>To fit Llama-2 into constrained memory, like in <a href=\"https://colab.research.google.com\">Google Colab</a>, we’ll configure <a href=\"https://huggingface.co/blog/4bit-transformers-bitsandbytes\">4-bit quantization</a> to load the model at a lower precision.</p>\n<pre><code>quantization_config = BitsAndBytesConfig(\n  load_in_4bit=True,\n  bnb_4bit_compute_dtype=torch.float16,\n  bnb_4bit_quant_type=\"nf4\",\n  bnb_4bit_use_double_quant=True,\n)\n</code></pre>\n\n<p>Google Colab is where I typically do most of my language model experiments. We’re shrinking the language model down with that last snippet so it’s not too large for Colab to support.</p>\n<p>Next, we need to initialize <a href=\"https://docs.llamaindex.ai/en/latest/api_reference/llms/huggingface.html#\">HuggingFaceLLM</a> to set up our model for generating text on the fly:</p>\n<div>\n<pre><code>llm = HuggingFaceLLM(\n    model_name=\"meta-llama/Llama-2-7b-chat-hf\", \n    tokenizer_name=\"meta-llama/Llama-2-7b-chat-hf\",\n    query_wrapper_prompt=PromptTemplate(\"&lt;s&gt; [INST] {query_str} [/INST] \"),\n    context_window=3900,\n    model_kwargs={\"token\": hf_token, \"quantization_config\": quantization_config},\n    tokenizer_kwargs={\"token\": hf_token},\n    device_map=\"auto\",\n)\n</code></pre>\n</div>\n\n<p>Note that what’s happening here is that we’ve defined our model (Llama-2), but a specific subset of it is designed for a chat UI (Llama-2-Chat). Even though this is what we are using for this article, you can also pick from <a href=\"https://huggingface.co/models?pipeline_tag=text-generation&amp;sort=trending\">other text generation models in the Hugging Face hub</a>, such as <a href=\"https://huggingface.co/Intel/neural-chat-7b-v3-1\">Neural-chat</a> from Intel.</p>\n<h3>Compare Outputs</h3>\n<p>OK, so we have the model loaded and configured. Let’s try it out by asking it questions that it could reasonably answer using the content we provided via the ARM-RAG PDF file to see how the model responds without any context. The following code is for displaying the text output <em>without</em> the PDF providing data to the model for comparison sake:</p>\n<div>\n<pre><code>from IPython.display import HTML, display\n\n# Assuming resp contains the response\nresp = llm.complete(\"What is ARM-RAG?\")\n\n# Using HTML with inline CSS for styling (gray color, smaller font size)\nhtml_text = f'&lt;p style=\"color: #1f77b4; font-size: 14px;\"&gt;&lt;b&gt;{resp}&lt;/b&gt;&lt;/p&gt;'\n</code></pre>\n</div>\n\n<p>Let’s see the response:</p>\n<div>\n<pre><code>display(HTML(html_text))\n\nARM-RAG (ARM Register-Allocating Generator) is a register allocation algorithm used in compiler design. nobody knows who invented it, but it was first described in a 1995 paper by Mark H. T. Kim and Andrew Y. Chen. The ARM-RAG algorithm is a register-allocating generator, meaning it is a heuristic algorithm that takes a program as input and generates a register allocation plan for it. The goal of the algorithm is to assign registers to variables in a way that minimizes the number of spills (i.e., loads or stores to/from memory) while satisfying all the memory access constraints of the program. The ARM-RAG algorithm works by first partitioning the program into a set of basic blocks, and then iteratively allocating registers to variables within each basic block. The algorithm uses a cost function to evaluate the quality of each allocation, and it selects the allocation with the lowest cost. The cost function takes into account factors such as the distance between the variable and the current register, the distance between the variable and the next allocation, and the number of spills that would be required to allocate the variable. ARM-RAG\n</code></pre>\n</div>\n\n<p>Obviously, without any context from the PDF file, the model generates a hallucinated response that describes some unrelated algorithm. To fix this, we need to provide relevant passages from the paper to ground Llama-2’s responses. We’ll encode the document into embeddings and index them for retrieval; then, when we query, we can feed LLama-2 relevant retrieved passages to steer it toward accurate, on-topic responses based on the contents of the PDF file.</p>\n<p>First, we need to create a client to interact with our ChromaDB database and a new collection that will hold our vector index.</p>\n<div>\n<pre><code># create client and a new collection\nchroma_client = chromadb.EphemeralClient()\nchroma_collection = chroma_client.create_collection(\"firstcollection\")\n</code></pre>\n</div>\n\n<p>Then we need to set up the <a href=\"https://docs.llamaindex.ai/en/stable/examples/embeddings/huggingface.html#huggingfaceembedding\"><code>HuggingFaceEmbedding</code></a> class with the specified model name for embedding the text into vectors:</p>\n<div>\n<pre><code># Load the embedding model\nembed_model = HuggingFaceEmbedding(model_name=\"BAAI/bge-base-en-v1.5\")\n</code></pre>\n</div>\n\n<p>This initializes <code>HuggingFaceEmbedding</code>, passing the name of the pre-trained model we want to use, <a href=\"https://huggingface.co/BAAI/bge-base-en-v1.5\">BAAI/bge-base-en-v1.5</a>. There are <a href=\"https://huggingface.co/spaces/mteb/leaderboard\">other options</a>, of course.</p>\n<p>Now, we can set up the vector store and use it to index the embedded document vectors:</p>\n<div>\n<pre><code># set up ChromaVectorStore and load in data\nvector_store = ChromaVectorStore(chroma_collection=chroma_collection)\nstorage_context = StorageContext.from_defaults(vector_store=vector_store)\nservice_context = ServiceContext.from_defaults(llm=llm, embed_model=embed_model)\nindex = VectorStoreIndex.from_documents(\n  documents, storage_context=storage_context, service_context=service_context\n)\n</code></pre>\n</div>\n\n<p>This creates a <code>ChromaVectorStore</code> connected to our collection, defines the storage and service contexts, and generates a <a href=\"https://docs.llamaindex.ai/en/stable/module_guides/indexing/vector_store_guide.html\"><code>VectorStoreIndex</code></a> from the loaded documents using the embedding model. The index is what allows us to quickly find relevant passages for a given query to augment the quality of the model’s response.</p>\n<p>We should also establish a way for the model to summarize the data rather than spitting everything out at once. A <code>SummaryIndex</code> offers efficient summarization and retrieval of information:</p>\n<div>\n<pre><code>summary_index = SummaryIndex.from_documents(documents, service_context=service_context)\n</code></pre>\n</div>\n\n<p>Earlier, the model hallucinated when we queried it without the added context from the PDF file. Now, let’s ask the same question, this time querying our indexed data:</p>\n<div>\n<pre><code>#Define your query\nquery=\"what is ARM-RAG?\"\n\nfrom llama_index.embeddings.base import similarity\nquery_engine =index.as_query_engine(response_mode=\"compact\")\nresponse = query_engine.query(query)\nfrom IPython.display import HTML, display\n\n# Using HTML with inline CSS for styling (blue color)\nhtml_text = f'&lt;p style=\"color: #1f77b4; font-size: 14px;\"&gt;&lt;b&gt;{response}&lt;/b&gt;&lt;/p&gt;'\ndisplay(HTML(html_text))\n</code></pre>\n</div>\n\n<p>Here’s the output:</p>\n<div>\n<pre><code>Final Response: Based on the context information provided, ARM-RAG is a system that utilizes Neural Information Retrieval to archive reasoning chains derived from solving grade-school math problems. It is an Auxiliary Rationale Memory for Retrieval Augmented Generation, which aims to enhance the problem-solving capabilities of Large Language Models (LLMs). The system surpasses the performance of a baseline system that relies solely on LLMs, demonstrating the potential of ARM-RAG to improve problem-solving capabilities.\n</code></pre>\n</div>\n\n<p><em>Correct!</em> This response is way better than the one we saw earlier — no hallucinations here.</p>\n<p>Since we’re using the chat subset of the Llama-2 model, we could have a back-and-forth conversation with the model about the content of the PDF file with follow-up questions. That’s because the indexed data supports NLP.</p>\n<div>\n<pre><code>chat_engine = index.as_chat_engine(chat_mode=\"condense_question\", verbose=True)\nresponse = chat_engine.chat(\"give me real world examples of apps/system i can build leveraging ARM-RAG?\")\nprint(response)\n</code></pre>\n</div>\n\n<p>This is the resulting output:</p>\n<div>\n<pre><code>Querying with: What are some real-world examples of apps or systems that can be built leveraging the ARM-RAG framework, which was discussed in our previous conversation?\nBased on the context information provided, the ARM-RAG framework can be applied to various real-world examples, including but not limited to:\n\n1. Education: ARM-RAG can be used to develop educational apps that can help students learn and understand complex concepts by generating explanations and examples that can aid in their understanding.\n\n2. Tutoring: ARM-RAG can be applied to tutoring systems that can provide personalized explanations and examples to students, helping them grasp difficult concepts more quickly and effectively.\n\n3. Customer Service: ARM-RAG can be utilized in chatbots or virtual assistants to provide customers with detailed explanations and examples of products or services, enabling them to make informed decisions.\n\n4. Research: ARM-RAG can be used in research environments to generate explanations and examples of complex scientific concepts, enabling researchers to communicate their findings more effectively to a broader audience.\n\n5. Content Creation: ARM-RAG can be applied to content creation systems that can generate explanations and examples of complex topics, such as news articles, blog posts, or social media content, making them more engaging and easier\n</code></pre>\n</div>\n\n<p>Try asking more questions! Now that the model has additional context to augment its existing dataset, we can have a more productive — and natural — interaction.</p>\nAdditional RAG Tooling Options\n<p>The whole point of this article is to explain the concept of RAG and demonstrate how it can be used to enhance a language model with accurate and updated data.</p>\n<p>Chroma and LlamaIndex were the main components of the demonstrated RAG approach, but there are other tools for integrating RAG with language models. I’ve prepared a table that outlines some popular options you might consider trying with your own experiments and projects.</p>\n<table>\n    <thead>\n        <tr>\n            <th>RAG</th>\n            <th>Type of System</th>\n      <th>Capabilities</th>\n      <th>Integrations</th>\n      <th>Documentation / Repo</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td><a href=\"https://weaviate.io/\">Weaviate</a></td>\n            <td>Vector Database</td>\n      <td>Vector &amp; Generative search</td>\n      <td>LlamaIndex, LangChain, Hugging Face, Cohere, OpenAI, etc.</td>\n      <td><ul><li><a href=\"https://weaviate.io/developers/weaviate\">Documentation</a></li><li><a href=\"https://github.com/weaviate/weaviate\">GitHub</a></li></ul></td>\n        </tr>\n        <tr>\n            <td><a href=\"https://www.pinecone.io/\">Pinecone</a></td>\n            <td>Vector Database</td>\n      <td>Vector search, NER-Powered search, Long-term memory</td>\n      <td><a href=\"https://docs.pinecone.io/docs/openai\">OpenAI</a>, <a href=\"https://docs.pinecone.io/docs/langchain\">LangChain</a>, <a href=\"https://docs.pinecone.io/docs/cohere\">Cohere</a>, <a href=\"https://docs.pinecone.io/docs/databricks\">Databricks</a></td>\n      <td><ul><li><a href=\"https://docs.pinecone.io/\">Documentation</a></li><li><a href=\"https://github.com/pinecone-io\">GitHub</a></li></ul></td>\n        </tr>\n        <tr>\n            <td>txtai</td>\n            <td>Embeddings Database</td>\n      <td>Semantic graph &amp; search, Conversational search</td>\n      <td>Hugging face models</td>\n      <td><ul><li><a href=\"https://neuml.github.io/txtai/\">Documentation</a></li><li><a href=\"https://github.com/neuml/txtai\">GitHub</a></li></ul></td>\n        </tr>\n    <tr>\n            <td><a href=\"https://qdrant.tech/\">Qdrant</a></td>\n            <td>Vector Database</td>\n      <td>Similarity image search, Semantic search, Recommendations</td>\n      <td><a href=\"https://qdrant.tech/documentation/integrations/langchain/\">LangChain</a>, <a href=\"https://qdrant.tech/documentation/integrations/llama-index/\">LlamaIndex</a>, <a href=\"https://qdrant.tech/documentation/integrations/docarray/\">DocArray</a>, <a href=\"https://qdrant.tech/documentation/integrations/haystack/\">Haystack</a>, <a href=\"https://qdrant.tech/documentation/integrations/txtai/\">txtai</a>, <a href=\"https://qdrant.tech/documentation/integrations/fifty-one/\">FiftyOne</a>, <a href=\"https://qdrant.tech/documentation/integrations/cohere/\">Cohere</a>, <a href=\"https://qdrant.tech/documentation/integrations/jina-embeddings/\">Jina Embeddings</a>, <a href=\"https://qdrant.tech/documentation/integrations/openai/\">OpenAI</a></td>\n      <td><ul><li><a href=\"https://qdrant.tech/documentation/\">Documentation</a></li><li><a href=\"https://github.com/qdrant/qdrant\">GitHub</a></li></ul></td>\n        </tr>\n    <tr>\n            <td><a href=\"https://haystack.deepset.ai/\">Haystack</a></td>\n            <td>Framework</td>\n      <td>QA, Table QA, Document search, Evaluation</td>\n      <td><a href=\"https://haystack.deepset.ai/integrations/elasticsearch-document-store\">Elasticsearch</a>, <a href=\"https://haystack.deepset.ai/integrations/pinecone-document-store\">Pinecone</a>, <a href=\"https://haystack.deepset.ai/integrations/qdrant-document-store\">Qdrant</a>, <a href=\"https://haystack.deepset.ai/integrations/weaviate-document-store\">Weaviate</a>, <a href=\"https://haystack.deepset.ai/integrations/vllm\">vLLM</a>, <a href=\"https://haystack.deepset.ai/integrations/cohere\">Cohere</a></td>\n      <td><ul><li><a href=\"https://docs.haystack.deepset.ai/docs\">Documentation</a></li><li><a href=\"https://github.com/deepset-ai\">GitHub</a></li></ul></td>\n        </tr>\n    <tr>\n            <td>Ragchain</td>\n            <td>Framework</td>\n      <td>Reranking, OCR loaders</td>\n      <td>Hugging Face, OpenAI, Chroma, Pinecone</td>\n      <td><ul><li><a href=\"https://nomadamas.gitbook.io/ragchain-docs/\">Documentation</a></li><li><a href=\"https://github.com/NomaDamas/RAGchain\">GitHub</a></li></ul></td>\n        </tr>\n    <tr>\n            <td><a href=\"https://www.getmetal.io/\">metal</a></td>\n            <td>Vector Database</td>\n      <td>Clustering, Semantic search, QA</td>\n      <td><a href=\"https://python.langchain.com/docs/integrations/retrievers/metal\">LangChain</a>, <a href=\"https://gpt-index.readthedocs.io/en/latest/examples/vector_stores/MetalIndexDemo.html\">LlamaIndex</a></td>\n      <td><ul><li><a href=\"https://docs.getmetal.io/introduction/introduction\">Documentation</a></li><li><a href=\"https://github.com/getmetal/Metal\">GitHub</a></li></ul></td>\n        </tr>\n    </tbody>\n</table>\n\nConclusion\n<p>In this article, we examined examples of language models producing “hallucinated” responses to queries as well as possible causes of those hallucinations. At the end of the day, a <strong>language model’s responses are only as good as the data it provided</strong>, and as we’ve seen, even the most widely used models consist of outdated information. And rather than admit defeat, the language model spits out confident guesses that could be misconstrued as accurate information.</p>\n<p>Retrieval Augmented Generation is one possible cure for hallucinations.</p>\n<p>By embedding text vectors pulled from additional sources of data, a language model’s existing dataset is augmented with not only new information but the ability to query it more effectively with a semantic search that helps the model more broadly interpret the meaning of a query.</p>\n<p>We did this by registering a PDF file with the model that contains content the model could use when it receives a query on a particular subject, in this case, “Enhancing LLM Intelligence with ARM-RAG: Auxiliary Rationale Memory for Retrieval Augmented Generation.”</p>\n<p>This, of course, was a rather simple and contrived example. I wanted to focus on the concept of RAG more than its capabilities and stuck with a single source of new context around a single, specific subject so that we could easily compare the model’s responses before and after implementing RAG.</p>\n<p>That said, there are some good next steps you could take to level up your understanding:</p>\n<ul>\n<li>Consider using <strong>high-quality data and embedding models</strong> for better RAG performance.</li>\n<li><strong>Evaluate the model you use</strong> by checking <a href=\"https://github.com/vectara/hallucination-leaderboard/\">Vectara’s hallucination leaderboard</a> and <a href=\"https://huggingface.co/vectara/hallucination_evaluation_model\">consider using their model</a> instead. The quality of the model is essential, and referencing the leaderboard can help you avoid models known to hallucinate more often than others.</li>\n<li><strong>Try refining your retriever and generator</strong> to improve results.</li>\n</ul>\n<p>My previous articles on <a href=\"https://www.smashingmagazine.com/2023/10/overview-large-language-model-concepts-use-cases-tools/\">LLM concepts</a> and <a href=\"https://www.smashingmagazine.com/2023/07/artificial-intelligence-machine-learning-summarize-chat-conversations/\">summarizing chat conversations</a> are also available to help provide even more context about the components we worked with in this article and how they are used to produce high-quality responses.</p>\n<h3>References</h3>\n<ul>\n<li><a href=\"https://docs.llamaindex.ai/en/stable/\">LlamaIndex documentation</a></li>\n<li><a href=\"https://docs.trychroma.com/getting-started\">ChromaDB documentation</a></li>\n<li><a href=\"https://ai.meta.com/resources/models-and-libraries/llama-downloads/\">Metas Llama-2 access</a></li>\n<li><a href=\"https://arxiv.org/abs/2311.04177\">ARM-RAG research paper</a></li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"7fc458d8a7312d5149359cbf04ef8c5bf68daaa0a3d39d40313a3ea672b3ece5","category":"Tech"}