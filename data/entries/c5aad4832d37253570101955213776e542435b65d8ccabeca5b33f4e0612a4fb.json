{"title":"สรุปแนวทางในการติดต่อสื่อสารระหว่าง Module","link":"https://www.somkiat.cc/communication-modular-monolith/","date":1724419839000,"content":"<p><img width=\"150\" height=\"150\" src=\"https://www.somkiat.cc/wp-content/uploads/2024/08/module-03-150x150.jpg\" loading=\"lazy\" srcset=\"https://www.somkiat.cc/wp-content/uploads/2024/08/module-03-150x150.jpg 150w, https://www.somkiat.cc/wp-content/uploads/2024/08/module-03-75x75.jpg 75w\" /></p>\n<figure><a href=\"https://www.somkiat.cc/wp-content/uploads/2024/08/module-03.jpg\"><img src=\"https://www.somkiat.cc/wp-content/uploads/2024/08/module-03.jpg\" width=\"679\" height=\"381\" /></a></figure>\n\n\n\n<p>จากการแบ่งปันเรื่องของ Software Architecture ทั้ง Monolith, SOA และ Microservice นั้น<br />คำถามที่เจอบ่อย ๆ คือ การจัดการให้ service หนึ่ง ๆ เป็น module/component ให้มันดีก่อน<br />แต่เมื่อมีการติดต่อสื่อสารกันระหว่าง module แล้ว<br />จะจัดการ หรือ เลือกแนวทางไหนดี<br />หนึ่งในแนวทางที่เคยอธิบายไว้แล้วคือ <a href=\"https://www.somkiat.cc/better-modular/\" target=\"_blank\">ผ่านตัวกลาง หรือ การติดต่อแบบ indect</a></p>\n\n\n\n<span></span>\n\n\n\n<p>แต่ก็ยังมีวิธีการอื่น ๆ ในการจัดการ จึงสรุปแบบสั้น ๆ ไว้นิดหน่อย<br />โดยแต่ละวิธีก็มีข้อดีและข้อเสียต่างกันไป<br />ลองเรียนรู้ และ พิจารณากันดูครับ</p>\n\n\n\n<p><strong>แบบที่ 1 เรียกกันตรง ๆ ไปเลย</strong></p>\n\n\n\n<p>โดยปกติก็ reference ผ่าน code ตรง ๆ ไปเลย<br />แต่ผลที่ตามมาคือ แต่ละ module ผู้มัดกันไปหมดเลย<br />หาขอบเขตได้ยากมาก ๆ</p>\n\n\n\n<p>ดังนั้นถ้าเรียกตรง ๆ แบบนี้ ต้องจัดการให้ดี <br />เช่น การสร้าง public interface ของ module นั้น ๆ ขึ้นมา<br />ถ้าหลักการของ design pattern จะเรียกว่า <a href=\"https://refactoring.guru/design-patterns/facade\" target=\"_blank\">facade pattern</a></p>\n\n\n\n<p>หรือบ่อยครั้งจะเห็นว่า ติดต่อผ่านระบบ network กันไปเลย<br />นั่นคือ แต่ละ module ทำงานอยู่ต่าง process กัน<br />เช่นการติดต่อผ่าน HTTP protocol เป็นต้น<br />อาจะใช้รูปแบบของ RESTFul API และ gRPC เป็นต้น<br />แต่ต้องระวังด้วย เพราะว่าการติดต่อผ่านระบบ network มันพร้อมพังมาก ๆ<br />ต้องระมัดระวังให้ดี<br />Plan for fail ต้องมาแล้วนะ</p>\n\n\n\n<p><strong>แบบที่สอง แบบไม่เรียกตรง ๆ (indirect) หรือ มีคนกลางนั่นเอง</strong></p>\n\n\n\n<p>เป็นเหมือนการเพิ่ม hop เข้ามา เช่น</p>\n\n\n\n<ul>\n<li>Gateway ตรงกลาง</li>\n\n\n\n<li>Event-based ผ่าน memory, messaging server</li>\n\n\n\n<li>File system แล้วสร้าง batch process มาทำงานตามเวลาที่เราต้องการ</li>\n</ul>\n\n\n\n<p>แน่นอนว่า วิธีการนี้ทำให้แต่ละ module ผูกมัดกันน้อยลง<br />แต่ความซับซ้อนก็สูงขึ้นเช่นเดียวกัน<br />ก็ต้องระมัดระวังเช่นเดียวกัน</p>\n\n\n\n<p><strong><em>ลองดูว่า การติดต่อสื่อสารระหว่าง module ของระบบงานควรเป็นอย่างไร<br />เลือกให้เหมาะสมกับงาน คน เวลา<br />ขอให้สนุกกับการ coding ครับ</em></strong></p>\n","author":"somkiat","siteTitle":"cc :: somkiat","siteHash":"3a23a5a4389e1e40c6fbb16520a8cc20df5b3591c25145ce72aaa18b19e48201","entryHash":"c5aad4832d37253570101955213776e542435b65d8ccabeca5b33f4e0612a4fb","category":"Thai"}