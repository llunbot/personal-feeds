{"title":"Creating An Accessible Dialog From Scratch","link":"https://smashingmagazine.com/2021/07/accessible-dialog-from-scratch/","date":1627470000000,"content":"<p>First of all, don’t do this at home. Do not write your own dialogs or a library to do so. There are plenty of them out there already that have been tested, audited, used and reused and you should prefer these ones over your own. <a href=\"https://a11y-dialog.netlify.app/\">a11y-dialog</a> is one of them, but there are more (listed at the end of this article).</p>\n<p>Let me take this post as an opportunity to remind you all to <strong>be cautious when using dialogs</strong>. It is tentalizing to address all design problems with them, especially on mobile, but there often are other ways to overcome design issues. We tend to quickly fall into using dialogs not because they are necessarily the right choice but because they are easy. They set aside screen estate problems by trading them for context switching, which is not always the right trade-off. The point is: consider whether a dialog is the right design pattern before using it.</p>\n<p>In this post, we’re going to write <strong>a small JavaScript library for authoring accessible dialogs</strong> from the very beginning (essentially recreating a11y-dialog). The goal is to understand what goes into it. We’re not going to deal with styling too much, just the JavaScript part. We will use modern JavaScript for sake of simplicity (such as classes and arrow functions), but keep in mind that this code might not work in legacy browsers.</p>\n<ol>\n<li><a href=\"#defining-the-api\">Defining the API</a></li>\n<li><a href=\"#instantiating-the-dialog\">Instantiating the dialog</a></li>\n<li><a href=\"#showing-and-hiding\">Showing and hiding</a></li>\n<li><a href=\"#closing-with-overlay\">Closing with overlay</a></li>\n<li><a href=\"#closing-with-escape\">Closing with escape</a></li>\n<li><a href=\"#trapping-focus\">Trapping focus</a></li>\n<li><a href=\"#maintaining-focus\">Maintaining focus</a></li>\n<li><a href=\"#restoring-focus\">Restoring focus</a></li>\n<li><a href=\"#giving-an-accessible-name\">Giving an accessible name</a></li>\n<li><a href=\"#handling-custom-events\">Handling custom events</a></li>\n<li><a href=\"#cleaning-up\">Cleaning up</a></li>\n<li><a href=\"#bringing-it-all-together\">Bring it all together</a></li>\n<li><a href=\"#wrapping-up\">Wrapping up</a></li>\n</ol>\nDefining The API\n<p>First, we want to define how we’re going to use our dialog script. We are going to keep it as simple as possible to begin with. We give it the root HTML element for our dialog, and the instance we get has a <code>.show(..)</code> and a <code>.hide(..)</code> method.</p>\n<pre><code>class Dialog {\n  constructor(element) {}\n  show() {}\n  hide() {}\n}\n</code></pre>\n\nInstantiating The Dialog\n<p>Let’s say we have the following HTML:</p>\n<pre><code>&lt;div id=\"my-dialog\"&gt;This will be a dialog.&lt;/div&gt;\n</code></pre>\n\n<p>And we instantiate our dialog like this:</p>\n<pre><code>const element = document.querySelector('#my-dialog')\nconst dialog = new Dialog(element)\n</code></pre>\n\n<p>There are a few things we need to do under the hood when instantiating it:</p>\n<ul>\n<li>Hide it so it’s hidden by default (<code>hidden</code>).</li>\n<li>Mark it as a dialog for assistive technologies (<code>role=\"dialog\"</code>).</li>\n<li>Make the rest of the page inert when open (<code>aria-modal=\"true\"</code>).</li>\n</ul>\n<pre><code>constructor (element) {\n  // Store a reference to the HTML element on the instance so it can be used\n  // across methods.\n  this.element = element\n  this.element.setAttribute('hidden', true)\n  this.element.setAttribute('role', 'dialog')\n  this.element.setAttribute('aria-modal', true)\n}\n</code></pre>\n\n<p>Note that we could have added these 3 attributes in our initial HTML not to have to add them with JavaScript, but this way it’s out of sight, out of mind. Our script can make sure things will work as they should, regardless of whether we’ve thought about adding all our attributes or not.</p>\nShowing And Hiding\n<p>We have two methods: one to show the dialog and one to hide it. These methods won’t do much (for now) besides toggling the <code>hidden</code> attribute on the root element. We’re also going to maintain a boolean on the instance to quickly be able to assess if the dialog is shown or not. This will come in handy later.</p>\n<pre><code>show() {\n  this.isShown = true\n  this.element.removeAttribute('hidden')\n}\n\nhide() {\n  this.isShown = false\n  this.element.setAttribute('hidden', true)\n}\n</code></pre>\n\n<p>To avoid the dialog being visible before JavaScript kicks in and hides it by adding the attribute, it might be interesting to add <code>hidden</code> to the dialog directly in the HTML from the get go.</p>\n<pre><code>&lt;div id=\"my-dialog\" hidden&gt;This will be a dialog.&lt;/div&gt;\n</code></pre>\n\nClosing With Overlay\n<p>Clicking outside of the dialog should close it. There are several ways to do so. One way could be to listen to all click events on the page and filter out those happening within the dialog, but that’s relatively complex to do.</p>\n<p>Another approach would be to listen to click events on the overlay (sometimes called “backdrop”). The overlay itself can be as simple as a <code>&lt;div&gt;</code> with some styles.</p>\n<p>So when opening the dialog, we need to bind click events on the overlay. We could give it an ID or a certain class to be able to query it, or we could give it a data attribute. I tend to favor these for behavior hooks. Let’s modify our HTML accordingly:</p>\n<pre><code>&lt;div id=\"my-dialog\" hidden&gt;\n  &lt;div data-dialog-hide&gt;&lt;/div&gt;\n  &lt;div&gt;This will be a dialog.&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n\n<p>Now, we can query the elements with the <code>data-dialog-hide</code> attribute within the dialog and give them a click listener that hides the dialog.</p>\n<pre><code>constructor (element) {\n  // … rest of the code\n  // Bind our methods so they can be used in event listeners without losing the\n  // reference to the dialog instance\n  this._show = this.show.bind(this)\n  this._hide = this.hide.bind(this)\n\n  const closers = [...this.element.querySelectorAll('[data-dialog-hide]')]\n  closers.forEach(closer =&gt; closer.addEventListener('click', this._hide))\n}\n</code></pre>\n\n<p>The nice thing about having something quite generic like this is that we can use the same thing for the close button of the dialog as well.</p>\n<pre><code>&lt;div id=\"my-dialog\" hidden&gt;\n  &lt;div data-dialog-hide&gt;&lt;/div&gt;\n  &lt;div&gt;\n    This will be a dialog.\n    &lt;button type=\"button\" data-dialog-hide&gt;Close&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n\n\n\nClosing With Escape\n<p>Not only should the dialog be hidden when clicking outside of it, but it also should be hidden when pressing Esc. When opening the dialog, we can bind a keyboard listener to the document, and remove it when closing it. This way, it only listens to key presses while the dialog is open instead of all the time.</p>\n<pre><code>show() {\n  // … rest of the code\n  // Note: `_handleKeyDown` is the bound method, like we did for `_show`/`_hide`\n  document.addEventListener('keydown', this._handleKeyDown)\n}\n\nhide() {\n  // … rest of the code\n  // Note: `_handleKeyDown` is the bound method, like we did for `_show`/`_hide`\n  document.removeEventListener('keydown', this._handleKeyDown)\n}\n\nhandleKeyDown(event) {\n  if (event.key === 'Escape') this.hide()\n}\n</code></pre>\n\n\n\nTrapping Focus\n<p>Now that’s the good stuff. Trapping the focus within the dialog is kind of at the essence of the whole thing, and has to be the most complicated part (although probably not as complicated as you might think).</p>\n<p>The idea is pretty simple: when the dialog is open, we listen for Tab presses. If pressing Tab on the last focusable element of the dialog, we programmatically move the focus to the first. If pressing Shift + Tab on the first focusable element of the dialog, we move it to the last one.</p>\n<p>The function might look like this:</p>\n<pre><code>function trapTabKey(node, event) {\n  const focusableChildren = getFocusableChildren(node)\n  const focusedItemIndex = focusableChildren.indexOf(document.activeElement)\n  const lastIndex = focusableChildren.length - 1\n  const withShift = event.shiftKey\n\n  if (withShift &amp;&amp; focusedItemIndex === 0) {\n    focusableChildren[lastIndex].focus()\n    event.preventDefault()\n  } else if (!withShift &amp;&amp; focusedItemIndex === lastIndex) {\n    focusableChildren[0].focus()\n    event.preventDefault()\n  }\n}\n</code></pre>\n\n<p>The next thing we need to figure out is how to get all the focusable elements of the dialog (<code>getFocusableChildren</code>). We need to query all the elements that can theoretically be focusable, and then we need to make sure they effectively are.</p>\n<p>The first part can be done with <a href=\"https://github.com/KittyGiraudel/focusable-selectors\">focusable-selectors</a>. It’s a teeny tiny package I wrote which provides this array of selectors:</p>\n<pre><code>module.exports = [\n  'a[href]:not([tabindex^=\"-\"])',\n  'area[href]:not([tabindex^=\"-\"])',\n  'input:not([type=\"hidden\"]):not([type=\"radio\"]):not([disabled]):not([tabindex^=\"-\"])',\n  'input[type=\"radio\"]:not([disabled]):not([tabindex^=\"-\"]):checked',\n  'select:not([disabled]):not([tabindex^=\"-\"])',\n  'textarea:not([disabled]):not([tabindex^=\"-\"])',\n  'button:not([disabled]):not([tabindex^=\"-\"])',\n  'iframe:not([tabindex^=\"-\"])',\n  'audio[controls]:not([tabindex^=\"-\"])',\n  'video[controls]:not([tabindex^=\"-\"])',\n  '[contenteditable]:not([tabindex^=\"-\"])',\n  '[tabindex]:not([tabindex^=\"-\"])',\n]\n</code></pre>\n\n<p>And this is enough to get you 99% there. We can use these selectors to find all focusable elements, and then we can check every one of them to make sure it is actually visible on screen (and not hidden or something).</p>\n<pre><code>import focusableSelectors from 'focusable-selectors'\n\nfunction isVisible(element) {\n  return element =&gt;\n    element.offsetWidth ||\n    element.offsetHeight ||\n    element.getClientRects().length\n}\n\nfunction getFocusableChildren(root) {\n  const elements = [...root.querySelectorAll(focusableSelectors.join(','))]\n\n  return elements.filter(isVisible)\n}\n</code></pre>\n\n<p>We can now update our <code>handleKeyDown</code> method:</p>\n<pre><code>handleKeyDown(event) {\n  if (event.key === 'Escape') this.hide()\n  else if (event.key === 'Tab') trapTabKey(this.element, event)\n}\n</code></pre>\n\nMaintaining Focus\n<p>One thing that’s often overlooked when creating accessible dialogs is making sure the focus remains within the dialog even <em>after</em> the page has lost focus. Think of it this way: <strong>what happens if once the dialog is open?</strong> We focus the URL bar of the browser, and then start tabbing again. Our focus trap is not going to work, since it only preserves the focus within the dialog when it’s inside the dialog to begin with.</p>\n<p>To fix that problem, we can bind a focus listener to the <code>&lt;body&gt;</code> element when the dialog is shown, and move the focus to the first focusable element within the dialog.</p>\n<pre><code>show () {\n  // … rest of the code\n  // Note: `_maintainFocus` is the bound method, like we did for `_show`/`_hide`\n  document.body.addEventListener('focus', this._maintainFocus, true)\n}\n\nhide () {\n  // … rest of the code\n  // Note: `_maintainFocus` is the bound method, like we did for `_show`/`_hide`\n  document.body.removeEventListener('focus', this._maintainFocus, true)\n}\n\nmaintainFocus(event) {\n  const isInDialog = event.target.closest('[aria-modal=\"true\"]')\n  if (!isInDialog) this.moveFocusIn()\n}\n\nmoveFocusIn () {\n  const target =\n    this.element.querySelector('[autofocus]') ||\n    getFocusableChildren(this.element)[0]\n\n  if (target) target.focus()\n}\n</code></pre>\n\n<p>Which element to focus when opening the dialog is not enforced, and it could depend on which type of content the dialog displays. Generally speaking, there are a couple of options:</p>\n<ul>\n<li><strong>Focus the first element.</strong><br />This is what we do here, since it is made easier by the fact that we already have a <code>getFocusableChildren</code> function.</li>\n<li><strong>Focus the close button.</strong><br />This is also a good solution, especially if the button is absolutely positioned relatively to the dialog. We can conveniently make this happen by placing our close button as the first element of our dialog. If the close button lives in the flow of the dialog content, at the very end, it could be a problem if the dialog has a lot of content (and therefore is scrollable), as it would scroll the content to the end on open.</li>\n<li><a href=\"https://github.com/KittyGiraudel/a11y-dialog/issues/169\"><strong>Focus the dialog itself</strong></a>.<br />This is not very common among dialog libraries, but it should also work (although it would require adding <code>tabindex=\"-1\"</code> to it so that’s possible since a <code>&lt;div&gt;</code> element is not focusable by default).</li>\n</ul>\n<p>Note that we check whether there is an element with the <code>autofocus</code> HTML attribute within the dialog, in which case we would move the focus to it instead of the first item. </p>\nRestoring Focus\n<p>We’ve managed to successfully trap the focus within the dialog, but we forgot to move the focus inside the dialog once it opens. Similarly, we need to restore the focus back to the element that had it before the dialog was open.</p>\n<p>When showing the dialog, we can start by keeping a reference to the element that has the focus (<code>document.activeElement</code>). Most of the time, this will be the button that was interacted with to open the dialog, but in rare cases where a dialog is opened programmatically, it could be something else.</p>\n<pre><code>show() {\n  this.previouslyFocused = document.activeElement\n  // … rest of the code\n  this.moveFocusIn()\n}\n</code></pre>\n\n<p>When hiding the dialog, we can move the focus back to that element. We guard it with a condition to avoid a JavaScript error if the element somehow no longer exists (or <a href=\"https://github.com/KittyGiraudel/a11y-dialog/issues/108\">if it was a SVG</a>):</p>\n<pre><code>hide() {\n  // … rest of the code\n  if (this.previouslyFocused &amp;&amp; this.previouslyFocused.focus) {\n    this.previouslyFocused.focus()\n  }\n}\n</code></pre>\n\nGiving An Accessible Name\n<p>It is important our dialog has an accessible name, which is how it will be listed in the accessibility tree. There are a couple of ways to address it, one of which is to define a name in the <code>aria-label</code> attribute, but <a href=\"https://heydonworks.com/article/aria-label-is-a-xenophobe/\"><code>aria-label</code> has issues</a>.</p>\n<p>Another way is to have a title within our dialog (whether hidden or not), and to associate our dialog to it with the <code>aria-labelledby</code> attribute. It might look like this:</p>\n<pre><code>&lt;div id=\"my-dialog\" hidden aria-labelledby=\"my-dialog-title\"&gt;\n  &lt;div data-dialog-hide&gt;&lt;/div&gt;\n  &lt;div&gt;\n    &lt;h1 id=\"my-dialog-title\"&gt;My dialog title&lt;/h1&gt;\n    This will be a dialog.\n    &lt;button type=\"button\" data-dialog-hide&gt;Close&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n\n<p>I guess we could make our script apply this attribute dynamically based on the presence of the title and whatnot, but I’d say this is just as easily solved by authoring proper HTML, to begin with. No need to add JavaScript for that.</p>\nHandling Custom Events\n<p>What if we want to react to the dialog being open? Or closed? There is currently no way to do it, but adding a small event system should not be too difficult. We need a function to register events (let’s call it <code>.on(..)</code>), and a function to unregister them (<code>.off(..)</code>).</p>\n<pre><code>class Dialog {\n  constructor(element) {\n    this.events = { show: [], hide: [] }\n  }\n  on(type, fn) {\n    this.events[type].push(fn)\n  }\n  off(type, fn) {\n    const index = this.events[type].indexOf(fn)\n    if (index &gt; -1) this.events[type].splice(index, 1)\n  }\n}\n</code></pre>\n\n<p>Then when showing and hiding the method, we’ll call all functions that have been registered for that particular event.</p>\n<pre><code>class Dialog {\n  show() {\n    // … rest of the code\n    this.events.show.forEach(event =&gt; event())\n  }\n\n  hide() {\n    // … rest of the code\n    this.events.hide.forEach(event =&gt; event())\n  }\n}\n</code></pre>\n\nCleaning Up\n<p>We might want to provide a method to clean up a dialog in case we’re done using it. It would be responsible for unregistering event listeners so they don’t last more than they should.</p>\n<pre><code>class Dialog {\n  destroy() {\n    const closers = [...this.element.querySelectorAll('[data-dialog-hide]')]\n    closers.forEach(closer =&gt; closer.removeEventListener('click', this._hide))\n\n    this.events.show.forEach(event =&gt; this.off('show', event))\n    this.events.hide.forEach(event =&gt; this.off('hide', event))\n  }\n}\n</code></pre>\n\nBringing It All Together\n<pre><code>import focusableSelectors from 'focusable-selectors'\n\nclass Dialog {\n  constructor(element) {\n    this.element = element\n    this.events = { show: [], hide: [] }\n\n    this._show = this.show.bind(this)\n    this._hide = this.hide.bind(this)\n    this._maintainFocus = this.maintainFocus.bind(this)\n    this._handleKeyDown = this.handleKeyDown.bind(this)\n\n    element.setAttribute('hidden', true)\n    element.setAttribute('role', 'dialog')\n    element.setAttribute('aria-modal', true)\n\n    const closers = [...element.querySelectorAll('[data-dialog-hide]')]\n    closers.forEach(closer =&gt; closer.addEventListener('click', this._hide))\n  }\n\n  show() {\n    this.isShown = true\n    this.previouslyFocused = document.activeElement\n    this.element.removeAttribute('hidden')\n\n    this.moveFocusIn()\n\n    document.addEventListener('keydown', this._handleKeyDown)\n    document.body.addEventListener('focus', this._maintainFocus, true)\n\n    this.events.show.forEach(event =&gt; event())\n  }\n\n  hide() {\n    if (this.previouslyFocused &amp;&amp; this.previouslyFocused.focus) {\n      this.previouslyFocused.focus()\n    }\n\n    this.isShown = false\n    this.element.setAttribute('hidden', true)\n\n    document.removeEventListener('keydown', this._handleKeyDown)\n    document.body.removeEventListener('focus', this._maintainFocus, true)\n\n    this.events.hide.forEach(event =&gt; event())\n  }\n\n  destroy() {\n    const closers = [...this.element.querySelectorAll('[data-dialog-hide]')]\n    closers.forEach(closer =&gt; closer.removeEventListener('click', this._hide))\n\n    this.events.show.forEach(event =&gt; this.off('show', event))\n    this.events.hide.forEach(event =&gt; this.off('hide', event))\n  }\n\n  on(type, fn) {\n    this.events[type].push(fn)\n  }\n\n  off(type, fn) {\n    const index = this.events[type].indexOf(fn)\n    if (index &gt; -1) this.events[type].splice(index, 1)\n  }\n\n  handleKeyDown(event) {\n    if (event.key === 'Escape') this.hide()\n    else if (event.key === 'Tab') trapTabKey(this.element, event)\n  }\n\n  moveFocusIn() {\n    const target =\n      this.element.querySelector('[autofocus]') ||\n      getFocusableChildren(this.element)[0]\n\n    if (target) target.focus()\n  }\n\n  maintainFocus(event) {\n    const isInDialog = event.target.closest('[aria-modal=\"true\"]')\n    if (!isInDialog) this.moveFocusIn()\n  }\n}\n\nfunction trapTabKey(node, event) {\n  const focusableChildren = getFocusableChildren(node)\n  const focusedItemIndex = focusableChildren.indexOf(document.activeElement)\n  const lastIndex = focusableChildren.length - 1\n  const withShift = event.shiftKey\n\n  if (withShift &amp;&amp; focusedItemIndex === 0) {\n    focusableChildren[lastIndex].focus()\n    event.preventDefault()\n  } else if (!withShift &amp;&amp; focusedItemIndex === lastIndex) {\n    focusableChildren[0].focus()\n    event.preventDefault()\n  }\n}\n\nfunction isVisible(element) {\n  return element =&gt;\n    element.offsetWidth ||\n    element.offsetHeight ||\n    element.getClientRects().length\n}\n\nfunction getFocusableChildren(root) {\n  const elements = [...root.querySelectorAll(focusableSelectors.join(','))]\n\n  return elements.filter(isVisible)\n}\n</code></pre>\n\nWrapping Up\n<p>That was quite something, but we eventually got there! Once again, I would advise against rolling out your own dialog library since it’s not the most straightforward and errors could be highly problematic for assistive technology users. But at least now you know how it works under the hood!</p>\n<p>If you need to use dialogs in your project, consider using one of the following solutions (kind reminder that we have our <a href=\"https://www.smashingmagazine.com/2021/03/complete-guide-accessible-front-end-components/#accessible-modals\">comprehensive list of accessible components</a> as well):</p>\n<ul>\n<li>Vanilla JavaScript implementations: <a href=\"https://a11y-dialog.netlify.app\">a11y-dialog</a> by yours truly or <a href=\"https://github.com/scottaohara/accessible_modal_window\">aria-modal-dialog</a> by Scott O’Hara.</li>\n<li>React implementations: <a href=\"https://github.com/KittyGiraudel/react-a11y-dialog\">react-a11y-dialog</a> by yours truly again, <a href=\"https://reach.tech/dialog/\">reach/dialog</a> from the Reach framework, or <a href=\"https://react-spectrum.adobe.com/react-aria/useDialog.html\">@react-aria/dialog</a> from Adobe. You might be interested in <a href=\"https://github.com/KittyGiraudel/react-a11y-dialog/issues/58\">this comparison of the 3 libraries</a>.</li>\n<li>Vue implementations: <a href=\"https://github.com/morkro/vue-a11y-dialog\">vue-a11y-dialog</a> by Moritz Kröger, <a href=\"https://github.com/renatodeleao/a11y-vue-dialog\">a11y-vue-dialog</a> by Renato de Leão.</li>\n</ul>\n<p>Here are more things that could be added but were not for sake of simplicity:</p>\n<ul>\n<li>Support for alert-dialogs via the <code>alertdialog</code> role. Refer to the a11y-dialog <a href=\"https://a11y-dialog.netlify.app/advanced/alert-dialog\">documentation on alert dialogs</a>.</li>\n<li>Locking the ability to scroll while the dialog is open. Refer to the a11y-dialog <a href=\"https://a11y-dialog.netlify.app/advanced/scroll-lock\">documentation on scroll lock</a>.</li>\n<li>Support for the native HTML <code>&lt;dialog&gt;</code> element because it’s sub-par and inconsistent. Refer to the a11y-dialog <a href=\"https://a11y-dialog.netlify.app/advanced/dialog-element\">documentation on the dialog element</a> and <a href=\"https://www.scottohara.me/blog/2019/03/05/open-dialog.html\">this piece by Scott O’hara</a> for more information about why it’s not worth the trouble.</li>\n<li>Support for nested dialogs because it’s questionable. Refer to the a11y-dialog <a href=\"https://a11y-dialog.netlify.app/advanced/nested-dialogs\">documentation on nested dialogs</a>.</li>\n<li>Consideration for closing the dialog on browser navigation. In some cases, it might make sense to close the dialog when pressing the back button of the browser.</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"83a60dd5606305d537bdefc2d7d6fbe71ecef0b37661d4c10ea969d55eeef6eb","category":"Tech"}