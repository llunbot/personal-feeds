{"title":"Client-Side Routing In Next.js","link":"https://smashingmagazine.com/2021/06/client-side-routing-next-js/","date":1624021200000,"content":"<p>Hyperlinks have been one of the jewels of the Web <a href=\"https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Creating_hyperlinks\">since its inception</a> . According to MDN, hyperlinks are what makes the Web, <em>a web.</em> While used for purposes such as linking between documents, its primary use is to reference different web pages identifiable by a unique web address or a <a href=\"https://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_is_a_URL\">URL</a>.</p>\n<p>Routing is an important aspect of each web application as much as hyperlinks are to the Web. It is a mechanism through which requests are routed to the code that handles them. In relation to routing, Next.js pages are referenced and identifiable by a unique URL path. If the Web consists of <strong>navigational</strong> <strong>web pages</strong> interconnected by <strong>hyperlinks</strong>, then each Next.js app consists of route-able pages (route handlers or routes) interconnected by a router.</p>\n<p>Next.js has built-in support for routing that can be unwieldy to unpack, especially when considering rendering and data fetching. As a prerequisite to understanding client-side routing in Next.js, it is necessary to have an overview of concepts like routing, rendering, and data fetching in Next.js.</p>\n<p>This article will be beneficial to React developers who are familiar with Next.js and want to learn how it handles routing. You need to have a working knowledge of React and Next.js to get the most out of the article, which is solely about client-side routing and related concepts in Next.js. </p>\nRouting And Rendering\n<p>Routing and Rendering are complementary to each other and will play a huge part through the course of this article. I like how <a href=\"https://www.pluralsight.com/guides/pros-and-cons-of-client-side-routing-with-react\">Gaurav explains</a> them: </p>\n<blockquote><strong>Routing</strong> is the process through which the user is navigated to different pages on a website.<br /><br /><strong>Rendering</strong> is the process of putting those pages on the UI. Every time you request a route to a particular page, you are also rendering that page, but not every render is an outcome of a route.</blockquote>\n\n<p><a href=\"https://signalvnoise.com/posts/3124-give-it-five-minutes\">Take five minutes</a> to think about that.</p>\n<p>What you need to understand about rendering in Next.js is that each page is <a href=\"https://nextjs.org/docs/basic-features/pages#pre-rendering\">pre-rendered</a> in advance alongside the minimal JavaScript code necessary for it to become fully interactive through a process known as hydration. How Next.js does this is highly dependent on the <a href=\"https://nextjs.org/docs/basic-features/pages#two-forms-of-pre-rendering\">form of pre-rendering</a>: <strong>Static Generation</strong> or <strong>Server-side rendering</strong>, which are both highly coupled to the data fetching technique used, and separated by <strong>when</strong> the HTML for a page is generated.</p>\n<p>Depending on your data fetching requirements, you might find yourself using built-in data fetching functions like <code>getStaticProps</code>, <code>getStaticPaths</code>, or, <code>getServerSideProps</code>, client-side data fetching tools like SWR, react-query, or traditional data fetching approaches like <a href=\"https://reactjs.org/docs/concurrent-mode-suspense.html#approach-1-fetch-on-render-not-using-suspense\">fetch-on-render</a>, <a href=\"https://reactjs.org/docs/concurrent-mode-suspense.html#approach-2-fetch-then-render-not-using-suspense\">fetch-then-render</a>, <a href=\"https://reactjs.org/docs/concurrent-mode-suspense.html#approach-3-render-as-you-fetch-using-suspense\">render-as-you-fetch</a> (with <a href=\"https://reactjs.org/docs/concurrent-mode-suspense.html\">Suspense</a>).</p>\n<p>Pre-rendering (before rendering — <em>to the UI</em>) is complementary to Routing, and highly coupled with data fetching — a whole topic of its own in Next.js. So while these concepts are either complementary or closely related, this article will be solely focused on mere navigation between pages (routing), with references to related concepts where necessary.</p>\n<p>With that out of the way, let’s begin with the fundamental gist: Next.js has a file-system-based router built on the <a href=\"https://nextjs.org/docs/basic-features/pages\">concept of pages</a>.</p>\nPages\n<p>Pages in Next.js are React Components that are automatically available as routes. They are exported as default exports from the pages directory with supported file extensions like <code>.js</code>, <code>.jsx</code>, <code>.ts</code>, or <code>.tsx</code>.</p>\n<p>A typical Next.js app will have a folder structure with top-level directories like <strong>pages</strong>, <strong>public</strong>, and <strong>styles.</strong></p>\n<pre><code>next-app\n├── node_modules\n├── pages\n│   ├── index.js // path: base-url (/)\n│   ├── books.jsx // path: /books\n│   └── book.ts // path: /book\n├── public\n├── styles\n├── .gitignore\n├── package.json\n└── README.md</code></pre>\n\n<p>Each page is a React component:</p>\n<pre><code>// pages/books.js — `base-url/book`\nexport default function Book() {\n  return Books\n}</code></pre>\n\n<p><strong>Note</strong>: <em>Keep in mind that pages can also be referred to as “route handlers”.</em></p>\nCustom Pages\n<p>These are special pages that reside in the <strong>pages</strong> directory but do not participate in routing. They are prefixed with the underscore symbol, as in, <code>_app.js</code>, and <code>_document.js</code>.</p>\n<ul>\n<li><code>_app.js</code><br />This is a custom component that resides in the pages folder. Next.js uses this component to initialize pages.</li>\n<li><code>_document.js</code><br />Like <code>_app.js</code>, <code>_document.js</code> is a custom component that Next.js uses to augment your applications <code>&lt;html&gt;</code> and <code>&lt;body&gt;</code> tags. This is necessary because Next.js pages skip the definition of the surrounding document’s markup. </li>\n</ul>\n<div>\n<pre><code>next-app\n├── node_modules\n├── pages\n│   ├── _app.js // ⚠️ Custom page (unavailable as a route)\n│   ├── _document.jsx // ⚠️ Custom page (unavailable as a route)\n│   └── index.ts // path: base-url (/)\n├── public\n├── styles\n├── .gitignore\n├── package.json\n└── README.md</code></pre>\n</div>\n\nLinking Between Pages\n<p>Next.js exposes a <code>Link</code> component from the <code>next/link</code> API that can be used to perform client-side route transitions between pages.</p>\n<pre><code>// Import the &lt;Link/&gt; component\nimport Link from \"next/link\";\n\n// This could be a page component\nexport default function TopNav() {\n  return (\n    &lt;nav&gt;\n      &lt;Link href=\"/\"&gt;Home&lt;/Link&gt;\n      &lt;Link href=\"/\"&gt;Publications&lt;/Link&gt;\n      &lt;Link href=\"/\"&gt;About&lt;/Link&gt;\n    &lt;/nav&gt;\n  )\n}\n\n// This could be a non-page component\nexport default function Publications() {\n  return (\n    &lt;section&gt;\n      &lt;TopNav/&gt;\n      {/* ... */}\n    &lt;/section&gt;\n  )\n}</code></pre>\n\n<p>The <code>Link</code> component can be used inside any component, page or not. When used in its most basic form as in the example above, the <code>Link</code> component translates to a hyperlink with an <code>href</code> attribute. (More on <code>Link</code> in the next/link section below.)</p>\nRouting\n<p>Next.js file-based routing system can be used to define the most common route patterns. To accommodate for these patterns, each route is separated based on its <em>definition.</em></p>\n<h3>Index Routes</h3>\n<p>By default, in your Next.js app, the initial/default route is <code>pages/index.js</code> which automatically serves as the starting point of your application as <code>/</code>. With a base URL of <code>localhost:3000</code>, this index route can be accessed at the base URL level of the application in the browser.</p>\n<p>Index routes automatically act as the default route for each directory and can eliminate naming redundancies. The directory structure below exposes two route paths: <code>/</code> and <code>/home</code>.</p>\n<pre><code>next-app\n└── pages\n    ├── index.js // path: base-url (/)\n    └── home.js // path: /home</code></pre>\n\n<p>The elimination is more apparent with <strong>nested routes</strong>.</p>\n<h3>Nested Routes</h3>\n<p>A route like <code>pages/book</code> is one level deep. To go deeper is to create nested routes, which requires a nested folder structure. With a base-url of <code>https://www.smashingmagazine.com</code>, you can access the route <code>https://www.smashingmagazine.com/printed-books/printed-books</code> by creating a folder structure similar to the one below:</p>\n<div>\n<pre><code>next-app\n└── pages\n    ├── index.js // top index route\n    └── printed-books // nested route\n        └── printed-books.js // path: /printed-books/printed-books</code></pre>\n</div>\n\n<p>Or eliminate path redundancy with index routes and access the route for printed books at <code>https://www.smashingmagazine.com/printed-books</code>.</p>\n<pre><code>next-app\n└── pages\n    ├── index.js // top index route\n    └── printed-books // nested route\n        └── index.js // path: /printed-books</code></pre>\n\n<p><strong>Dynamic routes</strong> also play an important role in eliminating redundancies.</p>\n<h3>Dynamic Routes</h3>\n<p>From the previous example we use the index route to access all printed books. To access individual books requires either creating different routes for each book like:</p>\n<div>\n<pre><code>// ⚠️ Don't do this.\nnext-app\n└── pages\n    ├── index.js // top index route\n    └── printed-books // nested route\n        ├── index.js // path: /printed-books\n        ├── typesript-in-50-lessons.js // path: /printed-books/typesript-in-50-lessons\n        ├── checklist-cards.js // path: /printed-books/checklist-cards\n        ├── ethical-design-handbook.js // path: /printed-books/ethical-design-handbook\n        ├── inclusive-components.js // path: /printed-books/inclusive-components\n        └── click.js // path: /printed-books/click</code></pre>\n</div>\n\n<p>which is highly redundant, unscalable, and can be remedied with dynamic routes like:</p>\n<pre><code>// ✅ Do this instead.\nnext-app\n└── pages\n    ├── index.js // top index route\n    └── printed-books\n        ├── index.js // path: /printed-books\n        └── [book-id].js // path: /printed-books/:book-id</code></pre>\n\n<p>The bracket syntax — <code>[book-id]</code> — is the <strong>dynamic segment</strong>, and is not limited to files alone. It can also be used with folders like the example below, making the author available at the route <code>/printed-books/:book-id/author</code>.</p>\n<div>\n<pre><code>next-app\n└── pages\n    ├── index.js // top index route\n    └── printed-books\n        ├── index.js // path: /printed-books\n        └── [book-id]\n            └── author.js // path: /printed-books/:book-id/author</code></pre>\n</div>\n\n<p>The dynamic segment(s) of a route is exposed as a query parameter that can be accessed in any of the connecting component involved in the route with <code>query</code> object of the <code>useRouter()</code> hook — (More on this in the next/router API section).</p>\n<pre><code>// printed-books/:book-id\nimport { useRouter } from 'next/router';\n\nexport default function Book() {\n  const { query } = useRouter();\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;\n        book-id &lt;em&gt;{query['book-id']}&lt;/em&gt;\n      &lt;/h1&gt;\n    &lt;/div&gt;\n  );\n}</code></pre>\n\n<div>\n<pre><code>// /printed-books/:book-id/author\nimport { useRouter } from 'next/router';\n\nexport default function Author() {\n  const { query } = useRouter();\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;\n        Fetch author with book-id &lt;em&gt;{query['book-id']}&lt;/em&gt;\n      &lt;/h1&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n</div>\n\n<h3>Extending Dynamic Route Segments With Catch All Routes</h3>\n<p>You’ve seen the dynamic route segment bracket syntax as in the previous example with <code>[book-id].js</code>. The beauty of this syntax is that it takes things even further with <em>Catch-All Routes</em>. You can infer what this does from the name: it catches all routes.</p>\n<p>When we looked at the dynamic example, we learned how it helps eliminate file creation redundancy for a single route to access multiple books with their ID. But there’s something else we could have done.</p>\n<p>Specifically, we had the path <code>/printed-books/:book-id</code>, with a directory structure:</p>\n<pre><code>next-app\n└── pages\n    ├── index.js\n    └── printed-books\n        ├── index.js\n        └── [book-id].js</code></pre>\n\n<p>If we updated the path to have more segments like categories, we might end up with something like: <code>/printed-books/design/:book-id</code>, <code>/printed-books/engineering/:book-id</code>, or better still <code>/printed-books/:category/:book-id</code>.</p>\n<p>Let’s add the release year: <code>/printed-books/:category/:release-year/:book-id</code>. Can you see a pattern? The directory structure becomes:</p>\n<pre><code>next-app\n└── pages\n    ├── index.js\n    └── printed-books\n        └── [category]\n            └── [release-year]\n                └── [book-id].js</code></pre>\n\n<p>We substituted the use of named files for dynamic routes, but somehow still ended up with another form of redundancy. Well, there’s a fix: Catch All Routes that eliminates the need for deeply nested routes:</p>\n<pre><code>next-app\n└── pages\n    ├── index.js\n    └── printed-books\n        └── [...slug].js</code></pre>\n\n<p>It uses the same bracket syntax except that it is prefixed with three dots. Think of the dots like the JavaScript spread syntax. You might be wondering: If I use the catch-all routes, how do I access the category (<code>[category]</code>), and release year (<code>[release-year]</code>). Two ways:</p>\n<ol>\n<li>In the case of the printed-books example, the end goal is the book, and each book info will have its metadata attached with it, or</li>\n<li>The “slug” segments are returned as an array of query parameter(s).</li>\n</ol>\n<div>\n<pre><code>import { useRouter } from 'next/router';\n\nexport default function Book() {\n  const { query } = useRouter();\n  // There's a brief moment where <code>slug</code> is undefined\n  // so we use the Optional Chaining (?.) and Nullish coalescing operator (??)\n  // to check if slug is undefined, then fall back to an empty array\n  const [category, releaseYear, bookId] = query?.slug ?? [];\n\n  return (\n    &lt;table&gt;\n      &lt;tbody&gt;\n        &lt;tr&gt;\n          &lt;th&gt;Book Id&lt;/th&gt;\n          &lt;td&gt;{bookId}&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n          &lt;th&gt;Category&lt;/th&gt;\n          &lt;td&gt;{category}&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n          &lt;th&gt;Release Year&lt;/th&gt;\n          &lt;td&gt;{releaseYear}&lt;/td&gt;\n        &lt;/tr&gt;\n      &lt;/tbody&gt;\n    &lt;/table&gt;\n  );\n}</code></pre>\n</div>\n\n<p>Here’s more example for the route <code>/printed-books/[…slug]</code>:</p>\n<table>\n    <thead>\n        <tr>\n            <th>Path</th>\n            <th>Query parameter</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n      <td><code>/printed-books/click.js</code></td>\n            <td>{ “slug”: [“click”] }</td>\n        </tr>\n        <tr>\n      <td><code>/printed-books/2020/click.js</code></td>\n            <td>{ “slug”: [“2020”, “click”] }</td>\n        </tr>\n        <tr>\n      <td><code>/printed-books/design/2020/click.js</code></td>\n            <td>{ “slug”: [“design”, “2020”, “click”] }</td>\n        </tr>\n    </tbody>\n</table>\n\n<p>As it is with the catch-all route, the route <code>/printed-books</code> will throw a 404 error unless you provide a fallback index route.</p>\n<pre><code>next-app\n└── pages\n    ├── index.js\n    └── printed-books\n        ├── index.js // path: /printed-books\n        └── [...slug].js</code></pre>\n\n<p>This is because the catch-all route is “strict”. It either matches a slug, or it throws an error. If you’d like to avoid creating index routes alongside catch-all routes, you can use the <strong>optional catch-all routes</strong> instead.</p>\n<h3>Extending Dynamic Route Segments With Optional Catch-All Routes</h3>\n<p>The syntax is the same as catch-all-routes, but with double square brackets instead.</p>\n<pre><code>next-app\n└── pages\n    ├── index.js\n    └── printed-books\n        └── [[...slug]].js</code></pre>\n\n<p>In this case, the catch-all route (slug) is optional and if not available, fallbacks to the path <code>/printed-books</code>, rendered with <code>[[…slug]].js</code> route handler, without any query params.</p>\n<blockquote>Use catch-all alongside index routes, or optional catch-all routes alone. Avoid using catch-all and optional catch-all routes alongside.</blockquote>\n\n<h3>Routes Precedence</h3>\n<p>The capability to be able to define the most common routing patterns can be a “black swan”. The possibility of routes clashing is a looming threat, most especially when you start getting dynamic routes worked up.</p>\n<p>When it makes sense to do so, Next.js lets you know about route clashes in the form of errors. When it doesn’t, it applies precedence to routes according to their specificity.</p>\n<p>For example, it is an error to have more than one dynamic route on the same level.</p>\n<div>\n<pre><code>// ❌ This is an error\n// Failed to reload dynamic routes: Error: You cannot use different slug names for the // same dynamic path ('book-id' !== 'id').\nnext-app\n└── pages\n    ├── index.js\n    └── printed-books\n        ├── [book-id].js\n        └── [id].js</code></pre>\n</div>\n\n<p>If you look closely at the routes defined below, you’d notice the potential for clashes. </p>\n<pre><code>// Directory structure flattened for simplicity\nnext-app\n└── pages\n    ├── index.js // index route (also a predefined route)\n    └── printed-books\n        ├── index.js\n        ├── tags.js // predefined route\n        ├── [book-id].js // handles dynamic route\n        └── [...slug].js // handles catch all route</code></pre>\n\n<p>For example, try answering this: what route handles the path <code>/printed-books/inclusive-components</code>?</p>\n<ul>\n<li><code>/printed-books/[book-id].js</code>, or</li>\n<li><code>/printed-books/[…slug].js</code>.</li>\n</ul>\n<p>The answer lies in the “specificity” of the route handlers. Predefined routes come first, followed by dynamic routes, then catch-all routes. You can think of the route request/handling model as a pseudo-code with the following steps:</p>\n<ol>\n<li>Is there is a <strong>predefined route handler</strong> that can handle the route?<ul>\n<li><code>true</code> — handle the route request.</li>\n<li><code>false</code> — go to 2.</li>\n</ul>\n</li>\n<li>Is there a <strong>dynamic route handler</strong> that can handle the route?<ul>\n<li><code>true</code> — handle the route request.</li>\n<li><code>false</code> — go to 3.</li>\n</ul>\n</li>\n<li>Is there a <strong>catch-all route handler</strong> that can handle the route?<ul>\n<li><code>true</code> — handle the route request.</li>\n<li><code>false</code> — throw a 404 page not found.</li>\n</ul>\n</li>\n</ol>\n<p>Therefore, <code>/printed-books/[book-id].js</code> wins.</p>\n<p>Here are more examples:</p>\n<table>\n    <thead>\n        <tr>\n            <th>Route</th>\n            <th>Route handler</th>\n      <th>Type of route</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n      <td><code>/printed-books</code></td>\n            <td><code>/printed-books</code></td>\n      <td>Index route</td>\n        </tr>\n        <tr>\n            <td><code>/printed-books/tags</code></td>\n            <td><code>/printed-books/tags.js</code></td>\n      <td>Predefined route</td>\n        </tr>\n        <tr>\n            <td><code>/printed-books/inclusive-components</code></td>\n            <td><code>/printed-books/[book-id].js</code></td>\n      <td>Dynamic route</td>\n        </tr>\n    <tr>\n            <td><code>/printed-books/design/inclusive-components</code></td>\n            <td><code>/printed-books/[...slug].js</code></td>\n      <td>Catch-all route</td>\n        </tr>\n    </tbody>\n</table>\n\n\n\nThe <code>next/link</code> API\n<p>The <code>next/link</code> API exposes the <code>Link</code> component as a declarative way to perform client-side route transitions.</p>\n<pre><code>import Link from 'next/link'\n\nfunction TopNav() {\n  return (\n    &lt;nav&gt;\n      &lt;Link href=\"/\"&gt;Smashing Magazine&lt;/Link&gt;\n      &lt;Link href=\"/articles\"&gt;Articles&lt;/Link&gt;\n      &lt;Link href=\"/guides\"&gt;Guides&lt;/Link&gt;\n      &lt;Link href=\"/printed-books\"&gt;Books&lt;/Link&gt;\n    &lt;/nav&gt;\n  )\n}</code></pre>\n\n<p>The <code>Link</code> component will resolve to a regular HTML hyperlink. That is, <code>&lt;Link href=\"/\"&gt;Smashing Magazine&lt;/Link&gt;</code> will resolve to  <code>&lt;a href=\"/\"&gt;Smashing Magazine&lt;/a&gt;</code>.</p>\n<p>The <code>href</code> prop is the only required prop to the <code>Link</code> component. See the <a href=\"https://nextjs.org/docs/api-reference/next/link\">docs</a> for a complete list of props available on the <code>Link</code> component.</p>\n<p>There are other mechanisms of the <code>Link</code> component to be aware of.</p>\n<h3>Routes With Dynamic Segments</h3>\n<p>Prior to Next.js 9.5.3, <code>Link</code>ing to dynamic routes meant that you had to provide both the <code>href</code> and <code>as</code> prop to <code>Link</code> as in:</p>\n<pre><code>import Link from 'next/link';\n\nconst printedBooks = [\n  { name: 'Ethical Design', id: 'ethical-design' },\n  { name: 'Design Systems', id: 'design-systems' },\n];\n\nexport default function PrintedBooks() {\n  return printedBooks.map((printedBook) =&gt; (\n    &lt;Link\n      href=\"/printed-books/[printed-book-id]\"\n      as={`/printed-books/${printedBook.id}`}\n    &gt;\n      {printedBook.name}\n    &lt;/Link&gt;\n  ));\n}</code></pre>\n\n<p>Although this allowed Next.js to interpolate the href for the dynamic parameters, it was tedious, error-prone, and somewhat imperative, and has now been fixed for the majority of use-cases with the release of Next.js 10. </p>\n<p>This fix is also backward compatible. If you have been using both <code>as</code> and <code>href</code>, nothing breaks. To adopt the new syntax, discard the <code>href</code> prop and its value, and rename the <code>as</code> prop to <code>href</code> as in the example below:</p>\n<div>\n<pre><code>import Link from 'next/link';\n\nconst printedBooks = [\n  { name: 'Ethical Design', id: 'ethical-design' },\n  { name: 'Design Systems', id: 'design-systems' },\n];\n\nexport default function PrintedBooks() {\n  return printedBooks.map((printedBook) =&gt; (\n    &lt;Link href={<code>/printed-books/${printedBook.id}</code>}&gt;{printedBook.name}&lt;/Link&gt;\n  ));\n}</code></pre>\n</div>\n\n<blockquote>\n<p>See <a href=\"https://nextjs.org/blog/next-10#automatic-resolving-of-href\">Automatic resolving of href</a>.</p>\n</blockquote>\n<h3>Use-cases For The <code>passHref</code> Prop</h3>\n<p>Take a close look at the snippet below:</p>\n<div>\n<pre><code>import Link from 'next/link';\n\nconst printedBooks = [\n  { name: 'Ethical Design', id: 'ethical-design' },\n  { name: 'Design Systems', id: 'design-systems' },\n];\n\n// Say this has some sort of base styling attached\nfunction CustomLink({ href, name }) {\n  return &lt;a href={href}&gt;{name}&lt;/a&gt;;\n}\n\nexport default function PrintedBooks() {\n  return printedBooks.map((printedBook) =&gt; (\n    &lt;Link href={<code>/printed-books/${printedBook.id}</code>} passHref&gt;\n      &lt;CustomLink name={printedBook.name} /&gt;\n    &lt;/Link&gt;\n  ));\n}</code></pre>\n</div>\n\n<p>The <code>passHref</code> props force the <code>Link</code> component to pass the <code>href</code> prop down to the <code>CustomLink</code> child component. This is compulsory if the <code>Link</code> component wraps over a component that returns a hyperlink <code>&lt;a&gt;</code> tag. Your use-case might be because you are using a library like styled-components, or if you need to pass multiple children to the <code>Link</code> component, as it only expects a single child.</p>\n<blockquote>\n<p>See the <a href=\"https://nextjs.org/docs/api-reference/next/link#if-the-child-is-a-custom-component-that-wraps-an-a-tag\">docs</a> to learn more.</p>\n</blockquote>\n<h3>URL Objects</h3>\n<p>The <code>href</code> prop of the <code>Link</code> component can also be a URL object with properties like <code>query</code> which is automatically formatted into a URL string.</p>\n<p>With the <code>printedBooks</code> object, the example below will link to:</p>\n<ol>\n<li><code>/printed-books/ethical-design?name=Ethical+Design</code> and</li>\n<li><code>/printed-books/design-systems?name=Design+Systems</code>.</li>\n</ol>\n<pre><code>import Link from 'next/link';\n\nconst printedBooks = [\n  { name: 'Ethical Design', id: 'ethical-design' },\n  { name: 'Design Systems', id: 'design-systems' },\n];\n\nexport default function PrintedBooks() {\n  return printedBooks.map((printedBook) =&gt; (\n    &lt;Link\n      href={{\n        pathname: `/printed-books/${printedBook.id}`,\n        query: { name: `${printedBook.name}` },\n      }}\n    &gt;\n      {printedBook.name}\n    &lt;/Link&gt;\n  ));\n}</code></pre>\n\n<p>If you include a dynamic segment in the <code>pathname</code>, then you must also include it as a property in the query object to make sure the query is interpolated in the <code>pathname</code>:</p>\n<pre><code>import Link from 'next/link';\n\nconst printedBooks = [\n  { name: 'Ethical Design', id: 'ethical-design' },\n  { name: 'Design Systems', id: 'design-systems' },\n];\n\n// In this case the dynamic segment `[book-id]` in pathname\n// maps directly to the query param `book-id`\nexport default function PrintedBooks() {\n  return printedBooks.map((printedBook) =&gt; (\n    &lt;Link\n      href={{\n        pathname: `/printed-books/[book-id]`,\n        query: { 'book-id': `${printedBook.id}` },\n      }}\n    &gt;\n      {printedBook.name}\n    &lt;/Link&gt;\n  ));\n}</code></pre>\n\n<p>The example above have paths:</p>\n<ol>\n<li><code>/printed-books/ethical-design</code>, and</li>\n<li><code>/printed-books/design-systems</code>.</li>\n</ol>\n<p>If you inspect the <code>href</code> attribute in VSCode, you’d find the type <code>LinkProps</code>, with the <code>href</code> property a <code>Url</code> type, which is either a <code>string</code> or <code>UrlObject</code> as mentioned previously.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/742d24b6-2df9-4547-b6ae-29ec805103fa/1-client-side-routing-next-js.png\" /></p>\n<p>Inspecting the <code>UrlObject</code> further leads to the interface with the properties:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/1f943f3e-3c10-4cc8-b386-c8237a0f8cfd/2-client-side-routing-next-js.png\" /></p>\n<p>You can learn more about these properties in the <a href=\"https://nodejs.org/api/url.html#url_url_strings_and_url_objects\">Node.js URL module documentation</a>.</p>\n<p>One use case of the hash is to link to specific sections in a page.</p>\n<div>\n<pre><code>import Link from 'next/link';\n\nconst printedBooks = [{ name: 'Ethical Design', id: 'ethical-design' }];\n\nexport default function PrintedBooks() {\n  return printedBooks.map((printedBook) =&gt; (\n    &lt;Link\n      href={{\n        pathname: <code>/printed-books/${printedBook.id}</code>,\n        hash: 'faq',\n      }}\n    &gt;\n      {printedBook.name}\n    &lt;/Link&gt;\n  ));\n}</code></pre>\n</div>\n\n<p>The hyperlink will resolve to <code>/printed-books/ethical-design#faq</code>.</p>\n<blockquote>\n<p>Learn more in <a href=\"https://nextjs.org/docs/api-reference/next/link#with-url-object\">the docs</a>.</p>\n</blockquote>\nThe <code>next/router</code> API\n<p>If the <code>next/link</code> is declarative, then the <code>next/router</code> is imperative. It exposes a <code>useRouter</code> hook that allows access to the <a href=\"https://nextjs.org/docs/api-reference/next/router#router-object\"><code>router</code></a> object inside any function component. You can use this hook to manually perform routing, most especially in certain scenarios where the <code>next/link</code> is not enough, or where you need to “hook” into the routing.</p>\n<div>\n<pre><code>import { useRouter } from 'next/router';\n\nexport default function Home() {\n  const router = useRouter();\n\n  function handleClick(e) {\n    e.preventDefault();\n    router.push(href);\n  }\n\n  return (\n    &lt;button type=\"button\" onClick={handleClick}&gt;Click me&lt;/button&gt;\n  )\n}</code></pre>\n</div>\n\n<p><code>useRouter</code> is a React hook and cannot be used with classes. Need the <code>router</code> object in class components? Use <code>withRouter</code>.</p>\n<div>\n<pre><code>import { withRouter } from 'next/router';\n\nfunction Home({router}) {\n  function handleClick(e) {\n    e.preventDefault();\n    router.push(href);\n  }\n\n  return (\n    &lt;button type=\"button\" onClick={handleClick}&gt;Click me&lt;/button&gt;\n  )\n}\n\nexport default withRouter(Home);</code></pre>\n</div>\n\n<h3>The <code>router</code> Object</h3>\n<p>Both the <code>useRouter</code> hook and <code>withRouter</code> higher-order component, return a router object with properties like <code>pathname</code>, <code>query</code>, <code>asPath</code>, and <code>basePath</code> that gives you information about the URL state of the current page, <code>locale</code>, <code>locales</code>, and <code>defaultLocale</code> that gives information about the active, supported, or current default locale.</p>\n<p>The router object also has methods like <code>push</code> for navigating to a new URL by adding a new URL entry into the history stack, <code>replace</code>, similar to push but replaces the current URL instead of adding a new URL entry into the history stack.</p>\n<p>Learn more about the <a href=\"https://nextjs.org/docs/api-reference/next/router#router-object\">router object</a>.</p>\nCustom Route Configuration With <code>next.config.js</code>\n<p>This is a regular Node.js module that can be used to configure certain Next.js behavior.</p>\n<pre><code>module.exports = {\n  // configuration options\n}</code></pre>\n\n<blockquote>\n<p>Remember to restart your server anytime you update <code>next.config.js</code>. <a href=\"https://nextjs.org/docs/api-reference/next.config.js/introduction\">Learn more</a>.</p>\n</blockquote>\n<h3>Base Path</h3>\n<p>It was mentioned that the initial/default route in Next.js is <code>pages/index.js</code> with path <code>/</code>. This is configurable and you can make your default route a sub-path of the domain.</p>\n<pre><code>module.exports = {\n  // old default path: /\n  // new default path: /dashboard\n  basePath: '/dashboard',\n};</code></pre>\n\n<p>These changes will automatically take effect in your application with all <code>/</code> paths routed to <code>/dashboard</code>.</p>\n<blockquote>\n<p>This feature can only be used with Next.js 9.5 and above. <a href=\"https://nextjs.org/docs/api-reference/next.config.js/basepath\">Learn more</a>.</p>\n</blockquote>\n<h3>Trailing Slash</h3>\n<p>By default, a trailing slash will not be available at the end of each URL. However, you can switch that with:</p>\n<pre><code>module.exports = {\n  trailingSlash: true\n};</code></pre>\n\n<pre><code># trailingSlash: false\n/printed-books/ethical-design#faq\n# trailingSlash: true\n/printed-books/ethical-design/#faq</code></pre>\n\n<p>Both the <a href=\"https://nextjs.org/docs/api-reference/next.config.js/basepath\">base path</a> and <a href=\"https://nextjs.org/docs/api-reference/next.config.js/trailing-slash\">trailing slash</a> features can only be used with Next.js 9.5 and above.</p>\nConclusion\n<p>Routing is one of the most important parts of your Next.js application, and it reflects in the file-system-based router built on the concept of pages. Pages can be used to define the most common route patterns. The concepts of routing and rendering are closely related. Take the lessons of this article with you as you build your own Next.js app or work on a Next.js codebase. And check the resources below to learn more.</p>\n<h3>Related Resources</h3>\n<ul>\n<li><a href=\"https://nextjs.org/docs/basic-features/pages\">Next.js official documentation for Pages</a></li>\n<li><a href=\"https://nextjs.org/docs/basic-features/data-fetching\">Next.js official documentation for data fetching</a></li>\n<li><a href=\"https://nextjs.org/docs/api-reference/next.config.js/introduction\">Next.js official documentation for next.config.js</a></li>\n<li><a href=\"https://nextjs.org/blog/next-10#automatic-resolving-of-href\">Next.js 10: Automatic resolving of</a> <a href=\"https://nextjs.org/blog/next-10#automatic-resolving-of-href\"><code>href</code></a></li>\n<li><a href=\"https://nextjs.org/docs/api-reference/next/link\">Next.js official documentation for next/link</a></li>\n<li><a href=\"https://nextjs.org/docs/api-reference/next/router\">Next.js official documentation for next/router</a></li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"8c079dda05652a9a0a7b2e4a04cc85dea9ae1d4c68c9b3c4242e24899ee65adf","category":"Tech"}