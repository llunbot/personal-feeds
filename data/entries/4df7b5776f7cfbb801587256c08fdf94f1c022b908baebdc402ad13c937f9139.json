{"title":"Primitive Objects In JavaScript: When To Use Them (Part 2)","link":"https://smashingmagazine.com/2023/06/primitive-objects-javascript-part-2/","date":1685959200000,"content":"<p>Writing programs in JavaScript is approachable at the beginning. The language is forgiving, and you get accustomed to its affordances. With time and experience working on complex projects, you start to appreciate things like control and precision in the development flow.</p>\n<p>Another thing you might start to appreciate is predictability, but thatâ€™s way less of a guarantee in JavaScript. While primitive values are predictive enough, objects arenâ€™t. When you get an object as an input, you need to check for everything:</p>\n<ul>\n<li>Is it an object? </li>\n<li>Does it have that property youâ€™re looking for? </li>\n<li>When a property holds <code>undefined</code>, is that its value, or is the property itself missing?</li>\n</ul>\n<p>Itâ€™s understandable if this level of uncertainty leaves you slightly paranoid in the sense that you start to question all of your choices. Subsequently, your code becomes defensive. You think more about whether youâ€™ve handled all the faulty cases or not (chances are you have not). And in the end, your program is mostly a collection of checks rather than bringing real value to the project.</p>\n<p>By making objects <em>primitive</em>, many of the potential failure points are moved to a single place â€” the one where objects are initialized. If you can make sure that your objects are initialized with a certain set of properties and those properties hold certain values, you donâ€™t have to check for things like the existence of properties anywhere else in your program. You could guarantee that <code>undefined</code> is a value if you need to.</p>\n<p>Letâ€™s look at one of the ways we can make primitive objects. Itâ€™s not the only way or even the most interesting one. Rather, its purpose is to demonstrate that working with read-only objects doesnâ€™t have to be cumbersome or difficult.</p>\n<p><strong>Note</strong>: <em>I also recommend you to check <a href=\"https://www.smashingmagazine.com/2023/02/discovering-primitive-objects-javascript-part1/\">the first part of the series</a>, where I covered some aspects of JavaScript that help bring objects closer to primitive values, which in return allows us to benefit from common language features that arenâ€™t usually associated with an object, like comparisons and arithmetic operators.</em></p>\nMaking Primitive Objects In Bulk\n<p>The most simple, most <em>primitive</em> (pun intended) way to create a primitive object is the following:</p>\n<pre><code>const my_object = Object.freeze({});\n</code></pre>\n\n<p>This single line results in an object that can represent anything. For instance, you could implement a tabbed interface using an empty object for each tab.</p>\n<div>\n<pre><code>import React, { useState } from \"react\";\n\nconst summary_tab = Object.freeze({});\nconst details_tab = Object.freeze({});\n\nfunction TabbedContainer({ summary_children, details_children }) {\n    const [ active, setActive ] = useState(summary_tab);\n\n    return (\n        &lt;div className=\"tabbed-container\"&gt;\n            &lt;div className=\"tabs\"&gt;\n                &lt;label\n                    className={active === summary_tab ? \"active\" : \"\"}\n                    onClick={() =&gt; {\n                        setActive(summary_tab);\n                    }}\n                &gt;\n                    Summary\n                &lt;/label&gt;\n                &lt;label\n                    className={active === details_tab ? \"active\": \"\"}\n                    onClick={() =&gt; {\n                        setActive(details_tab);\n                    }}\n                &gt;\n                    Details\n                &lt;/label&gt;\n            &lt;/div&gt;\n            &lt;div className=\"tabbed-content\"&gt;\n                {active === summary_tab &amp;&amp; summary_children}\n                {active === details_tab &amp;&amp; details_children}\n            &lt;/div&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default TabbedContainer;\n</code></pre>\n</div>\n\n<p>If youâ€™re like me, that <code>tabs</code> element just screams to be reworked. Looking closely, youâ€™ll notice that tab elements are similar and need two things, such as an <strong>object reference</strong> and a <strong>label string</strong>. Letâ€™s include the <code>label</code> property in the <code>tabs</code> objects and move the objects themselves into an array. And since weâ€™re not planning to change <code>tabs</code> in any way, letâ€™s also make that array read-only while weâ€™re at it.</p>\n<pre><code>const tab_kinds = Object.freeze([\n    Object.freeze({ label: \"Summary\" }),\n    Object.freeze({ label: \"Details\" })\n]);\n</code></pre>\n\n<p>That does what we need, but it is verbose. The approach weâ€™ll look at now is often used to hide repeating operations to reduce the code to just the data. That way, it is more apparent when the data is incorrect. What we also want is to <code>freeze</code> objects (including the array) by default rather than it being something we have to remember to type out. For the same reason, the fact that we have to specify a property name every time leaves room for errors, like typos.</p>\n<p>To easily and consistently initialize arrays of primitive objects, I use a <code>populate</code> function. I donâ€™t actually have a single function that does the job. I usually create one every time based on what I need at the moment. In the particular case of this article, this is one of the simpler ones. Hereâ€™s how weâ€™ll do it:</p>\n<pre><code>function populate(...names) {\n    return function(...elements) {\n        return Object.freeze(\n            elements.map(function (values) {\n                return Object.freeze(names.reduce(\n                    function (result, name, index) {\n                        result[name] = values[index];\n                        return result;\n                    },\n                    Object.create(null)\n                ));\n            })\n        );\n    };\n}\n</code></pre>\n\n<p>If that one feels dense, hereâ€™s one thatâ€™s more readable:</p>\n<pre><code>function populate(...names) {\n    return function(...elements) {\n        const objects = [];\n\n        elements.forEach(function (values) {\n            const object = Object.create(null);\n\n            names.forEach(function (name, index) {\n                object[name] = values[index];\n            });\n\n            objects.push(Object.freeze(object));\n        });\n\n        return Object.freeze(objects);\n    };\n}\n</code></pre>\n\n<p>With that kind of function at hand, we can create the same array of tabbed objects like so:</p>\n<pre><code>const tab_kinds = populate(\n    \"label\"\n)(\n    [ \"Summary\" ],\n    [ \"Details\" ]\n);\n</code></pre>\n\n<p>Each array in the second call represents the values of resulting objects. Now letâ€™s say we want to add more properties. Weâ€™d need to add a new name to the first call and a value to each array in the second call.</p>\n<pre><code>const tab_kinds = populate(\n    \"label\",\n    \"color\",\n    \"icon\"\n)(                                          \n    [ \"Summary\", colors.midnight_pink, \"ðŸ’¡\" ],\n    [ \"Details\", colors.navi_white, \"ðŸ”¬\" ]\n);\n</code></pre>\n\n<p>Given some whitespace, you could make it look like a table. That way, itâ€™s much easier to spot an error in huge definitions.</p>\n<p>You may have noticed that <code>populate</code> returns another function. There are a couple of reasons to keep it in two function calls. First, I like how two contiguous calls create an empty line that separates keys and values. Secondly, I like to be able to create these sorts of generators for similar objects. For example, say we need to create those label objects for different components and want to store them in different arrays.</p>\n<p>Letâ€™s get back to the example and see what we gained with the <code>populate</code> function:</p>\n<div>\n<pre><code>import React, { useState } from \"react\";\nimport populate_label from \"./populate_label\";\n\nconst tabs = populate_label(\n    [ \"Summary\" ],\n    [ \"Details\" ]\n);\n\nconst [ summary_tab, details_tab ] = tabs;\n\nfunction TabbedContainer({ summary_children, details_children }) {\n    const [ active, setActive ] = useState(summary_tab);\n\n    return (\n        &lt;div className=\"tabbed-container\"&gt;\n            &lt;div className=\"tabs\"&gt;\n                {tabs.map((tab) =&gt; (\n                    &lt;label\n                        key={tab.label}\n                        className={tab === active ? \"active\" : \"\"}\n                        onClick={() =&gt; {\n                            setActive(tab);\n                        }}\n                    &gt;\n                        {tab.label}\n                    &lt;/label&gt;\n                )}\n            &lt;/div&gt;\n            &lt;div className=\"tabbed-content\"&gt;\n                {summary_tab === active &amp;&amp; summary_children}\n                {details_tab === active &amp;&amp; details_children}\n            &lt;/div&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default TabbedContainer;\n</code></pre>\n</div>\n\n\n<p>Using primitive objects makes writing UI logic straightforward.</p>\n<p>Using functions like <code>populate</code> is less cumbersome for creating these objects and seeing what the data looks like.</p>\nCheck That Radio\n<p>One of the alternatives to the approach above that Iâ€™ve encountered is to retain the <code>active</code> state â€” whether the tab is selected or not â€” stored as a property of the <code>tabs</code> object:</p>\n<pre><code>const tabs = [\n    {\n        label: \"Summary\",\n        selected: true\n    },\n    {\n        label: \"Details\",\n        selected: false\n    },\n];\n</code></pre>\n\n<p>This way, we replace <code>tab === active</code> with <code>tab.selected</code>. That might seem like an improvement, but look at how we would have to change the selected tab:</p>\n<pre><code>function select_tab(tab, tabs) {\n    tabs.forEach((tab) =&gt; tab.selected = false);\n    tab.selected = true;\n}\n</code></pre>\n\n<p>Because this is logic for a radio button, only a single element can be selected at a time. So, before setting an element to be selected, we first need to make sure that all the other elements are unselected. Yes, itâ€™s silly to do it like that for an array with only two elements, but the real world is full of longer lists than this example.</p>\n<p>With a primitive object, we need <strong>a single variable that represents the selected state</strong>. I suggest setting the variable on one of the elements to make it the currently-selected element or setting it to <code>undefined</code> if your implementation allows for no selection.</p>\n<p>With multi-choice elements like checkboxes, the approach is almost the same. We replace the selection variable with an array. Each time an element is selected, we push it to that array, or in the case of <a href=\"https://redux.js.org\">Redux</a>, we create a new array with that element present. To unselect it, we either splice it or filter out the element.</p>\n<pre><code>let selected = []; // Nothing is selected.\n\n// Select.\nselected = selected.concat([ to_be_selected ]);\n\n// Unselect.\nselected = selected.filter((element) =&gt; element !== to_be_unselected);\n\n// Check if an element is selected.\nselected.includes(element);\n</code></pre>\n\n<p>Again, this is straightforward and concise. You donâ€™t need to remember if the property is called <code>selected</code> or <code>active</code>; you use the object itself to determine that. When your program becomes more complex, those lines would be the least likely to be refactored.</p>\n<p>In the end, <strong>it is not a list elementâ€™s job to decide whether it is selected or not</strong>. It shouldnâ€™t hold this information in its state. For example, what if itâ€™s simultaneously selected and not selected in several lists at a time?</p>\nAlternative To Strings\n<p>The last thing Iâ€™d like to touch on is an example of string usage I often encounter. </p>\n<p>Text is a good trade-off for interoperability. You define something as a string and instantly get a representation of a context. Itâ€™s like getting an instant energy rush from eating sugar. As with sugar, the best case is that you get nothing in the long term. That said, it is unfulfilling, and you inevitably get hungry again.</p>\n<p>The problem with strings is that they are for humans. Itâ€™s natural for us to distinguish things by giving them a name. But a program doesnâ€™t understand the meaning of those names. </p>\n<p>Most code editors and integrated development environments (IDEs) donâ€™t understand strings. In other words, your tools wonâ€™t tell you whether or not the string is correct.</p>\n<p>Your program only knows whether two strings are <em>equal</em> or not. And even then, telling whether strings are equal or unequal doesnâ€™t necessarily provide an insight into whether or not any of those strings contain a typo.</p>\n<p>Objects provide more ways to see that something is wrong before you run your program. Because you cannot have literals for primitive objects, you would have to get a reference from somewhere. For example, if itâ€™s a variable and you make a typo, you get a <strong>reference error</strong>. There are tools that could catch that sort of thing before the file is saved.</p>\n<p>If you were to get your objects from an array or another object, then JavaScript wonâ€™t give you an error when the property or an index does not exist. What you get is <code>undefined</code>, and thatâ€™s something you could check for. You have a single thing to check. With strings, you have surprises you might want to avoid, like when theyâ€™re empty.</p>\n<p>Another use of strings I try to avoid is checking if we get the object we want. Usually, itâ€™s done by storing a string in a property named <code>id</code>. Like, letâ€™s say we have a variable. In order to check if it holds the object we want, we might need to check if a string in the <code>id</code> property matches the one we expect it to. To do that, we would first check if the variable holds an object. If the variable does hold an object, but the object lacks the <code>id</code> property, then we get <code>undefined</code>, and weâ€™re fine. However, if we have one of the bottom values in that variable, then we are unable to ask for the property directly. Instead, we have to do something to either make sure that only objects arrive at this point or to do both checks in place.</p>\n<div>\n<pre><code>const myID = \"Oh, it's so unique\";\n\nfunction magnification(value) {\n    if (value &amp;&amp; typeof value === \"object\" &amp;&amp; value.id === myID) {\n        // do magic\n    }\n}\n</code></pre>\n</div>\n\n<p>Hereâ€™s how we can do the same with primitive objects:</p>\n<pre><code>import data from \"./the file where data is stored\";\n\nfunction magnification(value) {\n    if (value === data.myObject) {\n        // do magic\n    }\n}\n</code></pre>\n\n<p>The benefit of strings is that they are a single thing that could be used for internal identification and are immediately recognizable in logs. They sure are easy to use right out of the box, but they are not your friend as the complexity of a project increases.</p>\n<p>I find <strong>thereâ€™s little benefit in relying on strings for anything other than output to the user</strong>. The lack of interoperability of strings in primitive objects could be solved gradually and without the need to change how you handle basic operations, like comparisons.</p>\nWrapping Up\n<p>Working directly with objects frees us from the pitfalls that come with other methods. Our code becomes simpler because we write what your program needs to do. By organizing your code with primitive objects, we are less affected by the dynamic nature of JavaScript and some of its baggage. Primitive objects give us more guarantees and a greater degree of predictability.</p>\n<h3>Further Reading On SmashingMag</h3>\n<ul>\n<li><a href=\"https://www.smashingmagazine.com/2022/09/javascript-api-guide/\">JavaScript APIs You Donâ€™t Know About</a>, Juan Diego RodrÃ­guez</li>\n<li><a href=\"https://www.smashingmagazine.com/2022/09/useful-javascript-data-grid-libraries/\">Useful JavaScript Data Grid Libraries</a>, Zara Cooper</li>\n<li><a href=\"https://www.smashingmagazine.com/2021/08/interactive-gantt-chart-component-vanilla-javascript/\">Creating An Interactive Gantt Chart Component With Vanilla JavaScript (Part 1)</a>, Anna Prenzel</li>\n<li><a href=\"https://www.smashingmagazine.com/2022/07/look-remix-differences-next/\">A Look At Remix And The Differences With Next.js</a>, Facundo Giuliani</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine â€” For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"4df7b5776f7cfbb801587256c08fdf94f1c022b908baebdc402ad13c937f9139","category":"Tech"}