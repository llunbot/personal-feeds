{"title":"Building a secure Azure reference architecture with Terraform","link":"https://www.hashicorp.com/blog/building-a-secure-azure-reference-architecture-with-terraform","date":1681401600000,"content":"<p>HashiCorp and Microsoft have partnered to create a number of <a href=\"https://developer.hashicorp.com/terraform/tutorials/modules/module\">Terraform modules</a> that build an N-tier architecture following Microsoft's <a href=\"https://learn.microsoft.com/en-us/azure/architecture/framework/\">Azure Well-Architected Framework</a> and security best practices. In this guide, we will walk you through using the modules to build this environment and add on security functionality and Terraform Cloud policies via <a href=\"https://www.hashicorp.com/sentinel\">Sentinel</a>.</p>\n\n<p>In part two of this series, we'll cover <a href=\"https://www.hashicorp.com/blog/deploying-securely-into-azure-architecture-with-terraform-cloud-and-hcp-vault\">Deploying securely into Azure architecture with Terraform Cloud and HCP Vault</a></p>\n\n<h2>Choosing a reference architecture</h2>\n\n<p>Microsoft has an excellent <a href=\"https://learn.microsoft.com/en-us/azure/architecture/\">architecture library</a> where you can find references for multiple environment types and scenarios. The example in this post uses an <a href=\"https://learn.microsoft.com/en-us/azure/architecture/guide/architecture-styles/n-tier\">N-tier architecture</a>, since it is a common starting point for traditional on-premises applications migrating to Azure infrastructure.</p>\n<img src=\"https://www.datocms-assets.com/2885/1681399105-image-1-n-tier-architecture.png\" alt=\"A\" /><p>An N-tier architecture divides an application into logical layers and physical tiers, and can be migrated to Azure with minimal refactoring. </p>\n\n<h2>Modules and policies</h2>\n\n<p>Once the environment has been selected, infrastructure code is needed to build it. You can use Terraform modules to easily break down this task into separate deployable sections and create a manageable set of environments that are built together to form the overall architecture.</p>\n\n<p>Using <a href=\"https://app.terraform.io/session\">Terraform Cloud</a> provides another layer of security to the environment with <a href=\"https://docs.hashicorp.com/sentinel/concepts/policy-as-code\">policy as code</a>, which is available in the <a href=\"https://www.hashicorp.com/products/terraform/pricing\">Terraform Cloud Team &amp; Governance</a> and <a href=\"https://www.hashicorp.com/products/terraform/pricing\">Business tiers</a>. Policies are rules that Terraform Cloud enforces on Terraform runs. You can define policies using either the <a href=\"https://developer.hashicorp.com/terraform/cloud-docs/policy-enforcement/sentinel\">HashiCorp Sentinel</a> or <a href=\"https://developer.hashicorp.com/terraform/cloud-docs/policy-enforcement/opa\">Open Policy Agent (OPA)</a>. Example Sentinel policies are available in the <a href=\"https://registry.terraform.io/browse/policies?provider=azurerm\">policy library</a> section of the Terraform Registry.  </p>\n\n<p><em>Note: To follow along in the “Applying Terraform Cloud policies” section of this post, you will need a Terraform Cloud account and organization set up with a workspace.</em></p>\n\n<h2>Building the architecture</h2>\n\n<p>To get started, clone the <a href=\"https://github.com/dawright22/azure-VM-reference-arch-linux.git\">N-tier architecture GitHub repository</a> created for this guide. If you’re using Visual Studio Code, we recommend using the supported <a href=\"https://marketplace.visualstudio.com/items?itemName=HashiCorp.terraform\">Terraform extension</a> and cloning the N-tier repository using the <a href=\"https://code.visualstudio.com/docs/sourcecontrol/overview#_cloning-a-repository\">built-in Git functionality</a>. Once complete, the code tree will look like this:</p>\n<img src=\"https://www.datocms-assets.com/2885/1681399164-image-2-building-the-architecture.png\" alt=\"Azure\" /><h2>Establishing the basics</h2>\n\n<p>From the module tree layout you can see the process and logic behind each module. We created smaller modules that focused on specific functions, starting with the network module, which provides the home for any VNets and subnets along with any DNS and endpoint configuration. </p>\n\n<p>We then created separate modules for the application gateway and the internal load balancers that become the choke points for traffic between the subnets. To create the virtual machine (VM) in a scalable way, we defined two separate modules: one for the web tier and one for the business tier (middleware). Finally, we have the database module creating the storage policies and array. </p>\n\n<p><em>Note: For the purposes of this example we’re using local modules within the project directory. Terraform Cloud also offers a <a href=\"https://developer.hashicorp.com/terraform/cloud-docs/registry\">private registry</a> where commonly used modules can be published and reused by others within your organization.</em></p>\n\n<p>To deploy all of the components, we created the main.tf in the root module to house the code that links the modules together. Once you have put these modules together and tested them, you can start adding security into the code. </p>\n\n<h3>Adding security best practices as code</h3>\n\n<p>Now we have a baseline environment. To improve the overall security posture of your architecture, there are established <a href=\"https://learn.microsoft.com/en-us/azure/security/fundamentals/network-overview\">security best practices you can follow</a> for the Azure platform.</p>\n\n<h3>Password management</h3>\n\n<p>To get a standardized random password we added the random password provider and set a length and the use of special characters to create a strong password structure based on the Microsoft <a href=\"https://learn.microsoft.com/en-us/microsoft-365/admin/misc/password-policy-recommendations?view=o365-worldwide\">recommendation</a>. The code we added to <code>main.tf</code> of our root module is shown here:</p>\n<pre><code>resource \"random_password\" \"password\" {\n length           = 16\n special          = true\n override_special = \"!#$%&amp;*()-_=+[]{}&lt;&gt;:?\"\n}</code></pre><p>Once added to <code>main.tf</code> the provider, it can be used anywhere it's needed across the architecture. We simply assign the <code>random_password.password.bcrypt_hash</code> attribute to a module input. In this example, we assign it to the web scale set. This uses a bcrypt salt of the created password that is passed into the attribute:</p>\n<pre><code>######################################\n# Create web scale set\n######################################\n\nmodule \"web_scale_sets\" {\n  source                   = \"./modules/web_scale_set\"\n  name                     = random_pet.name.id\n  resource_group_location  = var.resource_group_location\n  resource_group_name      = azurerm_resource_group.rg.name\n  scale_set_sub            = module.networks.subnet3\n  app_gty_backend_pool_ids = module.app-gateway.app_gateway.backend_address_pool[*].id\n  admin_user               = var.admin_user\n  admin_password           = random_password.password.bcrypt_hash\n}</code></pre><h3>Limiting access</h3>\n\n<p>To control traffic going into the newly created environment we want two classes: user and management. That is, the traffic that the customer/users of the application create by interacting with the application, and the traffic that manages devices and components of the environment itself. Taking this approach lets you separate the risk profiles of the traffic to create rules and access control based around those profiles.</p>\n\n<h4>Management traffic control</h4>\n\n<p>To limit management access, we leverage an Azure bastion host. Azure Bastion is a service that lets you connect to a virtual machine using your browser and the Azure portal or via the native SSH or RDP client already installed on your local computer. The Azure Bastion service is a fully platform-managed PaaS service that you provision inside a specific host called <code>AzureBastionSubnet</code>when provisioned via AzureRM (see the <a href=\"https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/bastion_host\">azurerm<em>bastion</em>host documentation</a>). </p>\n\n<p>When you connect via Azure Bastion, your VMs don't need a public IP address, agent, or special client software (<a href=\"https://learn.microsoft.com/en-us/azure/bastion/bastion-overview\">learn more about  Azure Bastion Host here</a>). This is deployed using the management tools module in the root module with these few lines of code:</p>\n<pre><code>######################################\n# Create Bastion Host\n######################################\n\nmodule \"bastion-host\" {\n  source                  = \"./modules/management_tools\"\n  name                    = random_pet.name.id\n  resource_group_location = var.resource_group_location\n  resource_group_name     = azurerm_resource_group.rg.name\n\n}</code></pre><h4>User traffic control</h4>\n\n<p>To limit user traffic we leveraged security groups. You can use an Azure network security group to filter network traffic to and from Azure resources in an Azure virtual network. A network security group contains <a href=\"https://learn.microsoft.com/en-us/azure/virtual-network/network-security-groups-overview#security-rules\">security rules</a> that allow or deny inbound network traffic to, or outbound network traffic from, several types of Azure resources. For each rule, you can specify source, destination, port, and protocol:</p>\n<pre><code>######################################\n# Create Security Groups and Rules\n######################################\nresource \"azurerm_network_security_group\" \"SecurityGroup\" {\n  name                = \"${var.name}-SecurityGroup\"\n  location            = var.resource_group_location\n  resource_group_name = var.resource_group_name\n\n\n  security_rule {\n    name                       = var.name\n    priority                   = 100\n    direction                  = \"Inbound\"\n    access                     = \"Allow\"\n    protocol                   = \"Tcp\"\n    source_port_range          = \"*\"\n    destination_port_range     = \"*\"\n    source_address_prefix      = \"*\"\n    destination_address_prefix = \"*\"\n  }\n\n  tags = {\n    environment = \"Terraform\"\n  }\n}</code></pre><p>To allow the most flexibility in the rule sets, we created unique network security groups for each subnet and associated the rule to that specific subnet via this code:</p>\n<pre><code>resource \"azurerm_subnet_network_security_group_association\" \"SGA\" {\n  subnet_id                 = azurerm_subnet.app_gateway_sub.id\n  network_security_group_id = azurerm_network_security_group.SecurityGroup.id\n}</code></pre><p>To limit access even further, you could tighten the rules by editing the source, destination port, or address range.</p>\n\n<h3>Tier isolation</h3>\n\n<p>To further limit the communication between tiers, the scale sets have also been configured to communicate only via the load balancer and application gateway. This limits the exposed services behind them and creates another obstacle for potential attackers. This is achieved by assigning the application gateway or load balancer IDs in the <code>ip_configuration</code> within the network section of the scale set:</p>\n<pre><code>network_interface {\n   name    = \"${var.name}-network-int\"\n   primary = true\n\n   ip_configuration {\n     name                                         = \"internal\"\n     primary                                      = true\n     subnet_id                                    = var.scale_set_sub\n     application_gateway_backend_address_pool_ids = var.app_gty_backend_pool_ids\n   }\n }</code></pre><h3>Database access</h3>\n\n<p>Databases are the ultimate target for most bad actors.  Taking measures to protect them is key to protecting your organization. For this environment we leverage the Azure Cosmos database, because all user data stored in Azure Cosmos DB is automatically encrypted at rest and in transit. Basically, encryption at rest is \"on\" by default. </p>\n\n<p>We also leverage the built-in CosmosDB Firewall by including the following code: <code>is_virtual_network_filter_enabled = \"true\"</code>. </p>\n\n<p>The <code>ip_range_filter</code> value specifies the set of IP addresses or IP address ranges in CIDR form to be included as the allowed list of client IPs for a given database account. In this case, we have locked the address range down to the 10.0.4.0/24 range of the biz tier using the <code>var.ip_range_filter</code> variable in the virtual network range shown here:</p>\n<pre><code>resource \"azurerm_cosmosdb_account\" \"Storacc\" {\n  name                              = \"${var.name}-cosmosdb-acc\"\n  location                          = var.resource_group_location\n  resource_group_name               = var.resource_group_name\n  offer_type                        = \"Standard\"\n  kind                              = \"GlobalDocumentDB\"\n  enable_automatic_failover         = false\n  enable_free_tier                  = true\n  is_virtual_network_filter_enabled = \"true\"\n  ip_range_filter                   = var.ip_range_filter\n  virtual_network_rule {\n    id                                   = var.data_tier_sub_id\n    ignore_missing_vnet_service_endpoint = true\n }\n geo_location {\n    location          = var.resource_group_location\n    failover_priority = 0\n }\n consistency_policy {\n    consistency_level       = \"BoundedStaleness\"\n    max_interval_in_seconds = 300\n    max_staleness_prefix    = 100000\n }\n depends_on = [\n   var.resource_group_name,\n   var.data_tier_sub_id\n ]\n\n}\n</code></pre><p>With these basic inclusions we have started to create a secure environment in which to build an application.</p>\n\n<h3>Applying Terraform Cloud policies</h3>\n\n<p>Within the <a href=\"https://registry.terraform.io/browse/policies\">Terraform policy library</a> you find Azure-specific policies based on <a href=\"https://www.cisecurity.org/cis-benchmarks\">CIS benchmarks</a> and apply them to your environment. To take advantage of policies, you group individual policies into policy sets and apply those policy sets to one or more workspaces in your organization. For each run in those workspaces, Terraform Cloud checks the Terraform plan against the policy set.</p>\n<img src=\"https://www.datocms-assets.com/2885/1681399640-policy-libraries.png\" alt=\"Terraform\" /><p>From the above list of available HashiCorp policies, select Azure Networking Sentinel Policies for Terraform from the list, as this provides additional security checks to the platform code highlighted above.</p>\n<img src=\"https://www.datocms-assets.com/2885/1681401053-azure-networking-sentinel-policies-for-terraform-edited.png\" alt=\"Azure\" /><p>From here, click the “Choose policies” button, which takes you to the policies tab. On the sidebar, you can select the specific policies you want to enforce and the code is generated for use as shown in the example below:</p>\n<img src=\"https://www.datocms-assets.com/2885/1681399746-usage-instrcutions.png\" alt=\"Usage\" /><p>Next, click “Copy Code Snippet” and go to your version control system, in this example its GitHub, and create a new repository called <code>azure-policy-lib</code> with a file called <code>sentinel.hcl</code>, where you’ll paste the code snippet:</p>\n<img src=\"https://www.datocms-assets.com/2885/1681399779-sentinel-hcl-snippet.png\" alt=\"usage\" /><p>Now go to the Terraform Cloud organization, and from the Settings page, select the policy set to open, as shown here:</p>\n<img src=\"https://www.datocms-assets.com/2885/1681399878-policy-sets-gov-azure.png\" alt=\"Policy\" /><p>Then click the “Create a new policy” button and connect the engine to your VCS, selecting GitHub (in this case) and your repository:</p>\n<img src=\"https://www.datocms-assets.com/2885/1681399913-choose-a-repository.png\" alt=\"Choose\" /><p>Connect the policy to the workspace by selecting the framework (Sentinel in this case), giving the policy a name, and selecting the specific workspace you want to test on. Make sure to click “Add workspace” to attach the policy and then click “Connect policy set”:</p>\n<img src=\"https://www.datocms-assets.com/2885/1681399956-connect-policy-to-worksapce.png\" alt=\"Connect\" /><p>Now, when you trigger a run in Terraform Cloud, you will have the additional Sentinel policy tab below showing the outcome:</p>\n<img src=\"https://www.datocms-assets.com/2885/1681399980-sentinel-policies-passed.png\" alt=\"Sentinel\" /><p>In this instance we triggered an advisory warning that we do not meet the RDP and SSH security requirements that we specified and that even though we created Network security groups in our code, they are too open to meet CIS benchmarks.</p>\n\n<h3>Next steps</h3>\n\n<p>Incorporating security best practices into infrastructure as code is essential for maintaining secure and reliable infrastructure. By doing so, organizations help ensure that their cloud deployments are secure, compliant, and easily maintainable. Terraform Cloud helps enforce these best practices and makes sure that you can use an <em>as code</em> approach to build your security workflow into your deployments.</p>\n\n<p>To learn more, watch the video <a href=\"https://www.youtube.com/watch?v=PMH516I8Pdk\">Securing Your Cloud with Terraform Foundational Policy Library</a> and join Microsoft and HashiCorp for our ongoing webinar series on <a href=\"https://www.hashicorp.com/events/webinars/part-1-maximizing-microsoft-azure-security-with-terraform\">Maximizing Microsoft Azure Security with Terraform</a>.</p>\n\n<p>To continue this series, read part two: <a href=\"https://www.hashicorp.com/blog/deploying-securely-into-azure-architecture-with-terraform-cloud-and-hcp-vault\">Deploying securely into Azure architecture with Terraform Cloud and HCP Vault</a>.</p>\n","author":"David Wright","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"7021298453146449cf045af389d365b8debd6c9c3f605e395abcb6db570eb6b3","category":"Tech"}