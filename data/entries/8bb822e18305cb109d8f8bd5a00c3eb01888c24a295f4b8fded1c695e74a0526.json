{"title":"Long Live The Test Pyramid","link":"https://smashingmagazine.com/2023/09/long-live-test-pyramid/","date":1693998000000,"content":"<p>A dear colleague of mine, <a href=\"http://www.jpietrzyk.de\">Jan Philip Pietrczyk</a>, once commented on the developer’s responsibility for writing functional code:</p>\n<blockquote>“Our daily work [...] ends up in the hands of people who trust us not only to have done our best but also that it works.”<br /><br />— Jan Philip Pietrczyk</blockquote>\n\n<p>His words have really stuck with me because it puts our code in the context of the people who rely on it. In this fast-paced world, users trust that we write the best code possible and that our software “simply” works. Living up to this level of trust is a challenge, for sure, and that’s why testing is such a crucial part of any development stack. Testing a process evaluates the quality of our work, validating it against different scenarios to help identify problems before they become, well, <em>problems</em>.</p>\n<p>The Test Pyramid is one testing strategy of many. While it’s perhaps been the predominant testing model for the better part of a decade since it was introduced in 2012, I don’t see it referenced these days as much as I used to. Is it still the “go-to” approach for testing? Plenty of other approaches have cropped up in the meantime, so is it perhaps the case that the Test Pyramid is simply drowned out and overshadowed by more modern models that are better fitting for today’s development?</p>\n<p>That’s what I want to explore.</p>\nThe Point Of Testing Strategies\n<p>Building trust with users requires a robust testing strategy to ensure the code we write makes the product function how they expect it to. Where shall we start with writing a good test? How many do we need? Many people have grappled with this question. But it was a brief comment that Kent C. Dodds made that gave me the “a-ha!” moment I needed:</p>\n<blockquote>“The biggest challenge is knowing what to test and how to test it in a way that gives true confidence rather than the false confidence of testing implementation details.”<br /><br />— Kent C. Dodds</blockquote>\n\n<p>That’s the starting point! <strong>Determining the goal of testing</strong> is the most crucial task of a testing strategy. The internet is full of memes depicting bad decisions, many resulting from simply not knowing the purpose of a particular test and how many we need to assert confidence. When it comes to testing, there is a “right ratio” to ensure that code is appropriately tested and that it functions as it should.</p>\n<p></p><blockquote><p>2 unit tests. 0 integration tests. <a href=\"https://t.co/K2MZKwr8JT\">pic.twitter.com/K2MZKwr8JT</a></p>— DEV Community (@ThePracticalDev) <a href=\"https://twitter.com/ThePracticalDev/status/892788721350836225?ref_src=twsrc%5Etfw\">August 2, 2017</a></blockquote> <p></p>\n<p><br /></p>\n<p>The problem is that many developers only focus on one type of testing — often unit test coverage — rather than having a strategy for how various units work together. For example, when testing a sink, we may have coverage for testing the faucet and the drain separately, but are they working <em>together</em>? If the drain clogs, but the faucet continues to pour water, things aren’t exactly working, even if unit tests say the faucet is.</p>\n<p>Approaches for testing are often described in terms of shapes, as we’ve already seen one shape with the pyramid model. In this article, I would like to share some of the shapes I have observed, how they have played out in real-world scenarios, and, in conclusion, which testing strategy fits my personal criteria for good test coverage in today’s development practices.</p>\nFlashback To The Basics\n<p>Before that, let’s revisit some common definitions of different test types to refresh our memories:</p>\n<ul>\n<li><strong>Manual tests</strong><br />This is testing done by actual people. That means a test will ask real users to click around an app by following scripted use cases, as well as unscripted attempts to “break” the app in unforeseen scenarios. This is often done with live, in-person, or remote interviews with users observed by the product team.</li>\n<li><strong>Unit tests</strong><br />This type of test is where the app is broken down into small, isolated, and testable parts — or “units” — providing coverage by individually and independently testing each unit for proper operation.</li>\n<li><strong>Integration tests</strong><br />These tests focus on the interaction between components or systems. They observe unit tests together to check that they work well when integrated together as a working whole.</li>\n<li><strong>End-to-end (E2E) tests</strong><br />The computer simulates actual user interactions in this type of test. Think of E2E as a way of validating user stories: can the user complete a specific task that requires a set of steps, and is the outcome what’s expected? That’s testing one end of the user’s experience to the other, ensuring that inputs produce proper outputs.</li>\n</ul>\n<p>Now, how should those types of testing interact? The Test Pyramid is the go-to metaphor we’ve traditionally relied on to bring these various types of testing together into a complete testing suite for any application.</p>\nAll Hail The Mighty Test Pyramid\n<p>The Test Pyramid, first introduced by Mike Cohn in his book <a href=\"https://www.mountaingoatsoftware.com/books/succeeding-with-agile-software-development-using-scrum\"><em>Succeeding with Agile</em></a>, and developed further by Martin Fowler in his “<a href=\"https://martinfowler.com/articles/practical-test-pyramid.html\">The Practical Test Pyramid</a>” post, prioritizes tests based on their performance and cost. It recommends writing tests with different levels of granularity, with fewer high-level tests and more unit tests that are fast, cheap, and reliable. The recommended test order is from quick and affordable to slow and expensive, starting with many unit tests at the bottom, followed by service, i.e., integration tests in the middle. Following that are fewer, but more specific, UI tests displayed at the top, including end-to-end tests.</p>\n<p><img src=\"https://files.smashing.media/articles/long-live-test-pyramid/test-pyramid.jpg\" /></p>\n<p>There’s a growing sentiment in the testing community that the Test Pyramid oversimplifies how tests ought to be structured. Martin Fowler addressed this <a href=\"https://martinfowler.com/articles/2021-test-shapes.html\">in a more recent blog post</a> nearly ten years after posting about the pyramid shape. My team has even questioned whether the model brings our work closer to the end user or further away. While higher levels of the pyramid increase confidence in individual tests and offer better value, it seems less mindful of the bigger picture of how everything works together. The testing pyramid felt like it was falling out of time, at least for us.</p>\nFrom Pyramids To Diamonds\n<p>One point my team discussed internally was the pyramid’s <strong>over-emphasis on unit testing</strong>. The pyramid is an excellent shape to describe what a unit test is and what scope it covers. But if you ask four people <em>what</em> a unit test is, you will likely get four different answers. Perhaps the shape needs a little altering to clear things up.</p>\n<p>The biggest clarification my team needed was <em>where</em> and <em>when</em> unit testing stops. The pyramid shape suggests that unit tests take up the majority of the test process, and that felt off to us. Integration tests are what pull those together, after all. </p>\n<p>So, another way we can view the pyramid shape of a testing strategy can is to let it evolve into a diamond shape:</p>\n<p><img src=\"https://files.smashing.media/articles/long-live-test-pyramid/testing-diamond-illustration.png\" /></p>\n<p>Integration testing is sometimes called the “forgotten layer” of the testing pyramid because it can be too complex for unit testing. But it gets more focus in the Testing Diamond (often split into two specific layers):</p>\n<ol>\n<li><strong>Integration Test Layer</strong><br />This layer is pretty much the same as what we see in the Test Pyramid, but it is reserved for tests that are considered “too big to be a unit test” — something in between the Unit and Integration Test layers. A test on a specific component would be an ideal sort of thing for this layer.</li>\n<li><strong>System Integration Test Layer</strong><br />This layer is more about “real” integration tests, like data received from an API.</li>\n</ol>\n<p>So, the diamond shape implies a process where unit tests are done immediately after integration testing is complete, but with less emphasis on those individual tests. This way, the integration layer gets the large billing it deserves while the emphasis on unit tests tapers off.</p>\nWhere’s Manual Testing?\n<p>Whether a testing strategy is called a “pyramid” or a “diamond,” it is still missing the critical place of manual testing in the process. Automated testing is valuable, to be sure,  but not to the extent that they make manual testing practices obsolete.</p>\n<p>I believe automated and manual tests work hand in hand. Automated testing should eliminate routine and common tasks, freeing testers to concentrate on the crucial areas that require more human attention. Rather than replace manual testing, automation should <em>complement</em> it.</p>\n<p>What does that mean for our diamond shape… or the pyramid, for that matter? Manual testing is nowhere in the layers but should be. Automated tests efficiently detect bugs, but manual testing is still necessary to ensure a more comprehensive testing approach to provide full coverage. That said, it’s still true that an ideal testing strategy will put a majority of the emphasis on automated tests.</p>\n<p>That means the testing strategy looks more like an ice cream cone than either a pyramid or a diamond.</p>\n<p><img src=\"https://files.smashing.media/articles/long-live-test-pyramid/testing-ice-cream-cone.png\" /></p>\n<p>In fact, this is a real premise called the “Ice Cream Cone” approach. Although this approach takes longer to implement, it results in a higher confidence level and more bugs detected. <a href=\"https://saeedgatson.com/the-software-testing-ice-cream-cone/\">Saeed Gatson provides a succinct description of it</a> in a post that dates back to 2015. </p>\n<p>But does a pizza shape actually go far enough to describe the full nature of testing? Gleb Bahmutov has taken this concept to the extreme with what he calls the <a href=\"https://changelog.com/posts/the-testing-pyramid-should-look-more-like-a-crab\">“Testing Crab”</a> model. This approach involves screenshot comparisons, which a human then verifies for differences. Bahmutov sees visual and functional testing as “the body” of the crab, with all other types of testing serving as “the limbs.” There are indeed tools that provide before-and-after snapshots during a test that, when layered on top of one another, can highlight visual regressions.</p>\nThe Testing Trophy\n<p>All testing approaches are costly, and the Test Pyramid got that point right. It’s just that the shape itself may not be realistic or effective at considering the full nature of testing and the emphasis that each layer of tests receives. So, what we need to do is <strong>find a compromise between all of these approaches</strong> that accurately depict the various layers of testing and how much emphasis each one deserves.</p>\n<p>I like how simply Guillermo Rauch summed that up back in 2016:</p>\n<p></p><blockquote><p>Write tests. Not too many. Mostly integration.</p>— Guillermo Rauch (@rauchg) <a href=\"https://twitter.com/rauchg/status/807626710350839808?ref_src=twsrc%5Etfw\">December 10, 2016</a></blockquote> <p></p>\n<p><br /></p>\n<p>Let’s break that down a bit further.</p>\n<ul>\n<li><strong>Write tests</strong><br />Not only because it builds trust but also because it saves time in maintenance.</li>\n<li><strong>Not too many</strong><br />100% coverage sounds nice, but it is not always good. If every single detail of an app is covered by tests, that means at least some of those tests are not critical to the end-user experience, and they are running purely for the sake of running, adding more overhead to maintain them.</li>\n<li><strong>Mostly integration</strong><br />Here is the emphasis on integration tests. They have the most business value because they offer a high level of confidence while maintaining a reasonable execution time.</li>\n</ul>\n<p>You might recognize the following idea if you’ve spent any amount of time following the work of Kent C. Dodds. His <a href=\"https://kentcdodds.com/blog/the-testing-trophy-and-testing-classifications\">“Testing Trophy”</a> approach elevates integration testing to a higher priority level than the traditional testing pyramid, which is perfectly aligned with Guillermo Rauch’s assertions.</p>\n<p><img src=\"https://files.smashing.media/articles/long-live-test-pyramid/testing-trophy-illustration.png\" /></p>\n<p>Kent discusses and explains the important role that comprehensive testing plays in a product’s success. He emphasizes the value of integration tests over testing individual units, as it provides a <strong>better understanding of the product’s core functionality and respected behaviors</strong>. He also suggests using fewer mockup tests in favor of more integration testing. The testing trophy is a metaphor depicting the granularity of tests in a slightly different way, distributing tests into the following types:</p>\n<ol>\n<li><strong>Static analysis</strong>: These tests quickly identify typos and type errors by way of executing debugging steps.</li>\n<li><strong>Unit tests</strong>: The trophy places less emphasis on them than the testing pyramid. </li>\n<li><strong>Integration</strong>: The trophy places the most emphasis on them.</li>\n<li><strong>User Interface (UI)</strong>: These include E2E and visual tests and maintain a significant role in the trophy as they do in the pyramid.</li>\n</ol>\n<p>The “Testing Trophy” prioritizes the user perspective and boasts a favorable cost-benefit ratio. Is it our top pick? This test strategy is the most sensible, but there is a catch. While unit tests still offer valuable benefits, there are drawbacks to integration and end-to-end tests, including longer runtimes and lower reliability. The benefits of unit tests are valid, and I still prefer to use them.</p>\nSo, Is The Test Pyramid Dead?\n<p>The Test Pyramid is still a popular testing model for software development that helps ensure applications function correctly. However, like any model, it has its flaws. One of the biggest challenges is defining what constitutes a unit test.</p>\n<p>My team implemented the modified diamond shape for our testing pipelines. And we’ve found that it’s not entirely wrong, just incomplete. We still gain valuable insights from it, particularly in prioritizing the different types of tests we run.</p>\n<p>It seems to me that development teams rarely stick to textbook test patterns, as Justin Searls has summed up nicely:</p>\n<p></p><blockquote><p>People love debating what percentage of which type of tests to write, but it's a distraction. Nearly zero teams write expressive tests that establish clear boundaries, run quickly &amp; reliably, and only fail for useful reasons. Focus on that instead.<a href=\"https://t.co/xLceALKrWe\">https://t.co/xLceALKrWe</a></p>— Justin Searls (@searls) <a href=\"https://twitter.com/searls/status/1393385209089990659?ref_src=twsrc%5Etfw\">May 15, 2021</a></blockquote> <p></p>\n<p><br /></p>\n<p>This is also true for my team’s experience, as dividing and defining tests is often difficult. And that’s not bad. Even Martin Fowler has emphasized the positive impact that different testing models have had on how we collectively view test coverage.</p>\n<p>So, in no way do I believe the Test Pyramid is dead. I might even argue that it is as essential to know it now as ever. But the point is not to get too caught up in its shape or any other shapes. The most important thing to remember is that <strong>tests should run quickly and reliably and only fail when there’s a real problem</strong>. They should benefit the user rather than simply aiming for full coverage. You’ve already accomplished the most important thing by prioritizing these aspects in test design.</p>\n<h3>References</h3>\n<ul>\n<li>“<a href=\"https://martinfowler.com/articles/practical-test-pyramid.html\">The Practical Test Pyramid</a>,” Ham Vocke</li>\n<li>“<a href=\"https://martinfowler.com/articles/2021-test-shapes.html\">On the Diverse And Fantastical Shapes of Testing</a>,” Martin Fowler</li>\n<li>“<a href=\"https://changelog.com/posts/the-testing-pyramid-should-look-more-like-a-crab\">The Testing Pyramid Should Look More Like A Crab</a>,” Gleb Bahmutov</li>\n<li>“<a href=\"https://saeedgatson.com/the-software-testing-ice-cream-cone/\">The Software Testing Ice Cream Cone</a>,” Saeed Gatson</li>\n<li>“<a href=\"https://kentcdodds.com/blog/write-tests\">Write tests. Not too many. Mostly integration</a>,” Kent C. Dodds</li>\n<li>“<a href=\"https://kentcdodds.com/blog/the-testing-trophy-and-testing-classifications\">The Testing Trophy and Testing Classifications</a>,” Kent C. Dodds</li>\n<li>“<a href=\"https://kentcdodds.com/blog/static-vs-unit-vs-integration-vs-e2e-tests\">Static vs Unit vs Integration vs E2E Testing for Frontend Apps</a>,” Kent C. Dodds</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"8bb822e18305cb109d8f8bd5a00c3eb01888c24a295f4b8fded1c695e74a0526","category":"Tech"}