{"title":"Improve the security of your software supply chain with Amazon CodeArtifact package group configuration","link":"https://aws.amazon.com/blogs/aws/improve-the-security-of-your-software-supply-chain-with-amazon-codeartifact-package-group-configuration/","date":1711061942000,"content":"<p>Starting today, administrators of package repositories can manage the configuration of multiple packages in one single place with the new <a href=\"https://aws.amazon.com/codeartifact\">AWS CodeArtifact</a> package group configuration capability. A package group allows you to define how packages are updated by internal developers or from upstream repositories. You can now allow or block internal developers to publish packages or allow or block upstream updates for a group of packages.</p> \n<p>CodeArtifact is a fully managed package repository service that makes it easy for organizations to securely store and share software packages used for application development. You can use CodeArtifact with popular build tools and package managers such as <a href=\"https://www.nuget.org/\">NuGet</a>, <a href=\"https://maven.apache.org/\">Maven</a>, <a href=\"https://gradle.org/\">Gradle</a>, <a href=\"https://www.npmjs.com/\">npm</a>, <a href=\"https://yarnpkg.com/\">yarn</a>, <a href=\"https://pypi.org/project/pip/\">pip</a>, <a href=\"https://pypi.org/project/twine/\">twine</a>, and the <a href=\"https://www.swift.org/documentation/package-manager/\">Swift Package Manager</a>.</p> \n<p>CodeArtifact supports on-demand importing of packages from public repositories such as <a href=\"https://www.npmjs.com/\">npmjs.com</a>, <a href=\"https://central.sonatype.com/?smo=true\">maven.org</a>, and <a href=\"https://pypi.org/\">pypi.org</a>. This allows your organization’s developers to fetch all their packages from one single source of truth: your CodeArtifact repository.</p> \n<p>Simple applications routinely include dozens of packages. Large enterprise applications might have hundreds of dependencies. These packages help developers speed up the development and testing process by providing code that solves common programming challenges such as network access, cryptographic functions, or data format manipulation. These packages might be produced by other teams in your organization or maintained by third parties, such as open source projects.</p> \n<p>To minimize the risks of supply chain attacks, some organizations manually vet the packages that are available in internal repositories and the developers who are authorized to update these packages. There are three ways to update a package in a repository. Selected developers in your organization might push package updates. This is typically the case for your organization’s internal packages. Packages might also be imported from upstream repositories. An upstream repository might be another CodeArtifact repository, such as a company-wide source of approved packages or external public repositories offering popular open source packages.</p> \n<p>Here is a diagram showing different possibilities to expose a package to your developers.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/03/04/codeartifact-repo-02.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/03/04/codeartifact-repo-02.png\" alt=\"CodeArtifact Multi Repository\" width=\"1920\" height=\"1080\" /></a></p> \n<p>When managing a repository, it is crucial to define how packages can be downloaded and updated. Allowing package installation or updates from external upstream repositories exposes your organization to <a href=\"https://incolumitas.com/2016/06/08/typosquatting-package-managers/\">typosquatting</a> or <a href=\"https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610\">dependency confusion</a> attacks, for example. Imagine a bad actor publishing a malicious version of a well-known package under a slightly different name. For example, instead of <code>coffee-script</code>, the malicious package is <code>cofee-script</code>, with only one “f.” When your repository is configured to allow retrieval from upstream external repositories, all it takes is a distracted developer working late at night to type <code>npm install cofee-script</code> instead of <code>npm install coffee-script</code> to inject malicious code into your systems.</p> \n<p>CodeArtifact defines three permissions for the three possible ways of updating a package. Administrators can <code>allow</code> or <code>block</code> installation and updates coming from internal <code>publish</code> commands, from an internal upstream repository, or from an external upstream repository.</p> \n<p>Until today, repository administrators had to manage these important security settings package by package. With today’s update, repository administrators can define these three security parameters for a group of packages at once. The packages are identified by their type, their namespace, and their name. This new capability operates at the domain level, not the repository level. It allows administrators to enforce a rule for a package group across all repositories in their domain. They don’t have to maintain <a href=\"https://docs.aws.amazon.com/codeartifact/latest/ug/package-origin-controls.html\">package origin controls</a> configuration in every repository.</p> \n<p><span><strong>Let’s see in detail how it works<br /> </strong></span>Imagine that I manage an internal package repository with CodeArtifact and that I want to distribute only the versions of the <a href=\"https://boto3.amazonaws.com/v1/documentation/api/latest/guide/quickstart.html\">AWS SDK for Python</a>, also known as <a href=\"https://github.com/boto/boto3\">boto3</a>, that have been vetted by my organization.</p> \n<p>I navigate to the CodeArtifact page in the <a href=\"https://console.aws.amazon.com\">AWS Management Console</a>, and I create a <code>python-aws</code> repository that will serve vetted packages to internal developers.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/02/16/2024-02-16_14-35-50.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/02/16/2024-02-16_14-35-50.png\" alt=\"CodeArtifact - Create a repo\" width=\"800\" height=\"734\" /></a></p> \n<p>This creates a staging repository in addition to the repository I created. The external packages from <code>pypi</code> will first be staged in the <code>pypi-store</code> internal repository, where I will verify them before serving them to the <code>python-aws</code> repository. Here is where my developers will connect to download them.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/02/16/2024-02-16_14-36-38.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/02/16/2024-02-16_14-36-38.png\" alt=\"CodeArtifact - Create a repo - package flow\" width=\"795\" height=\"652\" /></a>By default, when a developer authenticates against CodeArtifact and types <code>pip install boto3</code>, CodeArtifact downloads the packages from the public <code>pypi</code> repository, stages them on <code>pypi-store</code>, and copies them on <code>python-aws</code>.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/02/16/2024-02-16_14-43-55.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/02/16/2024-02-16_14-43-55.png\" alt=\"CodeArtifact - pip install\" width=\"800\" height=\"442\" /></a><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/02/16/2024-02-16_14-51-04-02.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/02/16/2024-02-16_14-51-04-02.png\" alt=\"CodeArtifact - list of packages after a pip install\" width=\"800\" height=\"481\" /></a></p> \n<p>Now, imagine I want to block CodeArtifact from fetching package updates from the upstream external <code>pypi</code> repository. I want <code>python-aws</code> to only serve packages that I approved from my <code>pypi-store</code> internal repository.</p> \n<p>With the new capability that we released today, I can now apply this configuration for a group of packages. I navigate to my domain and select the <strong>Package Groups</strong> tab. Then, I select the <strong>Create Package Group</strong> button.</p> \n<p>I enter the <strong>Package group definition</strong>. This expression defines what packages are included in this group. Packages are identified using a combination of three components: package format, an optional namespace, and name.</p> \n<p>Here are a few examples of patterns that you can use for each of the allowed combinations:</p> \n<ul> \n <li>All package formats: /*</li> \n <li>A specific package format: /npm/*</li> \n <li>Package format and namespace prefix: /maven/com.amazon~</li> \n <li>Package format and namespace: /npm/aws-amplify/*</li> \n <li>Package format, namespace, and name prefix: /npm/aws-amplify/ui~</li> \n <li>Package format, namespace, and name: /maven/org.apache.logging.log4j/log4j-core$</li> \n</ul> \n<p>I invite you to read <a href=\"https://docs.aws.amazon.com/codeartifact/latest/ug/package-groups.html\">the documentation</a> to learn all the possibilities.</p> \n<p>In my example, there is no concept of namespace for Python packages, and I want the group to include all packages with names starting with <code>boto3</code> coming from <code>pypi</code>. Therefore, I write <code>/pypi//boto3~</code>.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/03/19/2024-03-19_18-07-42.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/03/19/2024-03-19_18-07-42.png\" alt=\"CodeArtifact - package group definition\" width=\"800\" height=\"305\" /></a></p> \n<p>Then, I define the security parameters for my package group. In this example, I don’t want my organization’s developers to publish updates. I also don’t want CodeArtifact to fetch new versions from the external upstream repositories. I want to authorize only package updates from my internal staging directory.</p> \n<p>I uncheck all <strong>Inherit from parent group</strong> boxes. I select <strong>Block</strong> for <strong>Publish</strong> and <strong>External upstream</strong>. I leave <strong>Allow</strong> on <strong>Internal upstream</strong>. Then, I select <strong>Create Package Group</strong>.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/03/12/2024-03-12_09-43-42.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/03/12/2024-03-12_09-43-42.png\" alt=\"CodeArtifact - package group security configuration\" width=\"800\" height=\"496\" /></a></p> \n<p>Once defined, developers are unable to install different package versions than the ones authorized in the <code>python-aws</code> repository. When I, as a developer, try to install another version of the <code>boto3</code> package, I receive an error message. This is expected because the newer version of the <code>boto3</code> package is not available in the upstream staging repo, and there is <code>block</code> rule that prevents fetching packages or package updates from external upstream repositories.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/02/16/2024-02-16_15-30-34.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/02/16/2024-02-16_15-30-34.png\" alt=\"Code ARtifact - installation is denied when using a package version not already present in the repository\" width=\"800\" height=\"113\" /></a></p> \n<p>Similarly, let’s imagine your administrator wants to protect your organization from dependency substitution attacks. All your internal Python package names start with your company name (<code>mycompany</code>). The administrator wants to block developers for accidentally downloading from <code>pypi.org</code> packages that start with <code>mycompany</code>.</p> \n<p>Administrator creates a rule with the pattern <code>/pypi//mycompany~</code> with <code>publish=allow</code>, <code>external upstream=block</code>, and <code>internal upstream=block</code>. With this configuration, internal developers or your CI/CD pipeline can publish those packages, but CodeArtifact will not import any packages from <code>pypi.org</code> that start with <code>mycompany</code>, such as <code>mycompany.foo</code> or <code>mycompany.bar</code>. This prevents dependency substitution attacks for these packages.</p> \n<p>Package groups are available in <a href=\"https://docs.aws.amazon.com/general/latest/gr/codeartifact.html\">all AWS Regions where CodeArtifact is available</a>, at no additional cost. It helps you to better control how packages and package updates land in your internal repositories. It helps to prevent various supply chain attacks, such as <a href=\"https://incolumitas.com/2016/06/08/typosquatting-package-managers/\">typosquatting</a> or <a href=\"https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610\">dependency confusion</a>. It’s one additional configuration that you can add today into your infrastructure-as-code (IaC) tools to create and manage your CodeArtifact repositories.</p> \n<p>Go and <a href=\"https://docs.aws.amazon.com/codeartifact/latest/ug/package-groups.html\">configure your first package group today</a>.</p> \n<a href=\"https://twitter.com/sebsto\">-- seb</a>","author":"Sébastien Stormacq","siteTitle":"AWS News Blog","siteHash":"6093e072e4117ec22616e844cb857d03ca62c57a411a8affc77cb5e8b6b15bf6","entryHash":"1b3bb9d850fc9716848c4637584bc71823104e2e734861511248eb47849234a2","category":"Tech"}