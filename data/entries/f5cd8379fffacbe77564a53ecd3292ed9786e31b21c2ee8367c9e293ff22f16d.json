{"title":"Simplify How You Manage Authorization in Your Applications with Amazon Verified Permissions – Now Generally Available","link":"https://aws.amazon.com/blogs/aws/simplify-how-you-manage-authorization-in-your-applications-with-amazon-verified-permissions-now-generally-available/","date":1686673671000,"content":"<p>When developing a new application or integrating an existing one into a new environment, user authentication and authorization require significant effort to be correctly implemented. In the past, you would have built your own authentication system, but today you can use an external identity provider like <a href=\"https://aws.amazon.com/cognito/\">Amazon Cognito</a>. Yet, authorization logic is typically implemented in code.</p> \n<p>This might begin simply enough, with all users assigned a role for their job function. However, over time, these permissions grow increasingly complex. The number of roles expands, as permissions become more fine-grained. New use cases drive the need for custom permissions. For instance, one user might share a document with another in a different role, or a support agent might require temporary access to a customer account to resolve an issue. Managing permissions in code is prone to errors, and presents significant challenges when auditing permissions and deciding who has access to what, particularly when these permissions are expressed in different applications and using multiple programming languages.</p> \n<p>At <a href=\"https://reinvent.awsevents.com/\">re:Invent</a> 2022, we introduced in preview <a href=\"https://aws.amazon.com/verified-permissions/?trk=bfd62b3b-4901-4dca-bb9a-61dc1f9ce8db&amp;sc_channel=el\">Amazon Verified Permissions</a>, a fine-grained permissions management and authorization service for your applications that can be used at any scale. Amazon Verified Permissions centralizes permissions in a policy store and helps developers use those permissions to authorize user actions within their applications. Similar to how an identity provider simplifies authentication, a policy store lets you manage authorization in a consistent and scalable way.</p> \n<p>To define fine-grained permissions, Amazon Verified Permissions uses <a href=\"https://www.cedarpolicy.com/\">Cedar</a>, an <a href=\"https://github.com/cedar-policy/\">open-source policy language and software development kit (SDK)</a> for access control. You can define a schema for your authorization model in terms of principal types, resource types, and valid actions. In this way, when a policy is created, it is validated against your authorization model. You can simplify the creation of similar policies using templates. Changes to the policy store are audited so that you can see of who made the changes and when.</p> \n<p>You can then connect your applications to Amazon Verified Permissions through <a href=\"https://aws.amazon.com/tools/\">AWS SDKs</a> to authorize access requests. For each authorization request, the relevant policies are retrieved and evaluated to determine whether the action is permitted or not. You can reproduce those authorization requests to confirm that permissions work as intended.</p> \n<p>Today, I am happy to share that Amazon Verified Permissions is generally available with new capabilities and a simplified user experience in the <a href=\"https://console.aws.amazon.com\">AWS Management Console</a>.</p> \n<p>Let’s see how you can use it in practice.</p> \n<p><span><strong>Creating a Policy Store with Amazon Verified Permissions<br /> </strong></span>In the <a href=\"https://console.aws.amazon.com/verifiedpermissions\">Amazon Verified Permissions console</a>, I choose <strong>Create policy store</strong>. A policy store is a logical container that stores policies and schema. Authorization decisions are made based on all the policies present in a policy store.</p> \n<p>To configure the new policy store, I can use different methods. I can start with a guided setup, a sample policy store (such as for a photo-sharing app, an online store, or a task manager), or an empty policy store (recommended for advanced users). I select <strong>Guided setup</strong>, enter a namespace for my schema (<code>MyApp</code>), and choose <strong>Next</strong>.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/05/amazon-verified-permissions-create-policy-store.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/05/amazon-verified-permissions-create-policy-store-1024x760.png\" alt=\"Console screenshot.\" width=\"1024\" height=\"760\" /></a></p> \n<p>Resources are the objects that principals can act on. In my application, I have <code>Users</code> (principals) that can create, read, update, and delete <code>Documents</code> (resources). I start to define the <code>Documents</code> resource type.</p> \n<p>I enter the name of the resource type and add two required attributes:</p> \n<ul> \n <li><code>owner</code> (<strong>String</strong>) to specify who is the owner of the document.</li> \n <li><code>isPublic</code> (<strong>Boolean</strong>) to flag public documents that anyone can read.</li> \n</ul> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/05/amazon-verified-permissions-create-policy-store-resource.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/05/amazon-verified-permissions-create-policy-store-resource-1024x508.png\" alt=\"Console screenshot.\" width=\"1024\" height=\"508\" /></a></p> \n<p>I specify four actions for the <code>Document</code> resource type:</p> \n<ul> \n <li><code>DocumentCreate</code></li> \n <li><code>DocumentRead</code></li> \n <li><code>DocumentUpdate</code></li> \n <li><code>DocumentDelete</code></li> \n</ul> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/05/amazon-verified-permissions-create-policy-store-actions.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/05/amazon-verified-permissions-create-policy-store-actions-1024x407.png\" alt=\"Console screenshot.\" width=\"1024\" height=\"407\" /></a></p> \n<p>I enter <code>User</code> as the name of the principal type that will be using these actions on <code>Documents</code>. Then, I choose <strong>Next</strong>.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/05/amazon-verified-permissions-create-policy-store-principal.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/05/amazon-verified-permissions-create-policy-store-principal-1024x233.png\" alt=\"Console screenshot.\" width=\"1024\" height=\"233\" /></a></p> \n<p>Now, I configure the <code>User</code> principal type. I can use a custom configuration to integrate an external identity source, but in this case, I use an Amazon Cognito user pool that I created before. I choose <strong>Connect user pool</strong>.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/05/amazon-verified-permissions-create-policy-store-identity-source.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/05/amazon-verified-permissions-create-policy-store-identity-source-1024x712.png\" alt=\"Console screenshot.\" width=\"1024\" height=\"712\" /></a></p> \n<p>In the dialog, I select the <a href=\"https://aws.amazon.com/about-aws/global-infrastructure/regions_az/\">AWS Region</a> where the user pool is located, enter the user pool ID, and choose <strong>Connect</strong>.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/05/amazon-verified-permissions-create-policy-cognito-user-pool.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/05/amazon-verified-permissions-create-policy-cognito-user-pool-1024x608.png\" alt=\"Console screenshot.\" width=\"1024\" height=\"608\" /></a></p> \n<p>Now that the Amazon Cognito user pool is connected, I can add another level of protection by validating the client application IDs. For now, I choose not to use this option.</p> \n<p>In the <strong>Principal attributes</strong> section, I select which attributes I am planning to use for attribute-based access control in my policies. I select <code>sub</code> (the subject), used to identify the end user according to the <a href=\"https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims\">OpenID Connect specification</a>. I can select more attributes. For example, I can use <code>email_verified</code> in a policy to give permissions only to Amazon Cognito users whose email has been verified.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/05/amazon-verified-permissions-principal-attributes.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/05/amazon-verified-permissions-principal-attributes-1024x707.png\" alt=\"Console screenshot.\" width=\"1024\" height=\"707\" /></a></p> \n<p>As part of the policy store creation, I create a first policy to give read access to user <code>danilop</code> to the <code>doc.txt</code> document.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/05/amazon-verified-permissions-create-policy-store-first-policy.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/06/05/amazon-verified-permissions-create-policy-store-first-policy-1024x1009.png\" alt=\"Console screenshot.\" width=\"1024\" height=\"1009\" /></a></p> \n<p>In the following code, the console gives me a preview of the resulting policy using the Cedar language.</p> \n<div> \n <pre><code>permit(\n  principal == MyApp::User::\"danilop\",\n  action in [MyApp::Action::\"DocumentRead\"],\n  resource == MyApp::Document::\"doc.txt\"\n) when {\n  true\n};</code></pre> \n</div> \n<p>Finally, I choose <strong>Create policy store</strong>.</p> \n<p><span><strong>Adding Permissions to the Policy Store<br /> </strong></span>Now that the policy store has been created, I choose <strong>Policies</strong> in the navigation pane. In the <strong>Create policy</strong> dropdown, I choose <strong>Create static policy</strong>. A static policy contains all the information needed for its evaluation. In my second policy, I allow any user to read public documents. By default everything is forbidden, so in <strong>Policy Effect</strong> I choose <strong>Permit</strong>.</p> \n<p>In the <strong>Policy scope</strong>, I leave <strong>All principals</strong> and <strong>All resources</strong> selected, and select the <code>DocumentRead</code> action. In the <strong>Policy</strong> section, I change the <code>when</code> condition clause to limit permissions to resources where <code>isPublic</code> is equal to <code>true</code>:</p> \n<div> \n <pre><code>permit (\n  principal,\n  action in [MyApp::Action::\"DocumentRead\"],\n  resource\n)\nwhen { resource.isPublic };</code></pre> \n</div> \n<p>I enter a description for the policy and choose <strong>Create policy</strong>.</p> \n<p>For my third policy, I create another static policy to allow full access to the owner of a document. Again, in <strong>Policy Effect</strong>, I choose Permit and, in the <strong>Policy scope</strong>, I leave <strong>All principals</strong> and <strong>All resources</strong> selected. This time, I also leave <strong>All actions</strong> selected.</p> \n<p>In the <strong>Policy</strong> section, I change the <code>when</code> condition clause to limit permissions to resources where the <code>owner</code> is equal to the <code>sub</code> of the principal:</p> \n<div> \n <pre><code>permit (principal, action, resource)\nwhen { resource.owner == principal.sub };</code></pre> \n</div> \n<p>In my application, I need to allow read access to specific users that are not owners of a document. To simplify that, I create a policy template. Policy templates let me create policies from a template that uses placeholders for some of their values, such as the principal or the resource. The placeholders in a template are keywords that start with the <code>?</code> character.</p> \n<p>In the navigation pane, I choose <strong>Policy templates</strong> and then <strong>Create policy template</strong>. I enter a description and use the following policy template body. When using this template, I can specify the value for the <code>?principal</code> and <code>?resource</code> placeholders.</p> \n<div> \n <pre><code>permit(\n  principal == ?principal,\n  action in [MyApp::Action::\"DocumentRead\"],\n  resource == ?resource\n);</code></pre> \n</div> \n<p>I complete the creation of the policy template. Now, I use the template to simplify the creation of policies. I choose <strong>Policies</strong> in the navigation pane, and then <strong>Create a template-linked policy</strong> in the <strong>Create policy dropdown</strong>. I select the policy template I just created and choose <strong>Next</strong>.</p> \n<p>To give access to a user (<code>danilop</code>) for a specific document (<code>new-doc.txt</code>), I just pass the following values (note that <code>MyApp</code> is the namespace of the policy store):</p> \n<ul> \n <li>For the <strong>Principal</strong>: <code>MyApp::User::\"danilop\"</code></li> \n <li>For the <strong>Resource</strong>: <code>MyApp::Document::\"new-doc.txt\"</code></li> \n</ul> \n<p>I complete the creation of the policy. It’s now time to test if the policies work as expected.</p> \n<p><span><strong>Testing Policies in the Console<br /> </strong></span>In my applications, I can use the <a href=\"https://aws.amazon.com/tools/\">AWS SDKs</a> to run an authorization request. The console provides a way to to simulate what my applications would do. I choose <strong>Test bench</strong> in the navigation pane. To simplify testing, I use the <strong>Visual mode</strong>. As an alternative, I have the option to use the same JSON syntax as in the SDKs.</p> \n<p>As <strong>Principal</strong>, I pass the <code>janedoe</code> user. As <strong>Resource</strong>, I use <code>requirements.txt</code>. It’s not a public document (<code>isPublic</code> is <code>false</code>) and the <code>owner</code> attribute is equal to <code>janedoe</code>‘s <code>sub</code>. For the <strong>Action</strong>, I select <code>MyApp::Action::\"DocumentUpdate\"</code>.</p> \n<p>When running an authorization request, I can pass <strong>Additional entities</strong> with more information about principals and resources associated with the request. For now, I leave this part empty.</p> \n<p>I choose <strong>Run authorization request</strong> at the top to see the decision based on the current policies. As expected, the decision is <strong>allow</strong>. Here, I also see which policies hav been satisfied by the authorization request. In this case, it is the policy that allows full access to the owner of the document.</p> \n<p>I can test other values. If I change the owner of the document and the action to <code>DocumentRead</code>, the decision is <strong>deny</strong>. If I then set the resource attribute <code>isPublic</code> to <code>true</code>, the decision is <strong>allow</strong> because there is a policy that permits all users to read public documents.</p> \n<p><span><strong>Handling Groups in Permissions<br /> </strong></span>The administrative users in my application need to be able to delete any document. To do so, I create a role for admin users. First, I choose <strong>Schema</strong> in the navigation pane and then <strong>Edit schema</strong>. In the list of entity types, I choose to add a new one. I use <code>Role</code> as <strong>Type name</strong> and add it. Then, I select <code>User</code> in the entity types and edit it to add <code>Role</code> as a parent. I save changes and create the following policy:</p> \n<div> \n <pre><code>permit (\n  principal in MyApp::Role::\"admin\",\n  action in [MyApp::Action::\"DocumentDelete\"],\n  resource\n);</code></pre> \n</div> \n<p>In the <strong>Test bench</strong>, I run an authorization request to check if user <code>jeffbarr</code> can delete (<code>DocumentDelete</code>) resource <code>doc.txt</code>. Because he’s not the owner of the resource, the request is denied.</p> \n<p>Now, in the <strong>Additional entities</strong>, I add the <code>MyApp::User</code> entity with <code>jeffbarr</code> as identifier. As parent, I add the <code>MyApp::Role</code> entity with <code>admin</code> as identifier and confirm. The console warns me that entity <code>MyApp::Role::\"admin\"</code> is referenced, but it isn’t included in additional entities data. I choose to add it and fix this issue.</p> \n<p>I run an authorization request again, and it is now allowed because, according to the additional entities, the principal (<code>jeffbarr</code>) is an <code>admin</code>.</p> \n<p><span><strong>Using Amazon Verified Permissions in Your Application<br /> </strong></span>In my applications, I can run an authorization requests using the <code>isAuthorized</code> API action (or <code>isAuthrizedWithToken</code>, if the principal comes from an external identity source).</p> \n<p>For example, the following Python code uses the <a href=\"https://aws.amazon.com/sdk-for-python/\">AWS SDK for Python (Boto3)</a> to check if a user has read access to a document. The authorization request uses the policy store I just created.</p> \n<pre><code>import boto3\nimport time\n\nverifiedpermissions_client = boto3.client(\"verifiedpermissions\")\n\nPOLICY_STORE_ID = \"XAFTHeCQVKkZhsQxmAYXo8\"\n\ndef is_authorized_to_read(user, resource):\n\n    authorization_result = verifiedpermissions_client.is_authorized(\n        policyStoreId=POLICY_STORE_ID, \n        principal={\"entityType\": \"MyApp::User\", \"entityId\": user}, \n        action={\"actionType\": \"MyApp::Action\", \"actionId\": \"DocumentRead\"},\n        resource={\"entityType\": \"MyApp::Document\", \"entityId\": resource}\n    )\n\n    print('Can {} read {} ?'.format(user, resource))\n\n    decision = authorization_result[\"decision\"]\n\n    if decision == \"ALLOW\":\n        print(\"Request allowed\")\n        return True\n    else:\n        print(\"Request denied\")\n        return False\n\nif is_authorized_to_read('janedoe', 'doc.txt'):\n    print(\"Here's the doc...\")\n\nif is_authorized_to_read('danilop', 'doc.txt'):\n    print(\"Here's the doc...\")\n</code></pre> \n<p>I run this code and, as you can expect, the output is in line with the tests run before.</p> \n<div> \n <pre><code>Can janedoe read doc.txt ?\nRequest denied\nCan danilop read doc.txt ?\nRequest allowed\nHere's the doc...</code></pre> \n</div> \n<p><span><strong>Availability and Pricing<br /> </strong></span><a href=\"https://aws.amazon.com/verified-permissions/?trk=bfd62b3b-4901-4dca-bb9a-61dc1f9ce8db&amp;sc_channel=el\">Amazon Verified Permissions</a> is available today in all commercial <a href=\"https://aws.amazon.com/about-aws/global-infrastructure/regions_az/\">AWS Regions</a>, excluding those that are based in China.</p> \n<p>With Amazon Verified Permissions, you only pay for what you use based on the number of authorization requests and API calls made to the service. For more information, see <a href=\"https://aws.amazon.com/verified-permissions/pricing/?trk=0626634f-b3d9-4304-ba1a-49a9878addb0&amp;sc_channel=el\">Amazon Verified Permissions pricing</a>.</p> \n<p>Using Amazon Verified Permissions, you can configure fine-grained permissions using the <a href=\"https://www.cedarpolicy.com/\">Cedar</a> policy language and simplify the code of your applications. In this way, permissions are maintained in a centralized store and are easier to audit. Here, you can read more about <a href=\"https://www.amazon.science/blog/how-we-built-cedar-with-automated-reasoning-and-differential-testing\">how we built Cedar with automated reasoning and differential testing</a>.</p> \n<p><a href=\"https://aws.amazon.com/verified-permissions/?trk=bfd62b3b-4901-4dca-bb9a-61dc1f9ce8db&amp;sc_channel=el\"><span><strong>Manage authorization for your applications with Amazon Verified Permissions.</strong></span></a></p> \n<p>— <a href=\"https://twitter.com/danilop\">Danilo</a></p>","author":"Danilo Poccia","siteTitle":"AWS News Blog","siteHash":"6093e072e4117ec22616e844cb857d03ca62c57a411a8affc77cb5e8b6b15bf6","entryHash":"f5cd8379fffacbe77564a53ecd3292ed9786e31b21c2ee8367c9e293ff22f16d","category":"Tech"}