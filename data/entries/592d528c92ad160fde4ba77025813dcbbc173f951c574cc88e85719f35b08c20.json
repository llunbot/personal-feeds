{"title":"How To Protect Your API Key In Production With Next.js API Route","link":"https://smashingmagazine.com/2021/12/protect-api-key-production-nextjs-api-route/","date":1638437400000,"content":"<p>Front-end developers have to interact with private or public APIs whose method of authorization requires a secret key/API key that enables developers to use these APIs. The key(s) are important, hence the need to store/protect the key(s) arises. Creating an environment variable that stores the key is the “go-to” solution that most developers tend to embrace, but there’s a catch. The environment variable <strong>does not protect the key(s)</strong> from anyone that knows their way around the dev-tools of their browser. That’s why we need to use our keys at server-side when we’re writing our API calls.</p>\n<p>In this article, we’ll be using Next.js to bootstrap our app. This does not mean that the <a href=\"https://create-react-app.dev/\"><code>create-react-app</code></a> library will not work. You can make use of any one that you find convenient. We’re using Next.js because of the many perks that come with it. (You can read more about Next.js <a href=\"https://nextjs.org/docs/getting-started.\">here</a>.)</p>\n<p>Let us start by installing the dependencies that we need in this project. We’ll start by creating a Next.js app. The command below does that for us:</p>\n<pre><code>npx create-next-app [name-of-your-app]</code></pre>\n\n<p>We’ll make use of the native JavaScript <code>\"Fetch API\"</code> library to get data from the API. We won’t be covering much of the styling aspect in this article. (If you want to take a look at an example project I built using the Next.js API route pattern, you can find the repository <a href=\"https://github.com/Caleb335/article-example-projects/blob/master/src/container/users/index.js\">here</a>.)</p>\n<p>Now let’s have a look at the file structure of the app. We’ll be focusing on the important files needed in this app, so it’ll be concise.</p>\n<pre><code>|--pages\n|   |-- api\n|   |   |-- serverSideCall.js  \n|   |-- _app.js\n|   |-- index.js\n|__ .env.local</code></pre>\n\nBreakdown Of The Files In The App Structure\n<p>In this section, we are going to see the different files that make up the architecture of this project, and their respective functions below.</p>\n<p>The <code>pages</code> directory is where all the routing of the app takes place. This is an out-of-the-box feature of Next.js. It saves you the stress of hard hard-coding your independent routes.</p>\n<ul>\n<li><p><code>pages/api</code><br />The api directory enables you to have a backend for your Next.js app, inside the same codebase, instead of the common way of creating separate repositories for your REST or GraphQL APIs and deploying them on backend hosting platforms like Heroku, and so on.</p>\n<p>  With the <code>api</code> directory, every file is treated as an API endpoint. If you look at the <code>api</code> folder, you’ll notice that we have a file called <code>user.js</code> in it.</p>\n<p>  That file becomes an endpoint, which means an API call can be performed using the path to the file as the base URL.</p>\n</li>\n</ul>\n<pre><code>const getData = async() =&gt; {\n  fetch(\"/api/users\")\n   .then(response =&gt; response())\n   .then(response =&gt; console.log(response.data))\n   .catch(err =&gt; console.log(err)\n}</code></pre>\n\n<ul>\n<li><code>pages/_app.js</code><br />It is where all our components get attached to the DOM. If you take a look at the component structure, you’ll see that all the components are passed as <code>pageProps</code> to the <code>Component</code> props too.</li>\n</ul>\n<pre><code>function MyApp({ Component, pageProps }) {\n  return (\n    &lt;React.Fragment&gt;\n      &lt;Head&gt;\n        &lt;meta name=\"theme-color\" content=\"#73e2a7\" /&gt;\n        &lt;link rel=\"icon\" type=\"image/ico\" href=\"\" /&gt;\n      &lt;/Head&gt;\n      &lt;Component {...pageProps} /&gt;\n    &lt;/React.Fragment&gt;\n  );\n}\n\nexport default MyApp;</code></pre>\n\n<p>If you are new to Next.js, kindly go through this <a href=\"https://www.smashingmagazine.com/2020/10/getting-started-with-next-js/\">article</a> that will guide you through the process.</p>\n<ul>\n<li><code>index.js</code><br />It is the default route in the pages folder. When you run the command below, it starts up a development server and the contents of <code>index.js</code> are rendered on the web page.</li>\n</ul>\n<pre><code>npm run dev</code></pre>\n\n<ul>\n<li><code>.env.local</code><br />It is where we’re storing the API key that’ll enable us to consume this API.</li>\n</ul>\nThe Server-Side API Call\n<p>The previous section exposed you to the files that we’ll be interacting with and their specific functions. In this section, we will move on to how we can consume the API.</p>\n<p>The reason why we’re writing the API call at the server-side is for securing our API key, and Next.js already makes it an easy task for us. With the API routes in Next.js, we can perform our API calls without the fear of our API keys being revealed on the client-side.</p>\n<p>You may have been wondering what the essence of the environment variable in the <code>.env</code> file is, in this scenario.</p>\n<p>The environment variable (which is our API key) can only be available in <code>development</code> mode. </p>\n<p>That is why we can do something like <code>process.env.api_key</code>, and get access to the environment variable.</p>\n<p>But, the moment you deploy your app to platforms like Netlify or Vercel, the mode changes to <code>production</code>, which makes the Node.js <code>process</code> object unavailable on the client-side.</p>\n<p>Now that you have seen the reason why need to write a server-side API call. Let’s get to it right away.</p>\n<pre><code>export default async function serverSideCall(req, res) {\n    const {\n      query: { firstName, lastName },\n    } = req;\n\n    const baseUrl = `https://api.example-product.com/v1/search?\n        lastName=${lastName}&amp;firstName=${firstName}\n        &amp;apiKey=${process.env.KEY}\n    `;\n    const response = await fetch (baseUrl);\n    res.status(200).json({\n    data: response.data,\n  });\n}</code></pre>\n\n<p>In the snippet above, we created an asynchronous function called, <code>serverSideCall</code>. It takes in two arguments, <code>req</code> which stands for “request” in full, and <code>res</code> which is “response” in full.</p>\n<p>The <code>req</code> argument has some properties, (or “middlewares” as the Next.js docs call it) that can be accessed when we’re consuming our API, one of them is <code>req.query</code>.</p>\n<p>You’ll notice that we destructured the <code>query</code> property in the snippet above, so we should now be able to pass those variables as values to the query properties of the API endpoint. Take a look at it below.</p>\n<p><strong>Note</strong>: <em>You can read more about the in-built middlewares that come with the <code>req</code> argument <a href=\"https://nextjs.org/docs/api-routes/api-middlewares\">here</a>.</em></p>\n<pre><code>const {\n  query: { firstName, lastName },\n} = req;</code></pre>\n\n<p>The base URL takes the destructured query properties as values and the <code>apiKey</code> is gotten from the <code>.env</code> file via the Node.js <code>process</code> object.</p>\n<p>The destructured query properties are taken as requests that will be sent from the input values of the form component (which we’ll be creating in the next section) to the API, once it is received, we get a response that corresponds with the request we made.</p>\n<div>\n<pre><code>const baseUrl = <code>https://api.kelvindata.com/rest/v1/searchv2?  lastName=${lastName}&amp;firstName=${firstName}&amp;apiKey=${process.env.KEY}</code>;</code></pre>\n</div>\n\n<p>The next process the function has to complete is the response from the asynchronous API call. The snippet below assigns the API call which we are performing with the <code>axios</code> library to a variable, <code>response</code>.</p>\n<p>On the next line, the <code>res</code> argument uses the <code>status</code> method which is used to send a JSON response to us, then we can assign the response variable as a property of <code>data</code>.</p>\n<pre><code>const response = await axios.get(baseUrl);\nres.status(200).json({\n  data: response.data,\n});</code></pre>\n\n<p>You can read more about the various HTTP status codes <a href=\"https://dillionmegida.com/p/http-status-codes/\">here</a>.</p>\nPractical Usage Of The Server-Side API Function\n<p>In this section, we’ll have a look at how we can utilize the server-side API call by creating a form with two input fields. The input values will be sent as query parameters to the API endpoint.</p>\n<pre><code>import React from \"react\";\n\nconst Index = () =&gt; {\n  const [data, setData] = React.useState([]);\n  const [firstName, setFirstName] = React.useState(\"\");\n  const [lastName, setLastName] = React.useState(\"\");\n\n  const getuserData = async () =&gt; {\n    // api call goes here\n  };\n\n  const handleSubmit = (e) =&gt; {\n     e.preventDefault();\n     getuserData();\n  };\n\n  return (\n     &lt;React.Fragment&gt;\n       &lt;form onSubmit={handleSubmit}&gt;\n          &lt;label htmlFor=\"firstname\"&gt;First name&lt;/label&gt;\n          &lt;input\n            type=\"text\"\n            name=\"firstname\"\n            value={firstName}\n            placeholder=\"First Name\"\n            onChange={(e) =&gt; setFirstName(e.target.value)}\n          /&gt;\n          &lt;label htmlFor=\"lastname\"&gt;Lastname&lt;/label&gt;\n          &lt;input\n            type=\"text\"\n            name=\"lastname\"\n            value={lastName}\n            placeholder=\"Lastname\"\n            onChange={(e) =&gt; setLastName(e.target.value)}\n          /&gt;\n           &lt;button&gt;Search&lt;/button&gt;\n        &lt;/form&gt;\n        &lt;div className=\"results-from-api\"&gt;&lt;/div&gt;\n    &lt;/React.Fragment&gt;\n );\n};\n\nexport default Index;</code></pre>\n\n<p>Since this is a React component that is receiving data from an API endpoint, it should have an internal state of its own. The snippet below shows how we defined the different state variables with React Hooks.</p>\n<pre><code>const [userData, setUserData] = React.useState([]);\nconst [firstName, setFirstName] = React.useState(\"\");\nconst [lastName, setLastName] = React.useState(\"\");</code></pre>\n\n<p>The <code>firstName</code> and <code>lastName</code> variables will store the text values that are typed into the input field by anyone into the local state variables.</p>\n<p>The <code>data</code> state variable helps us store the response that we get from the API call in an array, so we can use the JavaScript <code>map()</code> method to render the response on the webpage.</p>\n<p>Below, we’re using <code>axios</code> to get data from the API endpoint. But here, the base URL is not a typical <code>https://</code> URL, instead, it is the path to the file where we made the server-side API call before.</p>\n<pre><code>const getuserData = async () =&gt; {\nfetch(`/api/usersfirstName=${firstName}&amp;lastName=${lastName}`, {\n       headers: {\n         Accept: \"application/json\",\n       },\n})\n  .then((response) =&gt; response)\n  .then((response) =&gt; {\n    setData(response.data.data); \n    console.log(response.data.data);\n  })\n  .catch((err) =&gt; console.log(err));\n};</code></pre>\n\n<p>The same process in the <code>serverSideCall.js</code> file is repeated, but this time around with the necessary fetch API headers and assignment of the input state variables to the API query parameters. </p>\nConclusion\n<p>There are other approaches that can help achieve this feat. Here are some of them:</p>\n<ul>\n<li><strong>Creating Netlify Lambda functions that’ll help protect your API keys on the client-side.</strong><br />This approach does it pretty much for you, but if you’re not a fan of writing so much code, it will help you get the little things done. The Next.js API route is your best bet in solving this issue.</li>\n<li><strong>Server rendering with Next.js to hide API keys.</strong><br />In this video, <a href=\"https://ijemmao.me/\">Ijemma Onwuzulike</a> gives an explanation of how to get this done with server-side rendering. <a href=\"https://www.youtube.com/watch?v=NbXwP1oBym8\">I recommend checking it out</a>.</li>\n</ul>\n<p>Thank you for reading this article. Kindly share it and also feel free to take a look at a practical example project that I built using the Next.js API route <a href=\"https://exdemo.netlify.app/demo/kelvin-data\">here</a>.</p>\n<h3>Further Reading On Smashing Magazine</h3>\n<ul>\n<li>“<a href=\"https://www.smashingmagazine.com/2021/05/implement-authentication-nextjs-auth0/\">How To Implement Authentication In Next.js With Auth0</a>,” Facundo Giuliani</li>\n<li>“<a href=\"https://www.smashingmagazine.com/2021/11/maintain-large-nextjs-application/\">How To Maintain A Large Next.js Application</a>,” Nirmalya Ghosh</li>\n<li>“<a href=\"https://www.smashingmagazine.com/2021/07/migrate-jquery-nextjs/\">How To Migrate From jQuery To Next.js</a>,” Facundo Giuliani</li>\n<li>“<a href=\"https://www.smashingmagazine.com/2021/10/nextjs-ecommerce-cls-case-study/\">Solving CLS Issues In A Next.js-Powered E-Commerce Website (Case Study)</a>,” Arijit Mondal</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"592d528c92ad160fde4ba77025813dcbbc173f951c574cc88e85719f35b08c20","category":"Tech"}