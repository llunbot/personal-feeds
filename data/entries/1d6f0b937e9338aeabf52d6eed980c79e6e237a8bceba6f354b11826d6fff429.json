{"title":"CSS <code>@scope</code>: An Alternative To Naming Conventions And Heavy Abstractions","link":"https://smashingmagazine.com/2026/02/css-scope-alternative-naming-conventions/","date":1770278400000,"content":"<p>When learning the principles of basic CSS, one is taught to write modular, reusable, and descriptive styles to ensure maintainability. But when developers become involved with real-world applications, it often feels impossible to add UI features without styles leaking into unintended areas.</p>\n<p>This issue often snowballs into a self-fulfilling loop; styles that are theoretically scoped to one element or class start showing up where they don’t belong. This forces the developer to create even more specific selectors to override the leaked styles, which then accidentally override global styles, and so on.</p>\n<p>Rigid class name conventions, such as <a href=\"https://getbem.com/introduction/\">BEM</a>, are one theoretical solution to this issue. The <strong>BEM (Block, Element, Modifier) methodology</strong> is a <a href=\"https://www.smashingmagazine.com/2012/04/a-new-front-end-methodology-bem/\">systematic way of naming CSS classes</a> to ensure reusability and structure within CSS files. Naming conventions like this can <a href=\"https://www.smashingmagazine.com/2018/06/bem-for-beginners/\">reduce cognitive load by leveraging domain language to describe elements and their state</a>, and if implemented correctly, <a href=\"https://www.smashingmagazine.com/2025/06/css-cascade-layers-bem-utility-classes-specificity-control/\">can make styles for large applications easier to maintain</a>. </p>\n<p>In the real world, however, it doesn’t always work out like that. Priorities can change, and with change, implementation becomes inconsistent. Small changes to the HTML structure can require many CSS class name revisions. With highly interactive front-end applications, class names following the BEM pattern can become long and unwieldy (e.g., <code>app-user-overview__status--is-authenticating</code>), and not fully adhering to the naming rules breaks the system’s structure, thereby negating its benefits.</p>\n<p>Given these challenges, it’s no wonder that developers have turned to frameworks, Tailwind being <a href=\"https://2024.stateofcss.com/en-US/tools/\">the most popular CSS framework</a>. Rather than trying to fight what seems like an unwinnable specificity war between styles, it is easier to give up on the <a href=\"https://css-tricks.com/the-c-in-css-the-cascade/\">CSS Cascade</a> and use tools that guarantee complete isolation.</p>\nDevelopers Lean More On Utilities\n<p>How do we know that some developers are keen on avoiding cascaded styles? It’s the rise of “modern” front-end tooling — like <a href=\"https://www.smashingmagazine.com/2016/04/finally-css-javascript-meet-cssx/\">CSS-in-JS frameworks</a> — designed specifically for that purpose. Working with isolated styles that are tightly scoped to specific components can seem like a breath of fresh air. It removes the need to name things — <a href=\"https://24ways.org/2014/naming-things/\">still one of the most hated and time-consuming front-end tasks</a> — and allows developers to be productive without fully understanding or leveraging the benefits of CSS inheritance.</p>\n<p>But ditching the CSS Cascade comes with its own problems. For instance, composing styles in JavaScript requires heavy build configurations and often leads to styles awkwardly intermingling with component markup or HTML. Instead of carefully considered naming conventions, we allow build tools to autogenerate selectors and identifiers for us (e.g., <code>.jsx-3130221066</code>), requiring developers to keep up with yet another pseudo-language in and of itself. (As if the cognitive load of understanding what all your component’s <code>useEffect</code>s do weren’t already enough!) </p>\n<p>Further abstracting the job of naming classes to tooling means that basic debugging is often constrained to specific application versions compiled for development, rather than leveraging native browser features that support live debugging, such as Developer Tools.</p>\n<p>It’s almost like we need to develop tools to debug the tools we’re using to abstract what the web already provides — all for the sake of running away from the “pain” of writing standard CSS.</p>\n<p>Luckily, modern CSS features not only make writing standard CSS more flexible but also give developers like us a great deal more power to manage the cascade and make it work for us. <a href=\"https://www.smashingmagazine.com/2022/01/introduction-css-cascade-layers/\">CSS Cascade Layers</a> are a great example, but there’s another feature that gets a surprising lack of attention — although that is changing now that it has recently become <strong>Baseline compatible</strong>.</p>\nThe CSS <code>@scope</code> At-Rule\n<p>I consider the <strong>CSS <code>@scope</code> at-rule</strong> to be a potential cure for the sort of style-leak-induced anxiety we’ve covered, one that does not force us to compromise native web advantages for abstractions and extra build tooling.</p>\n<blockquote>“The <code>@scope</code> CSS at-rule enables you to select elements in specific DOM subtrees, targeting elements precisely without writing overly-specific selectors that are hard to override, and without coupling your selectors too tightly to the DOM structure.”<br /><br />— <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/@scope\">MDN</a></blockquote>\n\n<p>In other words, we can work with isolated styles in specific instances <strong>without sacrificing inheritance, cascading, or even the basic separation of concerns</strong> that has been a long-running guiding principle of front-end development.</p>\n<p>Plus, it has <a href=\"https://caniuse.com/css-cascade-scope\">excellent browser coverage</a>. In fact, <a href=\"https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/146\">Firefox 146</a> added support for <code>@scope</code> in December, making it <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Baseline/Compatibility\">Baseline compatible</a> for the first time. Here is a simple comparison between a button using the BEM pattern versus the <code>@scope</code> rule:</p>\n<pre><code>&lt;!-- BEM --&gt; \n&lt;button class=\"button button--primary\"&gt;\n  &lt;span class=\"button__text\"&gt;Click me&lt;/span&gt;\n  &lt;span class=\"button__icon\"&gt;→&lt;/span&gt;\n&lt;/button&gt;\n\n&lt;style&gt;\n  .button .button__text { /* button text styles */ }\n  .button .button__icon { /* button icon styles */ }\n  .button--primary { primary button styles */ }\n&lt;/style&gt;\n</code></pre>\n\n<pre><code>&lt;!-- @scope --&gt; \n&lt;button class=\"primary-button\"&gt;\n  &lt;span&gt;Click me&lt;/span&gt;\n  &lt;span&gt;→&lt;/span&gt;\n&lt;/button&gt;\n\n&lt;style&gt;\n  @scope (.primary-button) {\n    span:first-child { /* button text styles */ }\n    span:last-child { /* button icon styles */ }\n  }\n&lt;/style&gt;\n</code></pre>\n\n<p>The <code>@scope</code> rule allows for <strong>precision with less complexity</strong>. The developer no longer needs to create boundaries using class names, which, in turn, allows them to write selectors based on native HTML elements, thereby eliminating the need for prescriptive CSS class name patterns. By simply removing the need for class name management, <code>@scope</code> can alleviate the fear associated with CSS in large projects.</p>\nBasic Usage\n<p>To get started, add the <code>@scope</code> rule to your CSS and insert a root selector to which styles will be scoped:</p>\n<pre><code>@scope (&lt;selector&gt;) {\n  /* Styles scoped to the &lt;selector&gt; */\n}\n</code></pre>\n\n<p>So, for example, if we were to scope styles to a <code>&lt;nav&gt;</code> element, it may look something like this:</p>\n<div>\n<pre><code>@scope (nav) {\n  a { /* Link styles within nav scope */ }\n\n  a:active { /* Active link styles */ }\n\n  a:active::before { /* Active link with pseudo-element for extra styling */ }\n\n  @media (max-width: 768px) {\n    a { /* Responsive adjustments */ }\n  }\n}\n</code></pre>\n</div>\n\n<p>This, on its own, is not a groundbreaking feature. However, a second argument can be added to the scope to create a <strong>lower boundary</strong>, effectively defining the scope’s start and end points.</p>\n<div>\n<pre><code>/* Any <code>a</code> element inside <code>ul</code> will not have the styles applied */\n@scope (nav) to (ul) {\n  a {\n    font-size: 14px;\n  }\n}\n</code></pre>\n</div>\n\n<p>This practice is called <strong>donut scoping</strong>, and <a href=\"https://css-tricks.com/solved-by-css-donuts-scopes/\">there are several approaches</a> one could use, including a series of similar, highly specific selectors coupled tightly to the DOM structure, a <code>:not</code> pseudo-selector, or assigning specific class names to <code>&lt;a&gt;</code> elements within the <code>&lt;nav&gt;</code> to handle the differing CSS.</p>\n<p>Regardless of those other approaches, the <code>@scope</code> method is much more concise. More importantly, it prevents the risk of broken styles if classnames change or are misused or if the HTML structure were to be modified. Now that <code>@scope</code> is Baseline compatible, we no longer need workarounds!</p>\n<p>We can take this idea further with multiple end boundaries to create a “style figure eight”:</p>\n<div>\n<pre><code>/* Any &lt;a&gt; or &lt;p&gt; element inside &lt;aside&gt; or &lt;nav&gt; will not have the styles applied */\n@scope (main) to (aside, nav) {\n  a {\n    font-size: 14px;\n  }\n  p {\n    line-height: 16px;\n    color: darkgrey;\n  }\n}\n</code></pre>\n</div>\n\n<p>Compare that to a version handled without the <code>@scope</code> rule, where the developer has to “reset” styles to their defaults:</p>\n<div>\n<pre><code>main a {\n  font-size: 14px;\n}\n\nmain p {\n  line-height: 16px;\n  color: darkgrey;\n}\n\nmain aside a,\nmain nav a {\n  font-size: inherit; /* or whatever the default should be */\n}\n\nmain aside p,\nmain nav p {\n  line-height: inherit; /* or whatever the default should be */\n  color: inherit; /* or a specific color */\n}\n</code></pre>\n</div>\n\n<p>Check out the following example. Do you notice how simple it is to target some nested selectors while exempting others?</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/wBWXggN\">@scope example [forked]</a> by <a href=\"https://codepen.io/blakeeric\">Blake Lundquist</a>.</p>\n<p>Consider a scenario where unique styles need to be applied to slotted content within <a href=\"https://www.smashingmagazine.com/2025/07/web-components-working-with-shadow-dom/\">web components</a>. When slotting content into a web component, that content becomes part of the Shadow DOM, but still inherits styles from the parent document. The developer might want to implement different styles depending on which web component the content is slotted into:</p>\n<pre><code>&lt;!-- Same &lt;user-card&gt; content, different contexts --&gt;\n&lt;product-showcase&gt;\n  &lt;user-card slot=\"reviewer\"&gt;\n    &lt;img src=\"avatar.jpg\" slot=\"avatar\"&gt;\n    &lt;span slot=\"name\"&gt;Jane Doe&lt;/span&gt;\n  &lt;/user-card&gt;\n&lt;/product-showcase&gt;\n\n&lt;team-roster&gt;\n  &lt;user-card slot=\"member\"&gt;\n    &lt;img src=\"avatar.jpg\" slot=\"avatar\"&gt;\n    &lt;span slot=\"name\"&gt;Jane Doe&lt;/span&gt;\n  &lt;/user-card&gt;\n&lt;/team-roster&gt;\n</code></pre>\n\n<p>In this example, the developer might want the <code>&lt;user-card&gt;</code> to have distinct styles only if it is rendered inside <code>&lt;team-roster&gt;</code>:</p>\n<pre><code>@scope (team-roster) {\n  user-card {\n    display: inline-flex;\n    align-items: center;\n    gap: 0.5rem;\n  }\n\n  user-card img {\n    border-radius: 50%;\n    width: 40px;\n    height: 40px;\n  }\n}\n</code></pre>\n\nMore Benefits\n<p>There are additional ways that <code>@scope</code> can remove the need for class management without resorting to utilities or JavaScript-generated class names. For example, <code>@scope</code> opens up the possibility to easily <strong>target descendants of any selector</strong>, not just class names:</p>\n<div>\n<pre><code>/* Only div elements with a direct child button are included in the root scope */\n@scope (div:has(&gt; button)) {\n  p {\n    font-size: 14px;\n  }\n}\n</code></pre>\n</div>\n\n<p>And they <strong>can be nested</strong>, creating scopes within scopes:</p>\n<pre><code>@scope (main) {\n  p {\n    font-size: 16px;\n    color: black;\n  }\n  @scope (section) {\n    p {\n      font-size: 14px;\n      color: blue;\n    }\n    @scope (.highlight) {\n      p {\n        background-color: yellow;\n        font-weight: bold;\n      }\n    }\n  }\n}\n</code></pre>\n\n<p>Plus, the root scope can be easily referenced within the <code>@scope</code> rule:</p>\n<div>\n<pre><code>/* Applies to elements inside direct child <code>section</code> elements of <code>main</code>, but stops at any direct <code>aside</code> that is a direct chiled of those sections */\n@scope (main &gt; section) to (:scope &gt; aside) {\n  p {\n    background-color: lightblue;\n    color: blue;\n  }\n  /* Applies to ul elements that are immediate siblings of root scope  */\n  :scope + ul {\n    list-style: none;\n  }\n}\n</code></pre>\n</div>\n\n<p>The <code>@scope</code> at-rule also introduces a new <strong>proximity</strong> dimension to CSS specificity resolution. In traditional CSS, when two selectors match the same element, the selector with the higher specificity wins. With <code>@scope</code>, when two elements have equal specificity, the one whose scope root is closer to the matched element wins. This eliminates the need to override parent styles by manually increasing an element’s specificity, since inner components naturally supersede outer element styles.</p>\n<div>\n<pre><code>&lt;style&gt;\n  @scope (.container) {\n    .title { color: green; } \n  }\n  &lt;!-- The &lt;h2&gt; is closer to .container than to .sidebar so \"color: green\" wins. --&gt;\n  @scope (.sidebar) {\n    .title { color: red; }\n  }\n&lt;/style&gt;\n\n&lt;div class=\"sidebar\"&gt;\n  &lt;div class=\"container\"&gt;\n    &lt;h2 class=\"title\"&gt;Hello&lt;/h2&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n</div>\n\nConclusion\n<p>Utility-first CSS frameworks, such as Tailwind, work well for prototyping and smaller projects. Their benefits quickly diminish, however, when used in larger projects involving more than a couple of developers.</p>\n<p>Front-end development has become increasingly overcomplicated in the last few years, and CSS is no exception. While the <code>@scope</code> rule isn’t a cure-all, it can reduce the need for complex tooling. When used in place of, or alongside strategic class naming, <code>@scope</code> can make it easier and more fun to write maintainable CSS. </p>\n<h3>Further Reading</h3>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/@scope\">CSS <code>@scope</code></a> (MDN)</li>\n<li>“<a href=\"https://css-tricks.com/almanac/rules/s/scope/\">CSS <code>@scope</code></a>”, Juan Diego Rodríguez (CSS-Tricks)</li>\n<li><a href=\"https://www.firefox.com/en-US/firefox/146.0/releasenotes/\">Firefox 146 Release Notes</a> (Firefox)</li>\n<li><a href=\"https://caniuse.com/css-cascade-scope\">Browser Support</a> (CanIUse)</li>\n<li><a href=\"https://2024.stateofcss.com/en-US/tools/\">Popular CSS Frameworks</a> (State of CSS 2024)</li>\n<li>“<a href=\"https://css-tricks.com/the-c-in-css-the-cascade/\">The “C” in CSS: Cascade</a>”, Thomas Yip (CSS-Tricks)</li>\n<li><a href=\"https://getbem.com/introduction/\">BEM Introduction</a> (Get BEM)</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"1d6f0b937e9338aeabf52d6eed980c79e6e237a8bceba6f354b11826d6fff429","category":"Tech"}