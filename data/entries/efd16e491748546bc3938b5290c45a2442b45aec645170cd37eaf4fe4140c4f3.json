{"title":"Running dynamic, ephemeral multi-hop workers for HCP Boundary: Part 1","link":"https://www.hashicorp.com/blog/running-dynamic-ephemeral-multi-hop-workers-for-hcp-boundary-part-1","date":1679587200000,"content":"<p>Running HashiCorp Boundary workers as dynamic workloads in autoscaling groups, Nomad jobs, or Kubernetes deployments is an efficient way to connect engineers with workloads, but how can you manage the lifecycle of the worker authentication token? How can you prevent worker sprawl and manage the worker in a stateless way without requiring persistent storage? </p>\n\n<p>This two-part blog series will show you how to use <a href=\"https://github.com/hashicorp-dev-advocates/vault-plugin-boundary-secrets-engine\">a custom Boundary secrets engine</a> for HashiCorp Vault to deploy dynamic ephemeral workers as Nomad jobs.</p>\n\n<h2>Why Boundary?</h2>\n\n<p>Boundary provides engineers with secure session access to their workloads on private networks. In the past, access to these workloads on private networks has been facilitated using jump boxes and bastion hosts, but there are some challenges and risks with these approaches. </p>\n\n<p>Both jump boxes and bastion hosts typically live inside a private subnet but expose an IP address and port to the public internet. This allows users to connect to them, then jump to their intended target within the private subnet. Some of the challenges with this approach are:</p>\n\n<ol>\n<li>The jump box will need to manage user identities. It is often the case that identity comes in the form of SSH keys. In many cases, as these systems are not directly connected to HR systems, the lifecycle of these identities is not tied to the lifecycle of employment, thus creating management overhead.</li>\n<li>Once a user is authenticated within the jump box, they are already inside your network and likely have unrestricted access to workloads they may not be authorized to access. The premise of <a href=\"https://www.hashicorp.com/resources/introduction-to-zero-trust-security\">zero trust security</a> is that it should be assumed that the network is already breached, and as such, all actions should be verified to ensure they are authorized.</li>\n<li>A host in a private network with a publically accessible endpoint represents an attack surface for many organizations.</li>\n</ol>\n\n<p>Boundary takes a much more secure approach. It is made up of two architectural components:</p>\n\n<ul>\n<li><strong>Controller</strong> - This is the brain of Boundary, which manages authentication, authorization, and handles requests. The controller is managed by HashiCorp if you choose to use the <a href=\"https://www.hashicorp.com/cloud\">HashiCorp Cloud Platform (HCP)</a> offering of Boundary.</li>\n<li><strong>Workers</strong> - They do the heavy lifting of proxying sessions between the target workloads and the authorized end users.</li>\n</ul>\n\n<h2>Workers</h2>\n\n<p>There are two flavors of workers for Boundary, <code>ingress workers</code> and <code>egress workers</code>. Ingress workers live in your private networks but expose a public endpoint for the controller to contact it. As a user, you don't actually connect directly to the worker to access your workloads. Instead the worker provides a proxy to your workload when a session is created by the controller. </p>\n\n<p>Egress workers operate differently and use a feature in Boundary called <a href=\"https://developer.hashicorp.com/boundary/tutorials/hcp-administration/hcp-manage-multi-hop\">multi-hop workers</a>, which allow the chaining of multiple workers together. HCP Boundary includes three managed public workers that can be chained to self-hosted workers in your private network. In the case of egress workers, they make outbound connections to the HCP-managed worker, which then talks to the controller. This allows the same level of proxy access to workloads without exposing public endpoints.</p>\n\n<p>The process of registering a worker with the controller can be conducted in two ways, worker-led, or controller-led. Worker-led is a manual process in which the worker is started and an auth token is printed out in the logs. Then a worker entry needs to be created in the controller and the auth token output from the previous step is entered here to authenticate the worker. The worker will persist its authentication in storage, making this a stateful workload.</p>\n\n<p>The controller-led process is much more automation friendly. In this workflow, a worker entry is created on the controller. This can be done using the CLI, API, web interface, or SDK. This will return an auth token, which is then included in the configuration file for the worker. When the worker is started, it uses this token to authenticate to the controller and the process is complete.</p>\n\n<h2>A custom Boundary secrets engine</h2>\n\n<p>In order to invalidate a worker, its entry must be deleted from the controller. This presents the risk of worker sprawl when workers are run as dynamic workloads. To counteract this, I came up with the concept of ephemeral workers, in which the lifecycle of the authenticated worker entry in the controller can be tied to the lifecycle of its workload.</p>\n\n<p>I expanded the capabilities of a <a href=\"https://github.com/hashicorp-dev-advocates/vault-plugin-boundary-secrets-engine\">custom Vault plugin for Boundary</a> I wrote to facilitate this workflow. The plugin is a secrets engine, which can generate on-demand, short-lived controller-led worker entries. The diagram below shows the workflow using Nomad to schedule a job for the Boundary worker and the Vault integration in the Nomad client to create the entry and build a config file for the worker to start:</p>\n<img src=\"https://www.datocms-assets.com/2885/1679508646-ephemeral-workers-1.png\" alt=\"Boundary,\" /><h2>Setting up Vault</h2>\n\n<p>As this workflow uses a custom plugin, you need to use a self-managed Vault instance to load the plugin. </p>\n\n<p>The first step is to download the plugin from the <a href=\"https://github.com/hashicorp-dev-advocates/vault-plugin-boundary-secrets-engine/releases\">releases page</a>. Be sure to select the correct binary for your operating system. Once the plugin is downloaded, move it to a folder that will house all of your custom plugins, and rename the file to <code>boundary</code>. The code example below shows the downloading, moving, and renaming of the binary for Linux operating systems:</p>\n\n<pre><code>curl -L -o boundary.zip https://github.com/hashicorp-dev-advocates/vault-plugin-boundary-secrets-engine/releases/download/v1.0.0/vault-plugin-boundary-secrets-engine_v1.0.0_linux_amd64.zip\n\n  unzip boundary.zip -d .\n\n  sudo mv vault-plugin-boundary-secrets-engine_v1.0.0 /etc/vault.d/plugins/boundary\n</code></pre>\n\n<p>This demonstration uses Vault in dev mode. Start Vault using the following command:</p>\n\n<pre><code>vault server -dev -dev-root-token-id=root -dev-plugin-dir=./etc/vault.d/plugins\n</code></pre>\n\n<p>This starts Vault in dev mode, tells it where to look to load the custom plugins, and sets a default root token with the value <code>root</code>.</p>\n\n<p><em>Note: This is not safe for production use. Dev mode is only for local testing and development.</em></p>\n\n<p>Now that Vault is started and the plugin is loaded, the next step is to enable the secrets engine with the following command:</p>\n\n<pre><code>vault secrets enable boundary\n</code></pre>\n\n<p>Next, configure the secrets backend to communicate with the Boundary controller. To do this, you need to provide connectivity information and authentication details for Boundary to Vault:</p>\n\n<pre><code>vault write boundary/config \\\n    addr=\"http://hcp-boundary-address:9200\" \\\n    login_name=admin-username \\\n    password=admin-password \\\n    auth_method_id=auth-method-id\n</code></pre>\n\n<p>The command example above will need to be refactored with your HCP Boundary details.</p>\n\n<p>The next step is to create a Vault role. There are two types of roles for this secrets engine: <code>user</code> and <code>worker</code>. For this demonstration, create a worker role that is specified with the <code>role_type</code> parameter:</p>\n\n<pre><code>vault write boundary/role/worker \\ \n    ttl=180 \\\n    max_ttl=360 \\\n    role_type=worker \\\n    scope_id=global\n</code></pre>\n\n<p>Once you have configured the secrets engine, you can test it by running the following command:</p>\n\n<pre><code>vault read boundary/creds/worker worker_name=\"local worker\"\n</code></pre>\n\n<p>This creates a worker named <code>local worker</code> on the controller. You can also add an optional description when creating a worker by changing the command above to the following:</p>\n\n<pre><code>vault read boundary/creds/worker \\\n    worker_name=\"local worker\" \\\n    description=\"my local worker for testing purposes\"\n</code></pre>\n\n<p>That command will give you a response similar to the output shown below:</p>\n\n<pre><code>Key                 Value\n---                 -----\nlease_id            boundary/creds/worker/tQkj52HSIRpCQMJ70FRLicCU\nlease_duration      768h\nlease_renewable     true\nactivation_token    neslat_2Kr71G5hdKEqs3w6vRGH4vPRJGiGbwiz22MVAMS75KxWSTMj3HjtXfX6sg2wvMwuqrscXJrsBbdjfCY5gqiA9hVJc24GB\nworker_id           w_xIy3DtXJcq\nworker_name         local worker\n</code></pre>\n\n<p>The auth token can then be used in the worker config file to authenticate it to Boundary. You can navigate to the web UI and see the Vault-generated worker there:</p>\n<img src=\"https://www.datocms-assets.com/2885/1679508658-web-ui.png\" alt=\"Web\" /><p>To revoke this before the TTL expires, copy the lease ID and run the following command replacing the lease ID with yours:</p>\n\n<pre><code>vault lease revoke boundary/creds/worker/ppOvYe6zQVmjO48TTvHMgZ0r\n</code></pre>\n\n<p>Now, if you refresh the Boundary web UI, you will notice the worker that Vault created is no longer present:</p>\n<img src=\"https://www.datocms-assets.com/2885/1679508671-web-ui-2.png\" alt=\"Web\" /><h2>Summary</h2>\n\n<p>This blog post discussed the challenges of running self-managed Boundary workers as dynamic workloads and how you can use my custom Boundary secrets engine to provision ephemeral workers. Part two of this series will build on this and show you how to deploy Boundary workers as Nomad jobs using the custom Boundary secrets engine.</p>\n\n<p><em>We recently launched Boundary on the HashiCorp Cloud Platform (HCP), now <a href=\"https://www.hashicorp.com/blog/hcp-boundary-now-ga-bolsters-hashicorp-s-zero-trust-security-solution\">generally available</a>. HCP Boundary provides a single, fully managed workflow to securely connect to hosts and critical systems <a href=\"https://www.hashicorp.com/blog/how-to-connect-to-kubernetes-clusters-using-boundary\">across Kubernetes clusters</a>, cloud service catalogs, and on-premises infrastructure. <a href=\"https://cloud.hashicorp.com/products/boundary\">Try HCP Boundary today</a>.</em></p>\n","author":"Rob Barnes","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"efd16e491748546bc3938b5290c45a2442b45aec645170cd37eaf4fe4140c4f3","category":"Tech"}