{"title":"Converting Plain Text To Encoded HTML With Vanilla JavaScript","link":"https://smashingmagazine.com/2024/04/converting-text-encoded-html-vanilla-javascript/","date":1713358800000,"content":"<p>When copying text from a website to your device’s clipboard, there’s a good chance that you will get the formatted HTML when pasting it. Some apps and operating systems have a “Paste Special” feature that will strip those tags out for you to maintain the current style, but what do you do if that’s unavailable?</p>\n<p>Same goes for converting plain text into formatted HTML. One of the closest ways we can convert plain text into HTML is writing in Markdown as an abstraction. You may have seen examples of this in many comment forms in articles just like this one. Write the comment in Markdown and it is parsed as HTML.</p>\n<p>Even better would be no abstraction at all! You may have also seen (and used) a number of online tools that take plainly written text and convert it into formatted HTML. The UI makes the conversion and previews the formatted result in real time.</p>\n<p>Providing a way for users to author basic web content — like comments — without knowing even the first thing about HTML, is a novel pursuit as it lowers barriers to communicating and collaborating on the web. Saying it helps “democratize” the web may be heavy-handed, but it doesn’t conflict with that vision!</p>\n<p><img src=\"https://files.smashing.media/articles/converting-text-encoded-html-vanilla-javascript/1-smashing-magazine-comment.png\" /></p>\n<p>We can build a tool like this ourselves. I’m all for using existing resources where possible, but I’m also for demonstrating how these things work and maybe learning something new in the process.</p>\nDefining The Scope\n<p>There are plenty of assumptions and considerations that could go into a plain-text-to-HTML converter. For example, should we assume that the first line of text entered into the tool is a title that needs corresponding <code>&lt;h1&gt;</code> tags? Is each new line truly a paragraph, and how does linking content fit into this?</p>\n<p>Again, the idea is that a user should be able to write without knowing Markdown or HTML syntax. This is a big constraint, and there are far too many HTML elements we might encounter, so it’s worth knowing the context in which the content is being used. For example, if this is a tool for writing blog posts, then we can limit the scope of which elements are supported based on those that are commonly used in long-form content: <code>&lt;h1&gt;</code>, <code>&lt;p&gt;</code>, <code>&lt;a&gt;</code>, and <code>&lt;img&gt;</code>. In other words, it will be possible to include top-level headings, body text, linked text, and images. There will be no support for bulleted or ordered lists, tables, or any other elements for this particular tool.</p>\n<p>The front-end implementation will rely on vanilla HTML, CSS, and JavaScript to establish a small form with a simple layout and functionality that converts the text to HTML. There is a server-side aspect to this if you plan on deploying it to a production environment, but our focus is purely on the front end.</p>\nLooking At Existing Solutions\n<p>There are existing ways to accomplish this. For example, some libraries offer a WYSIWYG editor. Import a library like <a href=\"https://www.tiny.cloud/get-tiny/\">TinyMCE</a> with a single <code>&lt;script&gt;</code> and you’re good to go. WYSIWYG editors are powerful and support all kinds of formatting, even applying CSS classes to content for styling.</p>\n<p>But TinyMCE isn’t the most efficient package at about 500 KB minified. That’s not a criticism as much as an indication of how much functionality it covers. We want something more “barebones” than that for our simple purpose. <a href=\"https://github.com/search?q=txt2html&amp;type=repositories&amp;s=updated&amp;o=desc\">Searching GitHub surfaces more possibilities.</a> The solutions, however, seem to fall into one of two categories:</p>\n<ul>\n<li>The input accepts plain text, but the generated HTML only supports the HTML <code>&lt;h1&gt;</code> and <code>&lt;p&gt;</code> tags.</li>\n<li>The input converts plain text into formatted HTML, but by ”plain text,” the tool seems to mean “Markdown” (or a variety of it) instead. The <a href=\"https://metacpan.org/dist/txt2html/view/scripts/txt2html\">txt2html Perl module</a> (from 1994!) would fall under this category.</li>\n</ul>\n<p>Even if a perfect solution for what we want was already out there, I’d still want to pick apart the concept of converting text to HTML to understand how it works and hopefully learn something new in the process. So, let’s proceed with our own homespun solution.</p>\nSetting Up The HTML\n<p>We’ll start with the HTML structure for the input and output. For the input element, we’re probably best off using a <code>&lt;textarea&gt;</code>. For the output element and related styling, choices abound. The following is merely one example with some very basic CSS to place the input <code>&lt;textarea&gt;</code> on the left and an output <code>&lt;div&gt;</code> on the right:</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/OJGoNOX\">Base Form Styles [forked]</a> by <a href=\"https://codepen.io/geoffgraham\">Geoff Graham</a>.</p>\n<p>You can further develop the CSS, but that isn’t the focus of this article. There is no question that the design can be prettier than what I am providing here!</p>\nCapture The Plain Text Input\n<p>We’ll set an <code>onkeyup</code> event handler on the <code>&lt;textarea&gt;</code> to call a JavaScript function called <code>convert()</code> that does what it says: convert the plain text into HTML. The conversion function should accept one parameter, a string, for the user’s plain text input entered into the <code>&lt;textarea&gt;</code> element:</p>\n<pre><code>&lt;textarea onkeyup='convert(this.value);'&gt;&lt;/textarea&gt;</code></pre>\n\n<p><code>onkeyup</code> is a better choice than <code>onkeydown</code> in this case, as <code>onkeyup</code> will call the conversion function <em>after</em> the user completes each keystroke, as opposed to <em>before</em> it happens. This way, the output, which is refreshed with each keystroke, always includes the latest typed character. If the conversion is triggered with an <code>onkeydown</code> handler, the output will exclude the most recent character the user typed. This can be frustrating when, for example, the user has finished typing a sentence but cannot yet see the final punctuation mark, say a period (<code>.</code>), in the output until typing another character first. This creates the impression of a typo, glitch, or lag when there is none.</p>\n<p>In JavaScript, the <code>convert()</code> function has the following responsibilities:</p>\n<ol>\n<li>Encode the input in HTML.</li>\n<li>Process the input line-by-line and wrap each individual line in either a <code>&lt;h1&gt;</code> or <code>&lt;p&gt;</code> HTML tag,  whichever is most appropriate.</li>\n<li>Process the output of the transformations as a single string, wrap URLs in HTML <code>&lt;a&gt;</code> tags, and replace image file names with <code>&lt;img&gt;</code> elements.</li>\n</ol>\n<p>And from there, we display the output. We can create separate functions for each responsibility. Let’s name them accordingly:</p>\n<ol>\n<li><code>html_encode()</code></li>\n<li><code>convert_text_to_HTML()</code></li>\n<li><code>convert_images_and_links_to_HTML()</code></li>\n</ol>\n<p>Each function accepts one parameter, a string, and returns a string.</p>\nEncoding The Input Into HTML\n<p>Use the <code>html_encode()</code> function to HTML encode/sanitize the input. HTML encoding refers to the process of escaping or replacing certain characters in a string input to prevent users from inserting their own HTML into the output. At a minimum, we should replace the following characters:</p>\n<ul>\n<li><code>&lt;</code> with <code>&amp;lt;</code></li>\n<li><code>&gt;</code> with <code>&amp;gt;</code></li>\n<li><code>&amp;</code> with <code>&amp;amp;</code></li>\n<li><code>'</code> with <code>&amp;#39;</code></li>\n<li><code>\"</code> with <code>&amp;quot;</code></li>\n</ul>\n<p>JavaScript does not provide a built-in way to HTML encode input as other languages do. For example, PHP has <a href=\"https://www.php.net/manual/en/function.htmlspecialchars\"><code>htmlspecialchars()</code></a>, <a href=\"https://www.php.net/manual/en/function.htmlentities\"><code>htmlentities()</code></a>, and <a href=\"https://www.php.net/manual/en/function.strip-tags\"><code>strip_tags()</code></a> functions. That said, it is relatively easy to write our own function that does this, which is what we’ll use the <code>html_encode()</code> function for that we defined earlier:</p>\n<pre><code>function html_encode(input) {\n  const textArea = document.createElement(\"textarea\");\n  textArea.innerText = input;\n  return textArea.innerHTML.split(\"&lt;br&gt;\").join(\"\\n\");\n}\n</code></pre>\n\n<p>HTML encoding of the input is a critical security consideration. It prevents unwanted scripts or other HTML manipulations from getting injected into our work. Granted, front-end input sanitization and validation are both merely deterrents because bad actors can bypass them. But we may as well make them work a little harder.</p>\n<p>As long as we are on the topic of securing our work, make sure to HTML-encode the input on the back end, where the user cannot interfere. At the same time, take care not to encode the input more than once. Encoding text that is already HTML-encoded will break the output functionality. The best approach for back-end storage is for the front end to pass the raw, unencoded input to the back end, then ask the back-end to HTML-encode the input before inserting it into a database.</p>\n<p>That said, this only accounts for sanitizing and storing the input on the back end. We still have to display the encoded HTML output on the front end. There are at least two approaches to consider:</p>\n<ol>\n<li><strong>Convert the input to HTML after HTML-encoding it and before it is inserted into a database.</strong><br />This is efficient, as the input only needs to be converted once. However, this is also an inflexible approach, as updating the HTML becomes difficult if the output requirements happen to change in the future. </li>\n<li><strong>Store only the HTML-encoded input text in the database and dynamically convert it to HTML before displaying the output for each content request.</strong><br />This is less efficient, as the conversion will occur on each request. However, it is also more flexible since it’s possible to update how the input text is converted to HTML if requirements change.</li>\n</ol>\nApplying Semantic HTML Tags\n<p>Let’s use the <code>convert_text_to_HTML()</code> function we defined earlier to wrap each line in their respective HTML tags, which are going to be either <code>&lt;h1&gt;</code> or <code>&lt;p&gt;</code>. To determine which tag to use, we will <code>split</code> the text input on the newline character (<code>\\n</code>) so that the text is processed as an array of lines rather than a single string, allowing us to evaluate them individually.</p>\n<div>\n<pre><code>function convert_text_to_HTML(txt) {\n  // Output variable\n  let out = '';\n  // Split text at the newline character into an array\n  const txt_array = txt.split(\"\\n\");\n  // Get the number of lines in the array\n  const txt_array_length = txt_array.length;\n  // Variable to keep track of the (non-blank) line number\n  let non_blank_line_count = 0;\n\n  for (let i = 0; i &lt; txt_array_length; i++) {\n    // Get the current line\n    const line = txt_array[i];\n    // Continue if a line contains no text characters\n    if (line === ''){\n      continue;\n    }\n\n    non_blank_line_count++;\n    // If a line is the first line that contains text\n    if (non_blank_line_count === 1){\n      // ...wrap the line of text in a Heading 1 tag\n      out += <code>&amp;lt;h1&amp;gt;${line}&amp;lt;/h1&amp;gt;</code>;\n      // ...otherwise, wrap the line of text in a Paragraph tag.\n    } else {\n      out += <code>&amp;lt;p&amp;gt;${line}&amp;lt;/p&amp;gt;</code>;\n    }\n  }\n\n  return out;\n}\n</code></pre>\n</div>\n\n<p>In short, this little snippet loops through the array of split text lines and ignores lines that do <em>not</em> contain any text characters. From there, we can evaluate whether a line is the first one in the series. If it is, we slap a <code>&lt;h1&gt;</code> tag on it; otherwise, we mark it up in a <code>&lt;p&gt;</code> tag.</p>\n<p>This logic could be used to account for other types of elements that you may want to include in the output. For example, perhaps the second line is assumed to be a byline that names the author and links up to an archive of all author posts.</p>\nTagging URLs And Images With Regular Expressions\n<p>Next, we’re going to create our <code>convert_images_and_links_to_HTML()</code> function to encode URLs and images as HTML elements. It’s a good chunk of code, so I’ll drop it in and we’ll immediately start picking it apart together to explain how it all works.</p>\n<div>\n<pre><code>\nfunction convert_images_and_links_to_HTML(string){\n  let urls_unique = [];\n  let images_unique = [];\n  const urls = string.match(/https*:\\/\\/[^\\s&lt;),]+[^\\s&lt;),.]/gmi) ?? [];\n  const imgs = string.match(/[^\"'&gt;\\s]+.(jpg|jpeg|gif|png|webp)/gmi) ?? [];\n\n  const urls_length = urls.length;\n  const images_length = imgs.length;\n\n  for (let i = 0; i &lt; urls_length; i++){\n    const url = urls[i];\n    if (!urls_unique.includes(url)){\n      urls_unique.push(url);\n    }\n  }\n\n  for (let i = 0; i &lt; images_length; i++){\n    const img = imgs[i];\n    if (!images_unique.includes(img)){\n      images_unique.push(img);\n    }\n  }\n\n  const urls_unique_length = urls_unique.length;\n  const images_unique_length = images_unique.length;\n\n  for (let i = 0; i &lt; urls_unique_length; i++){\n    const url = urls_unique[i];\n    if (images_unique_length === 0 || !images_unique.includes(url)){\n      const a_tag = <code>&amp;lt;a href=\"${url}\" target=\"&amp;#95;blank\"&amp;gt;${url}&amp;lt;/a&amp;gt;</code>;\n      string = string.replace(url, a_tag);\n    }\n  }\n\n  for (let i = 0; i &lt; images_unique_length; i++){\n    const img = images_unique[i];\n    const img_tag = <code>&amp;lt;img src=\"${img}\" alt=\"\"&amp;gt;</code>;\n    const img_link = <code>&amp;lt;a href=\"${img}\"&amp;gt;${img&amp;#95;tag}&amp;lt;/a&amp;gt;</code>;\n    string = string.replace(img, img_link);\n  }\n  return string;\n}\n</code></pre>\n</div>\n\n<p>Unlike the <code>convert_text_to_HTML()</code> function, here we use regular expressions to identify the terms that need to be wrapped and/or replaced with <code>&lt;a&gt;</code> or <code>&lt;img&gt;</code> tags. We do this for a couple of reasons:</p>\n<ol>\n<li>The previous <code>convert_text_to_HTML()</code> function handles text that would be transformed to the HTML block-level elements <code>&lt;h1&gt;</code> and <code>&lt;p&gt;</code>, and, if you want, other block-level elements such as <code>&lt;address&gt;</code>. Block-level elements in the HTML output correspond to discrete lines of text in the input, which you can think of as paragraphs, the text entered between presses of the Enter key. </li>\n<li>On the other hand, URLs in the text input are often included in the middle of a sentence rather than on a separate line. Images that occur in the input text are often included on a separate line, but not always. While you could identify text that represents URLs and images by processing the input line-by-line — or even word-by-word, if necessary — it is easier to use regular expressions and process the entire input as a single string rather than by individual lines.</li>\n</ol>\n<p>Regular expressions, though they are powerful and the appropriate tool to use for this job, <a href=\"https://blog.bitsrc.io/threats-of-using-regular-expressions-in-javascript-28ddccf5224c\">come with a performance cost</a>, which is another reason to use each expression only once for the entire text input.</p>\n<p><strong>Remember</strong>: <em>All the JavaScript in this example runs each time the user types a character, so it is important to keep things as lightweight and efficient as possible.</em></p>\n<p>I also want to make a note about the variable names in our <code>convert_images_and_links_to_HTML()</code> function. <code>images</code> (plural), <code>image</code> (singular), and <code>link</code> are reserved words in JavaScript. Consequently, <code>imgs</code>, <code>img</code>, and <code>a_tag</code> were used for naming. Interestingly, these specific reserved words are not listed on the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#reserved_words\">relevant MDN page</a>, but they are on <a href=\"https://www.w3schools.com/js/js_reserved.asp\">W3Schools</a>.</p>\n<p>We’re using the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match\"><code>String.prototype.match()</code></a> function for each of the two regular expressions, then storing the results for each call in an array. From there, we use the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing\">nullish coalescing operator</a> (<code>??</code>) on each call so that, if no matches are found, the result will be an empty array. If we do not do this and no matches are found, the result of each <code>match()</code> call will be <code>null</code> and will cause problems downstream.</p>\n<div>\n<pre><code>const urls = string.match(/https*:\\/\\/[^\\s&lt;),]+[^\\s&lt;),.]/gmi) ?? [];\nconst imgs = string.match(/[^\"'&gt;\\s]+.(jpg|jpeg|gif|png|webp)/gmi) ?? [];\n</code></pre>\n</div>\n\n<p>Next up, we filter the arrays of results so that <strong>each array contains only unique results</strong>. This is a critical step. If we don’t filter out duplicate results and the input text contains multiple instances of the same URL or image file name, then we break the HTML tags in the output. JavaScript does not provide a simple, built-in method to get unique items in an array that’s akin to the PHP <a href=\"https://www.php.net/manual/en/function.array-unique\"><code>array_unique()</code></a> function.</p>\n<p>The code snippet works around this limitation using an admittedly ugly but straightforward procedural approach. The same problem is solved using a more functional approach if you prefer. There are many articles on the web describing <a href=\"https://www.geeksforgeeks.org/how-to-get-all-unique-values-remove-duplicates-in-a-javascript-array/\">various ways to filter a JavaScript array</a> in order to <a href=\"https://chrisengelsma.medium.com/filtering-an-array-to-get-only-unique-values-in-javascript-and-typescript-3342e47b9448\">keep only the unique items</a>.</p>\n<p>We’re also checking if the URL is matched as an image before replacing a URL with an appropriate <code>&lt;a&gt;</code> tag and performing the replacement only if the URL doesn’t match an image. We may be able to avoid having to perform this check by using a more intricate regular expression. The example code deliberately uses regular expressions that are perhaps less precise but hopefully easier to understand in an effort to keep things as simple as possible.</p>\n<p>And, finally, we’re replacing image file names in the input text with <code>&lt;img&gt;</code> tags that have the <code>src</code> attribute set to the image file name. For example, <code>my_image.png</code> in the input is transformed into <code>&lt;img src='my_image.png'&gt;</code> in the output. We wrap each <code>&lt;img&gt;</code> tag with an <code>&lt;a&gt;</code> tag that links to the image file and opens it in a new tab when clicked.</p>\n<p>There are a couple of benefits to this approach:</p>\n<ul>\n<li>In a real-world scenario, you will likely use a CSS rule to constrain the size of the rendered image. By making the images clickable, you provide users with a convenient <strong>way to view the full-size image</strong>.</li>\n<li>If the image is not a local file but is instead a URL to an image from a third party, this is a <strong>way to implicitly provide attribution</strong>. Ideally, you should not rely solely on this method but, instead, provide explicit attribution underneath the image in a <code>&lt;figcaption&gt;</code>, <code>&lt;cite&gt;</code>, or similar element. But if, for whatever reason, you are unable to provide explicit attribution, you are at least providing a link to the image source.</li>\n</ul>\n<p>It may go without saying, but <a href=\"https://www.pixsy.com/image-protection/hotlinking\">“hotlinking”</a> images is something to avoid. Use only locally hosted images wherever possible, and provide attribution if you do not hold the copyright for them.</p>\n<p>Before we move on to displaying the converted output, let’s talk a bit about accessibility, specifically the image <code>alt</code> attribute. The example code I provided does add an <code>alt</code> attribute in the conversion but does not populate it with a value, as there is no easy way to automatically calculate what that value should be. An empty <code>alt</code> attribute can be acceptable if the image is considered “decorative,” i.e., purely supplementary to the surrounding text. But one may argue that <a href=\"https://www.smashingmagazine.com/2021/06/img-alt-attribute-alternate-description-decorative/\">there is no such thing as a purely decorative image</a>.</p>\n<p>That said, I consider this to be a limitation of what we’re building.</p>\nDisplaying the Output HTML\n<p>We’re at the point where we can finally work on displaying the HTML-encoded output! We've already handled all the work of converting the text, so all we really need to do now is call it:</p>\n<div>\n<pre><code>function convert(input_string) {\n  output.innerHTML = convert_images_and_links_to_HTML(convert_text_to_HTML(html_encode(input_string)));\n}\n</code></pre>\n</div>\n\n<p>If you would rather display the output string as raw HTML markup, use a <code>&lt;pre&gt;</code> tag as the output element instead of a <code>&lt;div&gt;</code>:</p>\n<pre><code>&lt;pre id='output'&gt;&lt;/pre&gt;\n</code></pre>\n\n<p>The only thing to note about this approach is that you would target the <code>&lt;pre&gt;</code> element’s <code>textContent</code> instead of <code>innerHTML</code>:</p>\n<div>\n<pre><code>function convert(input_string) {\n  output.textContent = convert_images_and_links_to_HTML(convert_text_to_HTML(html_encode(input_string)));\n}\n</code></pre>\n</div>\n\nConclusion\n<p>We did it! We built one of the same sort of copy-paste tool that converts plain text on the spot. In this case, we’ve configured it so that plain text entered into a <code>&lt;textarea&gt;</code> is parsed line-by-line and encoded into HTML that we format and display inside another element.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/yLrxOzP\">Convert Plain Text to HTML (PoC) [forked]</a> by <a href=\"https://codepen.io/geoffgraham\">Geoff Graham</a>.</p>\n<p>We were even able to keep the solution fairly simple, i.e., vanilla HTML, CSS, and JavaScript, without reaching for a third-party library or framework. Does this simple solution do everything a ready-made tool like a framework can do? Absolutely not. But a solution as simple as this is often all you need: nothing more and nothing less.</p>\n<p>As far as scaling this further, the code could be modified to <code>POST</code> what’s entered into the <code>&lt;form&gt;</code> using a PHP script or the like. That would be a great exercise, and if you do it, please share your work with me in the comments because I’d love to check it out.</p>\n<h3>References</h3>\n<ul>\n<li>“<a href=\"https://www.w3docs.com/snippets/javascript/how-to-html-encode-a-string.html\">How to HTML-encode a String</a>” (W3Docs)</li>\n<li>“<a href=\"https://www.educative.io/answers/how-to-escape-unescape-html-characters-in-string-in-javascript\">How to escape &amp; unescape HTML characters in string in JavaScript</a>” (Educative.io)</li>\n<li>“<a href=\"https://www.geeksforgeeks.org/how-to-get-all-unique-values-remove-duplicates-in-a-javascript-array/\">How to get all unique values (remove duplicates) in a JavaScript array?”</a>” (GeeksforGeeks)</li>\n<li>“<a href=\"https://chrisengelsma.medium.com/filtering-an-array-to-get-only-unique-values-in-javascript-and-typescript-3342e47b9448\">Getting Unique Array Values in Javascript and Typescript</a>,” Chris Engelsma</li>\n<li>“<a href=\"https://blog.bitsrc.io/threats-of-using-regular-expressions-in-javascript-28ddccf5224c\">Threats of Using Regular Expressions in JavaScript</a>,” Dulanka Karunasena</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"de1255e3b142e96a79f408968fa7ac60c876a0a195b8e439a34f238f10a763fa","category":"Tech"}