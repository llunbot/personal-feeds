{"title":"How To Build A Real-Time Multi-User Game From Scratch","link":"https://smashingmagazine.com/2021/10/real-time-multi-user-game/","date":1634895000000,"content":"<p>As the pandemic lingered, the suddenly-remote team I work with became increasingly <a href=\"https://en.wikipedia.org/wiki/Table_football\">foosball</a>-deprived. I thought about how to play foosball in a remote setting, but it was clear that simply reconstructing the rules of foosball on a screen would not be a lot of fun.</p>\n<p>What _is_ fun is to kick a ball using toy cars — a realization made as I was playing with my 2-year old kid. The same night I set out to build the first prototype for a game that would become <em>Autowuzzler</em>.</p>\n<p><strong>The idea is simple</strong>: players steer virtual toy cars in a top-down arena that resembles a foosball table. The first team to score 10 goals wins. </p>\n<p>Of course, the idea of using cars to play soccer is not unique, but two main ideas should set <em>Autowuzzler</em> apart: I wanted to reconstruct some of the look and feel of playing on a physical foosball table, and I wanted to make sure it is as easy as possible to invite friends or teammates to a quick casual game.</p>\n<p>In this article, I’ll describe <strong>the process behind the creation of <a href=\"https://www.autowuzzler.com/\">Autowuzzler</a></strong>, which tools and frameworks I chose, and share a few implementation details and lessons I learned. </p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6252ae01-40e7-48c9-88af-15add0425258/2-real-time-multi-user-game.png\" /></p>\nFirst Working (Terrible) Prototype\n<p>The first prototype was built using the open-source game engine <a href=\"https://phaser.io/\">Phaser.js</a>, mostly for the included physics engine and because I already had some experience with it. The game stage was embedded in a <a href=\"https://nextjs.org/\">Next.js</a> application, again because I already had a solid understanding of Next.js and wanted to focus mainly on the game. </p>\n<p>As the game needs to <strong>support multiple players in real-time</strong>, I utilized Express as a WebSockets broker. Here is where it becomes tricky, though. </p>\n<p>Since the physics calculations were done on the client in the Phaser game, I chose a simple, but obviously flawed logic: The <em>first</em> connected client had the doubtful privilege of doing the physics calculations for all game objects, sending the results to the express server, which in turn broadcasted the updated positions, angles and forces back to the other player’s clients. The other clients would then apply the changes to the game objects. </p>\n<p>This led to the situation where the <em>first</em> player got to <strong>see the physics happening in real-time</strong> (it is happening locally in their browser, after all), while all the other players were lagging behind at least 30 milliseconds (the broadcast rate I chose), or — if the <em>first</em> player’s network connection was slow — considerably worse. </p>\n<p>If this sounds like poor architecture to you — you’re absolutely right. However, I accepted this fact in favor of quickly getting something playable to figure out if the game is actually <em>fun</em> to play. </p>\n<h3>Validate The Idea, Dump The Prototype</h3>\n<p>As flawed as the implementation was, it was sufficiently playable to invite friends for a first test drive. <strong>Feedback was very positive</strong>, with the major concern being — not surprisingly — the real-time performance. Other inherent problems included the situation when the <em>first</em> player (remember, the one in charge of <em>everything</em>) left the game — who should take over? At this point there was only one game room, so anyone would join the same game. I was also a bit concerned by the bundle size the Phaser.js library introduced.</p>\n<p>It was time to dump the prototype and start with a fresh setup and a clear goal.</p>\nProject Setup\n<p>Clearly, the \"first client rules all\" approach needed to be replaced with a solution in which <strong>the game state lives on the server</strong>. In my research, I came across <a href=\"https://www.colyseus.io/\">Colyseus</a>, which sounded like the perfect tool for the job.</p>\n<p>For the other main building blocks of the game I chose:</p>\n<ul>\n<li><a href=\"https://brm.io/matter-js/\">Matter.js</a> as a physics engine instead of Phaser.js because it runs in Node and Autowuzzler does not require a full game framework.</li>\n<li><a href=\"https://kit.svelte.dev/\">SvelteKit</a> as an application framework instead of Next.js, because it <em>just</em> went into public beta at that time. (Besides: I love working with <a href=\"https://svelte.dev/\">Svelte</a>.)</li>\n<li><a href=\"https://supabase.io/\">Supabase.io</a> for storing user-created game PINs.</li>\n</ul>\n<p>Let’s look at those building blocks in more detail.</p>\n<h3>Synchronized, Centralized Game State With Colyseus</h3>\n<p>Colyseus is a multiplayer game framework based on Node.js and Express. At its core, it provides:</p>\n<ul>\n<li>Synchronizing state across clients in an authoritative fashion;</li>\n<li>Efficient real-time communication using WebSockets by sending changed data only;</li>\n<li>Multi-room setups;</li>\n<li>Client libraries for JavaScript, Unity, Defold Engine, Haxe, Cocos Creator, Construct3;</li>\n<li>Lifecycle hooks, e.g. room is created, user joins, user leaves, and more;</li>\n<li>Sending messages, either as broadcast messages to all users in the room, or to a single user;</li>\n<li>A built-in monitoring panel and load test tool.</li>\n</ul>\n<p><strong>Note</strong>: <em>The <a href=\"https://docs.colyseus.io/\">Colyseus docs</a> make it easy to get started with a barebones Colyseus server by providing an <code>npm init</code> script and <a href=\"https://github.com/colyseus/colyseus-examples\">an examples repository</a>.</em></p>\n<h3>Creating A Schema</h3>\n<p>The main entity of a Colyseus app is the game room, which holds the state for a single room instance and all its game objects. In the case of <em>Autowuzzler</em>, it’s a game session with:</p>\n<ul>\n<li>two teams,</li>\n<li>a finite amount of players,</li>\n<li>one ball.</li>\n</ul>\n<p>A schema needs to be defined for all properties of the game objects that <strong>should be synchronized across clients</strong>. For example, we want the ball to synchronize, and so we need to create a schema for the ball:</p>\n<pre><code>class Ball extends Schema {\n  constructor() {\n   super();\n   this.x = 0;\n   this.y = 0;\n   this.angle = 0;\n   this.velocityX = 0;\n   this.velocityY = 0;\n  }\n}\ndefineTypes(Ball, {\n  x: \"number\",\n  y: \"number\",\n  angle: \"number\",\n  velocityX: \"number\",\n  velocityY: \"number\"\n});\n</code></pre>\n\n<p>In the example above, a new class that extends the schema class provided by Colyseus is created; in the constructor, all properties receive an initial value. The position and movement of the ball is described using the five properties: <code>x</code>, <code>y</code>, <code>angle</code>, <code>velocityX,</code> <code>velocityY</code>. Additionally, we need to <strong>specify the types of each property</strong>. This example uses JavaScript syntax, but you can also use the slightly <a href=\"https://docs.colyseus.io/state/schema/\">more compact TypeScript syntax</a>. </p>\n<p>Property types can either be primitive types:</p>\n<ul>\n<li><code>string</code></li>\n<li><code>boolean</code></li>\n<li><code>number</code> (as well as more efficient integer and float types)</li>\n</ul>\n<p>or complex types:</p>\n<ul>\n<li><code>ArraySchema</code> (similar to Array in JavaScript)</li>\n<li><code>MapSchema</code> (similar to Map in JavaScript)</li>\n<li><code>SetSchema</code>  (similar to Set in JavaScript)</li>\n<li><code>CollectionSchema</code> (similar to ArraySchema, but without control over indexes)</li>\n</ul>\n<p>The <code>Ball</code> class above has five properties of type <code>number</code>: its coordinates (<code>x</code>, <code>y</code>), its current <code>angle</code> and the velocity vector (<code>velocityX</code>, <code>velocityY</code>). </p>\n<p>The schema for players is similar, but includes a few more properties to store the player's name and team’s number, which need to be supplied when creating a Player instance:</p>\n<pre><code>class Player extends Schema {\n  constructor(teamNumber) {\n    super();\n    this.name = \"\";\n    this.x = 0;\n    this.y = 0;\n    this.angle = 0;\n    this.velocityX = 0;\n    this.velocityY = 0;\n    this.teamNumber = teamNumber;\n  }\n}\ndefineTypes(Player, {\n  name: \"string\",\n  x: \"number\",\n  y: \"number\",\n  angle: \"number\",\n  velocityX: \"number\",\n  velocityY: \"number\",\n  angularVelocity: \"number\",\n  teamNumber: \"number\",\n});\n</code></pre>\n\n<p>Finally, the schema for the <em>Autowuzzler</em> <code>Room</code> connects the previously defined classes: One room instance has multiple teams (stored in an ArraySchema). It also contains a single ball, therefore we create a new Ball instance in the RoomSchema’s constructor. Players are stored in a MapSchema for quick retrieval using their IDs.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/511ac6c5-568b-45a4-95c8-8339c57d0e3e/5-real-time-multi-user-game.png\" /></p>\n<p>Now, with all the magic happening on the server, the client only handles the input and draws the state it receives from the server to the screen. With one exception:</p>\n<h4>Interpolation On The Client</h4>\n<p>Since we are re-using the same Matter.js physics world on the client, we can improve the experienced performance with a simple trick. Rather than only updating the position of a game object, we also <strong>synchronize the velocity of the object</strong>. This way, the object keeps on moving on its trajectory even if the next update from the server takes longer than usual. So rather than moving objects in discrete steps from position A to position B, we change their position and make them move in a certain direction.</p>\n<h3>Lifecycle</h3>\n<p>The <em>Autowuzzler</em> <code>Room</code> class is where the logic concerned with the different phases of a Colyseus room is handled. Colyseus provides several lifecycle methods: </p>\n<ul>\n<li><code>onCreate</code>: when a new room is created (usually when the first client connects);</li>\n<li><code>onAuth</code>: as an authorization hook to permit or deny entry to the room;</li>\n<li><code>onJoin</code>: when a client connects to the room;</li>\n<li><code>onLeave</code>: when a client disconnects from the room;</li>\n<li><code>onDispose</code>: when the room is discarded.</li>\n</ul>\n<p>The <em>Autowuzzler</em> room creates a new instance of the physics world (see section “<a href=\"#physics-in-a-colyseus-app\">Physics In A Colyseus App</a>”) as soon as it is created (<code>onCreate</code>) and adds a player to the world when a client connects (<code>onJoin</code>). It then updates the physics world 60 times a second (every 16.6 milliseconds) using the <code>setSimulationInterval</code> method (our main game loop):</p>\n<pre><code>// deltaTime is roughly 16.6 milliseconds\nthis.setSimulationInterval((deltaTime) =&gt; this.world.updateWorld(deltaTime));\n</code></pre>\n\n<p>The physics objects are independent of the Colyseus objects, which leaves us with <strong>two permutations of the same game object</strong> (like the ball), i.e. an object in the physics world and a Colyseus object that can be synced.</p>\n<p>As soon as the physical object changes, its updated properties need to be applied back to the Colyseus object. We can achieve that by listening to Matter.js’ <code>afterUpdate</code> event and setting the values from there:</p>\n<pre><code>Events.on(this.engine, \"afterUpdate\", () =&gt; {\n // apply the x position of the physics ball object back to the colyseus ball object\n this.state.ball.x = this.physicsWorld.ball.position.x;\n // ... all other ball properties\n // loop over all physics players and apply their properties back to colyseus players objects\n})\n</code></pre>\n\n<p>There’s one more copy of the objects we need to take care of: <strong>the game objects in the user-facing game</strong>.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6549e7bb-4207-4060-a46c-861671798c03/4-real-time-multi-user-game.png\" /></p>\nClient-Side Application\n<p>Now that we have an application on the server that handles the synchronization of the game state for multiple rooms as well as physics calculations, let’s focus on <strong>building the website and the actual game interface</strong>. The <em>Autowuzzler</em> frontend has the following responsibilities:</p>\n<ul>\n<li>enables users to create and share game PINs to access individual rooms;</li>\n<li>sends the created game PINs to a Supabase database for persistence;</li>\n<li>provides an optional “Join a game” page for players to enter the game PIN;</li>\n<li>validates game PINs when a player joins a game;</li>\n<li>hosts and renders the actual game on a shareable (i.e. unique) URL;</li>\n<li>connects to the Colyseus server and handle state updates;</li>\n<li>provides a landing (“marketing”) page.</li>\n</ul>\n<p>For the implementation of those tasks, I chose SvelteKit over Next.js for the following reasons:</p>\n<h3>Why SvelteKit?</h3>\n<p>I have been wanting to develop another app using Svelte ever since I built <a href=\"https://neolightsout.grooovinger.com/\">neolightsout</a>. When SvelteKit (the official application framework for Svelte) went into public beta, I decided to build <em>Autowuzzler</em> with it and accept any headaches that come with using a fresh beta — the joy of using Svelte clearly makes up for it.</p>\n<p>These <strong>key features</strong> made me choose SvelteKit over Next.js for the actual implementation of the game frontend:</p>\n<ul>\n<li>Svelte is a UI framework <em>and</em> a compiler and therefore ships minimal code without a client runtime;</li>\n<li>Svelte has an expressive templating language and component system (personal preference);</li>\n<li>Svelte includes global stores, transitions and animations out of the box, which means: no decision fatigue choosing a global state management toolkit and an animation library;</li>\n<li>Svelte supports scoped CSS in single-file-components;</li>\n<li>SvelteKit supports SSR, simple but flexible file-based routing and server-side routes for building an API;</li>\n<li>SvelteKit allows for each page to run code on the server, e.g. to fetch data that is used to render the page;</li>\n<li>Layouts shared across routes;</li>\n<li>SvelteKit can be run in a serverless environment.</li>\n</ul>\n<h3>Creating And Storing Game PINs</h3>\n<p>Before a user can start playing the game, they first need to create a game PIN. By sharing the PIN with others, they can all access the same game room.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/e55799f4-a6c6-4795-8261-0848a07645df/3-real-time-multi-user-game.png\" /></p>\n<p>This is a great use case for SvelteKits server-side <a href=\"https://kit.svelte.dev/docs#routing-endpoints\">endpoints</a> in conjunction with Sveltes <a href=\"https://svelte.dev/docs#onMount\">onMount</a> function: The endpoint <code>/api/createcode</code> generates a game PIN, stores it in a Supabase.io database and <strong>outputs the game PIN as a response</strong>. This is response is fetched as soon as the page component of the “create” page is mounted:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/da77cb83-8b8a-434c-b6a7-245dfbf91228/1-real-time-multi-user-game.png\" /></p>\n<h4>Storing Game PINs With Supabase.io</h4>\n<p>Supabase.io is an open-source alternative to Firebase. Supabase makes it very easy to create a PostgreSQL database and access it either via one of its client libraries or via REST.</p>\n<p>For the JavaScript client, we import the <code>createClient</code> function and execute it using the parameters <code>supabase_url</code> and <code>supabase_key</code> we received when creating the database. To <strong>store the game PIN</strong> that is created on each call to the <code>createcode</code> endpoint, all we need to do is to run this simple <code>insert</code> query:</p>\n<pre><code>import { createClient } from '@supabase/supabase-js'\n\nconst database = createClient(\n import.meta.env.VITE_SUPABASE_URL,\n import.meta.env.VITE_SUPABASE_KEY\n);\n\nconst { data, error } = await database\n .from(\"games\")\n .insert([{ code: 123456 }]);\n</code></pre>\n\n<p><strong>Note</strong>: <em>The <code>supabase_url</code> and <code>supabase_key</code> are stored in a .env file. Due to Vite — the build tool at the heart of SvelteKit — it is required to prefix the environment variables with VITE_ to make them accessible in SvelteKit.</em></p>\n<h3>Accessing The Game</h3>\n<p>I wanted to make joining an <em>Autowuzzler</em> game as easy as following a link. Therefore, every game room needed to have its <strong>own URL based on the previously created game PIN</strong>, e.g. <a href=\"https://autowuzzler.com/play/12345\">https://autowuzzler.com/play/12345</a>.</p>\n<p>In SvelteKit, pages with dynamic route parameters are created by putting the dynamic parts of the route in square brackets when naming the page file: <code>client/src/routes/play/[gamePIN].svelte</code>. The value of the <code>gamePIN</code> parameter will then become available in the page component (see the <a href=\"https://kit.svelte.dev/docs#routing-pages\">SvelteKit docs</a> for details). In the <code>play</code> route, we need to connect to the Colyseus server, instantiate the physics world to render to the screen, handle updates to game objects, listen to keyboard input and display other UI like the score, and so on.</p>\n<h3>Connecting To Colyseus And Updating State</h3>\n<p>The Colyseus client library enables us to connect a client to a Colyseus server. First, let’s create a new <code>Colyseus.Client</code> by pointing it to the Colyseus server (<code>ws://localhost:2567</code>in development). Then join the room with the name we chose earlier (<code>autowuzzler</code>) and the <code>gamePIN</code> from the route parameter. The <code>gamePIN</code> parameter makes sure the user joins the correct room instance (see “<a href=\"#multi-room-setup-match-making\">match-making</a>” above).</p>\n<pre><code>let client = new Colyseus.Client(\"ws://localhost:2567\");\nthis.room = await client.joinOrCreate(\"autowuzzler\", { gamePIN });\n</code></pre>\n\n<p>Since SvelteKit renders pages on the server initially, we need to make sure that this <strong>code only runs on the client</strong> after the page is done loading. Again, we use the <code>onMount</code> lifecycle function for that use case. (If you’re familiar with React, <code>onMount</code> is similar to the <code>useEffect</code> hook with an empty dependency array.)</p>\n<pre><code>onMount(async () =&gt; {\n  let client = new Colyseus.Client(\"ws://localhost:2567\");\n  this.room = await client.joinOrCreate(\"autowuzzler\", { gamePIN });\n})\n</code></pre>\n\n<p>Now that we are connected to the Colyseus game server, we can start to listen to any changes to our game objects.</p>\n<p>Here’s an example of <strong>how to listen to a player joining the room</strong> (<code>onAdd</code>) and receiving consecutive state updates to this player:</p>\n<pre><code>this.room.state.players.onAdd = (player, key) =&gt; {\n  console.log(`Player has been added with sessionId: ${key}`);\n\n  // add player entity to the game world\n  this.world.createPlayer(key, player.teamNumber);\n\n  // listen for changes to this player\n  player.onChange = (changes) =&gt; {\n   changes.forEach(({ field, value }) =&gt; {\n     this.world.updatePlayer(key, field, value); // see below\n   });\n };\n};\n</code></pre>\n\n<p>In the <code>updatePlayer</code> method of the physics world, we update the properties one by one because Colyseus’ <code>onChange</code> delivers a set of all changed properties.</p>\n<p><strong>Note</strong>: <em>This function only runs on the client version of the physics world, as game objects are only manipulated indirectly via the Colyseus server.</em></p>\n<pre><code>updatePlayer(sessionId, field, value) {\n // get the player physics object by its sessionId\n let player = this.world.players.get(sessionId);\n // exit if not found\n if (!player) return;\n // apply changes to the properties\n switch (field) {\n   case \"angle\":\n     Body.setAngle(player, value);\n     break;\n   case \"x\":\n     Body.setPosition(player, { x: value, y: player.position.y });\n     break;\n   case \"y\":\n     Body.setPosition(player, { x: player.position.x, y: value });\n     break;\n   // set velocityX, velocityY, angularVelocity ...\n }\n}\n</code></pre>\n\n<p>The same procedure applies to the other game objects (ball and teams): listen to their changes and apply the changed values to the client's physics world.</p>\n<p>So far, no objects are moving because we still need to <strong>listen to keyboard input and send it to the server</strong>. Instead of directly sending events on every <code>keydown</code> event, we maintain a map of currently pressed keys and send events to the Colyseus server in a 50ms loop. This way, we can support pressing multiple keys at the same time and mitigate the pause that happens after the first and consecutive <code>keydown</code> events when the key stays pressed:</p>\n<pre><code>let keys = {};\nconst keyDown = e =&gt; {\n keys[e.key] = true;\n};\nconst keyUp = e =&gt; {\n keys[e.key] = false;\n};\ndocument.addEventListener('keydown', keyDown);\ndocument.addEventListener('keyup', keyUp);\n\nlet loop = () =&gt; {\n if (keys[\"ArrowLeft\"]) {\n   this.room.send(\"move\", { direction: \"left\" });\n }\n else if (keys[\"ArrowRight\"]) {\n   this.room.send(\"move\", { direction: \"right\" });\n }\n if (keys[\"ArrowUp\"]) {\n   this.room.send(\"move\", { direction: \"up\" });\n }\n else if (keys[\"ArrowDown\"]) {\n   this.room.send(\"move\", { direction: \"down\" });\n }\n // next iteration\n requestAnimationFrame(() =&gt; {\n  setTimeout(loop, 50);\n });\n}\n// start loop\nsetTimeout(loop, 50);\n</code></pre>\n\n<p>Now the cycle is complete: listen for keystrokes, send the corresponding commands to the Colyseus server to manipulate the physics world on the server. The Colyseus server then applies the new physical properties to all the game objects and propagates the data back to the client to update the user-facing instance of the game. </p>\nMinor Nuisances\n<p>In retrospect, two things of the category <em>nobody-told-me-but-someone-should-have</em> come to mind:</p>\n<ul>\n<li>A <strong>good understanding of how physics engines work</strong> is beneficial. I spent a considerable amount of time fine-tuning physics properties and constraints. Even though I built a small game with Phaser.js and Matter.js before, there was a lot of trial-and-error to get objects to move in the way I imagined them to.</li>\n<li><strong>Real-time is hard</strong> — especially in physics-based games. Minor delays considerably worsen the experience, and while synchronizing state across clients with Colyseus works great, it can’t remove computation and transmission delays.</li>\n</ul>\n<h3>Gotchas And Caveats With SvelteKit</h3>\n<p>Since I used SvelteKit when it was fresh out of the beta-oven, there were a few gotchas and caveats I would like to point out:</p>\n<ul>\n<li>It took a while to figure out that environment variables need to be prefixed with VITE_ in order to use them in SvelteKit. This is now properly documented in the <a href=\"https://kit.svelte.dev/faq\">FAQ</a>.</li>\n<li>To use Supabase, I had to add Supabase to <em>both</em> the <code>dependencies</code> and <code>devDependencies</code> lists of package.json. I believe this is no longer the case.</li>\n<li>SvelteKits <code>load</code> function runs both on the server <em>and</em> the client!</li>\n<li>To enable full hot module replacement (including preserving state), you have to manually add a comment line <code>&lt;!-- @hmr:keep-all --&gt;</code> in your page components. See <a href=\"https://kit.svelte.dev/faq\">FAQ</a> for more details.</li>\n</ul>\n<p>Many other frameworks would have been great fits as well, but I have no regrets about choosing SvelteKit for this project. It enabled me to work on the client application in a very efficient way — mostly because Svelte itself is very expressive and skips a lot of the boilerplate code, but also because Svelte has things like animations, transitions, scoped CSS and global stores baked in. SvelteKit <strong>provided all the building blocks I needed</strong> (SSR, routing, server routes) and although still in beta, it felt very stable and fast.</p>\n<h3>Deployment And Hosting</h3>\n<p>Initially, I hosted the Colyseus (Node) server on a <a href=\"https://www.heroku.com/\">Heroku</a> instance and wasted a lot of time getting WebSockets and CORS working. As it turns out, the performance of a tiny (free) Heroku dyno is not sufficient for a real-time use case. I later migrated the Colyseus app to a small server at <a href=\"http://linode.com/\">Linode</a>. The client-side application is deployed by and hosted on Netlify via SvelteKits<a href=\"https://github.com/sveltejs/kit/tree/master/packages/adapter-netlify\"> adapter-netlify</a>. No surprises here: Netlify just worked great!</p>\nConclusion\n<p>Starting out with a really simple prototype to validate the idea helped me a lot in figuring out if the project is worth following and where the technical challenges of the game lay. In the final implementation, Colyseus took care of all the heavy lifting of synchronizing state in real-time across multiple clients, distributed in multiple rooms. <strong>It’s impressive how quickly a real-time multi-user application can be built</strong> with Colyseus — once you figure out how to properly describe the schema. Colyseus’ built-in monitoring panel helps in troubleshooting any synchronizing issues.</p>\n<p>What complicated this setup was the physics layer of the game because it introduced an additional copy of each physics-related game object that needed to be maintained. Storing game PINs in Supabase.io from the SvelteKit app was very straightforward. In hindsight, I could have just used an SQLite database to store the game PINs, but <strong>trying out new things</strong> is half of the fun when building side projects.</p>\n<p>Finally, using SvelteKit for building out the frontend of the game allowed me to move quickly — and with the occasional grin of joy on my face.</p>\n<p>Now, go ahead and invite your friends to a round of <a href=\"https://www.autowuzzler.com/\">Autowuzzler</a>!</p>\n<h3>Further Reading on Smashing Magazine</h3>\n<ul>\n<li>“<a href=\"https://www.smashingmagazine.com/2021/05/get-started-whac-a-mole-react-game/\">Get Started With React By Building A Whac-A-Mole Game</a>,” Jhey Tompkins</li>\n<li>“<a href=\"https://www.smashingmagazine.com/2019/08/real-time-multiplayer-virtual-reality-game-part-1/\">How To Build A Real-Time Multiplayer Virtual Reality Game</a>,” Alvin Wan</li>\n<li>“<a href=\"https://www.smashingmagazine.com/2018/12/multiplayer-text-adventure-engine-node-js/\">Writing A Multiplayer Text Adventure Engine In Node.js</a>,” Fernando Doglio</li>\n<li>“<a href=\"https://www.smashingmagazine.com/2018/03/future-mobile-web-design-video-game-design-storytelling/\">The Future Of Mobile Web Design: Video Game Design And Storytelling</a>,” Suzanne Scacca</li>\n<li>“<a href=\"https://www.smashingmagazine.com/2019/03/virtual-reality-endless-runner-game-vr-part-1/\">How To Build An Endless Runner Game In Virtual Reality</a>,” Alvin Wan</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"c149c458b65d51b33c0b550405f439ad8ad3c497f061d17a039b5006b6c9fbb6","category":"Tech"}