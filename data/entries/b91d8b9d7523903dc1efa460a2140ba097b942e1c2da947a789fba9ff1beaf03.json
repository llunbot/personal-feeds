{"title":"สรุปการอ่านเรื่อง How we run migrations across 2,800 microservices","link":"https://www.somkiat.cc/note-how-migrations-across-2800-microservices/","date":1730870321000,"content":"<p><img width=\"150\" height=\"150\" src=\"https://www.somkiat.cc/wp-content/uploads/2024/11/monzo-casae-study-150x150.png\" loading=\"lazy\" srcset=\"https://www.somkiat.cc/wp-content/uploads/2024/11/monzo-casae-study-150x150.png 150w, https://www.somkiat.cc/wp-content/uploads/2024/11/monzo-casae-study-75x75.png 75w\" /></p>\n<figure><a href=\"https://www.somkiat.cc/wp-content/uploads/2024/11/monzo-casae-study.png\"><img src=\"https://www.somkiat.cc/wp-content/uploads/2024/11/monzo-casae-study-1024x512.png\" width=\"741\" height=\"371\" /></a></figure>\n\n\n\n<p>จากการอ่านบทความเรื่อง <strong><a href=\"https://monzo.com/blog/how-we-run-migrations-across-2800-microservices\" target=\"_blank\">How we run migrations across 2,800 microservices ของทาง monzo</a></strong><br />ซึ่งเป็น online banking ที่ UK<br />ทำการเขียนบทความเรื่องการ upgrade library <br />จากเดิมที่ใช้งาน OpenTracing และ Jaeger ที่ deprecated ไปแล้ว <br />มาใช้งาน OpenTelemetry<br />บน service จำนนวน 2,800 service !! <br />มาดูกันว่าทำอย่างไรบ้าง ?</p>\n\n\n\n<span></span>\n\n\n\n<p><strong>แนวทางในการ upgrade มีอยู่ 3 ทางเลือกคือ</strong></p>\n\n\n\n<ul>\n<li>Update library มายัง version ล่าสุด</li>\n\n\n\n<li>ทุก ๆ  serviceต้องใช้ library version เดียวกันเสมอ</li>\n\n\n\n<li>ใช้ effort ในการ upgrade ให้น้อยที่สุด เปลี่ยนแปลง code ให้น้อยที่สุด</li>\n</ul>\n\n\n\n<figure><a href=\"https://www.somkiat.cc/wp-content/uploads/2024/11/Screenshot-2567-11-06-at-11.41.21.png\"><img src=\"https://www.somkiat.cc/wp-content/uploads/2024/11/Screenshot-2567-11-06-at-11.41.21.png\" width=\"416\" height=\"382\" /></a></figure>\n\n\n\n<p><strong>โดยในการ upgrade หรือ migrate ครั้งนี้</strong></p>\n\n\n\n<p>ต้องการลดปัญหาที่อาจจะเกิดขึ้น เช่น</p>\n\n\n\n<p>การทำงานร่วมกับหลาย ๆ  ทีม ซึ่งอาจจะเกิด overhead ในการพูดคุยหรือติดต่อกัน ทำให้ช้าลงไปอีก <br />รวมทั้ง version ของ library ที่ใช้งานอาจจะไม่ตรงกัน<br />ดังนั้นแก้ไขด้วยการสร้างทีม migration ขึ้นมาเลย เพื่อจัดการเรื่องนี้โดยตรง<br />ซึ่ง code ของ  service ต่าง ๆ  จะเป็นแบบ monorepo<br />และมีการใช้ automation tool ในขั้นตอนต่าง ๆ ทั้งการ deploy และ rollback เป็นต้น</p>\n\n\n\n<p><strong>มี Migration Principles ดังนี้</strong></p>\n\n\n\n<ul>\n<li><strong>Centrally driven migrations that are transparent to service owners</strong> ลด overhead ในการทำงานร่วมกัน และลดความเสี่ยงต่าง ๆ  ด้วยการสร้างทีมจัดการโดยตรงมาเลย และยังต้องสร้างความชัดเจนไปยังเข้าของ service ต่าง ๆ  ด้วย ว่าผลการ migrate/upgrade เป็นอย่างไร กระทบต่อ service หรือไม่</li>\n\n\n\n<li><strong>No downtime</strong> ชัดเจนมาก ๆ มิเช่นนั้นจะกระทบต่อ business แน่ ๆ</li>\n\n\n\n<li><strong>Gradual roll forward, quick roll back</strong> จะค่อย ๆ  ทำการ rollout ออกไป แต่ถ้ามีปัญหาก็สามารถ rollback ได้อย่างรวดเร็ว เพื่อลดผลกระทบที่จะเกิดขึ้น</li>\n\n\n\n<li><strong>80/20 rule when it comes to automation</strong> ในการ migrate/upgrade จำนวนมาก ๆ  บบนี้ มีการเปลี่ยนแปลงที่เยอะมาก ๆ ดังนั้นจะทำการสร้าง template ของการเปลี่ยนแปลงขึ้นมา เพื่อให้ง่ายต่อการ automated ซึ่งช่วยลดความเสี่ยงต่าง ๆ   ลงไปได้เยอะ</li>\n</ul>\n\n\n\n<p><strong>ขั้นตอนการ migrate/upgrade library เป็นดังนี้</strong></p>\n\n\n\n<p><strong>ขั้นตอนแรก ในการใช้งาน 3-party library ความมี abstraction layer คั่นก่อนเสมอ</strong></p>\n\n\n\n<p>เพื่อลดการผูกมัดกับ library และ ระบบงานลงไป<br />จะเรียกส่วนนี้ว่า adapter</p>\n\n\n\n<figure><a href=\"https://www.somkiat.cc/wp-content/uploads/2024/11/step-01.png\"><img src=\"https://www.somkiat.cc/wp-content/uploads/2024/11/step-01.png\" width=\"331\" height=\"284\" /></a></figure>\n\n\n\n<p><strong>ขั้นตอนที่สอง ทำการเพิ่มเติม library version ใหม่ในส่วนของ adapter นั่นเอง</strong></p>\n\n\n\n<p>พร้อมให้มีการ configuration ให้ใช้ของเก่า หรือ ใหม่ แบบ dynamic ได้<br />ทำให้มี library ทั้งสอง version อยู่ด้วยกัน<br />ไม่ต้องทำการ refactor ใด ๆ<br />ทำให้ง่ายต่อการเปลี่ยน หรือ rollback นั่นเอง โดยไม่ต้อง deploy ใหม่</p>\n\n\n\n<figure><a href=\"https://www.somkiat.cc/wp-content/uploads/2024/11/step-02.png\"><img src=\"https://www.somkiat.cc/wp-content/uploads/2024/11/step-02.png\" width=\"538\" height=\"269\" /></a></figure>\n\n\n\n<p><strong><em>หัวใจหลัก ๆ  ของแนวทางนี้ คือ <br />ลดการผูกมัดระหว่าง external code กับ application code ให้น้องลง (Loose coupling)</em></strong></p>\n\n\n\n<p><strong>ขั้นตอนต่อมา คือ การจัดการกับ service จำนวนมาก ๆ</strong></p>\n\n\n\n<p>สิ่งที่ขาดไม่ได้คือ automation tool นั่นเอง<br />เมื่อทำการ push code version ใหม่เข้ามา<br />จะทำการ deploy ไปยังแต่ละ  service แบบอัตโนมัติ<br />ทำการเป็น asynchronous batch job<br />แต่เมื่อการ deploy มีปัญหา ก็ต้องทำการ rollback ซึ่งใช้งาน</p>\n\n\n\n<ul>\n<li><a href=\"https://argoproj.github.io/rollouts/\" target=\"_blank\">Argo Rollouts</a></li>\n</ul>\n\n\n\n<p>แน่นอนว่า เรื่องของ Monitoring ก็สำคัญมาก ๆ  <br />เพื่อช่วยตรวจสอบว่า  หลังจากการ deploy ไปแล้วมีปัญหาหรือไม่<br />ด้วยการใช้งาน Grafana และ Prometheus<br />เมื่อเกิดปัญหา หรือ ตาม pattern ที่กำหนดไว้ ก็ทำการ rollback ทันที</p>\n\n\n\n<p><strong>ขั้นตอนสุดท้าย เมื่อทำการ migrate/update ตรงเรียบร้อยแล้ว</strong></p>\n\n\n\n<p>ทำการลบ code ของ version เก่าทิ้งไปซะ</p>\n\n\n\n<p>ลองอ่านในรายละเอียดเพิ่มเติมได้<br />น่าจะเป็นอีก use case ที่น่าสนใจ<br />ว่าการ migrate/update library ที่ใช้ก็สำคัญมาก ๆ<br />Later === Never !!<br /></p>\n","author":"somkiat","siteTitle":"cc :: somkiat","siteHash":"3a23a5a4389e1e40c6fbb16520a8cc20df5b3591c25145ce72aaa18b19e48201","entryHash":"b91d8b9d7523903dc1efa460a2140ba097b942e1c2da947a789fba9ff1beaf03","category":"Thai"}