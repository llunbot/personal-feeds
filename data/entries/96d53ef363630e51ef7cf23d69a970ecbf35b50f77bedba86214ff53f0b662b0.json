{"title":"Building A Static-First MadLib Generator With Portable Text And Netlify On-Demand Builder Functions","link":"https://smashingmagazine.com/2021/10/static-first-madlib-generator-portable-text-netlify-builder-functions/","date":1633687200000,"content":"<p>Creating an interactive experience with fiction can be a chore with traditional content management tools. Writing the prose, creating the forms, combining them in the frontend — these are often the domain of three different people.</p>\n<p>Let’s make it <strong>the domain of just one content creator</strong> in which the user will fill out a form before reading the story — creating odd and often funny stories. This type of experience was popularized as “Madlibs.” </p>\n<ul>\n<li>Generate your own madlibs <a href=\"https://brob-madlibs.netlify.app/\">in the demo</a>;</li>\n<li>Look through the final code <a href=\"https://github.com/brob/madlibs\">on Github</a>;</li>\n<li><a href=\"https://www.sanity.io/create?template=brob/sanity-template-11ty-madlibs\">Get a fully-built version</a> set up in your accounts.</li>\n</ul>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/47bc83a3-5a27-4afc-9504-05b04c38b66b/madlib-example.jpg\" /></p>\nHow The Generator Will Work\n<p>An editor can create a series of madlibs that an end-user can fill out and save a copy with their unique answers. The editor will be working with the Sanity Studio inside a rich-text field that we’ll craft to provide additional information for our front-end to build out forms. </p>\n<p>For the editor, it will feel like writing standard paragraph content. They’ll be able to write like they’re used to writing. They can then create specific blocks inside their content that will specify a part of speech and display text.</p>\n<p>The front-end of the application can then use that data to both display the text <em>and</em> build a form. We’ll <strong>use 11ty to create the frontend</strong> with some small templates. The form that is built will display to the user before they see the text. They’ll know what type of speech and general context for the phrases and words they can enter. </p>\n<p>After the form is submitted, they’ll be given their fully formed story (with hopefully hilarious results). This creation will only be set within their browser. If they wish to share it, they can then click the “Save” button. This will submit the entire text to a serverless function in Netlify to save it to the Sanity data store. Once that has been created, a link will appear for the user to view the permanent version of their madlib and share it with friends. </p>\n<p>Since 11ty is a static site generator, we can’t count on a site rebuild to generate each user’s saved Madlib on the fly. We can use 11ty’s new Serverless mode to build them on request using Netlify’s On-Demand Builders to cache each Madlib.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c8fedfcd-88e1-4bfe-ab7c-26b313bdf783/flow-chart.jpg\" /></p>\nThe Tools\n<h3>Sanity.io</h3>\n<p>Sanity.io is a unified content platform that believes that content is data and data can be used as content. Sanity pairs a real-time data store with three open-source tools: a powerful query language (GROQ), a CMS (Sanity Studio), and a rich-text data specification (Portable Text).</p>\n<h3>Portable Text</h3>\n<p>Portable Text is an open-source specification designed to treat rich text as data. We’ll be using Portable Text for the rich text that our editors will enter into a Sanity Studio. Data will decorate the rich text in a way that we can create a form on the fly based on the content.</p>\n<h3>11ty And 11ty Serverless</h3>\n<p>11ty is a static site generator built in Node. It allows developers to ingest data from multiple sources, write templates in multiple templating engines, and output simple, clean HTML.</p>\n<p>In the upcoming 1.0 release, 11ty is introducing the concept of 11ty Serverless. This update allows sites to use the same templates and data to render pages via a serverless function or on-demand builder. 11ty Serverless begins to blur the line between “static site generator” and server-rendered page.</p>\n<h3>Netlify On-Demand Builders</h3>\n<p>Netlify has had serverless functions as part of its platform for years. For example, an “On-Demand Builder” is a serverless function dedicated to serving a cached file. Each builder works similarly to a standard serverless function on the first call. Netlify then caches that page on its edge CDN for each additional call.</p>\nBuilding The Editing Interface And Datastore\n<p>Before we can dive into serverless functions and the frontend, it would be helpful to have our data set up and ready to query.</p>\n<p>To do this, we’ll set up a new project and install <a href=\"https://www.sanity.io/studio\">Sanity’s Studio</a> (an open-source content platform for managing data in your Sanity Content Lake).</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/5763893d-f797-49c4-9fb8-bdf5a598ce5c/studio-screenshot.jpg\" /></p>\n<p>To create a new project, we can use Sanity’s CLI tools.</p>\n<p>First, we need to create a new project directory to house both the front-end and the studio. I’ve called mine <code>madlibs</code>.</p>\n<p>From inside this directory in the command line, run the following commands:</p>\n<pre><code>npm i -g @sanity/cli\nsanity init</code></pre>\n\n<p>The <code>sanity init</code> command will run you through a series of questions. Name your project <code>madlibs</code>, create a new dataset called <code>production</code>, set the “output path” to <code>studio</code>, and for “project template,” select “Clean project with no predefined schemas.”</p>\n<p>The CLI creates a new Sanity project and installs all the needed dependencies for a new studio. Inside the newly created <code>studio</code> directory, we have everything we need to make our editing experience.</p>\n<p>Before we create the first interface, run <code>sanity start</code> in the <code>studio</code> directory to run the studio.</p>\n<h3>Creating The <code>madlib</code> Schema</h3>\n<p>A set of schema defines the studio’s editing interface. To create a new interface, we’ll create a new schema in the schema folder.</p>\n<div>\n <pre><code>// madlibs/studio/schemas/madlib.js\n\nexport default {\n  // Name in the data\n  name: 'madlib',\n  // Title visible to editors\n  title: 'Madlib Template',\n  // Type of schema (at this stage either document or object)\n  type: 'document',\n  // An array of fields\n  fields: [\n    {\n      name: 'title',\n      title: 'Title',\n      type: 'string'\n    },\n    {\n      title: 'Slug',\n      name: 'slug',\n      type: 'slug',\n      options: {\n        source: 'title',\n        maxLength: 200, // // will be ignored if slugify is set\n      }\n    },\n  ]\n}\n</code></pre>\n</div>\n\n<p>The schema file is a JavaScript file that exports an object. This object defines the data's <code>name</code>, <code>title</code>, <code>type</code>, and any fields the document will have.</p>\n<p>In this case, we'll start with a <code>title</code> string and a <code>slug</code> that can be generated from the title field. Once the file and initial code are created, we need to add this schema to our <code>schema.js</code> file.</p>\n<div>\n <pre><code>// /madlibs/studio/schema/schema.js\n\n// First, we must import the schema creator\nimport createSchema from 'part:@sanity/base/schema-creator'\n\n// Then import schema types from any plugins that might expose them\nimport schemaTypes from 'all:part:@sanity/base/schema-type'\n\n// Imports our new schema\nimport madlib from './madlib'\n\n// Then we give our schema to the builder and provide the result to Sanity\nexport default createSchema({\n  // We name our schema\n  name: 'default',\n  // Then proceed to concatenate our document type\n  // to the ones provided by any plugins that are installed\n  types: schemaTypes.concat([\n    // document\n    // adds the schema to the list the studio will display\n    madlib,\n  ])\n})\n</code></pre>\n</div>\n\n<p>Next, we need to create a rich text editor for our madlib authors to write the templates. Sanity has a built-in way of handling rich text that can convert to the flexible Portable Text data structure.</p>\n<p>To create the editor, we use an <code>array</code> field that contains a special schema type: <code>block</code>.</p>\n<p>The <code>block</code> type will return all the default options for rich text. We can also extend this type to create specialty blocks for our editors.</p>\n<div>\n <pre><code>export default {\n  // Name in the data\n  name: 'madlib',\n  // Title visible to editors\n  title: 'Madlib Template',\n  // Type of schema (at this stage either document or object)\n  type: 'document',\n  // An array of fields\n  fields: [\n    {\n      name: 'title',\n      title: 'Title',\n      type: 'string'\n    },\n    {\n      title: 'Slug',\n      name: 'slug',\n      type: 'slug',\n      options: {\n        source: 'title',\n        maxLength: 200, // // will be ignored if slugify is set\n      }\n    },\n    {\n      title: 'Madlib Text',\n      name: 'text',\n      type: 'array',\n      of: [\n        {\n          type: 'block',\n          name: 'block',\n          of: [\n            // A new type of field that we'll create next\n            { type: 'madlibField' }\n          ]\n        },\n      ]\n    },\n  ]\n}\n</code></pre>\n</div>\n\n<p>This code will set up the Portable Text editor. It builds various types of “blocks.” Blocks roughly equate to top-level data in the JSON data that Portable Text will return. By default, standard blocks take the shape of things like paragraphs, headers, lists, etc.</p>\n<p>Custom blocks can be created for things like images, videos, and other data. For our madlib fields, we want to make “inline” blocks — blocks that flow within one of these larger blocks. To do that, the <code>block</code> type can accept its own <code>of</code> array. These fields can be any type, but we’ll make a custom type and add it to our schema in our case.</p>\n<h3>Creating A Custom Schema Type For The Madlib Field</h3>\n<p>To create a new custom type, we need to create a new file and import the schema into <code>schema.js</code> as we did for a new document type.</p>\n<p>Instead of creating a schema with a <code>type</code> of <code>document</code>, we need to create one of <code>type: object</code>.</p>\n<p>This custom type needs to have two fields: the display text and the grammar type. By structuring the data this way, we open up future possibilities for inspecting our content.</p>\n<p>Alongside the data fields for this type, we can also specify a custom preview to show more than one field displayed in the rich text. To make this work, we define a React component that will accept the data from the fields and display the text the way we want it.</p>\n<div>\n <pre><code>// /madlibs/studio/schemas/object/madLibField.js\nimport React from 'react'\n\n// A React Component that takes hte value of data\n// and returns a simple preview of the data that can be used\n// in the rich text editor\nfunction madlibPreview({ value }) {\n  const { text, grammar } = value\n\n  return (\n    \n      {text} ({grammar})\n    \n  );\n}\n\nexport default {\n  title: 'Madlib Field Details',\n  name: 'madlibField',\n  type: 'object',\n  fields: [\n    {\n      name: 'displayText',\n      title: 'Display Text',\n      type: 'string'\n    },\n    {\n      name: 'grammar',\n      title: 'Grammar Type',\n      type: 'string'\n    }\n  ],\n  // Defines a preview for the data in the Rich Text editor\n  preview: {\n    select: {\n      // Selects data to pass to our component\n      text: 'displayText',\n      grammar: 'grammar'\n    },\n\n    // Tells the field which preview to use\n    component: madlibPreview,\n  },\n}\n</code></pre>\n</div>\n\n<p>Once that’s created, we can add it to our schemas array and use it as a type in our Portable Text blocks.</p>\n<div>\n <pre><code>// /madlibs/studio/schemas/schema.js\n// First, we must import the schema creator\nimport createSchema from 'part:@sanity/base/schema-creator'\n\n// Then import schema types from any plugins that might expose them\nimport schemaTypes from 'all:part:@sanity/base/schema-type'\n\nimport madlib from './madlib'\n// Import the new object\nimport madlibField from './objects/madlibField'\n\n// Then we give our schema to the builder and provide the result to Sanity\nexport default createSchema({\n  // We name our schema\n  name: 'default',\n  // Then proceed to concatenate our document type\n  // to the ones provided by any plugins that are installed\n  types: schemaTypes.concat([\n    // documents\n    madlib,\n    //objects\n    madlibField\n  ])\n})\n</code></pre>\n</div>\n\n<h3>Creating The Schema For User-generated Madlibs</h3>\n<p>Since the user-generated madlibs will be submitted from our frontend, we don’t technically need a schema for them. However, if we create a schema, we get an easy way to see all the entries (and delete them if necessary).</p>\n<p>We want the structure for these documents to be the same as our madlib templates. The main differences in this schema from our <code>madlib</code> schema are the <code>name</code>, <code>title</code>, and, optionally, making the fields read-only.</p>\n<div>\n <pre><code>// /madlibs/studio/schema/userLib.js\nexport default {\n  name: 'userLib',\n  title: 'User Generated Madlibs',\n  type: 'document',\n  fields: [\n    {\n      name: 'title',\n      title: 'Title',\n      type: 'string',\n      readOnly: true\n    },\n    {\n      title: 'Slug',\n      name: 'slug',\n      type: 'slug',\n      readOnly: true,\n      options: {\n        source: 'title',\n        maxLength: 200, // // will be ignored if slugify is set\n      },\n    },\n    {\n      title: 'Madlib Text',\n      name: 'text',\n      type: 'array',\n      readOnly: true,\n      of: [\n        {\n          type: 'block',\n          name: 'block',\n          of: [\n            { type: 'madlibField' }\n          ]\n        },\n      ]\n    },\n  ]\n}\n</code></pre>\n</div>\n\n<p>With that, we can add it to our <code>schema.js</code> file, and our admin is complete. Before we move on, be sure to add at least one madlib template. I found the first paragraph of Moby Dick worked surprisingly well for some humorous results.</p>\nBuilding The Frontend With 11ty\n<p>To create the frontend, we’ll use 11ty. 11ty is a static site generator written in and extended by Node. It does the job of creating HTML from multiple sources of data well, and with some new features, we can extend that to server-rendered pages and build-rendered pages.</p>\n<h3>Setting Up 11ty</h3>\n<p>First, we’ll need to get things set up.</p>\n<p>Inside the main <code>madlibs</code> directory, let’s create a new <code>site</code> directory. This directory will house our 11ty site.</p>\n<p>Open a new terminal and change the directory into the <code>site</code> directory. From there, we need to install a few dependencies.</p>\n<pre><code>// Create a new package.json\nnpm init -y\n// Install 11ty and Sanity utilities\nnpm install @11ty/eleventy@beta @sanity/block-content-to-html @sanity/client</code></pre>\n\n<p>Once these have been installed, we’ll add a couple of scripts to our <code>package.json</code></p>\n<pre><code>// /madlibs/site/package.json\n\n\"scripts\": {\n \"start\": \"eleventy --serve\",\n \"build\": \"eleventy\"\n  },</code></pre>\n\n<p>Now that we have a build and start script, let’s add a base template for our pages to use and an index page.</p>\n<p>By default, 11ty will look in an <code>_includes</code> directory for our templates, so create that directory and add a <code>base.njk</code> file to it.</p>\n<div>\n <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n  &lt;title&gt;Madlibs&lt;/title&gt;\n  {# Basic reset #}\n  &lt;link rel=\"stylesheet\" href=\"<a href=\"https://unpkg.com/some-nice-basic-css/global.css&quot;\">https://unpkg.com/some-nice-basic-css/global.css\"</a> /&gt;\n\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;nav class=\"container navigation\"&gt;\n    &lt;a class=\"logo\" href=\"/\"&gt;Madlibs&lt;/a&gt;\n  &lt;/nav&gt;\n\n  &lt;div class=\"stack container bordered\"&gt;\n    {# Inserts content from a page file and renders it as html #}\n    {{ content | safe }}\n  &lt;/div&gt;\n\n  {% block scripts %}\n  {# Block to insert scripts from child templates #}\n  {% endblock %}\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre>\n</div>\n\n<p>Once we have a template, we can create a page. First, in the root of the <code>site</code> directory, add an <code>index.html</code> file. Next, we’ll use frontmatter to add a little data — a title and the layout file to use.</p>\n<div>\n <pre><code>---\ntitle: Madlibs \nlayout: 'base.njk'\n---\n&lt;p&gt;Some madlibs to take your mind off things. They're stored in &lt;a href=\"<a href=\"https://sanity.io&quot;&gt;Sanity.io&lt;/a&gt;\">https://sanity.io\"&gt;Sanity.io&lt;/a&gt;</a>, built with &lt;a href=\"<a href=\"https://11ty.dev&quot;&gt;11ty&lt;/a&gt;\">https://11ty.dev\"&gt;11ty&lt;/a&gt;</a>, and do interesting things with Netlify serverless functions.&lt;/p&gt;\n</code></pre>\n</div>\n\n<p>Now you can start 11ty by running <code>npm start</code> in the <code>site</code> directory.</p>\n<h3>Creating Pages From Sanity Data Using 11ty Pagination</h3>\n<p>Now, we want to create pages dynamically from data from Sanity. To do this, we’ll create a JavaScript Data file and a Pagination template.</p>\n<p>Before we dive into those files, we need to create a couple of utilities for working with the Sanity data.</p>\n<p>Inside the <code>site</code> directory, let’s create a <code>utils</code> directory.</p>\n<p>The first utility we need is an initialized Sanity JS client. First, create a file named <code>sanityClient.js</code> in the new <code>utils</code> directory.</p>\n<div>\n <pre><code>// /madlibs/site/utils/sanityClient.js'\nconst sanityClient = require('@sanity/client')\nmodule.exports = sanityClient({\n  // The project ID\n  projectId: '&lt;YOUR-ID&gt;',\n  // The dataset we created\n  dataset: 'production',\n  // The API version we want to use\n  // Best practice is to set this to today's date\n  apiVersion: '2021-06-07',\n  // Use the CDN instead of fetching directly from the data store\n  useCdn: true\n})\n</code></pre>\n</div>\n\n<p>Since our rich text is stored as Portable Text JSON, we need a way to convert the data to HTML. We’ll create a utility to do this for us. First, create a file named <code>portableTextUtils.js</code> in the <code>utils</code> directory.</p>\n<p>For Sanity and 11ty sites, we typically will want to convert the JSON to either Markdown or HTML. For this site, we’ll use HTML to have granular control over the output.</p>\n<p>Earlier, we installed <code>@sanity/block-content-to-html</code>, which will help us serialize the data to HTML. The package will work on all basic types of Portable Text blocks and styles. However, we have a custom block type that needs a custom serializer.</p>\n<div>\n <pre><code>// Initializes the package\nconst toHtml = require('@sanity/block-content-to-html')\nconst h = toHtml.h;\n\nconst serializers = {\n  types: {\n    madlibField: ({ node }) =&gt; {\n      // Takes each node of <code>type</code> <code>madlibField</code>\n      // and returns an HTML span with an id, class, and text\n      return h('span', node.displayText, { id: node._key, className: 'empty' })\n    }\n  }\n}\n\nconst prepText = (data) =&gt; {\n  // Takes the data from a specific Sanity document\n  // and creates a new htmlText property to contain the HTML\n  // This lets us keep the Portable Text data intact and still display HTML\n  return {\n    ...data,\n    htmlText: toHtml({\n      blocks: data.text, // Portable Text data\n      serializers: serializers // The serializer to use\n    })\n  }\n}\n\n// We only need to export prepText for our functions\nmodule.exports = { prepText }\n</code></pre>\n</div>\n\n<p>The <code>serializers</code> object in this code has a <code>types</code> object. In this object, we create a specialized serializer for any type. The key in the object should match the <code>type</code> given in our data. In our case, this is <code>madlibField</code>. Each type will have a function that returns an element written using hyperscript functions.</p>\n<p>In this case, we create a <code>span</code> with children of the <code>displayText</code> from the current data. Later we’ll need unique IDs based on the data’s <code>_key</code>, and we’ll need a class to style these. We provide those in an object as the third argument for the <code>h()</code> function. We’ll use this same serializer setup for both our madlib templates and the user-generated madlibs.</p>\n<p>Now that we have our utilities, it’s time to create a JavaScript data file. First, create a <code>_data</code> in the <code>site</code> directory. In this file, we can add global data to our 11ty site. Next, create a <code>madlibs.js</code> file. This file is where our JavaScript will run to pull each madlib template. The data will be available to any of our templates and pages under the <code>madlibs</code> key.</p>\n<div>\n <pre><code>// Get our utilities\nconst client = require('../utils/sanityClient')\nconst {prepText} = require('../utils/portableTextUtils')\n// The GROQ query used to find specific documents and \n// shape the output \nconst query = <code>*[_type == \"madlib\"]{\n    title,\n    \"slug\": slug.current,\n    text,\n    _id,\n    \"formFields\": text[]{\n        children[_type == \"madlibField\"]{\n            displayText,\n            grammar,\n            _key\n      }\n      }.children[]\n  }</code>\n\nmodule.exports = async function() {\n    // Fetch data based on the query\n    const madlibs = await client.fetch(query);\n\n    // Prepare the Portable Text data\n    const preppedMadlib = madlibs.map(prepText)\n    // Return the full array\n    return preppedMadlib\n}\n</code></pre>\n</div>\n\n<p>To fetch the data, we need to get the utilities we just created. The Sanity client has a <code>fetch()</code> method to pass a GROQ query. We’ll map over the array of documents the query returns to prepare their Portable Text and then return that to 11ty’s data cascade.</p>\n<p>The GROQ query in this code example is doing most of the work for us. We start by requesting all documents with a <code>_type</code> of <code>madlib</code> from our Sanity content lake. Then we specify which data we want to return. The data starts simply: we need the title, slug, rich text, and id from the document, but we also want to reformat the data into a set of form fields, as well.</p>\n<p>To do that, we create a new property on the data being returned: <code>formFields</code>. This looks at the <code>text</code> data (a Portable Text array) and loops over it with the <code>[]</code> operator. We can then build a new project on this data like we’re doing with the entire document with the <code>{}</code> operator.</p>\n<p>Each <code>text</code> object has a <code>children</code> array. We can loop through that, and if the item matches the filter inside the <code>[]</code>, we can run another projection on that. In this case, we’re filtering all <code>children</code> that have a <code>_type == \"madlibField\"</code>. In other words, any inline block that has an item with the type we created. We need the <code>displayText</code>, <code>grammar</code>, and <code>_key</code> for each of these. This will return an array of <code>text</code> objects with the children matching our filter. We need to flatten this to be an array of children. To do this, we can add the <code>.children[]</code> after the projects. This will return a flat array with just the children elements we need.</p>\n<p>This gives us all the documents in an array with just the data we need (including newly reformatted items).</p>\n<p>To use them in our 11ty build, we need a template that will use Pagination.</p>\n<p>In the root of the <code>site</code>, create a <code>madlib.njk</code> file. This file will generate each madlib page from the data.</p>\n<div>\n <pre><code>---\nlayout: 'base.njk'\npagination:\n  data: madlibs\n  alias: madlib\n  size: 1\npermalink: \"madlibs/{{ madlib.slug | slug }}/index.html\"\n---\n</code></pre>\n</div>\n\n<p>In the front matter of this file, we specify some data 11ty can use to generate our pages:</p>\n<ul>\n<li><strong><code>layout</code></strong><br />The template to use to render the page.</li>\n<li><strong><code>pagination</code></strong><br />An object with pagination information.</li>\n<li><strong><code>pagination.data</code></strong><br />The data key for pagination to read.</li>\n<li><strong><code>pagination.alias</code></strong><br />A key to use in this file for ease.</li>\n<li><strong><code>pagination.size</code></strong><br />The number of madlibs per page (in this case, 1 per page to create individual pages).</li>\n<li><strong><code>permalink</code></strong><br />The URLs at which each of these should live (can be partially generated from data).</li>\n</ul>\n<p>With that data in place, we can specify how to display each piece of data for an item in the array.</p>\n<div>\n <pre><code>---\nlayout: 'base.njk'\npagination:\n  data: madlibs\n  alias: madlib\n  size: 1\npermalink: \"madlibs/{{ madlib.slug | slug }}/index.html\"\n---\n\n&lt;h2&gt;{{ madlib.title }}&lt;/h2&gt;\n&lt;p&gt;&lt;em&gt;Instructions:&lt;/em&gt; Fill out this form, submit it and get your story. It will hopfully make little-to-no sense. Afterward, you can save the madlib and send it to your friends.&lt;/p&gt;\n&lt;div class=\"madlibtext\"&gt;\n&lt;a href=\"#\" class=\"saver\"&gt;Save it&lt;/a&gt;\n{{ madlib.htmlText | safe }}\n&lt;/div&gt;\n&lt;h2&gt;Form&lt;/h2&gt;\n&lt;form class=\"madlibForm stack\"&gt;\n{% for input in madlib.formFields %}\n    &lt;label&gt;\n        {{ input.displayText }} ({{ input.grammar }})\n        &lt;input type=\"text\" class=\"libInput\" name={{input._key}}&gt;\n    &lt;/label&gt;\n{% endfor %}\n&lt;button&gt;Done&lt;/button&gt;\n&lt;/form&gt;\n</code></pre>\n</div>\n\n<p>We can properly format the title and HTML text. We can then use the <code>formFields</code> array to create a form that users can enter their unique answers.</p>\n<p>There’s some additional markup for use in our JavaScript — a form button and a link to save the finalized madlib. The link and madlib text will be hidden (no peeking for our users!).</p>\n<p>For every madlib template, you created in your studio, 11ty will build a unique page. The final URLs should look like this</p>\n<pre><code>http://localhost:8080/madlibs/the-slug-in-the-studio/</code></pre>\n\nMaking The Madlibs Interactive\n<p>With our madlibs generated, we need to make them interactive. We’ll sprinkle a little JavaScript and CSS to make them interactive. Before we can use CSS and JS, we need to tell 11ty to copy the static files to our built site.</p>\n<h3>Copying Static Assets To The Final Build</h3>\n<p>In the root of the <code>site</code> directory, create the following files and directories:</p>\n<ul>\n<li><code>assets/css/style.css</code> — for any additional styling,</li>\n<li><code>assets/js/madlib.js</code> — for the interactions,</li>\n<li><code>.eleventy.js</code> — the 11ty configuration file.</li>\n</ul>\n<p>When these files are created, we need to tell 11ty to copy the assets to the final build. Those instructions live in the <code>.eleventy.js</code> configuration file.</p>\n<pre><code>module.exports = function(eleventyConfig) {\n eleventyConfig.addPassthroughCopy(\"assets/\");\n}</code></pre>\n\n<p>This instructs 11ty to copy the entire <code>assets</code> directory to the final build.</p>\n<p>The only necessary CSS to make the site work is a snippet to hide and show the madlib text. However, if you want the whole look and feel, you can find all the styles <a href=\"https://github.com/brob/madlibs/blob/main/site/assets/css/style.css\">in this file</a>.</p>\n<pre><code>.madlibtext {\n display: none\n}\n.madlibtext.show {\n display: block;\n}</code></pre>\n\n<h3>Filling In The Madlib With User Input And JavaScript</h3>\n<p>Any frontend framework will work with 11ty if you set up a build process. For this example, we’ll use plain JavaScript to keep things simple. The first task is to take the user data in the form and populate the generic madlib template that 11ty generated from our Sanity data.</p>\n<div>\n <pre><code>// Attach the form handler\nconst form = document.querySelector('.madlibForm')\nform.addEventListener('submit', completeLib);\n\nfunction showText() {\n  // Find the madlib text in the document\n  const textDiv = document.querySelector('.madlibtext')\n  // Toggle the class \"show\" to be present\n  textDiv.classList.toggle('show')\n}\n\n// A function that takes the submit event\n// From the event, it will get the contents of the inputs\n// and write them to page and show the full text\nfunction completeLib(event) {\n  // Don't submit the form\n  event.preventDefault();\n  const { target } = event // The target is the form element\n\n  // Get all inputs from the form in array format\n  const inputs = Array.from(target.elements)\n\n  inputs.forEach(input =&gt; {\n    // The button is an input and we don't want that in the final data\n    if (input.type != 'text') return\n    // Find a span by the input's name\n    // These will both be the _key value\n    const replacedContent = document.getElementById(input.name)\n    // Replace the content of the span with the input's value\n    replacedContent.innerHTML = input.value\n  })\n  // Show the completed madlib\n  showText();\n}\n</code></pre>\n</div>\n\n<p>This functionality comes in three parts: attaching an event listener, taking the form input, inserting it into the HTML, and then showing the text.</p>\n<p>When the form is submitted, the code creates an array from the form’s inputs. Next, it finds elements on the page with ids that match the input’s name — both created from the <code>_key</code> values of each block. It then replaces the content of that element with the value from the data.</p>\n<p>Once that’s done, we toggle the full madlib text to show on the page.</p>\n<p>We need to add this script to the page. To do this, we create a new template for the madlibs to use. In the <code>_includes</code> directory, create a file named <code>lib.njk</code>. This template will extend the base template we created and insert the script at the bottom of the page’s body.</p>\n<div>\n <pre><code>{% extends 'base.njk' %}\n\n{% block scripts %}\n&lt;script&gt;\n  var pt = {{ madlib.text | dump | safe }}\n  var data = {\n      libId: <code>{{ madlib._id }}</code>,\n      libTitle: <code>{{ madlib.title }}</code>\n  }\n&lt;/script&gt;\n&lt;script src=\"/assets/js/madlib.js\"&gt;&lt;/script&gt;\n{% endblock %}\n</code></pre>\n</div>\n\n<p>Then, our <code>madlib.njk</code> pagination template needs to use this new template for its layout.</p>\n<div>\n <pre><code>---\nlayout: 'lib.njk'\npagination:\n  data: madlibs\n  alias: madlib\n  size: 1\npermalink: \"madlibs/{{ madlib.slug | slug }}/index.html\"\n---\n\n// page content\n</code></pre>\n</div>\n\n<p>We now have a functioning madlib generator. To make this more robust, let’s allow users to save and share their completed madlibs.</p>\nSaving A User Madlib To Sanity With A Netlify Function\n<p>Now that we have a madlib displayed to the user, we need to create the link for saving send the information to Sanity.</p>\n<p>To do that, we’ll add some more functionality to our front-end JavaScript. But, first, we need to add some more data pulled from Sanity into our JavaScript, so we’ll add a couple of new variables in the <code>scripts</code> block on the <code>lib.njk</code> template.</p>\n<div>\n <pre><code>{% extends 'base.njk' %}\n\n{% block scripts %}\n&lt;script&gt;\n  // Portable Text data\n  var pt = {{ madlib.text | dump | safe }}\n  var data = {\n      libId: <code>{{ madlib._id }}</code>,\n      libTitle: <code>{{ madlib.title }}</code>\n  }\n&lt;/script&gt;\n&lt;script src=\"/assets/js/madlib.js\"&gt;&lt;/script&gt;\n{% endblock %}\n</code></pre>\n</div>\n\n<p>We can write a script to send it and the user-generated answers to a serverless function to send to Sanity with that additional data.</p>\n<div>\n <pre><code>// /madlibs/site/assets/js/madlib.js\n\n// ... completeLib()\n\nasync function saveLib(event) {\n  event.preventDefault();\n\n  // Return an Map of ids and content to turn into an object\n  const blocks = Array.from(document.querySelectorAll('.empty')).map(item =&gt; {\n    return [item.id, { content: item.outerText }]\n  })\n  // Creates Object ready for storage from blocks map\n  const userContentBlocks = Object.fromEntries(blocks);\n\n  // Formats the data for posting\n  const finalData = {\n    userContentBlocks,\n    pt, // From nunjucks on page\n    ...data // From nunjucks on page\n  }\n\n  // Runs the post data function for createLib\n  postData('/.netlify/functions/createLib', finalData)\n    .then(data =&gt; {\n      // When post is successful\n      // Create a div for the final link\n      const landingZone = document.createElement('div')\n      // Give the link a class\n      landingZone.className = \"libUrl\"\n      // Add the div after the saving link\n      saver.after(landingZone)\n      // Add the new link inside the landing zone\n      landingZone.innerHTML = <code>&lt;a href=\"/userlibs/${data._id}/\" class=\"savedUrl\"&gt;Your url is /userlibs/${data._id}/&lt;/a&gt;</code>\n\n    }).catch(error =&gt; {\n      // When errors happen, do something with them\n      console.log(error)\n    });\n}\n\nasync function postData(url = '', data = {}) {\n  // A wrapper function for standard JS fetch\n  const response = await fetch(url, {\n    method: 'POST',\n    mode: 'cors',\n    cache: 'no-cache',\n    credentials: 'same-origin',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(data)\n  });\n  return response.json(); // parses JSON response into native JavaScript objects\n}\n</code></pre>\n</div>\n\n<p>We add a new event listener to the “Save” link in our HTML.</p>\n<p>The <code>saveLib</code> function will take the data from the page and the user-generated data and combine them in an object to be handled by a new serverless function. The serverless function needs to take that data and create a new Sanity document. When creating the function, we want it to return the <code>_id</code> for the new document. We use that to create a unique link that we add to the page. This link will be where the newly generated page will be.</p>\n<h3>Setting Up Netlify Dev</h3>\n<p>To use Netlify Functions, we’ll need to get our project set up on Netlify. We want Netlify to build and serve from the <code>site</code> directory. To give Netlify this information, we need to create a <code>netlify.toml</code> file at the root of the entire project.</p>\n<pre><code>[build]\n command = \"npm run build\" # Command to run\n functions = \"functions\"            # Directory we store the functions\n publish = \"_site\"                        # Folder to publish (11ty automatically makes the _site folder\n base = \"site\"                                # Folder that is the root of the build</code></pre>\n\n<p>To develop these locally, it’s helpful to install Netlify’s CLI globally.</p>\n<pre><code>npm install -g netlify-cli</code></pre>\n\n<p>Once that’s installed, you can run <code>netlify dev</code> in your project. This will take the place of running your <code>start</code> NPM script.</p>\n<p>The CLI will run you through connecting your repository to Netlify. Once it’s done, we’re ready to develop our first function.</p>\n<h3>Creating A Function To Save Madlibs To Sanity</h3>\n<p>Since our TOML file sets the functions directory to <code>functions</code>, we need to create the directory. Inside the directory, make a <code>createLib.js</code> file. This will be the serverless function for creating a madlib in the Sanity data store.</p>\n<p>The standard Sanity client we’ve been using is read-only. To give it write permissions, we need to reconfigure it to use an API read+write token. To generate a token, log into the project dashboard and go to the project settings for your madlibs project. In the settings, find the Tokens area and generate a new token with “Editor” permissions. When the token is generated, save the string to Netlify’s environment variables dashboard with the name <code>SANITY_TOKEN</code>. Netlify Dev will automatically pull these environment variables into the project while running.</p>\n<p>To reconfigure the client, we’ll require the file from our utilities, and then run the <code>.config()</code> method. This will let us set any configuration value for this specific use. We’ll set the token to the new environment variable and set <code>useCdn</code> to false.</p>\n<pre><code>// Sanity JS Client\n// The build client is read-only\n// To use to write, we need to add an API token with proper permissions\nconst client = require('../utils/sanityClient')\nclient.config({\n    token: process.env.SANITY_TOKEN,\n    useCdn: false\n})</code></pre>\n\n<p>The basic structure for a Netlify function is to export a handler function that is passed an event and returns an object with a status code and string body.</p>\n<div>\n <pre><code>// Grabs local env variables from .env file\n// Not necessary if using Netlify Dev CLI\nrequire('dotenv').config()\n\n// Sanity JS Client\n// The build client is read-only\n// To use to write, we need to add an API token with proper permissions\nconst client = require('../utils/sanityClient')\nclient.config({\n  token: process.env.SANITY_TOKEN,\n  useCdn: false\n})\n\n// Small ID creation package\nconst { nanoid } = require('nanoid')\n\nexports.handler = async (event) =&gt; {\n  // Get data off the event body\n  const {\n    pt,\n    userContentBlocks,\n    id,\n    libTitle\n  } = JSON.parse(event.body)\n\n  // Create new Portable Text JSON\n  // from the old PT and the user submissions\n  const newBlocks = findAndReplace(pt, userContentBlocks)\n\n  // Create new Sanity document object\n  // The doc's _id and slug are based on a unique ID from nanoid\n  const docId = nanoid()\n  const doc = {\n    _type: \"userLib\",\n    _id: docId,\n    slug: { current: docId },\n    madlib: id,\n    title: <code>${libTitle} creation</code>,\n    text: newBlocks,\n  }\n\n  // Submit the new document object to Sanity\n  // Return the response back to the browser\n  return client.create(doc).then((res) =&gt; {\n    // Log the success into our function log\n    console.log(<code>Userlib was created, document ID is ${res._id}</code>)\n    // return with a 200 status and a stringified JSON object we get from the Sanity API\n    return { statusCode: 200, body: JSON.stringify(doc) };\n  }).catch(err =&gt; {\n    // If there's an error, log it\n    // and return a 500 error and a JSON string of the error\n    console.log(err)\n    return {\n      statusCode: 500, body: JSON.stringify(err)\n    }\n  })\n}\n\n// Function for modifying the Portable Text JSON\n// pt is the original portable Text\n// mods is an object of modifications to make \nfunction findAndReplace(pt, mods) {\n  // For each block object, check to see if a mod is needed and return an object\n  const newPT = pt.map((block) =&gt; ({\n    ...block, // Insert all current data\n    children: block.children.map(span =&gt; {\n      // For every item in children, see if there's a modification on the mods object\n      // If there is, set modContent to the new content, if not, set it to the original text \n      const modContent = mods[span._key] ? mods[span._key].content : span.text\n      // Return an object with all the original data, and a new property\n      // displayText for use in the frontends\n      return {\n        ...span,\n        displayText: modContent\n      }\n    })\n  }))\n  // Return the new Portable Text JSON\n  return newPT\n}\n</code></pre>\n</div>\n\n<p>The body is the data we just submitted. For ease, we’ll destructure the data off the <code>event.body</code> object. Then, we need to compare the original Portable Text and the user content we submitted and create the new Portable Text JSON that we can submit to Sanity.</p>\n<p>To do that, we run a find and replace function. This function maps over the original Portable Text and for every child in the blocks, replace its content with the corresponding data from the modfications object. If there isn’t a modification, it will store the original text.</p>\n<p>With modified Portable Text in hand, we can create a new object to store as a document in the Sanity content lake. Each document needs a unique identifier (which we can use the <code>nanoid</code> NPM package to create. We’ll also let this newly created ID be the slug for consistency.</p>\n<p>The rest of the data is mapped to the proper key in our <code>userLib</code> schema we created in the studio and submitted with the authenticated client’s <code>.create()</code> method. When success or failure returns from Sanity, we pass that along to the frontend for handling.</p>\n<p>Now, we have data being saved to our Sanity project. Go ahead and fill out a madlib and submit. You can view the creation in the studio. Those links that we’re generating don’t work yet, though. This is where 11ty Serverless comes in.</p>\nSetting Up 11ty Serverless\n<p>You may have noticed when we installed 11ty that we used a specific version. This is the beta of the upcoming 1.0 release. 11ty Serverless is one of the big new features in that release.</p>\n<h3>Installing The Serverless Plugin</h3>\n<p>11ty Serverless is an included plugin that can be initialized to create all the boilerplate for running 11ty in a serverless function. To get up and running, we need to add the plugin to our <code>.eleventy.js</code> configuration file.</p>\n<div>\n <pre><code>const { EleventyServerlessBundlerPlugin } = require(\"@11ty/eleventy\");\n\nmodule.exports = function (eleventyConfig) {\n  eleventyConfig.addPassthroughCopy(\"assets/\");\n\n  eleventyConfig.addPlugin(EleventyServerlessBundlerPlugin, {\n    name: \"userlibs\", // the name to use for the functions\n    functionsDir: \"./functions/\", // The functions directory\n    copy: [\"utils/\"], // Any files that need to be copied to make our scripts work\n    excludeDependencies: [\"./_data/madlibs.js\"] // Exclude any files you don't want to run\n  });\n};\n</code></pre>\n</div>\n\n<p>After creating this file, restart 11ty by rerunning <code>netlify dev</code>. On the next run, 11ty will create a new directory in our <code>functions</code> directory named <code>userlibs</code> (matching the name in the serverless configuration) to house everything it needs to have to run in a serverless function. The <code>index.js</code> file in this directory is created if it doesn’t exist, but any changes you make will persist.</p>\n<p>We need to make one small change to the end of this file. By default, 11ty Serverless will initialize using standard serverless functions. This will run the function on every load of the route. That’s an expensive load for content that can’t be changed after it’s been generated. Instead, we can change it to use Netlify’s On-Demand Builders. This will build the page on the first request and cache the result for any later requests. This cache will persist until the next build of the site.</p>\n<p>To update the function, open the <code>index.js</code> file and change the ending of the file.</p>\n<pre><code>// Comment this line out\nexports.handler = handler\n\n// Uncomment these lines\nconst { builder } = require(\"@netlify/functions\");\nexports.handler = builder(handler);</code></pre>\n\n<p>Since this file is using Netlify’s functions package, we also need to install that package.</p>\n<pre><code>npm install @netlify/functions</code></pre>\n\n<h3>Creating A Data File For User-generated Madlibs</h3>\n<p>Now that we have an On-Demand Builder, we need to pull the data for user-generated madlibs. We can create a new JavaScript data file in the <code>_data</code> file named <code>userlibs.js</code>. Like our madlibs data file, the file name will be the key to get this data in our templates.</p>\n<div>\n <pre><code>// /madlibs/site/_data/userlibs.js\n\nconst client = require('../utils/sanityClient')\nconst {prepText} = require('../utils/portableTextUtils')\n\nconst query = <code>*[_type == \"userLib\"]{\n    title,\n    \"slug\": slug.current,\n    text,\n    _id\n  }</code>\n\nmodule.exports = async function() {\n    const madlibs = await client.fetch(query);\n    // Protect against no madlibs returning\n    if (madlibs.length == 0) return {\"404\": {}} \n\n    // Run through our portable text serializer\n    const preppedMadlib = madlibs.map(prepText)\n\n    // Convert the array of documents into an object\n    // Each item in the Object will have a key of the item slug\n    // 11ty's Pagination will create pages for each one\n    const mapLibs = preppedMadlib.map(item =&gt; ([item.slug, item]))\n    const objLibs = Object.fromEntries(mapLibs)\n    return objLibs\n}\n</code></pre>\n</div>\n\n<p>This data file is similar to what we wrote earlier, but instead of returning the array, we need to return an object. The object’s keys are what the serverless bundle will use to pull the correct madlib on request. In our case, we’ll make the item’s <code>slug</code> the key since the serverless route will be looking for a slug.</p>\n<h3>Creating A Pagination Template That Uses Serverless Routes</h3>\n<p>Now that the plugin is ready, we can create a new pagination template to use the generated function.</p>\n<p>In the root of our <code>site</code>, add a <code>userlibs.njk</code> template. This template will be like the <code>madlibs.njk</code> template, but it will use different data without any interactivity.</p>\n<div>\n <pre><code>---\nlayout: 'base.njk'\npagination:\n  data: userLibs\n  alias: userlib\n  size: 1\n  serverless: eleventy.serverless.path.slug\n\npermalink: \n  userlibs: \"/userlibs/:slug/\"\n---\n\n&lt;h2&gt;{{ userlib.title }}&lt;/h2&gt;\n&lt;div&gt;\n  {{ userlib.htmlText | safe }}\n&lt;/div&gt;\n</code></pre>\n</div>\n\n<p>In this template, we use <code>base.njk</code> to avoid including the JavaScript. We specify the new <code>userlibs</code> data for pagination.</p>\n<p>To pull the correct data, we need to specify what the lookup key will be. On the pagination object, we do this with the <code>serverless</code> property. When using serverless routes, we get access to a new object: <code>eleventy.serverless</code>. On this object, there’s a <code>path</code> object that contains information on what URL the user requested. In this case, we’ll have a <code>slug</code> property on that object. That needs to correspond to a key on our pagination data.</p>\n<p>To get the <code>slug</code> on our path, we need to add it to the <code>permalink</code> object. 11ty Serverless allows for more than one route for a template. The route’s key needs to match the name provided in the <code>.eleventy.js</code> configuration. In this case, it should be <code>userlibs</code>. We specify the static <code>/userlibs/</code> start to the path and then add a dynamic element: <code>:slug/</code>. This slug will be what gets passed to <code>eleventy.serverless.path.slug</code>.</p>\n<p>Now, the link that we created earlier by submitting a madlib to Sanity will work.</p>\nNext Steps\n<p>Now we have a madlib generator that saves to a data store. We build only the necessary pages to allow a user to create a new madlib. When they create one, we make those pages on-demand with 11ty and Netlify Functions. From here, we can extend this further.</p>\n<ul>\n<li>Statically build the user-generated content as well as render them on request.</li>\n<li>Create a counter for the total number of madlibs saved by each madlib template.</li>\n<li>Create a list of words users use by parts of speech.</li>\n</ul>\n<p>When you can statically build AND dynamically render, what sorts of applications does this open up?</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"96d53ef363630e51ef7cf23d69a970ecbf35b50f77bedba86214ff53f0b662b0","category":"Tech"}