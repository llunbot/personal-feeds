{"title":"Seamlessly migrate from Consul service discovery to service mesh","link":"https://www.hashicorp.com/blog/seamlessly-migrate-from-consul-service-discovery-to-service-mesh","date":1710172800000,"content":"<p>Migrating from HashiCorp Consul service discovery to service mesh is a smart move for platform teams looking to boost their applications’ security, observability, and availability, all without requiring modifications from their development teams. This blog post will briefly introduce you to the advantages of moving to a service mesh and provide a step-by-step, no-downtime migration guide. </p>\n\n<h2>Service mesh benefits</h2>\n\n<p>Why is a service mesh migration worth your time? Here are some of the benefits:</p>\n\n<h3>Advance security</h3>\n\n<p>Service mesh allows teams to quickly enforce <a href=\"https://www.hashicorp.com/resources/introduction-to-zero-trust-security\">zero trust security principles</a> using mTLS on all east/west traffic, significantly reducing the risk of unauthorized access and data breaches. Platform teams can enable an application’s existing service discovery DNS lookup to allow for both HTTP and mTLS connections. This allows all applications to transition to using mTLS connections without impacting any of their dependent services (such as downstreams).</p>\n\n<h3>Enhance observability</h3>\n\n<p>It also provides application teams with new capabilities such as distributed tracing and data plane metrics. Distributed tracing acts like a GPS tracking system for each request, providing detailed insights into its journey across services, and helping quickly pinpoint bottlenecks and performance issues. Data plane metrics offer real-time insights into traffic flows between microservices that include requests per second, error rates, and advanced L7 features such as retries. These insights can improve decision-making and lead to higher application availability.</p>\n\n<h3>Increase resilience</h3>\n\n<p>Service mesh improves application availability by automatically handling retries, rate limiting, circuit breaking, and timeouts, helping to ensure that services remain accessible and performant, even under adverse conditions. Applications in a service mesh use traffic splitting for blue/green or canary deployments to reduce risks associated with updates and new releases.</p>\n\n<h3>Improve multi-tenancy scalability</h3>\n\n<p>If you need to give users self-service capabilities in multi-tenant environments or meet higher compliance requirements, consider upgrading to <a href=\"https://developer.hashicorp.com/consul/docs/enterprise\">Consul Enterprise</a>. With the power to manage their own namespaces or even entire service meshes, Consul Enterprise gives teams the autonomy to innovate and streamline operations. It ensures team isolation, enabling the safe management of application deployments and resilience strategies. </p>\n\n<p>Beyond operational agility, Consul Enterprise empowers teams to comply with rigorous regulations, by offering L3/L4 networking control over service mesh connections, FIPS 140–2 compliance, and full audit logs. This enhanced level of governance and flexibility allows teams to fine-tune their service ecosystems to meet specific operational demands and compliance needs.</p>\n\n<h2>Migration to service mesh</h2>\n\n<p>Now that we’ve explored the top reasons to switch to Consul service mesh, it’s time to walk through the migration, step by step. </p>\n\n<p>We’ll begin with an overview of the Amazon EKS cluster and the Consul components that will be deployed. In this guide, the Consul server and example services will be deployed on the same EKS cluster for simplicity. However, the principles and steps outlined are also relevant for environments utilizing virtual machines or combination of platforms. The EKS cluster in this guide will run a legacy <code>api</code> service, using only service discovery, and the new mesh-enabled <code>web</code> service that is accessible only through the <a href=\"https://developer.hashicorp.com/consul/docs/connect/gateways/api-gateway\"><code>Consul API gateway</code></a>. The diagram below shows the initial environment that will be setup:</p>\n<img src=\"https://www.datocms-assets.com/2885/1709933168-init-eks.png\" alt=\"Amazon\" /><p>To streamline the initial setup, the following key steps are condensed into bullet points, with detailed step-by-step instructions available in the <a href=\"https://github.com/ppresto/aws-consul-sd-to-sm/blob/main/README.md\">README.md</a> for <a href=\"https://github.com/ppresto/aws-consul-sd-to-sm/tree/main\">this project’s GitHub repo</a>.</p>\n\n<ul>\n<li><strong>Provision infrastructure</strong>: Use HashiCorp Terraform to provision an AWS VPC and EKS cluster. This includes cloning the repository, initializing Terraform, and applying infrastructure as code to set up the environment.</li>\n<li><strong>Connect to EKS</strong>: Update the kubeconfig with the EKS cluster details using the AWS CLI and set up convenient kubectl aliases for easier management.</li>\n<li><strong>Install the AWS LB controller</strong>: Set up the AWS load balancer controller to map internal Network load balancers or Application load balancers to Kubernetes services. The Consul Helm chart will use AWS LB annotations to properly set up internally routable mesh gateways and make the Consul UI externally available.</li>\n<li><strong>Install Consul Helm chart</strong>: Deploy the example <a href=\"https://github.com/ppresto/aws-consul-sd-to-sm/blob/main/quickstart/infrastructure/consul_helm_values/yaml/community-values.yaml\">Consul Helm chart values</a> enabling the following components:\n\n<ul>\n<li><a href=\"https://developer.hashicorp.com/consul/tutorials/security/tls-encryption-secure\">TLS</a>: Enables TLS across the cluster to verify the authenticity of the Consul servers and clients</li>\n<li><a href=\"https://developer.hashicorp.com/consul/tutorials/security/access-control-setup-production\">Access Control Lists</a>: Automatically manage ACL tokens and policies for all of Consul</li>\n<li><a href=\"https://developer.hashicorp.com/consul/docs/k8s/helm#connectinject-1\">connect-inject:</a> Configures Consul’s automatic service mesh sidecar injector</li>\n<li><a href=\"https://developer.hashicorp.com/consul/docs/k8s/helm#v-connectinject-apigateway\">api-gateway</a>: Enables the Consul API gateway and manages it with Kubernetes Gateway API CRDs</li>\n<li><a href=\"https://developer.hashicorp.com/consul/docs/k8s/helm#synccatalog\">sync-catalog</a>: A process that syncs Kubernetes services to Consul for service discovery</li>\n<li><a href=\"https://developer.hashicorp.com/consul/docs/k8s/helm#v-connectinject-cni\">cni</a>: Facilitates service mesh traffic redirection without requiring CAP<em>NET</em>ADMIN privileges for Kubernetes pods</li>\n<li><a href=\"https://developer.hashicorp.com/consul/docs/k8s/helm#v-global-metrics\">metrics</a>: Exposes Prometheus metrics for Consul servers, gateways, and Envoy sidecars</li>\n</ul></li>\n<li><strong>Setup DNS forwarding in EKS</strong>: <a href=\"https://developer.hashicorp.com/consul/tutorials/networking/dns-forwarding\">Configure DNS forwarding</a> within EKS to allow service discovery via Consul.</li>\n<li><strong>Deploy service using Consul service discovery</strong>: Deploy <code>api</code> and Kubernetes catalog-sync to automatically register the service with Consul the same way VMs register services using Consul agents.</li>\n<li><strong>Deploy service using Consul service mesh</strong>: Deploy the service <code>web</code> into the mesh.  Mesh-enabled services aren’t available externally without a special ingress or API gateway allowing the traffic. Set up the <code>Consul API gateway</code>with a route to <code>web</code> so it's accessible from the browser.</li>\n</ul>\n\n<p>The steps above complete the initial setup. Consul is installed on EKS, and the web service is operational within the service mesh, directing requests to the <code>api</code> service outside the mesh, which utilizes service discovery exclusively. The <code>Consul API gateway</code> has been set up with routes to enable external requests to <code>web</code>. Run the command below to retrieve the URL for the <code>Consul API gateway</code> and store it in a variable for future use. The external address may take a couple minutes to propagate, so be patient. </p>\n<pre><code>export APIGW_URL=$(kubectl get services --namespace=consul api-gateway -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')\nnslookup ${APIGW_URL}</code></pre><p>Once the gateway is resolvable, use the generated URL below to access <code>web</code> and verify the initial environment is working as expected.</p>\n<pre><code>echo \"http://${APIGW_URL}/ui\"</code></pre><img src=\"https://www.datocms-assets.com/2885/1709933176-init-service.png\" alt=\"The\" /><p>The image above shows the expected response: <code>web</code> is within the mesh accessing <code>api.service.consul</code>, which is located outside the mesh. Traffic between <code>web</code> and <code>api</code> is HTTP and unencrypted. </p>\n\n<p>Now it’s time to migrate <code>api</code> into the service mesh:</p>\n\n<h3><strong>Migrate services into the service mesh</strong></h3>\n\n<p>To smoothly migrate services into the service mesh, we'll follow a clear, three-step approach:</p>\n\n<ul>\n<li><strong>Step 1: Enable permissive mode</strong></li>\n<li><strong>Step 2: Enforce mTLS</strong></li>\n<li><strong>Step 3: Use virtual services</strong></li>\n</ul>\n\n<h4><strong>Step 1: Enable permissive mode</strong></h4>\n\n<p>To begin, you need to migrate <code>api</code> into the mesh. It’s crucial that HTTP requests to <code>api.service.consul</code> continue to function for downstream services not in the service mesh, while services within the mesh use mTLS for secure communication.</p>\n\n<p>The first step is implementing <a href=\"https://developer.hashicorp.com/consul/docs/connect/config-entries/service-defaults#mutualtlsmode\">permissive MutualTLSMode</a> for <code>api</code>, allowing it to accept both HTTP and mTLS connections.</p>\n<img src=\"https://www.datocms-assets.com/2885/1709933182-step1-eks.png\" alt=\"The\" /><p>To enable permissive <code>MutualTLSMode</code>, the <code>api</code> service defaults need to configure <code>MutualTLSMode</code> to permissive. Here’s an example for <code>ServiceDefaults</code>:</p>\n<pre><code>apiVersion: consul.hashicorp.com/v1alpha1\nkind: ServiceDefaults\nmetadata:\n  name: api\n  namespace: api\nspec:\n  protocol: http\n  mutualTLSMode: \"permissive\"</code></pre><p>Create a new deployment for <code>api</code> enabling service mesh and apply these new <code>ServiceDefaults</code> to enable permissive mode:</p>\n<pre><code>kubectl apply -f api/permissive_mTLS_mode/init-consul-config/servicedefaults-permissive.yaml\nkubectl apply -f api/permissive_mTLS_mode/api-v2-mesh-enabled.yaml</code></pre><p>Refresh the browser a few times and watch how the same requests from <code>web</code> to <code>api.service.consul</code> are routed to both <code>api</code> (non-mesh) and <code>api</code> (mesh) deployments. Consul uses a weighted round-robin load balancing algorithm by default to distribute requests from <code>web</code> across both <code>api</code> deployments. </p>\n<img src=\"https://www.datocms-assets.com/2885/1709933189-step1-service.png\" alt=\"web\" /><p>After verifying the <code>api</code> (mesh) deployment is working with the original DNS lookup <code>api.service.consul</code>, remove the original <code>api</code> (non-mesh) deployment:</p>\n<pre><code>kubectl -n api delete deployment api-v1</code></pre><p>Newly onboarded services can run in permissive mode while other downstream and upstream services are migrated to the service mesh in any order. This ensures a smooth transition for all services. </p>\n\n<p>Services can be onboarded to the mesh upon their next release using an annotation or by enabling the entire namespace, which doesn’t require changes from the development team. While in permissive mode, requests to the original service discovery name <code>api.service.consul</code> will be over HTTP. Verify this by sniffing the incoming traffic to the <code>api</code> pod while refreshing the browser to generate traffic:</p>\n<pre><code>kubectl debug -it -n api $(kubectl -n api get pods --output jsonpath='{.items[0].metadata.name}') --target consul-dataplane --image nicolaka/netshoot -- tcpdump -i eth0 src port 9091 -A\n\n\nTargeting container \"consul-dataplane\". If you don't see processes from this container it may be because the container runtime doesn't support this feature.\nDefaulting debug container name to debugger-v77g6.\nIf you don't see a command prompt, try pressing enter.\n{\n \"name\": \"api (mesh)\",\n \"uri\": \"/\",\n \"type\": \"HTTP\",\n \"ip_addresses\": [\n   \"10.15.3.183\"\n ],\n \"start_time\": \"2024-02-16T19:46:35.805652\",\n \"end_time\": \"2024-02-16T19:46:35.827025\",\n \"duration\": \"21.372186ms\",\n \"body\": \"API response\",\n \"code\": 200\n}\n</code></pre><p>Follow these steps to migrate all downstream and upstream services into the service mesh without impacting service availability or development teams. </p>\n\n<h4><strong>Step 2: Enforce mTLS</strong></h4>\n\n<p>After migrating all dependent downstream services into the mesh, disable permissive mode and start enforcing secure mTLS connections for all requests to <code>api</code>. To avoid any downstream service changes or disruptions, configure the service mesh to properly handle the original DNS lookups, so <code>web</code> can continue making requests to <code>api.service.consul</code>.</p>\n<img src=\"https://www.datocms-assets.com/2885/1709933195-step2-eks.png\" alt=\"The\" /><p>During this step, switch <code>api</code> from permissive to strict <code>mutualTLSMode</code> to enforce mTLS for all requests. To ensure downstream services, such as <code>web</code>using <code>api.service.consul</code>, aren’t impacted, set the <a href=\"https://developer.hashicorp.com/consul/docs/connect/config-entries/service-defaults#transparentproxy\"><code>dialedDirectly</code></a> transparent proxy mode. This action enables a TCP passthrough on the <code>api</code> service’s Envoy sidecar proxy. This enforces mTLS on requests going to the <code>api</code> pod IP. This means requests for <code>api.service.consul</code> will be routed to the <code>api</code> pod IP where the proxy is now listening and enforcing mTLS. These two settings can be updated while the <code>api</code> service is running.</p>\n\n<p>To enable strict <code>MutualTLSMode</code> and <code>dialedDirectly</code>, update the <code>api</code> <code>ServiceDefaults</code>.</p>\n<pre><code>kubectl apply -f ./api/permissive_mTLS_mode/init-consul-config/intention-api.yaml\nkubectl apply -f ./api/permissive_mTLS_mode/servicedefaults-strict-dialedDirect.yaml.enable</code></pre><p><strong>Note</strong>: Before enabling strict <code>mutualTLSMode</code>, a service intention is created first to ensure <code>web</code> is authorized to make requests to <code>api</code>.</p>\n\n<p>Now all requests to <code>api.service.consul</code> are being encrypted with mTLS:</p>\n<pre><code>kubectl debug -it -n api $(kubectl -n api get pods --output jsonpath='{.items[0].metadata.name}') --target consul-dataplane --image nicolaka/netshoot -- tcpdump -i eth0 src port 9091 -A\n\n\n\nTargeting container \"consul-dataplane\". If you don't see processes from this container it may be because the container runtime doesn't support this feature.\nDefaulting debug container name to debugger-g669d.\nIf you don't see a command prompt, try pressing enter.\n20:18:34.047169 IP api-v2-b45bf7655-9kshs.9091 &gt; 10-15-3-175.web.web.svc.cluster.local.43512: Flags [P.], seq 148:626, ack 3559, win 462, options [nop,nop,TS val 3923183901 ecr 2279397636], length 478\nE....;@....'\n...\n...#.....k.f4m............\n.. ...................6.@nW.S._r\"h....m.@;U....WyY........h........m......q.B.......N.Y}.F.A.{y..^..........]..@0.zv\"&gt;Y#.....6.n.z..Oh.6.p..G.....9...@0.zv.y.......#U.......h.o..w6.....`.\\......*...N..u.\".U...`\\.;....M..=.....$..,....e...T`.I/.a.z.$;...c........z..Y..q...W..\"...........%.*...\n.3..Y/.....a..R(..6..0...Ka`.GIt._.Dn...N......L k..j...ch.7)'......m/........3....t.\"....r..4|t7..Q..vfs.....I..*..|..4m%......c..!w7u..s.......t.,.....EF7....Bd...P..........E....h..3;n..........+.\n</code></pre><p>Congratulations! You have successfully migrated an existing service into the Consul service mesh and enforced mTLS without requiring any changes from development. </p>\n\n<h4><strong>Step 3: Use virtual services</strong></h4>\n\n<p>For development teams to take full advantage of the L7 traffic capabilities such as retries, rate limits, timeouts, circuit breakers, and traffic splitters, they will want to start using <a href=\"https://developer.hashicorp.com/consul/docs/k8s/l7-traffic/route-to-virtual-services\">virtual services</a>. For example, <code>web</code> would stop making requests to <code>api.service.consul</code> and start using <code>api.virtual.consul</code>. </p>\n\n<p>Once <code>web</code> is updated to use the virtual address, it will have immediate access to all L7 traffic routing rules applied to <code>api</code>. These capabilities provide huge improvements in service availability that any development team will appreciate, and they can make this change at their convenience. Here’s how:</p>\n\n<p>Deploy <code>web-v2</code>, which has been updated to use <code>api.virtual.consul</code>. Refresh the browser until you see requests from <code>web-v2</code> route to the new virtual address (you may need to clear the cache). Once validated, delete <code>web-v1</code> to ensure all requests use the new virtual address:</p>\n<pre><code>kubectl apply -f api/permissive_mTLS_mode/web-v2-virtualaddress.yaml.enable\nkubectl -n web delete deploy/web-v1</code></pre><img src=\"https://www.datocms-assets.com/2885/1709933201-step3-service.png\" alt=\"The\" /><p><code>web</code> is now making requests to <code>api.virtual.consul</code>. That means <code>api</code> can now create traffic splitters to support canary deployments, or retries to improve availability, and <code>web</code> will automatically apply them with every request to <code>api</code>. Once all downstream services are using the virtual address, disable <code>dialedDirectly</code> for <code>api</code> to ensure L7 traffic patterns are being applied to all future requests (included in the <code>ServiceDefaults</code> recommendation example below).</p>\n\n<h2>Additional security recommendations</h2>\n\n<p>Following the migration, there are several ways to further secure your service mesh. First, remove the <code>MutualTLSMode</code> line from the service defaults for each service. This will enforce the strict mode and reduce misconfiguration risks for a critical security setting:</p>\n<pre><code>apiVersion: consul.hashicorp.com/v1alpha1\nkind: ServiceDefaults\nmetadata:\n  name: api\n  namespace: api\nspec:\n  protocol: http\n  #mutualTLSMode: \"strict\"\n  transparentProxy: \n    #dialedDirectly: true</code></pre><p>Next, disable the <code>EnablingPermissiveMutualTLS</code> mode mesh-wide so no services can enable permissive mode in the future and bypass mTLS.  </p>\n\n<p><strong>Note</strong>: If services were already able to set their <code>MutualTLSMode=permissive</code>, this mesh-wide setting will not override those services already running in permissive mode because  doing so could impact service availability. Those services must first remove permissive <code>MutualTLSMode</code>, as recommended above:</p>\n<pre><code>apiVersion: consul.hashicorp.com/v1alpha1\nkind: Mesh\nmetadata:\n  name: mesh\n  namespace: consul\nspec:\n  #allowEnablingPermissiveMutualTLS: true</code></pre><p>Additionally, secure the mesh by setting <code>meshDestinationsOnly: true</code> to restrict any service from making external requests. A terminating gateway would now be required to authorize all external requests:</p>\n<pre><code>apiVersion: consul.hashicorp.com/v1alpha1\nkind: Mesh\nmetadata:\n  name: mesh\n  namespace: consul\nspec:\n  #allowEnablingPermissiveMutualTLS: true\n  transparentProxy:\n    meshDestinationsOnly: true</code></pre><p>Apply these additional security recommendations using the following commands:</p>\n<pre><code>kubectl apply -f api/permissive_mTLS_mode/init-consul-config/servicedefaults-std.yaml.enable\nkubectl apply -f web/init-consul-config/mesh-secure.yaml.enable</code></pre><h2>Recap</h2>\n\n<p>Transitioning from Consul service discovery to service mesh brings immediate enhancements in zero trust security and observability. By following the three-step approach described in this blog post, platform teams can smoothly transition to service mesh without modifying current application configurations. This approach benefits organizations that have numerous development teams, operate in silos, or face communication hurdles. </p>\n\n<p>Initially, enabling permissive <code>MutualTLSMode</code> allows services to support both HTTP and mTLS connections, ensuring accessibility across mesh and non-mesh services. Subsequently, enforcing mTLS secures all traffic with encryption, and setting <code>dialedDirectly</code> supports all existing requests using Consul DNS. Finally, adopting virtual services unlocks advanced Layer 7 traffic-management features, allowing developers to enhance service reliability at their own pace by simply updating request strings from <code>service</code> to <code>virtual</code>. </p>\n\n<p>As your service mesh and multi-tenant ecosystem grow, you might encounter increasing demands for self-service options and higher compliance standards. Learn how <a href=\"https://developer.hashicorp.com/consul/docs/enterprise\">Consul Enterprise</a> extends the foundational capabilities of Consul with enhanced governance, multi-tenant support, and operational agility, ensuring organizations can meet the demands of complex service ecosystems and regulatory standards with ease. </p>\n","author":"Patrick Presto","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"fc65371fc661896e16801408dc0624727f961729c45e74ca1560b4fdda5513d8","category":"Tech"}