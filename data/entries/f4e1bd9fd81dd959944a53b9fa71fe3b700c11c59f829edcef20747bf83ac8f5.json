{"title":"Refactoring CSS: Strategy, Regression Testing And Maintenance (Part 2)","link":"https://smashingmagazine.com/2021/08/refactoring-css-strategy-regression-testing-maintenance-part2/","date":1627902000000,"content":"<p>In <a href=\"https://www.smashingmagazine.com/2021/07/refactoring-css-introduction-part1/\">Part 1</a>, we’ve covered the side effects of low-quality CSS codebase on end-users, development teams, and management. Maintaining, extending, and working with the low-quality codebase is difficult and often requires additional time and resources. Before bringing up the refactoring proposal to the management and stakeholders, it can be useful to back up the suggestion with some hard data about the <strong>codebase health</strong> — not only to convince the management department, but also have a measurable goal for the refactoring process.</p>\n<p>Let’s assume that management has approved the CSS refactoring project. The development team has analyzed and pinpointed the weaknesses in the CSS codebase and has set target goals for the refactor (file size, specificity, color definitions, and so on). In this article, we’ll take a deep dive into the refactoring process itself, and cover incremental refactoring strategy, visual regression testing, and maintaining the refactored codebase.</p>\nPreparation And Planning\n<p>Before starting the refactoring process, the team needs to go over the codebase issues <a href=\"https://www.smashingmagazine.com/2021/07/refactoring-css-introduction-part1/#auditing-css-codebase-health\">and</a> <a href=\"https://www.smashingmagazine.com/2021/07/refactoring-css-introduction-part1/#auditing-css-codebase-health\">CSS health audit data</a> (CSS file size, selector complexity, duplicated properties, and declarations, etc.) and discuss individual issues about how to approach them and what challenges to expect. These issues and challenges are specific to the codebase and can make the refactoring process or testing difficult. As concluded in the <a href=\"https://www.smashingmagazine.com/2021/07/refactoring-css-introduction-part1/\">previous article</a>, it’s important to establish internal rules and codebase standards and keep them documented to make sure that the team is on the same page and has a more <strong>unified and standardized approach to refactoring</strong>.</p>\n<p>The team also needs to outline the individual refactoring tasks and set the deadlines for completing the refactoring project, taking into account current tasks and making sure that refactoring project doesn’t prevent the team from addressing urgent tasks or working on planned features. Before estimating the time duration and workload of the refactoring project, the team needs to consult with the management about the short-term plans and adjust their estimates and workload based on the planned features and regular maintenance procedures.</p>\n<p>Unlike regular features and bug fixes, the refactoring process yields little to no visible and measurable changes on the front end, and management cannot keep track of the progress on their own. It’s important to establish <strong>transparent communication</strong> to keep the management and other project stakeholders updated on the refactoring progress and results. Online collaborative workspace tools like <a href=\"https://miro.com/\">Miro</a> or <a href=\"https://www.mural.co/\">MURAL</a> can also be used for effective communication and collaboration between the team members and management, as well as a quick and simple task management tool.</p>\n<p>Christoph Reinartz pointed out the importance of transparency and clear communication while the <a href=\"https://tech.trivago.com/2016/02/02/large-scale-css-refactoring-at-trivago/\">team at trivago</a> was working on the CSS refactoring project.</p>\n<blockquote>“Communication and clearly making the progress and any upcoming issues visible to the whole company were our only weapon. We decided to build up a very simple Kanban board, established a project stand-up and a project Slack channel, and kept management and the company up-to-date via our internal social cast network.”</blockquote>\n\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/0cd05d84-1be6-4da6-9115-692cbcbadddc/1-refactoring-css-strategy-regression-testing-maintenance-part2.png\" /></p>\n<p>The most crucial element of planning the refactoring process is to keep the CSS refactoring task scope as small as possible. This makes the tasks more manageable, and easier to test and integrate.</p>\n<p>Harry Roberts refers to these tasks as “<a href=\"https://csswizardry.com/2017/06/refactoring-tunnels/\">refactoring tunnels</a>”. For example, refactoring the entire codebase to follow the BEM methodology all at once can yield a massive improvement to the codebase and the development process. This might seem like a simple search-and-replace task at first. However, this task affects all elements on every page (high scope) and the team cannot “see the light at the end of the tunnel” right away; a lot of things can break in the process and unexpected issues can slow down the progress and <strong>no one can tell when the task is going to be finished</strong>. The team can spend days or weeks working on it and risk hitting a wall, accumulate additional technical debt, or making the codebase even less healthy. The team ends up either giving up on the task of starting over, wasting time and resources in the process.</p>\n<p>By contrast, improving just the navigation component CSS is a smaller scope task and is much more manageable and doable. It is also easier to test and verify. This task can be done in a few days. Even with potential issues and challenges that slow down the task, there is a high chance of success. The team can always “see the end of the tunnel” while they’re working on the task because they know the task will be completed once the component has been refactored and all issues related to the component have been fixed.</p>\n<p>Finally, the team needs to agree on the refactoring strategy and regression testing method. This is where the refactoring process gets challenging — refactoring should be as streamlined as possible and shouldn’t introduce any regressions or bugs. </p>\n<p>Let’s dive into one of the <strong>most effective CSS refactoring strategies</strong> and see how we can use it to improve the codebase quickly and effectively.</p>\nIncremental Refactoring Strategy\n<p>Refactoring is a challenging process that is much more complex than simply deleting the legacy code and replacing it with the refactored code. There is also the matter of integrating the refactored codebase with the legacy codebase and avoiding regressions, accidental code deletions, preventing stylesheet conflicts, etc. To avoid these issues, I would recommend using an incremental (or granular) refactoring strategy.</p>\n<p>In my opinion, this is one of the safest, most logical, and most recommended CSS refactoring strategies I’ve come across so far. Harry Roberts has <a href=\"https://www.youtube.com/watch?v=fvTryZjGyg8\">outlined this strategy</a> in 2017. and it has been my personal go-to CSS refactoring strategy since I first heard about it.</p>\n<p>Let’s go over this strategy step by step.</p>\n<h3>Step 1: Pick A Component And Develop It In Isolation</h3>\n<p>This strategy relies on individual tasks having low scope, meaning that we should refactor the project component by component. It’s recommended to start with low-scope tasks (individual components) and then move onto higher-scoped tasks (global styles).</p>\n<p>Depending on the project structure and CSS selectors, individual component styles consist of a combination of component (class) styles and global (wide-ranging element) styles. Both component styles and global styles can be the source of the codebase issues and might need to be refactored. </p>\n<p>Let’s take a look at the <strong>more common CSS codebase issues</strong> which can affect a single component. Component (class) selectors might be too complex, difficult to reuse, or can have high specificity and enforce the specific markup or structure. Global (element) selectors might be greedy and leak unwanted styles into multiple components which need to be undone with high-specificity component selectors.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7b5a165e-537a-4554-819e-6b9e47ae134d/3-refactoring-css-strategy-regression-testing-maintenance-part2.jpg\" /></p>\n<p>After choosing a component to refactor (a lower-scoped task), we need to develop it in an isolated environment away from the legacy code, its weaknesses, and conflicting selectors. This is also a good opportunity to improve the HTML markup, remove unnecessary nestings, use better CSS class names, use ARIA attributes, etc. </p>\n<p>You don’t have to go out of your way to set up a whole build system for this, you can even use <a href=\"https://codepen.io/\">CodePen</a> to rebuild the individual components. To avoid conflicts with the legacy class names and to separate the refactored code from the legacy code more clearly, we’ll use an <code>rf-</code> prefix on CSS class name selectors.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/af7ed03e-4d73-47ec-91a4-95294d593239/4-refactoring-css-strategy-regression-testing-maintenance-part2.jpg\" /></p>\n<h3>Step 2: Merge With The Legacy Codebase And Fix Bugs</h3>\n<p>Once we’ve finished rebuilding the component in an isolated environment, we need to replace the legacy HTML markup with refactored markup (new HTML structure, class names, attributes, etc.) and add the refactored component CSS alongside the legacy CSS.</p>\n<p>We don’t want to act too hastily and remove legacy styles right away. By making too many changes simultaneously, we’ll lose track of the issues that might happen due to the conflicting codebases and multiple changes. For now, let’s replace the markup and add refactored CSS to the existing codebase and see what happens. Keep in mind that refactored CSS should have the <code>.rf-</code> prefix in their class names to prevent conflicts with the legacy codebase.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8896e361-f959-4004-b007-cec12612efaf/5-refactoring-css-strategy-regression-testing-maintenance-part2.jpg\" /></p>\n<p>Legacy component CSS and global styles can cause unexpected side-effects and leak unwanted styles into the refactored component. Refactored codebase might be missing the faulty CSS which was required to undo these side-effects. Due to those styles having a wider reach and possibly affecting other components, we cannot simply edit the problematic code directly. We need to use a different approach to tackle these conflicts.</p>\n<p>We need to create a separate CSS file, which we can name <code>overrides.css</code> or <code>defend.css</code> which will contain hacky, high-specificity code that combats the unwanted leaked styles from the legacy codebase.</p>\n<p><code>overrides.css</code> which will contain high-specificity selectors which make sure that the refactored codebase works with the legacy codebase. This is only a temporary file and it will be removed once the legacy code is deleted. For now, add the high-specificity style overrides to unset the styles applied by legacy styles and test if everything is working as expected.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/3d821412-5eea-4ccd-a969-84b91b99d5bf/6-refactoring-css-strategy-regression-testing-maintenance-part2.jpg\" /></p>\n<p>If you notice any issues, check if the refactored component is missing any styles by going back to the isolated environment or if any other styles are leaking into the component and need to be overridden. If the component looks and works as expected after adding these overrides, remove the legacy code for the refactored component and check if any issues happen. Remove related hacky code from <code>overrides.css</code> and test again. </p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ce07ddae-979c-4d8d-9e00-7825cb52613f/7-refactoring-css-strategy-regression-testing-maintenance-part2.jpg\" /></p>\n<p>Depending on the case, you probably won’t be able to remove every override right away. For example, if the issue lies within a global element selector which leaks styles into other components that also need to be refactored. For those cases, we won’t risk expanding the scope of the task and the pull request but rather <strong>wait until all components have been refactored</strong> and tackle the high-scope tasks after we’ve removed the same style dependency from all other components.</p>\n<p>In a way, you can treat the <code>overrides.css</code> file as your makeshift TODO list for refactoring greedy and wide-reaching element selectors. You should also consider updating the task board to include the newly uncovered issues. Make sure to add useful comments in the <code>overrides.css</code> file so other team members are on the same page and instantly know why the override has been applied and in response to which selector.</p>\n<pre><code>/* overrides.css */\n/* Resets dimensions enforced by \".sidebar &gt; div\" in \"sidebar.css\" */\n.sidebar &gt; .card {\n  min-width: 0;\n}\n\n/* Resets font size enforced by \".hero-container\" in \"hero.css\"*/\n.card {\n  font-size: 18px;\n}\n</code></pre>\n\n<h3>Step 3: Test, Merge And Repeat</h3>\n<p>Once the refactored component has been successfully integrated with the legacy codebase, create a Pull Request and run an automated visual regression test to catch any issues that might have gone unnoticed and fix them before merging them into one of the main git branches. Visual regression testing can be treated as the last line of defense before merging the individual pull requests. We’ll cover visual regression testing in more detail in one of the upcoming sections of this article.</p>\n<p>Now rinse and repeat these three steps until the codebase has been refactored and <code>overrides.css</code> is empty and can be safely removed.</p>\n<h3>Step 4: Moving From Components To Global Styles</h3>\n<p>Let’s assume that we have refactored all individual low-scoped components and all that is left in the <code>overrides.css</code> file are related to global wide-reaching element selectors. This is a very realistic case, speaking from the experience, as many CSS issues are caused by wide-reaching element selectors leaking styles into multiple components.</p>\n<p>By tackling the individual components first and shielding them from the global CSS side-effects using <code>overrides.css</code> file, we’ve made these higher-scoped tasks much more manageable and less risky to do. We can move onto refactoring global CSS styles more safely than before and remove duplicated styles from the individual components and replacing them with general element styles and utilities — buttons, links, images, containers, inputs, grids, and so on. By doing so, we’re going to incrementally remove the code from our makeshift TODO <code>overrides.css</code> file and duplicated code repeated in multiple components.</p>\n<p>Let’s apply the same three steps of the incremental refactoring strategy, starting by developing and testing the styles in isolation.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/9ef08ea8-4d4c-4238-be9b-e21b2fe5a70e/8-refactoring-css-strategy-regression-testing-maintenance-part2.jpg\" /></p>\n<p>Next, we need to add the refactored global styles to the codebase. We might encounter the same issues when merging the two codebases and we can add the necessary overrides in the <code>overrides.css</code>. However, this time, we can expect that as we are gradually removing legacy styles, we will also be able to gradually remove overrides that we’ve introduced to combat those unwanted side-effects.</p>\n<p>The <strong>downside of developing components in isolation</strong> can be found in element styles that are shared between multiple components — style guide elements like buttons, inputs, headings, and so on. When developing these in isolation from the legacy codebase, we don’t have access to the legacy style guide. Additionally, we don’t want to create those dependencies between the legacy codebase and refactored codebase.</p>\n<p>That is why it’s easier to remove the duplicated code blocks and move these styles into separate, more general style guide components and selectors later on. It allows us to address these changes right at the end and with the lower risk as we are working with a much healthier and consistent codebase, instead of the messy, inconsistent, and buggy legacy codebase. Of course, any unintended side-effects and bugs can still happen and these should be caught with the visual regression testing tools which we’ll cover in one of the following sections of the article.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/1e87fa4c-2750-49c8-94db-7fdf06298e1f/9-refactoring-css-strategy-regression-testing-maintenance-part2.jpg\" /></p>\n<p>When the codebase has been completely refactored and we’ve removed all makeshift TODO items from the <code>overrides.css</code> file, we can safely remove it and we are left with the refactored and improved CSS codebase.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/bed7a19f-1d3c-4f29-bfad-285eb3f42184/10-refactoring-css-strategy-regression-testing-maintenance-part2.jpg\" /></p>\nIncremental CSS Refactoring Example\n<p>Let’s use the incremental refactoring strategy to refactor a simple page that consists of a title element and two card components in a grid component. Each card element consists of an image, title, subtitle, description, and a button and is placed in a 2-column grid with horizontal and vertical spacing.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/3646bf6c-a2be-4be3-b7cc-335a27894924/11-refactoring-css-strategy-regression-testing-maintenance-part2.png\" /></p>\n<p>Depending on the project, testing tools don’t need to be complex or sophisticated to be effective. While working on <a href=\"https://www.kirbyyardley.com/work/sundance-design-system\">refactoring the Sundance Institute’s</a> CSS codebase, the development team used a simple static style guide page generated by Jekyll to test the refactored components.</p>\n<blockquote>“One unintended consequence of executing the refactor in abstraction on a Jekyll instance was that we could now publish it to Github pages as a <a href=\"https://sundance-org.github.io/styles/cards/\">living style guide</a>. This has become an invaluable resource for our dev team and for external vendors to reference.”</blockquote>\n\n<p>Once the CSS refactor tasks have been completed and the refactored code is ready for production, the team can also consider doing an <strong>A/B test to check the effect of the refactored codebase on users</strong>. For example, if the goal of the refactoring process was to reduce the overall CSS file size, the A/B test can potentially yield significant improvements for mobile users, and these results can also be beneficial to project stakeholders and management. That’s exactly how the <a href=\"https://tech.trivago.com/2016/02/02/large-scale-css-refactoring-at-trivago/\">team at Trivago</a> approached the deployment of their large-scale refactoring project.</p>\n<blockquote>“(…) we were able to release the technical migration as an A/B Test. We tested the migration for one week, with positive results on mobile devices where mobile-first paid out and accepted the migration after only four weeks.”</blockquote>\n\nKeeping Track Of Refactoring Progress\n<p>Kanban board, GitHub issues, GitHub project board, and standard project management tools can do a great job of keeping track of the refactoring progress. However, depending on the tools and how the project is organized, it may be difficult to estimate the progress on a per-page basis or do a quick check on which components need to be refactored.</p>\n<p>This is where our <code>.rf</code>-prefixed CSS classes come in. Harry Roberts has talked about the <a href=\"https://www.youtube.com/watch?v=fvTryZjGyg8\">benefits of using the prefix</a> in detail. The bottom line is — not only do these classes allow developers to <strong>clearly separate the refactored CSS codebase from the legacy codebase</strong>, but also to quickly show the progress to the project managers and other project stakeholders on a per-page basis.</p>\n<p>For example, management may decide to test the effects of the refactored codebase early by deploying only the refactored homepage code and they would want to know when the homepage components will be refactored and ready for A/B testing.</p>\n<p>Instead of wasting some time comparing the homepage components with the available tasks on the Kanban board, developers can just temporarily add the following styles to highlight the refactored components which have the <code>rf-</code> prefix in their class names, and the components that need to be refactored. That way, they can reorganize the tasks and prioritize refactoring homepage components.</p>\n<pre><code>/* Highlights all refactored components */\n[class*=\"rf-\"] {\n  outline: 5px solid green;\n}\n\n/* Highlights all components that havent been refactored */\n[class]:not([class*=\"rf-\"]),\nbody *:not([class]) {\n  outline: 5px solid red;\n}</code></pre>\n\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/0eb881b0-0e6c-4cda-8216-725e8948fb29/13-refactoring-css-strategy-regression-testing-maintenance-part2.png\" /></p>\nMaintaining The Refactored Codebase\n<p>After the refactoring project has been completed, the team needs to make sure to maintain the codebase health for the foreseeable future — new features will be developed, some new features might even be rushed and produce technical debt, various bugfixes will also be developed, etc. All in all, the development team needs to make sure that the codebase health remains stable as long as they’re in charge of the codebase.</p>\n<p>Technical debt which can result in potentially faulty CSS code should be isolated, documented, and implemented in a <a href=\"https://csswizardry.com/2013/04/shame-css/\">separate CSS file</a> which is often named as <code>shame.css</code>.</p>\n<p><strong>It’s important to document the rules and best practices</strong> that were established and applied during the refactoring projects. Having those rules in writing allows for standardized code reviews, faster project onboarding for new team members, easier project handoff, etc.</p>\n<p>Some of the rules and best practices can also be enforced and documented with automated code-checking tools like <a href=\"https://stylelint.io/\">stylelint</a>. Andrey Sitnik, the author of widely-used CSS development tools like PostCSS and Autoprefixer, has noted how automatic linting tools can make code reviews and onboarding <a href=\"https://evilmartians.com/chronicles/five-years-of-postcss-state-of-the-union\">easier and less stressful</a>.</p>\n<blockquote>“However, automatic linting is not the only reason to adopt Stylelint in your project. It can be extremely helpful for onboarding new developers on the team: a lot of time (and nerves!) are wasted on code reviews until junior developers are fully aware of accepted code standards and best practices. Stylelint can make this process much less stressful for everyone.”</blockquote>\n\n<p>Additionally, the team can create a <a href=\"https://docs.github.com/en/communities/using-templates-to-encourage-useful-issues-and-pull-requests/creating-a-pull-request-template-for-your-repository\">Pull Request template</a> and include the checklist of standards and best practices and a link to the project code rules document so that the developers making the Pull Request can check the code themselves and make sure that it follows the agreed standards and best practices.</p>\nConclusion\n<p>Incremental refactoring strategy is one of the safest and most recommended approaches when it comes to refactoring CSS. The development team needs to refactor the codebase component by component to ensure that the tasks have a low scope and are manageable. Individual components need to be then developed in isolation — away from the faulty code — and then merged with the existing codebase. The issues that may come up from the conflicting codebases can be solved by adding a temporary CSS file that contains all the necessary overrides to <strong>remove the conflicts in CSS styles</strong>. After that, legacy code for the target component can be removed and the process continues until all components have been refactored and until the temporary CSS file which contains the overrides is empty.</p>\n<p>Visual regression testing tools like Percy and Chromatic can be used for testing and to detect any regressions and unwanted changes on the Pull Request level, so developers can fix these issues before the refactored code is deployed to the live site.</p>\n<p>Developers can use A/B testing and use monitoring tools to make sure that the refactoring doesn’t negatively affect performance and user experience before finally launching the refactored project on a live site. Developers will also need to ensure that the agreed standards and best practices are used on the project continues to maintain the codebase health and quality in the future.</p>\n<h3>References</h3>\n<ul>\n<li>“<a href=\"https://www.youtube.com/watch?v=fvTryZjGyg8\">Refactoring CSS Without Losing Your Mind</a>,” Harry Roberts (Video, WeAreDevelopers Conference, 2017)</li>\n<li>“<a href=\"https://tech.trivago.com/2016/02/02/large-scale-css-refactoring-at-trivago/\">Large Scale CSS Refactoring At Trivago</a>,” Christoph Reinartz</li>\n<li>“<a href=\"https://csswizardry.com/2017/06/refactoring-tunnels/\">Refactoring Tunnels</a>,” Harry Roberts</li>\n<li>“<a href=\"https://www.kirbyyardley.com/work/sundance-design-system\">Sundance.org Design System And CSS Refactor</a>,” Kirby Yardley</li>\n<li>“<a href=\"https://evilmartians.com/chronicles/five-years-of-postcss-state-of-the-union\">Five Years Of PostCSS: State Of The Union</a>,” Andrey Sitnik</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"f4e1bd9fd81dd959944a53b9fa71fe3b700c11c59f829edcef20747bf83ac8f5","category":"Tech"}