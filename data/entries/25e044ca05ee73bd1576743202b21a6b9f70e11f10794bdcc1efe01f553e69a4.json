{"title":"A New Set of APIs for Amazon SQS Dead-Letter Queue Redrive","link":"https://aws.amazon.com/blogs/aws/a-new-set-of-apis-for-amazon-sqs-dead-letter-queue-redrive/","date":1686239495000,"content":"<p>Today, we launch a new set of APIs for <a href=\"https://aws.amazon.com/sqs/\">Amazon Simple Queue Service (Amazon SQS)</a>. These new APIs allow you to manage <a href=\"https://aws.amazon.com/what-is/dead-letter-queue/\">dead-letter queue</a> (DLQ) redrive programmatically. You can now use the <a href=\"https://aws.amazon.com/tools/\">AWS SDKs</a> or the <a href=\"https://aws.amazon.com/cli/\">AWS Command Line Interface (AWS CLI)</a> to programmatically move messages from the DLQ to their original queue, or to a custom queue destination, to attempt to process them again. A DLQ is a queue where Amazon SQS automatically moves messages that are not correctly processed by your consumer application.</p> \n<p>To fully appreciate how this new API might help you, let’s have a quick look back at history.</p> \n<p><a href=\"https://en.wikipedia.org/wiki/Message_queue\">Message queues</a> are an integral part of modern application architectures. They allow developers to decouple services by allowing asynchronous and message-based communications between message producers and consumers. In most systems, messages are persisted in shared storage (the queue) until the consumer processes them. Message queues allow developers to build applications that are resilient to temporary service failure. They help prioritize message processing and scale their fleet of worker nodes that process the messages. Message queues are also popular in event-driven architectures.</p> \n<p>Asynchronous message exchange is not new in application architectures. The concept of exchanging messages asynchronously between applications appeared in the 1960s and was first made popular when <a href=\"https://en.wikipedia.org/wiki/Telecommunications_Access_Method\">IBM launched TCAM for OS/360 in 1972</a>. The general adoption came 20 years later with <a href=\"https://en.wikipedia.org/wiki/IBM_MQ\">IBM MQ Series in 1993</a> (now IBM MQ) and when <a href=\"https://en.wikipedia.org/wiki/Jakarta_Messaging\">Sun Microsystems released Java Messaging Service (JMS) in 1998</a>, a standard API for Java applications to interact with message queues.</p> \n<p>AWS launched <a href=\"https://aws.amazon.com/sqs/\">Amazon SQS</a> on <a href=\"https://www.allthingsdistributed.com/2006/07/your_queues_are_ready.html\">July 12, 2006</a>. Amazon SQS is a highly scalable, reliable, and elastic queuing service that “just works.” <a href=\"https://www.allthingsdistributed.com/2006/07/your_queues_are_ready.html\">As Werner wrote at the time</a>: “<em>We have chosen a concurrency model where the process working on a message automatically acquires a leased lock on that message; if the message is not deleted before the lease expires, it becomes available for processing again. Makes failure handling very simple.</em>”</p> \n<p>On January 29, 2014, <a href=\"https://aws.amazon.com/fr/blogs/aws/amazon-sqs-new-dead-letter-queue/\">we introduced dead-letter queues (DLQ)</a>. DLQs help you avoid a message that failed to be processed from staying forever on top of the queue, possibly preventing other messages in the queue from processing. With DLQs, each queue has an associated property telling Amazon SQS how many times a message may be presented for processing (<code>maxReceiveCount</code>). Each message also has an associated receive counter (<code>ReceiveCount</code>). Each time a consumer application picks up a message for processing, the message receive count is incremented by 1. When <code>ReceiveCount</code> &gt; <code>maxReceiveCount</code>, Amazon SQS moves the message to your designated DLQ for human analysis and debugging. You generally associate alarms with the DLQ to send notifications when such events happen. Typical reasons to move a message to the DLQ are because they are incorrectly formatted, there are bugs in the consumer application, or it takes too long to process the message.</p> \n<p>At AWS re:Invent 2021, <a href=\"https://aws.amazon.com/fr/blogs/compute/introducing-amazon-simple-queue-service-dead-letter-queue-redrive-to-source-queues/\">AWS announced dead-letter queue redrive on the Amazon SQS console</a>. The redrive addresses the second part of the failed message lifecycle. It allows you to reinject the message in its original queue to attempt processing it again. After the consumer application is fixed and ready to consume the failed messages, you can redrive the messages from the DLQ back in the source queue or a customized queue destination. It just requires a couple of clicks on the console.</p> \n<p>Today, we are adding APIs allowing you to write applications and scripts that handle the redrive programmatically. There is no longer a need to have a human clicking on the console. Using the API increases the scalability of your processes and reduces the risk of human error.</p> \n<p><span><strong>Let’s See It in Action<br /> </strong></span>To try out this new API, I open a terminal for a command-line only demo. Before I get started, I make sure <a href=\"https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html\">I have the latest version of the AWS CLI</a>. On macOS I enter <code>brew upgrade awscli</code>.</p> \n<p>I first create two queues. One is the dead-letter queue, and the other is my application queue:</p> \n<pre><code># First, I create the dead-letter queue (notice the -dlq I choose to add at the end of the queue name)\n➜ ~ aws sqs create-queue \\\n            --queue-name awsnewsblog-dlq                                            \n{\n    \"QueueUrl\": \"https://sqs.us-east-2.amazonaws.com/012345678900/awsnewsblog-dlq\"\n}\n\n# second, I retrieve the Arn of the queue I just created\n➜  ~ aws sqs get-queue-attributes \\\n             --queue-url https://sqs.us-east-2.amazonaws.com/012345678900/awsnewsblog-dlq \\\n             --attribute-names QueueArn\n{\n    \"Attributes\": {\n        \"QueueArn\": \"arn:aws:sqs:us-east-2:012345678900:awsnewsblog-dlq\"\n    }\n}\n\n# Third, I create the application queue. I enter a redrive policy: post messages in the DLQ after three delivery attempts\n➜  ~ aws sqs create-queue \\\n             --queue-name awsnewsblog \\\n             --attributes '{\"RedrivePolicy\": \"{\\\"deadLetterTargetArn\\\":\\\"arn:aws:sqs:us-east-2:012345678900:awsnewsblog-dlq\\\",\\\"maxReceiveCount\\\":\\\"3\\\"}\"}' \n{\n    \"QueueUrl\": \"https://sqs.us-east-2.amazonaws.com/012345678900/awsnewsblog\"\n}</code></pre> \n<p>Now that the two queues are ready, I post a message to the application queue:</p> \n<pre><code>➜ ~ aws sqs send-message \\\n            --queue-url https://sqs.us-east-2.amazonaws.com/012345678900/awsnewsblog \\\n            --message-body \"Hello World\"\n{\n\"MD5OfMessageBody\": \"b10a8db164e0754105b7a99be72e3fe5\",\n\"MessageId\": \"fdc26778-ce9a-4782-9e33-ae73877cfcb2\"\n}</code></pre> \n<p>Next, I consume the message, but I don’t delete it from the queue. This simulates a crash in the message consumer application. Message consumers are supposed to delete the message after successful processing. I set the <code>maxReceivedCount</code> property to 3 when I entered the <code>redrivePolicy</code>. I therefore repeat this operation three times to force Amazon SQS to move the message to the dead-letter queue after three delivery attempts. The <a href=\"https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-visibility-timeout.html\">default visibility timeout is 30 seconds</a>, so I have to wait 30 seconds or more between the retries.</p> \n<pre><code>➜ ~ aws sqs receive-message \\\n            --queue-url https://sqs.us-east-2.amazonaws.com/012345678900/awsnewsblog\n{\n\"Messages\": [\n{\n\"MessageId\": \"fdc26778-ce9a-4782-9e33-ae73877cfcb2\",\n\"ReceiptHandle\": \"AQEBP8yOfgBlnjlkGXjyeLROiY7xg7cZ6Znq8Aoa0d3Ar4uvTLPrHZptNotNfKRK25xm+IU8ebD3kDwZ9lja6JYs/t1kBlwiNO6TBACN5srAb/WggQiAAkYl045Tx3CvsOypbJA3y8U+MyEOQRwIz6G85i7MnR8RgKTlhOzOZOVACXC4W8J9GADaQquFaS1wVeM9VDsOxds1hDZLL0j33PIAkIrG016LOQ4sAntH0DOlEKIWZjvZIQGdlRJS65PJu+I/Ka1UPHGiFt9f8m3SR+Y34/ttRWpQANlXQi5ByA47N8UfcpFXXB5L30cUmoDtKucPewsJNG2zRCteR0bQczMMAmOPujsKq70UGOT8X2gEv2LfhlY7+5n8z3yew8sdBjWhVSegrgj6Yzwoc4kXiMddMg==\",\n\"MD5OfBody\": \"b10a8db164e0754105b7a99be72e3fe5\",\n\"Body\": \"Hello World\"\n}\n]\n}\n\n# wait 30 seconds,\n# then repeat two times (for a total of three receive-message API calls)</code></pre> \n<p>After three processing attempts, the message is not in the queue anymore:</p> \n<pre><code>➜  ~ aws sqs receive-message \\\n             --queue-url  https://sqs.us-east-2.amazonaws.com/012345678900/awsnewsblog\n{\n    \"Messages\": []\n}</code></pre> \n<p>The message has been moved to the dead-letter queue. I check the DLQ to confirm (notice the queue URL ending with <code>-dlq</code>):</p> \n<pre><code>➜  ~ aws sqs receive-message \\\n             --queue-url  https://sqs.us-east-2.amazonaws.com/012345678900/awsnewsblog-dlq\n{\n    \"Messages\": [\n        {\n            \"MessageId\": \"fdc26778-ce9a-4782-9e33-ae73877cfcb2\",\n            \"ReceiptHandle\": \"AQEBCLtBMoZYVMMq7fUGNHeCliqE3mFXnkuJ+nOXLK1++uoXWBG31nDejCpxElmiBZWfbcfGJrEdKj4P9HJdrQMYDbeSqB+u1ZlB7CYzQBiQps4SEG0biEoubwqjQbmDZlPrmkFsnYgLD98D1XYWk/Ik6Z2n/wxDo9ko9rbZ15izK5RFnbwveNy8dfc6ireqVB1EGbeGkHcweHGuoeKWXEab1ynZWhNqZsQgCR6pWRkgtn59lJcLv4cJ4UMewNzvt7tMHH69GvVjXdYDYvJJI2vj+6RHvcvSHWWhTNT+CuPEXguVNuNrSya8gho1fCnKpVwQre6HhMlLPjY4wvn/tXY7+5rmte9eXagCqLQXaENB2R7qWNVPiWRIJy8/cTf37NLYVzBom030DNJlH9EeceRhCQ==\",\n            \"MD5OfBody\": \"b10a8db164e0754105b7a99be72e3fe5\",\n            \"Body\": \"Hello World\"\n        }\n    ]\n}</code></pre> \n<p>Now that the setup is ready, let’s programmatically redrive the message to its original queue. Let’s assume I understand why the consumer didn’t correctly process the message and that I fixed the consumer application code. I use <code>start-message-move-task</code> on the DLQ to start the asynchronous redrive. There is an optional attribute (<code>MaxNumberOfMessagesPerSecond</code>) to control the velocity of the redrive:</p> \n<pre><code>➜ ~ aws sqs start-message-move-task \\\n            --source-arn arn:aws:sqs:us-east-2:012345678900:awsnewsblog-dlq\n{\n    \"TaskHandle\": \"eyJ0YXNrSWQiOiI4ZGJmNjBiMy00MmUwLTQzYTYtYjg4Zi1iMTZjYWRjY2FkNmEiLCJzb3VyY2VBcm4iOiJhcm46YXdzOnNxczp1cy1lYXN0LTI6NDg2NjUyMDY2NjkzOmF3c25ld3NibG9nLWRscSJ9\"\n}\n\n</code></pre> \n<p>I can list and check status the of the move tasks I initiated with <code>list-message-move-tasks</code> or cancel a running task by calling the <code>cancel-message-move-task</code> API:</p> \n<pre><code>➜ ~ aws sqs list-message-move-tasks \\\n            --source-arn arn:aws:sqs:us-east-2:012345678900:awsnewsblog-dlq\n{\n    \"Results\": [\n        {\n            \"Status\": \"COMPLETED\",\n            \"SourceArn\": \"arn:aws:sqs:us-east-2:012345678900:awsnewsblog-dlq\",\n            \"ApproximateNumberOfMessagesMoved\": 1,\n            \"ApproximateNumberOfMessagesToMove\": 1,\n            \"StartedTimestamp\": 1684135792239\n        }\n    ]\n}</code></pre> \n<p>Now my application can consume the message again from the application queue:</p> \n<pre><code>➜  ~ aws sqs receive-message \\\n             --queue-url  https://sqs.us-east-2.amazonaws.com/012345678900/awsnewsblog                                   \n{\n    \"Messages\": [\n        {\n            \"MessageId\": \"a7ae83ca-cde4-48bf-b822-3d4bc1f4dcae\",\n            \"ReceiptHandle\": \"AQEB9a+Dm2nvb3VUn9+46j9UsDidU/W6qFwJtXtNWTyfoSDOKT7h73e6ctT9RVZysEw3qqzJOx1cxblTTOSrYwwwoBA2qoJMGsqsrsRGGYojBvf9X8hqi8B8MHn9rTm8diJ2wT2b7WC+TDrx3zIvUeiSEkP+EhqyYOvOs7Q9aETR+Uz02kQxZ/cUJWsN4MMSXBejwW+c5ivv5uQtpfUrfZuCWa9B9O67Kj/q52clriPHpcqCCfJwFBSZkGTXYwTpnjxD4QM7DPS+xVeVfTyM7DsKCAOtpvFBmX5m4UNKT6TROgCnGxTRglUSMWQp8ufVxXiaUyM1dwqxYekM9uX/RCb01gEyCZHas4jeNRV5nUJlhBkkqPlw3i6w9Uuc2y9nH0Df8nH3g7KTXo4lv5Bl3ayh9w==\",\n            \"MD5OfBody\": \"b10a8db164e0754105b7a99be72e3fe5\",\n            \"Body\": \"Hello World\"\n        }\n    ]\n}</code></pre> \n<p><strong><span>Availability</span><br /> </strong>DLQ redrive APIs are available today <a href=\"https://docs.aws.amazon.com/general/latest/gr/sqs-service.html\">in all commercial Regions where Amazon SQS is available</a>.</p> \n<p>Redriving the messages from the dead-letter queue to the source queue or a custom destination queue generates additional API calls <a href=\"https://aws.amazon.com/sqs/pricing/\">billed based on existing pricing</a> (starting at $0.40 per million API calls, after the first million, which is free every month). Amazon SQS batches the messages while redriving them from one queue to another. This makes moving messages from one queue to another a simple and low-cost option.</p> \n<p>To learn more about DLQ and DLQ redrive, <a href=\"https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-dead-letter-queues.html\">check our documentation</a>.</p> \n<p><a href=\"https://www.youtube.com/watch?v=RfvL_423a-I\">Remember that we live in an asynchronous world</a>—so should your applications. <strong>Get started today and <a href=\"https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-dead-letter-queues.html\">write your first redrive application</a></strong>.</p> \n<a href=\"https://twitter.com/sebsto\">-- seb</a>","author":"Sébastien Stormacq","siteTitle":"AWS News Blog","siteHash":"6093e072e4117ec22616e844cb857d03ca62c57a411a8affc77cb5e8b6b15bf6","entryHash":"25e044ca05ee73bd1576743202b21a6b9f70e11f10794bdcc1efe01f553e69a4","category":"Tech"}