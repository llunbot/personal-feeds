{"title":"Herding (Apache) Camels with HashiCorp Consul","link":"https://www.hashicorp.com/blog/herding-apache-camels-with-hashicorp-consul","date":1626803100000,"content":"<p><a href=\"https://camel.apache.org/\">Apache Camel</a> really is the Swiss Army Knife of application integration for any Java (or Spring) developer. With 400+ components/adapters — all open source and easily extensible — Camel fits almost any integration use case. But there’s a catch: How do you keep track of your Camel services running throughout a deployment, and how can they communicate with one another in a multi-cloud or hybrid cloud environment?</p>\n<p>In this post, I’ll show you how to use Camel with HashiCorp Consul to address this challenge. In the walkthrough, we’ll use the <a href=\"https://camel.apache.org/components/latest/eips/serviceCall-eip.html\">Service Call</a> Enterprise Integration Pattern (EIP) and <a href=\"https://spring.io/projects/spring-boot\">Spring Boot</a>.</p>\n<h2><a href=\"#background\">»</a><a></a>Background</h2>\n<p>Kubernetes is a commonly suggested solution for orchestrating containers and service registration, but it can be <a href=\"https://www.hashicorp.com/resources/hashicorp-nomad-vs-kubernetes-comparing-complexity\">complex</a>, cumbersome, and a pain to deploy and manage. <a href=\"https://www.consul.io/\">HashiCorp Consul</a> presents a much simpler solution.</p>\n<p>All we really need is <a href=\"https://www.consul.io/use-cases/service-discovery-and-health-checking\">service discovery, service health checks</a>, and possibly a <a href=\"https://www.consul.io/use-cases/multi-platform-service-mesh\">service mesh</a> if we’re doing <a href=\"https://www.hashicorp.com/resources/why-microservices\">microservices</a>. In Apache Camel, the way we tackle this is using an Enterprise Integration Pattern called <a href=\"https://camel.apache.org/components/latest/eips/serviceCall-eip.html\">Service Call</a>. Basically, it’s a simple load-balancing flow that lets a client call any available service, and if the service is not available, then allow Camel to communicate with an external service registry to figure out what is available. A service registry maintains a list of healthy, available services in the form of a catalog that can be queried by external components.</p>\n<p>Open source service registry options include HashiCorp Consul, etcd, Zookeeper, and DNS. For this walkthrough, I’ve chosen to use <a href=\"https://www.consul.io/\">HashiCorp Consul</a> because of its <a href=\"https://twitter.com/mitchellh/status/1068584717589434368\">mass adoption</a>, <a href=\"https://github.com/hashicorp/consul\">maturity</a>, <a href=\"https://www.consul.io/community\">community</a>, and <a href=\"https://www.hashicorp.com/resources?products=consul&amp;type=case-study\">industry use cases.</a></p>\n<h2><a href=\"#the-service-call-eip-with-hashicorp-consul\">»</a><a></a>The Service Call EIP with HashiCorp Consul</h2>\n<p>To grab the code for this walkthrough, you can clone my repo: <a href=\"https://github.com/sigreen/camel-spring-boot-consul\">Load Balancing Apache Camel routes with Consul</a>. Here’s a flowchart diagram of the Service Call Enterprise Integration Pattern illustrating the problem we’re trying to solve:</p><img src=\"https://www.datocms-assets.com/2885/1626797814-consul-camel-servicecall-flow.png\" /><p>To execute this pattern, follow this procedure:</p>\n<h3><a href=\"#prerequisites\">»</a><a></a>Prerequisites</h3>\n<ul>\n<li><a href=\"https://www.docker.com/products/docker-desktop\">Docker</a></li>\n<li><a href=\"https://openjdk.java.net/\">Java 11+</a></li>\n<li><a href=\"https://maven.apache.org/\">Maven 3.8+</a></li>\n<li><a href=\"https://curl.se/\">curl</a></li>\n</ul>\n<h3><a href=\"#steps\">»</a><a></a>Steps</h3>\n<p>1. Start up <a href=\"https://hub.docker.com/_/consul\">Consul’s Docker image</a> on a development machine. We’ll refer to the Consul server as <em>Badger</em>:</p><pre><code>docker pull consul\ndocker run -d -p 8500:8500 -p 8600:8600/udp --name=badger consul agent -server -ui -node=server-1 \\ -bootstrap-expect=1 -client=0.0.0.0</code></pre><p>2. Start up the first Consul client. We’ll refer to the first Consul client as <em>Fox</em>:</p><pre><code>docker run --name=fox -d -e CONSUL_BIND_INTERFACE=eth0 consul agent -node=client-1 -dev -join=172.17.0.2 -ui</code></pre><p>3. Start up the second Consul client. We’ll refer to the second Consul client as <em>Weasel</em>:</p><pre><code>docker run --name=weasel -d -e CONSUL_BIND_INTERFACE=eth0 consul agent -node=client-2 -dev -join=172.17.0.2 -ui</code></pre><p>The above steps run a completely in-memory Consul server agent with default bridge networking and no services exposed on the host.  This is useful for development but should not be used in production. Since the server is running at internal address <code>172.17.0.2</code>, you can run a three-node cluster for development by starting up two more instances and telling them to join the first node.</p>\n<p>Now that we have Badger, Fox, and Weasel started, we can check their connectivity and health via the Consul web UI:</p><img src=\"https://www.datocms-assets.com/2885/1626792561-camelconsulnoderegistration.png\" /><p>We now have three nodes that are alive, active, and healthy: <em>server-1</em>, <em>client-1</em>, and <em>client-2</em>. This means Consul is ready to act as our service registry, meaning all we need to do is tell it which services to register and monitor.</p>\n<p>Using our example, copy the Consul service definitions to each client (<em>Weasel</em> and <em>Fox</em>):</p><pre><code>git clone https://github.com/sigreen/camel-spring-boot-consul \ncd camel-spring-boot-consul/services/src/main/resources/consul\ndocker cp services.json weasel:/consul/config/services.json\ndocker exec weasel consul reload\ndocker cp services.json fox:/consul/config/services.json\ndocker exec fox consul reload</code></pre><p>The Consul <code>services.json</code> file is illustrated below. Notice there are eight services defined: four for service-1, plus another four for service-2. All services have a unique identifier, but importantly can be referenced by a common service name: <em>service-1</em> and <em>service-2</em>. That way, Camel is unaware of dynamic IP changes, caring only about the service name that remains.</p><img src=\"https://www.datocms-assets.com/2885/1626792568-camelconsulservicesjson.png\" /><p>Go back to the Consul web UI, where you’ll notice that our eight Camel HTTP services are registered by Consul:</p><img src=\"https://www.datocms-assets.com/2885/1626792572-camelconsulservicesregistered.png\" /><p>Now, all we need to do is configure our Camel consumer. As we’re using SpringBoot, we can define allow/deny lists of services to determine which ones to call. Furthermore, with the Consul service registry, we don’t need to worry about dynamic IPs. We can simply refer to our service using a service name, or in this example, <code>localhost</code>. This information is found in the SpringBoot <code>applications.properties</code> file:</p><pre><code># Configure service filter\ncamel.cloud.service-filter.blacklist[service-1] = localhost:9012\n\n# Configure additional services\ncamel.cloud.service-discovery.services[service-2] = localhost:9021,localhost:9022,localhost:9023</code></pre><p>Let’s fire up our two backend services (<em>service-1</em> and <em>service-2</em>) together with our Camel consumer. We’re going to need four terminal sessions to execute the services. You can use either a generic command-line interface (CLI) or an IDE like <a href=\"https://code.visualstudio.com/\">VSCode</a> to execute the following commands.</p>\n<p>In the first terminal session:</p><pre><code>cd camel-spring-boot-consul/services\nmvn spring-boot:run -Dspring-boot.run.profiles=service-1</code></pre><p>In the second terminal session:</p><pre><code>cd camel-spring-boot-consul/services\nmvn spring-boot:run -Dspring-boot.run.profiles=service-2</code></pre><p>In the third terminal session:</p><pre><code>cd camel-spring-boot-consul/consumer\nmvn spring-boot:run</code></pre><p>And finally, now that we have our services and consumer running, we can use <code>curl</code> to call our Camel consumer in the fourth terminal session:</p><pre><code>curl localhost:8080/camel/serviceCall/service1\nHi!, I'm service-1 on camel-1/route1\ncurl localhost:8080/camel/serviceCall/service2\nHi!, I'm service-1 on camel-1/route2</code></pre><p>There is a hidden gotcha here, though. Did you notice the following error message?</p><pre><code>simongreen@simongreen-C02DRCJHMD6R Workspace % curl localhost:8080/camel/serviceCall/service2\n\njava.net.ConnectException: Connection refused\n    at java.base/sun.nio.ch.Net.pollConnect(Native Method)\n    at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:660)\n    at java.base/sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:875)\n    at org.xnio.nio.WorkerThread$ConnectHandle.handleReady(WorkerThread.java:327)\n    at org.xnio.nio.WorkerThread.run(WorkerThread.java:591)</code></pre><p>We’re getting this error message on purpose to simulate <em>service-1/route 4</em> and <em>service2/route4</em> being unavailable. You’ll notice we have four services registered in Consul for <em>service-1</em> (ports 9011 - 9014) and four services registered in Consul for <em>service-2</em> (ports (9021-9024). But only six services were implemented in Camel (service-1: 9011-9013, service-2: 9021-9023). Therefore, because those two services were left out (or unavailable), Camel throws a <code>Connection refused</code> error. To fix this, we simply add those services to our backend implementation.</p><img src=\"https://www.datocms-assets.com/2885/1626792553-camelconsuladdcode.png\" /><h2><a href=\"#further-reading\">»</a><a></a>Further Reading</h2>\n<p>Hopefully you found this example useful. For more information on this example, or to try it out yourself, visit my <a href=\"https://github.com/sigreen/camel-spring-boot-consul\">GitHub repo</a>.</p>\n<p>For another perspective, take a look at <a href=\"https://lburgazzoli.github.io/\">Luca Burgazzoli’s</a> blog: <a href=\"https://lburgazzoli.github.io/2017/04/12/A-camel-running-in-the-clouds-part-2.html\">A camel running in the clouds, part 2</a>. Luca also takes things a step further and adds health checking to the mix in <a href=\"https://lburgazzoli.github.io/2017/10/13/A-camel-running-in-the-clouds-part-3.html\">part 3 of his blog</a>. With health checks, it’s easy to see which Camel endpoints are healthy and alive in Consul, adding to the service registry functionality of Consul.</p>\n<p>Lastly, to learn more about <a href=\"https://www.consul.io/\">HashiCorp Consul</a>, try one of our <a href=\"https://learn.hashicorp.com/consul\">hands-on exercises</a>. Consul can be deployed to a large number of platforms, including Kubernetes, Amazon Web Services, Microsoft Azure, Google Cloud, or on-premises.</p>","author":"Simon Green","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"257738ac34693e97fca8c74696bebb051129bcc9677b69d8125ceb88e8d7b4e3","category":"Tech"}