{"title":"Introducing Amazon CloudFront KeyValueStore: A low-latency datastore for CloudFront Functions","link":"https://aws.amazon.com/blogs/aws/introducing-amazon-cloudfront-keyvaluestore-a-low-latency-datastore-for-cloudfront-functions/","date":1700601153000,"content":"<p><a href=\"https://aws.amazon.com/cloudfront/\">Amazon CloudFront</a> allows you to securely deliver static and dynamic content with low latency and high transfer speeds. With CloudFront Functions, you can perform latency-sensitive customizations for millions of requests per second. For example, you can use CloudFront Functions to modify headers, normalize cache keys, rewrite URLs, or authorize requests.</p> \n<p>Today, we are introducing <a href=\"https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/kvs-with-functions.html\">CloudFront KeyValueStore</a>, a secure global low-latency key value datastore that allows read access from within CloudFront Functions, enabling advanced customizable logic at the CloudFront edge locations.</p> \n<p>Previously, you had to embed configuration data inside the function code. For example, data for determining if a URL should be redirected and which URL to redirect the viewer to. When embedding configuration data with the function code, every small change in configuration requires a code change and a redeployment of the function code. Updating and deploying code for every new lookup addition introduces the risk of making inadvertent changes to code. Also, the <a href=\"https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html#limits-functions\">maximum function size is 10 KB</a>, making it difficult for many use cases to fit all the data within the code.</p> \n<p>With CloudFront KeyValueStore, you can now update the data associated with a function and the function code independently from each other. This simplifies function code and makes it easy to update data without the need to deploy code changes.</p> \n<p>Let’s see how this works in practice.</p> \n<p><span><strong>Creating a CloudFront key value store<br /> </strong></span>In the <a href=\"https://console.aws.amazon.com/cloudfront\">CloudFront console</a>, I choose <strong>Functions</strong> from the navigation pane. In the <strong>KeyValueStores</strong> tab, I choose <strong>Create KeyValueStore</strong>.</p> \n<p>Here, I have the option to import key value pairs from a JSON file in an <a href=\"https://aws.amazon.com/s3/\">Amazon Simple Storage Service (Amazon S3)</a> bucket. I am not doing that now because I want to start with no keys. I enter a name and description and complete the creation of the key value store.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/11/02/cloudfront-kvs-create.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/11/02/cloudfront-kvs-create.png\" alt=\"Console screenshot.\" width=\"1662\" height=\"958\" /></a></p> \n<p>When the key value store has been created, I choose <strong>Edit</strong> in the <strong>Key value pairs</strong> section and then <strong>Add pair</strong>. I type <code>hello</code> for the key and <code>Hello World</code> for the value and save the changes. I can add more keys and values, but one key is enough for now.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/11/02/cloudfront-kvs-edit.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/11/02/cloudfront-kvs-edit.png\" alt=\"Console screenshot.\" width=\"1668\" height=\"676\" /></a></p> \n<p>When I update a key value store, changes are propagated to all CloudFront edge locations in a few seconds so that it can be used with low latency by the functions that are associated with the key value store. Let’s see how that works.</p> \n<p><span><strong>Using CloudFront KeyValueStore from CloudFront Functions<br /> </strong></span>In the <a href=\"https://console.aws.amazon.com/cloudfront\">CloudFront console</a>, I choose <strong>Functions</strong> in the navigation pane and then <strong>Create function</strong>. I type a name for the function, select the <strong>cloudfront-js-2.0</strong> runtime, and complete the creation of the function. Then, I use the new option to associate the key value store with this function.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/11/02/cloudfront-kvs-1.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/11/02/cloudfront-kvs-1.png\" alt=\"Console screenshot.\" width=\"2222\" height=\"492\" /></a></p> \n<p>I copy the key value store ID from the console to use it in the following function code:</p> \n<pre><code>import cf from 'cloudfront';\n\nconst kvsId = '&lt;KEY_VALUE_STORE_ID&gt;';\n\n// This fails if the key value store is not associated with the function\nconst kvsHandle = cf.kvs(kvsId);\n\nasync function handler(event) {\n    // Use the first part of the pathname as key, for example http(s)://domain/&lt;key&gt;/something/else\n    const key = event.request.uri.split('/')[1]\n    let value = \"Not found\" // Default value\n    try {\n        value = await kvsHandle.get(key);\n    } catch (err) {\n        console.log(`Kvs key lookup failed for ${key}: ${err}`);\n    }\n    var response = {\n        statusCode: 200,\n        statusDescription: 'OK',\n        body: {\n            encoding: 'text',\n            data: `Key: ${key} Value: ${value}\\n`\n        }\n    };\n    return response;\n}</code></pre> \n<p>This function uses the first part of the path of the request as key and responds with the name of the key and its value.</p> \n<p>I save the changes and publish the function. In the <strong>Publish</strong> tab of the function, I associate the function with a CloudFront distribution that I created before. I use the <strong>Viewer Request</strong> event type and <strong>Default (*)</strong> cache behavior to intercept all requests to the distribution.</p> \n<p>In the console, I go back to the list of functions and wait for the function to be deployed. Then, I use <a href=\"https://curl.se/\">curl</a> from the command line to download content from the distribution and test the result of the function.</p> \n<p>First, I try with a couple of paths that invoke the function and look up the key I created before (<code>hello</code>):</p> \n<div> \n <pre><code>curl https://distribution-domain.cloudfront.net/hello\nKey: hello Value: Hello World\n\ncurl https://distribution-domain.cloudfront.net/hello/world\nKey: hello Value: Hello World</code></pre> \n</div> \n<p>It works! Then, I try with a different path to see that the default value I use in the code is returned when the key is not found.</p> \n<div> \n <pre><code>curl https://distribution-domain.cloudfront.net/hi\nKey: hi Value: Not found</code></pre> \n</div> \n<p>Now that this first example works, let’s try something more advanced and useful.</p> \n<p><span><strong>Rewriting the URL using configuration data in CloudFront KeyValueStore<br /> </strong></span>Let’s build a function that uses the content of the URL in the HTTP request to look up in a key value store the custom path that CloudFront should use to make the actual request. This function can help manage the multiple services that are part of a website.</p> \n<p>For example, I want to update the blog platform I use for my website. The old blog has origin path <code>/blog-v1</code> while the new blog has origin path <code>/blog-v2</code>.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/11/01/cloudfront-kvs-architecture.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/11/01/cloudfront-kvs-architecture.png\" alt=\"Architectural diagram.\" width=\"1498\" height=\"857\" /></a></p> \n<p>At first, I am still using the old blog. In the CloudFormation console, I add the <code>blog</code> key to the key value store with value <code>blog-v1</code>.</p> \n<p>Then, I create the following function and associate it with the distribution using <strong>Viewer Request</strong> event and <strong>Default (*)</strong> cache behavior to intercept all requests to the distribution.</p> \n<pre><code>import cf from 'cloudfront';\n\nconst kvsId = \"&lt;KEY_VALUE_STORE_ID&gt;\";\n\n// This fails if the key value store is not associated with the function\nconst kvsHandle = cf.kvs(kvsId);\n\nasync function handler(event) {\n    const request = event.request;\n    // Use the first segment of the pathname as key\n    // For example http(s)://domain/&lt;key&gt;/something/else\n    const pathSegments = request.uri.split('/')\n    const key = pathSegments[1]\n    try {\n        // Replace the first path of the pathname with the value of the key\n        // For example http(s)://domain/&lt;value&gt;/something/else\n        pathSegments[1] = await kvsHandle.get(key);\n        const newUri = pathSegments.join('/');\n        console.log(`${request.uri} -&gt; ${newUri}`)\n        request.uri = newUri;\n    } catch (err) {\n        // No change to the pathname if the key is not found\n        console.log(`${request.uri} | ${err}`);\n    }\n    return request;\n}</code></pre> \n<p>Now, when I type <code>blog</code> at the beginning of the URL path, the request will actually go to the <code>blog-v1</code> path. CloudFront will make the HTTP request to the old blog because <code>blog-v1</code> is the origin path used by the old blog.</p> \n<p>For example, if I type <code>https://distribution-domain.cloudfront.net/blog/index.html</code> in a browser, I see the old blog (V1).</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/11/01/cloudfront-kvs-blog-v1.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/11/01/cloudfront-kvs-blog-v1.png\" alt=\"Browser screenshot showing blog V1.\" width=\"2128\" height=\"428\" /></a></p> \n<p>In the console, I update the <code>blog</code> key with value <code>blog-v2</code>. I access the same URL after a few seconds, and now I reach the new blog (V2).</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/11/01/cloudfront-kvs-blog-v2.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2023/11/01/cloudfront-kvs-blog-v2.png\" alt=\"Browser screenshot showing blog V2.\" width=\"2128\" height=\"428\" /></a></p> \n<p>As you can see, the public URL is the same, but the content has changed. More generally, this function assumes that URLs do not change between the two blog versions.</p> \n<p>I can now add more keys for the different services that are part of my website (blog, support, help, commerce, and so on) and set their values to use the correct URL path for each of them. When I add a new version for one of them (for example, I migrate to a new commerce platform), I can configure a new origin and update the corresponding key to use the new origin path.</p> \n<p>This is just an example of the flexibility you get when you separate configuration data from code. If you are already using CloudFront Functions, you can simplify your code by using CloudFront KeyValueStore.</p> \n<p><strong><span>Things to know</span></strong><br /> CloudFront KeyValueStore is available today in all edge locations globally. With CloudFront KeyValueStore, you pay only for what you use based on the read/write operations from the public API and the read operations from within CloudFront Functions. For more information, see <a href=\"https://aws.amazon.com/cloudfront/pricing/\">CloudFront pricing</a>.</p> \n<p>You can manage a key value store using the <a href=\"https://console.aws.amazon.com\">AWS Management Console</a>, <a href=\"https://aws.amazon.com/cli/\">AWS Command Line Interface (AWS CLI)</a>, and <a href=\"https://aws.amazon.com/tools/\">AWS SDKs</a>. <a href=\"https://aws.amazon.com/cloudformation/\">AWS CloudFormation</a> support is coming soon. The maximum size of a key value store is 5 MB, and you can associate a single key value store to each function. The maximum size of a key is 512 bytes. Values can be up to 1KB in size. When creating a key value store, you can import key/value data during creation using a source file on <a href=\"https://aws.amazon.com/s3/\">Amazon S3</a> with this JSON structure:</p> \n<pre><code>{\n  \"data\":[\n    {\n      \"key\":\"key1\",\n      \"value\":\"val1\"\n    },\n    {\n      \"key\":\"key2\",\n      \"value\":\"val2\"\n    }\n  ]\n}</code></pre> \n<p>Importing key/value data at creation can help automate the setup of a new environment (such as test or dev) and easily replicate the configuration from one environment to another (such as preproduction to production).</p> \n<p><a href=\"https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/kvs-with-functions.html\"><strong>Simplify the way you add custom logic at the edge using CloudFront KeyValueStore.</strong></a></p> \n<p>— <a href=\"https://twitter.com/danilop\">Danilo</a></p>","author":"Danilo Poccia","siteTitle":"AWS News Blog","siteHash":"6093e072e4117ec22616e844cb857d03ca62c57a411a8affc77cb5e8b6b15bf6","entryHash":"7a5dcf5db2b40e2d2ec5bf0856613da12857d0363e011dfe208f08128e8fdb2a","category":"Tech"}