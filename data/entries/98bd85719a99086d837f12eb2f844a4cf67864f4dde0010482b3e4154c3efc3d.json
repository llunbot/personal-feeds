{"title":"X.509 certificate management with Vault","link":"https://www.hashicorp.com/blog/certificate-management-with-vault","date":1709053200000,"content":"<p><em>This blog post was originally published in 2018 and updated on October 24, 2022 and February 27, 2024.</em></p>\n\n<p>HashiCorp Vault provides secrets management and protection of sensitive data. It offers a central place to secure, store, and control access to tokens, passwords, certificates, and encryption keys. Users typically start by creating secrets and storing them in Vault’s static secrets engine. Applications would then retrieve and use secrets from Vault, restarting each time you manually revoke and rotate the secret in the Vault.</p>\n\n<p>Alternatively, Vault can manage the revocation and rotation of secrets for you in the form of <a href=\"https://www.hashicorp.com/blog/why-we-need-dynamic-secrets\">dynamic secrets</a>. For example, Vault applies a dynamic secret approach to X.509 public key infrastructure (PKI) certificates, acting as a signing intermediary to generate short-lived certificates. This allows certificates to be generated on-demand and rotated automatically.</p>\n\n<p>In this post, we’ll demonstrate how to configure Vault to manage PKI certificates with both self-signed and offline root certificate authorities (CAs). We’ll also use <a href=\"https://www.hashicorp.com/blog/why-use-the-vault-agent-for-secrets-management\">Vault Agent</a> to write certificates to a file for applications to use.</p>\n\n<h2>Enable the PKI secrets engine</h2>\n\n<p>Vault supports many <a href=\"https://developer.hashicorp.com/vault/docs/secrets\">secrets engines</a> plugins that handle the storage and rotation of secrets. Secrets engines are enabled at a mount path. For Vault to manage and issue certificates, enable the <a href=\"https://developer.hashicorp.com/vault/docs/secrets/pki\">PKI secrets engine</a> at the <code>pki/</code> path.</p>\n<pre><code>$ vault secrets enable pki\n\nSuccess! Enabled the pki secrets engine at: pki/</code></pre><p>By default, Vault mounts secrets engines at the path corresponding to their type. You can also enable secrets engines at their own unique path using the <code>-path</code> argument. Enabled secrets engines cannot access each other’s data, even if they are of the same type.</p>\n\n<p>Certificates include a validity period with a start and end date before they expire. When enabling Vault’s PKI secrets engine, certificates have a default validity period of 30 days. However, most certificates have a validity period of up to one year. To configure the validity period of the certificate, adjust the global maximum time-to-live (TTL) for the secrets engine. For more information on the PKI secrets engine, refer to <a href=\"https://developer.hashicorp.com/vault/docs/secrets/pki/setup\">documentation on setup and usage</a>.</p>\n\n<h2>Configure a root CA</h2>\n\n<p>Each PKI secrets engine needs to reference a root CA, CA certificate, and private key. You have three methods for configuring a root CA in Vault:</p>\n\n<p>Generate a <a href=\"https://developer.hashicorp.com/vault/tutorials/secrets-management/pki-engine\">self-signed root CA</a> issued by Vault\nBring your own <a href=\"https://developer.hashicorp.com/vault/tutorials/secrets-management/pki-engine-external-ca\">offline root CA</a>\n<a href=\"https://developer.hashicorp.com/vault/api-docs/secret/pki#import-ca-certificates-and-keys\">Import</a> a CA certificate and private key bundle using the <code>pki/config/ca</code> endpoint.</p>\n\n<p>For example, you can generate a self-signed root CA with a validity period of one year using the <code>pki/root/generate/internal</code> endpoint:</p>\n<pre><code>$ vault write pki/root/generate/internal \\\n   common_name=my-website.com \\\n   issuer_name=\"blog-root\" \\\n   ttl=8760h\n\n## omitted for clarity\n\nKey                     Value\n---                     -----\ncertificate             REDACTED\nexpiration              1697210094\nissuer_id               5e240c32-47ce-8f9a-fac0-0c712e98c1e1\nissuer_name             blog-root\nissuing_ca              REDACTED\nkey_id                  b10be38f-4834-dd57-fb75-e742d92585a6\nkey_name                n/a\nserial_number           REDACTED</code></pre><p>In general, you will want to create a CA hierarchy in which a root CA issues intermediate CAs. Each intermediate CA will issue leaf certificates to applications and other services. A hierarchical CA protects the root CA by separating intermediate CAs depending on their purpose.</p>\n\n<p>If you bring your own root CA hosted outside of Vault, avoid storing it in Vault. Issue short-lived intermediate CAs by creating mounts for each intermediate. Review PKI secrets engine documentation for <a href=\"https://developer.hashicorp.com/vault/docs/secrets/pki/considerations\">additional security considerations</a>.</p>\n\n<p>Vault only allows one CA certificate per secrets engine. If you want to issue certificates from multiple CAs, mount the PKI secrets engine at multiple mount points with separate CA certificates in each.</p>\n\n<h2>Set URL configuration</h2>\n\n<p>Each PKI secrets engine requires:\n- A URL configuration (for issuing certificate endpoints)\n- Certificate revocation list (CRL) distribution points\n- Online Certificate Status Protocol (OCSP) server endpoints\nThe URLs usually point to Vault’s fully-qualified domain name (FQDN). This example uses a Vault instance running locally:</p>\n<pre><code>$ vault write pki/config/urls \\\n    issuing_certificates=\"http://127.0.0.1:8200/v1/pki/ca\" \\\n    crl_distribution_points=\"http://127.0.0.1:8200/v1/pki/crl\"\n\nSuccess! Data written to: pki/config/urls</code></pre><p>You can update the URLs at any time.</p>\n\n<h2>Create a role to generate certificate</h2>\n\n<p>Generating certificates requires you to supply a Vault role. The role definition sets the conditions under which a certificate can be generated.</p>\n\n<p>Use the <code>/pki/roles/&lt;name&gt;</code> endpoint to create and update roles.</p>\n<pre><code>$ vault write pki/roles/example-dot-com \\\n    allowed_domains=example.com \\\n    allow_subdomains=true max_ttl=72h\n\nSuccess! Data written to: pki/roles/example-dot-com</code></pre><p>Review the <a href=\"https://developer.hashicorp.com/vault/api-docs/secret/pki#create-update-role\">PKI HTTP API reference</a> to learn about other attributes you can configure for roles, including allowed domains and IP Subject Alternative Names (IP SANs).</p>\n\n<p>Once a role has been created, you can use it to generate certificates with the <code>pki/issue</code> endpoint:</p>\n<pre><code>$ vault write pki/issue/example-dot-com \\\n    common_name=my.example.com\n\nKey                    Value\n---                    -----\nca_chain               REDACTED\ncertificate            REDACTED\nexpiration             1665938529\nissuing_ca             REDACTED\nprivate_key            REDACTED\nprivate_key_type       rsa\nserial_number          REDACTED</code></pre><p>Renew your certificate by providing an issuer with the same common name as an existing certificate. The original certificate will continue to be valid through its original time-to-live unless explicitly revoked.</p>\n\n<h2>Revoke or manage expired certificates</h2>\n\n<p>When you <a href=\"https://developer.hashicorp.com/vault/api-docs/secret/pki#revoke-certificate\">revoke a certificate</a>, you also regenerate the CRL. This removes any expired certificates from the list.</p>\n\n<p>To revoke your certificate based on its serial number, type the following command:</p>\n<pre><code>$ vault write pki/revoke serial_number=\n\nKey                        Value\n---                        -----\nrevocation_time            1665679572\nrevocation_time_rfc3339    2022-10-13T16:46:12.169387969Z</code></pre><p>To force a rotation of all certificates, read from the <a href=\"https://developer.hashicorp.com/vault/api-docs/secret/pki#rotate-crls\"><code>pki/crl/rotate</code> endpoint</a>:</p>\n<pre><code>$ vault read pki/crl/rotate\n\nKey        Value\n---        -----\nsuccess    true</code></pre><p>Vault will maintain expired certificates for a certain buffer period. To optimize Vault’s storage backend and CRL, use the <a href=\"https://developer.hashicorp.com/vault/api-docs/secret/pki#tidy\"><code>tidy</code> endpoint</a> to remove expired certificates from Vault.</p>\n<pre><code>$ vault write pki/tidy tidy_cert_store=true tidy_revoked_certs=true</code></pre><p>You can also set up <a href=\"https://developer.hashicorp.com/vault/api-docs/secret/pki#configure-automatic-tidy\">automatic tidying</a>, which periodically removes expired certificates from Vault’s storage backend.</p>\n\n<h2>Configure applications to use certificates from Vault</h2>\n\n<p>By setting up the PKI secrets engine, Vault automates the process of generating a private key, generating a certificate signing request (CSR), submitting to a CA, and then waiting for a verification and signing process to complete. How can applications and other services retrieve and use certificates from Vault?</p>\n\n<p>Rather than refactor applications to call the Vault API, you can use <a href=\"https://developer.hashicorp.com/vault/docs/agent\">Vault Agent</a> to retrieve a certificate from Vault and write it to a file for the application to use.</p>\n\n<h3>Create a Vault policy for the application’s certificates</h3>\n\n<p>The application needs sufficient access to retrieve a certificate from the PKI secrets engine. Create a Vault policy with create, read, and update permissions for the <code>pki/</code> endpoint.</p>\n<pre><code>$ echo 'path \"pki/*\" {\n  capabilities = [\"read\",\"create\",\"update\"]\n}' | vault policy write certs -\n\nSuccess! Uploaded policy: certs</code></pre><h3>Set up authentication to Vault</h3>\n\n<p>For Vault Agent to authenticate to Vault, set up a compatible <a href=\"https://developer.hashicorp.com/vault/docs/agent/autoauth/methods\">authentication method</a>. Enable the AppRole auth method for this example:</p>\n<pre><code>$ vault auth enable approle</code></pre><p>Create a named role for Vault Agent that matches the role for the PKI secrets engine.</p>\n<pre><code>$ vault write auth/approle/role/example-dot-com \\\n   role_id=example-dot-com \\\n   secret_id_ttl=30m \\\n   token_num_uses=0 \\\n   token_ttl=30m \\\n   token_max_ttl=60m \\\n   token_policies=certs \\\n   secret_id_num_uses=0\n\nSuccess! Data written to: auth/approle/role/example-dot-com</code></pre><p>Get the role ID and save it to a file for Vault Agent to reference.</p>\n<pre><code>$ vault read -field=role_id \\\n   auth/approle/role/example-dot-com/role-id &gt; vault_agent_role_id</code></pre><p>Get the secret ID and save it to a file for Vault Agent to reference.</p>\n<pre><code>$ vault write -f -field=secret_id \\\n   auth/approle/role/example-dot-com/secret-id &gt; vault_agent_secret_id</code></pre><h3>Create templates for certificate data</h3>\n\n<p>Vault Agent queries Vault at a supplied API endpoint (<code>pki/issue/example-dot-com</code>) with the given parameters (<code>common_name=my.example.com</code>). You previously issued the equivalent command as <code>vault write pki/issue/example-dot-com</code>. The API query returns a response with the following data:</p>\n<pre><code>{\n...\n  \"data\": {\n    \"certificate\": \"-----BEGIN CERTIFICATE-----\",\n    \"issuing_ca\": \"-----BEGIN CERTIFICATE-----\",\n    \"private_key\": \"-----BEGIN RSA PRIVATE KEY-----\",\n    ...\n    },\n}</code></pre><p>Use Vault Agent’s <a href=\"https://developer.hashicorp.com/vault/docs/agent/template\">template functionality</a> to extract the values of each field into individual files. </p>\n\n<p>Vault Agent reads a set of templates to create new files with the certificate contents, so create a directory for template files:</p>\n\n<pre><code>$ mkdir templates\n</code></pre>\n\n<p>Create a template file for the <strong>CA</strong> using the command below. The template reads information from <code>pki/issue/example-dot-com</code> using the <a href=\"https://github.com/hashicorp/consul-template/blob/main/docs/templating-language.md#pkicert\">pkiCert</a> function and writes out the certificate authority as a string.</p>\n<pre><code>$ cat &lt;&lt; EOF &gt; templates/ca.tpl\n{{ with pkiCert \"pki/issue/example-dot-com\" \"common_name=my.example.com\" }}{{ .CA }}{{ end }}\nEOF</code></pre><p>Create a template file for the <strong>certificate</strong> using the command below. The template reads information from <code>pki/issue/example-dot-com</code> using the pkiCert function and writes out the certificate as a string.</p>\n<pre><code>$ cat &lt;&lt; EOF &gt; templates/cert.tpl\n{{ with pkiCert \"pki/issue/example-dot-com\" \"common_name=my.example.com\" }}{{ .Cert }}{{ end }}\nEOF</code></pre><p>Create a template file for the <strong>private key</strong> using the command below. The template reads information from <code>pki/issue/example-dot-com</code> using the pkiCert function and writes out the private key as a string.</p>\n<pre><code>$ cat &lt;&lt; EOF &gt; templates/key.tpl\n{{ with pkiCert \"pki/issue/example-dot-com\" \"common_name=my.example.com\" }}{{ .Key }}{{ end }}\nEOF</code></pre><h3>Use Vault agent to create certificate files</h3>\n\n<p>Vault Agent uses the role and secret ID to authenticate to Vault and retrieve certificate information. Then, it writes the certificate data based on each template file. Create a file for Vault Agent configuration using the code below:</p>\n<pre><code>$ cat &lt;&lt; EOF &gt; vault-agent.hcl\npid_file        = \"./pidfile\"\nexit_after_auth = true\n\nvault {\n  address = \"http://127.0.0.1:8200\"\n}\n\nauto_auth {\n\n  method {\n    type = \"approle\"\n    config = {\n      role_id_file_path                   = \"vault_agent_role_id\"\n      secret_id_file_path                 = \"vault_agent_secret_id\"\n      remove_secret_id_file_after_reading = false\n    }\n  }\n\n  sink {\n    type = \"file\"\n    config = {\n      path = \"vault_agent_token\"\n    }\n  }\n\n}\n\ntemplate {\n  source      = \"templates/cert.tpl\"\n  destination = \"examples/my-app.crt\"\n}\n\ntemplate {\n  source      = \"templates/ca.tpl\"\n  destination = \"examples/ca.crt\"\n}\n\ntemplate {\n  source      = \"templates/key.tpl\"\n  destination = \"examples/my-app.key\"\n}\nEOF</code></pre><p>Use multiple template blocks to define multiple templates. The <code>source</code> directive indicates which source file on disk to use as the input template. The <code>destination</code> directive indicates the path on disk where the source template will render.</p>\n\n<p>Run Vault Agent to generate the certificate files:</p>\n<pre><code>$ vault agent -config=vault-agent.hcl</code></pre><p>Review the certificate files under the <code>examples/</code> directory. It has three files: one for the certificate, CA, and private key.</p>\n<pre><code>$ ls examples/\n\nca.crt     my-app.crt my-app.key</code></pre><p>Vault Agent renews the certificate at half the lease duration of the original. For example, if the certificate role has a maximum lease of 72 hours, Vault Agent generates a new certificate every 36 hours.</p>\n\n<h2>Summary</h2>\n\n<p>Using Vault to manage certificate rotation and revocation, you can audit the issuance and expiration of certificates from one central location. To enable your application to use the certificates without refactoring the application, configure Vault Agent to retrieve the certificates each time they update and write them to a file.</p>\n\n<p>Review our <a href=\"https://developer.hashicorp.com/vault/docs/secrets/pki\">Vault PKI documentation</a> for more attributes and configuration for the PKI secrets engine. For more information about Vault Agent, review its <a href=\"https://developer.hashicorp.com/vault/docs/agent\">supported authentication methods and templating language</a>.</p>\n\n<p><em>This post was originally published in 2018 by HashiCorp Developer Advocate Christie Koeler. It was updated in 2022 by HashiCorp Developer Advocate Rosemary Wang.</em></p>\n","author":"Christie Koehler","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"98bd85719a99086d837f12eb2f844a4cf67864f4dde0010482b3e4154c3efc3d","category":"Tech"}