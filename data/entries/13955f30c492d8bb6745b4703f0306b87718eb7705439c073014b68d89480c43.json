{"title":"Uniting Web And Native Apps With 4 Unknown JavaScript APIs","link":"https://smashingmagazine.com/2024/06/uniting-web-native-apps-unknown-javascript-apis/","date":1719252000000,"content":"<p>A couple of years ago, <a href=\"https://www.smashingmagazine.com/2022/09/javascript-api-guide/\">four JavaScript APIs that landed at the bottom of awareness in the State of JavaScript survey</a>. I took an interest in those APIs because they have so much potential to be useful but don’t get the credit they deserve. Even after a quick search, I was amazed at how many new web APIs have been added to the ECMAScript specification that aren’t getting their dues and with a lack of awareness and browser support in browsers.</p>\n<p>That situation can be a “catch-22”:</p>\n<p>An API is interesting but lacks awareness due to incomplete support, and there is no immediate need to support it due to low awareness.</p>\n<p>Most of these APIs are designed to power progressive web apps (PWA) and close the gap between web and native apps. Bear in mind that creating a PWA involves more than just adding a <a href=\"https://css-tricks.com/how-to-transition-to-manifest-v3-for-chrome-extensions/\">manifest file</a>. Sure, it’s a PWA by definition, but it functions like a bookmark on your home screen in practice. In reality, we need several APIs to achieve a fully native app experience on the web. And the four APIs I’d like to shed light on are part of that PWA puzzle that brings to the web what we once thought was only possible in native apps.</p>\n<p>You can see all these <a href=\"https://monknow.github.io/pwa-features-demo/\">APIs in action in this demo</a> as we go along.</p>\n1. Screen Orientation API\n<p>The <a href=\"https://www.w3.org/TR/screen-orientation/\">Screen Orientation API</a> can be used to sniff out the device’s current orientation. Once we know whether a user is browsing in a portrait or landscape orientation, we can use it to <strong>enhance the UX for mobile devices</strong> by changing the UI accordingly. We can also use it to <strong>lock the screen in a certain position</strong>, which is useful for displaying videos and other full-screen elements that benefit from a wider viewport.</p>\n<p>Using the global <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/screen\"><code>screen</code></a> object, you can access various properties the screen uses to render a page, including the <code>screen.orientation</code> object. It has two properties:</p>\n<ul>\n<li><strong><code>type</code>:</strong> The current screen orientation. It can be: <code>\"portrait-primary\"</code>, <code>\"portrait-secondary\"</code>, <code>\"landscape-primary\"</code>, or <code>\"landscape-secondary\"</code>.</li>\n<li><strong><code>angle</code>:</strong> The current screen orientation angle. It can be any number from 0 to 360 degrees, but it’s normally set in multiples of 90 degrees (e.g., <code>0</code>, <code>90</code>, <code>180</code>, or <code>270</code>).</li>\n</ul>\n<p>On mobile devices, if the <code>angle</code> is <code>0</code> degrees, the <code>type</code> is most often going to evaluate to <code>\"portrait\"</code> (vertical), but on desktop devices, it is typically <code>\"landscape\"</code> (horizontal). This makes the <code>type</code> property precise for knowing a device’s true position.</p>\n<p>The <code>screen.orientation</code> object also has two methods:</p>\n<ul>\n<li><strong><code>.lock()</code>:</strong> This is an async method that takes a <code>type</code> value as an argument to lock the screen.</li>\n<li><strong><code>.unlock()</code>:</strong> This method unlocks the screen to its default orientation.</li>\n</ul>\n<p>And lastly, <code>screen.orientation</code> counts with an <code>\"orientationchange\"</code> event to know when the orientation has changed.</p>\n<h3>Browser Support</h3>\n<p><img src=\"https://files.smashing.media/articles/uniting-web-native-apps-unknown-javascript-apis/screen-orientation-api-support.jpg\" /></p>\n<h3>Finding And Locking Screen Orientation</h3>\n<p>Let’s code a short demo using the Screen Orientation API to know the device’s orientation and lock it in its current position.</p>\n<p>This can be our HTML boilerplate:</p>\n<div>\n<pre><code>&lt;main&gt;\n  &lt;p&gt;\n    Orientation Type: &lt;span class=\"orientation-type\"&gt;&lt;/span&gt;\n    &lt;br /&gt;\n    Orientation Angle: &lt;span class=\"orientation-angle\"&gt;&lt;/span&gt;\n  &lt;/p&gt;\n\n  &lt;button type=\"button\" class=\"lock-button\"&gt;Lock Screen&lt;/button&gt;\n\n  &lt;button type=\"button\" class=\"unlock-button\"&gt;Unlock Screen&lt;/button&gt;\n\n  &lt;button type=\"button\" class=\"fullscreen-button\"&gt;Go Full Screen&lt;/button&gt;\n&lt;/main&gt;\n</code></pre>\n</div>\n\n<p>On the JavaScript side, we inject the screen orientation <code>type</code> and <code>angle</code> properties into our HTML.</p>\n<div>\n<pre><code>let currentOrientationType = document.querySelector(\".orientation-type\");\nlet currentOrientationAngle = document.querySelector(\".orientation-angle\");\n\ncurrentOrientationType.textContent = screen.orientation.type;\ncurrentOrientationAngle.textContent = screen.orientation.angle;\n</code></pre>\n</div>\n\n<p>Now, we can see the device’s orientation and angle properties. On my laptop, they are <code>\"landscape-primary\"</code> and <code>0°</code>.</p>\n<p><img src=\"https://files.smashing.media/articles/uniting-web-native-apps-unknown-javascript-apis/screen-orientation-1.png\" /></p>\n<p>If we listen to the window’s <code>orientationchange</code> event, we can see how the values are updated each time the screen rotates.</p>\n<pre><code>window.addEventListener(\"orientationchange\", () =&gt; {\n  currentOrientationType.textContent = screen.orientation.type;\n  currentOrientationAngle.textContent = screen.orientation.angle;\n});\n</code></pre>\n\n<p><img src=\"https://files.smashing.media/articles/uniting-web-native-apps-unknown-javascript-apis/screen-orientation-2.png\" /></p>\n<p>To lock the screen, we need to first be in full-screen mode, so we will use another extremely useful feature: the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API\"><strong>Fullscreen API</strong></a>. Nobody wants a webpage to pop into full-screen mode without their consent, so we need <a href=\"https://developer.mozilla.org/en-US/docs/Web/Security/User_activation#transient_activation\">transient activation</a> (i.e., a user click) from a DOM element to work.</p>\n<p>The Fullscreen API has two methods:</p>\n<ol>\n<li><code>Document.exitFullscreen()</code> is used from the global document object,</li>\n<li><code>Element.requestFullscreen()</code> makes the specified element and its descendants go full-screen.</li>\n</ol>\n<p>We want the entire page to be full-screen so we can invoke the method from the root element at the <code>document.documentElement</code> object:</p>\n<div>\n<pre><code>const fullscreenButton = document.querySelector(\".fullscreen-button\");\n\nfullscreenButton.addEventListener(\"click\", async () =&gt; {\n  // If it is already in full-screen, exit to normal view\n  if (document.fullscreenElement) {\n    await document.exitFullscreen();\n  } else {\n    await document.documentElement.requestFullscreen();\n  }\n});\n</code></pre>\n</div>\n\n<p>Next, we can lock the screen in its current orientation:</p>\n<pre><code>const lockButton = document.querySelector(\".lock-button\");\n\nlockButton.addEventListener(\"click\", async () =&gt; {\n  try {\n    await screen.orientation.lock(screen.orientation.type);\n  } catch (error) {\n    console.error(error);\n  }\n});\n</code></pre>\n\n<p>And do the opposite with the unlock button:</p>\n<pre><code>const unlockButton = document.querySelector(\".unlock-button\");\n\nunlockButton.addEventListener(\"click\", () =&gt; {\n  screen.orientation.unlock();\n});\n</code></pre>\n\n<h3>Can’t We Check Orientation With a Media Query?</h3>\n<p>Yes! We can indeed check page orientation via the <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/@media/orientation\"><code>orientation</code> media feature</a> in a CSS media query. However, media queries compute the current orientation by checking if the width is “bigger than the height” for landscape or “smaller” for portrait. By contrast,</p>\n<p>The Screen Orientation API checks for the screen rendering the page regardless of the viewport dimensions, making it resistant to inconsistencies that may crop up with page resizing.</p>\n<p>You may have noticed how PWAs like Instagram and X force the screen to be in portrait mode even when the native system orientation is unlocked. It is important to notice that this behavior isn’t achieved through the Screen Orientation API, but by setting the <code>orientation</code> property on the <code>manifest.json</code> file to the desired orientation type.</p>\n2. Device Orientation API\n<p>Another API I’d like to poke at is the Device Orientation API. It provides access to a device’s gyroscope sensors to read the device’s orientation in space; something used all the time in mobile apps, mainly games. The API makes this happen with a <code>deviceorientation</code> event that triggers each time the device moves. It has the following properties:</p>\n<ul>\n<li><strong><code>event.alpha</code>:</strong> Orientation along the Z-axis, ranging from 0 to 360 degrees.</li>\n<li><strong><code>event.beta</code>:</strong> Orientation along the X-axis, ranging from -180 to 180 degrees.</li>\n<li><strong><code>event.gamma</code>:</strong> Orientation along the Y-axis, ranging from -90 to 90 degrees.</li>\n</ul>\n<h3>Browser Support</h3>\n<p><img src=\"https://files.smashing.media/articles/uniting-web-native-apps-unknown-javascript-apis/device-orientation-api-support.jpg\" /></p>\n<h3>Moving Elements With Your Device</h3>\n<p>In this case, we will make a 3D cube with CSS that can be rotated with your device! The full instructions I used to make the initial CSS cube are credited to <a href=\"https://desandro.com\">David DeSandro</a> and can be <a href=\"https://3dtransforms.desandro.com/cube\">found in his introduction to 3D transforms</a>.</p>\n<p><img src=\"https://files.smashing.media/articles/uniting-web-native-apps-unknown-javascript-apis/device-motion-1.png\" /></p>\n<p>To rotate the cube, we change its CSS <code>transform</code> properties according to the device orientation data:</p>\n<div>\n<pre><code>const currentAlpha = document.querySelector(\".currentAlpha\");\nconst currentBeta = document.querySelector(\".currentBeta\");\nconst currentGamma = document.querySelector(\".currentGamma\");\n\nconst cube = document.querySelector(\".cube\");\n\nwindow.addEventListener(\"deviceorientation\", (event) =&gt; {\n  currentAlpha.textContent = event.alpha;\n  currentBeta.textContent = event.beta;\n  currentGamma.textContent = event.gamma;\n\n  cube.style.transform = <code>rotateX(${event.beta}deg) rotateY(${event.gamma}deg) rotateZ(${event.alpha}deg)</code>;\n});\n</code></pre>\n</div>\n\n<p>This is the result:</p>\n<p><img src=\"https://files.smashing.media/articles/uniting-web-native-apps-unknown-javascript-apis/device-motion-2.jpg\" /></p>\n3. Vibration API\n<p>Let’s turn our attention to the Vibration API, which, unsurprisingly, allows access to a device’s vibrating mechanism. This comes in handy when we need to alert users with in-app notifications, like when a process is finished or a message is received. That said, we have to use it sparingly; no one wants their phone blowing up with notifications.</p>\n<p>There’s just one method that the Vibration API gives us, and it’s all we need: <code>navigator.vibrate()</code>.</p>\n<p><code>vibrate()</code> is available globally from the <code>navigator</code> object and takes an argument for how long a vibration lasts in milliseconds. It can be either a number or an array of numbers representing a patron of vibrations and pauses.</p>\n<div>\n<pre><code>navigator.vibrate(200); // vibrate 200ms\nnavigator.vibrate([200, 100, 200]); // vibrate 200ms, wait 100, and vibrate 200ms.\n</code></pre>\n</div>\n\n<h3>Browser Support</h3>\n<p><img src=\"https://files.smashing.media/articles/uniting-web-native-apps-unknown-javascript-apis/vibration-api-support.jpg\" /></p>\n<h3>Vibration API Demo</h3>\n<p>Let’s make a quick demo where the user inputs how many milliseconds they want their device to vibrate and buttons to start and stop the vibration, starting with the markup:</p>\n<pre><code>&lt;main&gt;\n  &lt;form&gt;\n    &lt;label for=\"milliseconds-input\"&gt;Milliseconds:&lt;/label&gt;\n    &lt;input type=\"number\" id=\"milliseconds-input\" value=\"0\" /&gt;\n  &lt;/form&gt;\n\n  &lt;button class=\"vibrate-button\"&gt;Vibrate&lt;/button&gt;\n  &lt;button class=\"stop-vibrate-button\"&gt;Stop&lt;/button&gt;\n&lt;/main&gt;\n</code></pre>\n\n<p>We’ll add an event listener for a click and invoke the <code>vibrate()</code> method:</p>\n<div>\n<pre><code>const vibrateButton = document.querySelector(\".vibrate-button\");\nconst millisecondsInput = document.querySelector(\"#milliseconds-input\");\n\nvibrateButton.addEventListener(\"click\", () =&gt; {\n  navigator.vibrate(millisecondsInput.value);\n});\n</code></pre>\n</div>\n\n<p>To stop vibrating, we override the current vibration with a zero-millisecond vibration.</p>\n<div>\n<pre><code>const stopVibrateButton = document.querySelector(\".stop-vibrate-button\");\n\nstopVibrateButton.addEventListener(\"click\", () =&gt; {\n  navigator.vibrate(0);\n});\n</code></pre>\n</div>\n\n\n\n4. Contact Picker API\n<p>In the past, it used to be that only native apps could connect to a device’s “contacts”. But now we have the fourth and final API I want to look at: the <a href=\"https://w3c.github.io/contact-picker/\"><strong>Contact Picker API</strong></a>.</p>\n<p>The API grants web apps access to the device’s contact lists. Specifically, we get the <code>contacts.select()</code> async method available through the <code>navigator</code> object, which takes the following two arguments:</p>\n<ul>\n<li><strong><code>properties</code>:</strong> This is an array containing the information we want to fetch from a contact card, e.g., <code>\"name\"</code>, <code>\"address\"</code>, <code>\"email\"</code>, <code>\"tel\"</code>, and <code>\"icon\"</code>.</li>\n<li><strong><code>options</code>:</strong> This is an object that can only contain the <code>multiple</code> boolean property to define whether or not the user can select one or multiple contacts at a time.</li>\n</ul>\n<h3>Browser Support</h3>\n<p>I’m afraid that browser support is next to zilch on this one, limited to Chrome Android, Samsung Internet, and Android’s native web browser at the time I’m writing this.</p>\n<p><img src=\"https://files.smashing.media/articles/uniting-web-native-apps-unknown-javascript-apis/contacts-manager-api-support.jpg\" /></p>\n<h3>Selecting User’s Contacts</h3>\n<p>We will make another demo to select and display the user’s contacts on the page. Again, starting with the HTML:</p>\n<pre><code>&lt;main&gt;\n  &lt;button class=\"get-contacts\"&gt;Get Contacts&lt;/button&gt;\n  &lt;p&gt;Contacts:&lt;/p&gt;\n  &lt;ul class=\"contact-list\"&gt;\n    &lt;!-- We’ll inject a list of contacts --&gt;\n  &lt;/ul&gt;\n&lt;/main&gt;\n</code></pre>\n\n<p>Then, in JavaScript, we first construct our elements from the DOM and choose which properties we want to pick from the contacts.</p>\n<div>\n<pre><code>const getContactsButton = document.querySelector(\".get-contacts\");\nconst contactList = document.querySelector(\".contact-list\");\n\nconst props = [\"name\", \"tel\", \"icon\"];\nconst options = {multiple: true};\n</code></pre>\n</div>\n\n<p>Now, we asynchronously pick the contacts when the user clicks the <code>getContactsButton</code>.</p>\n<div>\n<pre><code>\nconst getContacts = async () =&gt; {\n  try {\n    const contacts = await navigator.contacts.select(props, options);\n  } catch (error) {\n    console.error(error);\n  }\n};\n\ngetContactsButton.addEventListener(\"click\", getContacts);\n</code></pre>\n</div>\n\n<p>Using DOM manipulation, we can then append a list item to each contact and an icon to the <code>contactList</code> element.</p>\n<div>\n<pre><code>const appendContacts = (contacts) =&gt; {\n  contacts.forEach(({name, tel, icon}) =&gt; {\n    const contactElement = document.createElement(\"li\");\n\n    contactElement.innerText = <code>${name}: ${tel}</code>;\n    contactList.appendChild(contactElement);\n  });\n};\n\nconst getContacts = async () =&gt; {\n  try {\n    const contacts = await navigator.contacts.select(props, options);\n    appendContacts(contacts);\n  } catch (error) {\n    console.error(error);\n  }\n};\n\ngetContactsButton.addEventListener(\"click\", getContacts);\n</code></pre>\n</div>\n\n<p>Appending an image is a little tricky since we will need to convert it into a URL and append it for each item in the list.</p>\n<div>\n<pre><code>const getIcon = (icon) =&gt; {\n  if (icon.length &gt; 0) {\n    const imageUrl = URL.createObjectURL(icon[0]);\n    const imageElement = document.createElement(\"img\");\n    imageElement.src = imageUrl;\n\n    return imageElement;\n  }\n};\n\nconst appendContacts = (contacts) =&gt; {\n  contacts.forEach(({name, tel, icon}) =&gt; {\n    const contactElement = document.createElement(\"li\");\n\n    contactElement.innerText = <code>${name}: ${tel}</code>;\n    contactList.appendChild(contactElement);\n\n    const imageElement = getIcon(icon);\n    contactElement.appendChild(imageElement);\n  });\n};\n\nconst getContacts = async () =&gt; {\n  try {\n    const contacts = await navigator.contacts.select(props, options);\n    appendContacts(contacts);\n  } catch (error) {\n    console.error(error);\n  }\n};\n\ngetContactsButton.addEventListener(\"click\", getContacts);\n</code></pre>\n</div>\n\n<p>And here’s the outcome:</p>\n<p><img src=\"https://files.smashing.media/articles/uniting-web-native-apps-unknown-javascript-apis/contact-picker-1.png\" /></p>\n<p><strong>Note</strong>: <strong><em>The Contact Picker API will only work if the context is secure</em></strong>, <em>i.e., the page is served over <code>https://</code> or <code>wss://</code> URLs.</em></p>\nConclusion\n<p>There we go, four web APIs that I believe would empower us to <strong>build more useful and robust PWAs</strong> but have slipped under the radar for many of us. This is, of course, due to inconsistent browser support, so I hope this article can bring awareness to new APIs so we have a better chance to see them in future browser updates.</p>\n<p>Aren’t they interesting? We saw how much control we have with the orientation of a device and its screen as well as the level of access we get to access a device’s hardware features, i.e. vibration, and information from other apps to use in our own UI.</p>\n<p>But as I said much earlier, there’s a sort of infinite loop where <strong>a lack of awareness begets a lack of browser support</strong>. So, while the four APIs we covered are super interesting, your mileage will inevitably vary when it comes to using them in a production environment. Please tread cautiously and refer to <a href=\"https://caniuse.com\">Caniuse</a> for the latest support information, or check for your own devices using <a href=\"https://webapicheck.com/\">WebAPI Check</a>.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"13955f30c492d8bb6745b4703f0306b87718eb7705439c073014b68d89480c43","category":"Tech"}