{"title":"Ephemeral values in Terraform","link":"https://www.hashicorp.com/blog/ephemeral-values-in-terraform","date":1741620600000,"content":"<p>Before Terraform 1.11, working with sensitive values was a challenge — sensitive values were always persisted to the Terraform plan artifact and state. As a result, we advised (and <a href=\"https://developer.hashicorp.com/terraform/language/state/sensitive-data\">still advise</a>) treating your state as sensitive data. This advice applies equally to us as it does to you. To address this, we introduced the concept of ephemerality in Terraform, allowing you to work with sensitive data like passwords and tokens securely, without leaving a trace.</p>\n\n<h2>Ephemerality</h2>\n\n<p>Ephemerality in computing refers to the ability to create something that is short-lived or temporary — a piece of data that exists only for a brief period and is discarded once its purpose is fulfilled. In Terraform, this concept was introduced to manage sensitive data or open a connection in a way that ensures it doesn’t persist beyond its immediate use. We’ve implemented new language constructs that track values only at runtime, making them transient and, therefore, ephemeral by design. </p>\n\n<p>These are part of what we call <strong>ephemeral values</strong>, a term that covers both <strong>ephemeral resources</strong>, <strong>ephemeral input variables</strong>, and <strong>write-only arguments</strong>.</p>\n\n<h2>Ephemeral resources</h2>\n\n<p><a href=\"https://developer.hashicorp.com/terraform/plugin/framework/ephemeral-resources\">Ephemeral resources</a> are Terraform resources that are essentially temporary. They are responsible for reading data from a source such as a <a href=\"https://www.vaultproject.io/use-cases/secrets-management\">secrets manager</a>, or opening a connection, and their attributes can be referenced in other places without persisting anything to the Terraform plan artifact or state file.</p>\n\n<p>It’s important to note that ephemeral resources require all their dependencies to exist because they always run during both the plan and apply stages. If an ephemeral resource attempts to read a secret from a secrets manager that doesn’t exist, it will result in an error. However, Terraform can defer the execution of an ephemeral resource to the apply stage if one of its input arguments references a value that is not yet known at the plan stage but will be determined during apply.</p>\n\n<p>Here’s an example of an ephemeral password resource with no dependencies, executed during both plan and apply:</p>\n<pre><code>ephemeral \"random_password\" \"db_password\" {\n  length = 16\n}</code></pre><p>This generates an ephemeral password string using a cryptographic random number generator. The generated string can then be used as input for a write-only attribute on a managed or ephemeral resource.</p>\n\n<h2>Write-only arguments</h2>\n\n<p><a href=\"https://developer.hashicorp.com/terraform/plugin/framework/resources/write-only-arguments\">Write-only arguments</a> are managed resource attributes that are configured by users but are not persisted to the Terraform plan artifact or state file. Terraform providers implement write-only arguments on managed resources to handle sensitive values, such as passwords, tokens, and other secrets, securely. </p>\n\n<p>An example of a write-only argument is the <code>secret_string_wo</code> argument on the <code>aws_secretsmanager_secret_version</code> resource:</p>\n<pre><code>resource \"aws_secretsmanager_secret_version\" \"db_password\" {\n  secret_id                = aws_secretsmanager_secret.db_password.id\n  secret_string_wo         = ephemeral.random_password.db_password.result\n  secret_string_wo_version = 1\n}</code></pre><p>It’s common for write-only arguments to be assigned an ephemeral resource attribute, as shown in the example above. This enables end-to-end ephemerality in Terraform, ensuring that sensitive values are not persisted in either the Terraform plan artifact or the state file.</p>\n\n<p>Earlier, we mentioned that ephemeral resources are executed during every plan and apply. This means that a new ephemeral random password is generated, or a new value is fetched from a secrets manager, with each plan and each apply. To prevent a write-only argument from being updated on every run after creation, you set the write-only version argument. Terraform stores this version in state and uses it to track changes. When the version is incremented, Terraform allows the resource to accept the new value for the write-only argument, which is then sent to the provider to update it accordingly.</p>\n\n<h3>Write-only version arguments</h3>\n\n<p>Terraform doesn’t store write-only arguments in the plan or state file, meaning it can’t track changes to their values. As a result, write-only arguments are sent to the provider during every operation. However, providers typically include write-only version arguments (e.g. <code>password_wo_version</code>) alongside write-only value arguments (e.g. <code>password_wo</code>), where the version arguments are stored in the state file and can be tracked for changes.</p>\n\n<p>These write-only version arguments enable users to update a write-only value by incrementing the version number. When the write-only version argument is updated, Terraform detects this change in the plan and notifies the provider. The provider then uses the updated write-only value to update the resource accordingly.</p>\n\n<p>If a resource depends on multiple write-only arguments in the dependency graph, it’s a good idea to keep their version arguments in sync. This way, all the related write-only values are updated together, avoiding inconsistencies and ensuring the provider uses the correct values during each operation. In the next section, we’ll cover deferring ephemeral resources, and the example code will demonstrate how to synchronize versioning for write-only arguments.</p>\n\n<h2>Deferring ephemeral resources</h2>\n\n<p>If an input argument of an ephemeral resource references a value that is not yet known but will be during or after the plan, Terraform defers the resource’s execution to the apply stage instead of running it during the plan. This behavior allows Terraform to evaluate the ephemeral resource at the correct time and ensures that the resource is not executed prematurely.</p>\n\n<p>Similarly, ephemeral resources form nodes in Terraform’s dependency graph. When a managed resource or data source depends on an attribute of an ephemeral resource, Terraform automatically provisions the ephemeral resource first.</p>\n\n<p>As we concluded earlier, ephemeral resources are executed during every plan and apply. It’s important to model your Terraform configuration in such a way that the dependency graph of all of the managed resources and ephemeral resources ensures correct execution order and prevents unintended behavior. </p>\n\n<p>By using the ephemeral random password and AWS Secrets Manager secret we created earlier, we can take advantage of ephemerality and its deferring logic to securely provision an AWS RDS instance.</p>\n<pre><code>ephemeral \"random_password\" \"db_password\" {\n  length           = 16\n  override_special = \"!#$%&amp;*()-_=+[]{}&lt;&gt;:?\"\n}\n\nresource \"aws_secretsmanager_secret\" \"db_password\" {\n  name = \"db-password\"\n}\n\nresource \"aws_secretsmanager_secret_version\" \"db_password\" {\n  secret_id                = aws_secretsmanager_secret.db_password.id\n  secret_string_wo         = ephemeral.random_password.db_password.result\n  secret_string_wo_version = 1\n}\n\nephemeral \"aws_secretsmanager_secret_version\" \"db_password\" {\n  secret_id = aws_secretsmanager_secret_version.db_password.secret_id\n}\n\nresource \"aws_db_instance\" \"example\" {\n  instance_class      = \"db.t3.micro\"\n  allocated_storage   = \"5\"\n  engine              = \"postgres\"\n  username            = \"example\"\n  skip_final_snapshot = true\n  password_wo         = ephemeral.aws_secretsmanager_secret_version.db_password.secret_string\n  password_wo_version = aws_secretsmanager_secret_version.db_password.secret_string_wo_version\n}</code></pre><p>In the above example, the ephemeral resource <code>aws_secretsmanager_secret_version</code> depends on an argument that Terraform doesn’t initially know. Terraform defers executing this ephemeral resource until the apply stage, ensuring it runs only after the necessary information becomes available.</p>\n\n<p>During the apply stage Terraform first creates the secret in AWS Secrets Manager using the ephemeral <code>random_password</code>, then Terraform retrieves the secret using the ephemeral <code>aws_secretsmanager_secret_version</code> resource. The last thing Terraform does is write the password to the write-only <code>password_wo</code> argument of the <code>aws_db_instance</code> resource.</p>\n\n<h2>Lifecycle of an ephemeral resource</h2>\n\n<p>Ephemeral resources have a lifecycle that differs from other resources and data sources. The lifecycle has three steps: </p>\n\n<ul>\n<li><strong>Opening</strong>: When Terraform needs the result of an ephemeral resource, it opens it — much like reading a secret from a secrets manager.</li>\n<li><strong>Renewing</strong>: If Terraform needs access to the ephemeral resource for longer than the remote system’s enforced expiration time, Terraform asks the provider to periodically renew it.</li>\n<li><strong>Closing</strong>: Once Terraform no longer needs an ephemeral resource, it closes it. This happens after the providers that depend on an ephemeral resource complete all of their work for the current Terraform run phase.</li>\n</ul>\n\n<p>All ephemeral resources implement a form of opening logic, but not all implement closing or renewing logic. Whether they do depends on the ephemeral nature of the resource — handling tunnel connections, for instance, may require periodic renewal and proper closure of the connection. Leasing a temporary set of credentials from Vault would similarly imply renewal and revocation of those credentials when they're no longer needed.</p>\n\n<h2>Persisting ephemeral secrets</h2>\n\n<p>Ephemerality in Terraform prevents introspection of the value itself, which is the expected and intended behavior. However, this could lead to a potential issue. When using the ephemeral random password, you’re generating a new secret that hasn’t been persisted to a secrets manager yet, so it’s important to store it to ensure it remains accessible. This is why, in the third code snippet above, we write the ephemeral random password to a secrets manager first and then fetch it from there during the apply stage using another ephemeral resource, effectively persisting an ephemeral secret to a secrets manager.</p>\n\n<p>However, if you’re reading existing secrets from a secrets manager that’s managed outside of the Terraform module you’re working in, there’s no need to persist them again.</p>\n\n<h2>Learn more about ephemeral values</h2>\n\n<p>For more information on working with ephemeral values, resources, and write-only arguments, check out the <a href=\"https://developer.hashicorp.com/terraform/language/resources/ephemeral\">ephemerality in resources</a> documentation. You can find detailed information on ephemeral resources in the <a href=\"https://developer.hashicorp.com/terraform/language/resources/ephemeral/reference\">ephemeral resource block</a> documentation, or learn more about write-only arguments in the <a href=\"https://developer.hashicorp.com/terraform/language/resources/ephemeral/write-only\">write-only arguments</a> documentation.</p>\n","author":"Bruno Schaatsbergen","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"6923e26f9a1a25b7fab18875323e53751c514ee6144b195053554ef512701117","category":"Tech"}