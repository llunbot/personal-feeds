{"title":"Building A Dynamic Header With Intersection Observer","link":"https://smashingmagazine.com/2021/07/dynamic-header-intersection-observer/","date":1626177600000,"content":"<p>The <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\">Intersection Observer API</a> is a JavaScript API that enables us to observe an element and detect when it passes a specified point in a scrolling container — often (but not always) the viewport — triggering a callback function.</p>\n<p>Intersection Observer can be considered more performant than listening for scroll events on the main thread, as it is asynchronous, and the callback will only fire when the element we’re observing meets the specified threshold, instead every time the scroll position is updated. In this article, we’ll walk through an example of how we can use Intersection Observer to build a fixed header component that changes when it intersects with different sections of the webpage.</p>\nBasic Usage\n<p>To use Intersection Observer, we need to first create a new observer, which takes two parameters: An object with the observer’s options, and the callback function that we want to execute whenever the element we’re observing (known as the observer target) intersects with the root (the scrolling container, which must be an ancestor of the target element).</p>\n<pre><code>const options = {\n  root: document.querySelector('[data-scroll-root]'),\n  rootMargin: '0px',\n  threshold: 1.0\n}\n\nconst callback = (entries, observer) =&gt; {\n  entries.forEach((entry) =&gt; console.log(entry))\n}\n\nconst observer = new IntersectionObserver(callback, options)\n</code></pre>\n\n<p>When we’ve created our observer, we then need to instruct it to watch a target element:</p>\n<pre><code>const targetEl = document.querySelector('[data-target]')\n\nobserver.observe(targetEl)\n</code></pre>\n\n<p>Any of the options values can be omitted, as they will fall back to their default values:</p>\n<pre><code>const options = {\n  rootMargin: '0px',\n  threshold: 1.0\n}\n</code></pre>\n\n<p>If no root is specified, then it will be classed as the browser viewport. The above code example shows the default values for both <code>rootMargin</code> and <code>threshold</code>. These can be hard to visualize, so are worth explaining:</p>\n<h3><code>rootMargin</code></h3>\n<p>The <code>rootMargin</code> value is a bit like adding CSS margins to the root element — and, just like margins, can take multiple values, including negative values. The target element will be considered to be intersecting relative to the margins. </p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/769b2733-5700-4d2d-a32f-6850a173abaa/1-dynamic-header-intersection-observer.png\" /></p>\n<p>That means that an element can technically be classed as “intersecting” even when it is out of view (if our scroll root is the viewport).</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a5908e69-f81a-4e1c-81e6-aae2f1b96a28/2-dynamic-header-intersection-observer.png\" /></p>\n<p><code>rootMargin</code> defaults to <code>0px</code>, but can take a string consisting of multiple values, just like using the <code>margin</code> property in CSS.</p>\n<h3><code>threshold</code></h3>\n<p>The <code>threshold</code> can consist of a single value or an array of values between 0 and 1. It represents the <strong>proportion of the element that must be within the root bounds for it to be considered intersecting</strong>. Using the default value of 1, the callback will fire when 100% of the target element is visible within the root.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b95822cd-d3e8-4b71-9d38-862e6d39990a/3-dynamic-header-intersection-observer.png\" /></p>\n<p>It’s not always easy to visualize when an element will be classed as visible using these options. I’ve built <a href=\"https://codepen.io/michellebarker/full/xxwLpRG\">a small tool</a> to help get to grips with Intersection Observer.</p>\nCreating The Header\n<p>Now that we’ve grasped the basic principles, let’s start building our dynamic header. We’ll start with a webpage divided up into sections. This image shows the complete layout of the page we’ll be building:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/886e6b93-48a4-4282-8823-a7bd9e74058c/4-dynamic-header-intersection-observer.png\" /></p>\n<p>I’ve included a demo at the end of this article, so feel free to <a href=\"https://codepen.io/michellebarker/pen/aee240bb09868abfc5854854cf0843e3\">jump straight to it</a> if you’re keen to unpick the code. (There’s also a <a href=\"https://github.com/mbarker84/smashing-io-header\">Github repository</a>.)</p>\n<p>Each section has a minimum height of <code>100vh</code> (although they could be longer, depending on content). Our header is fixed at the top of the page and stays in place as the user scrolls (using <code>position: fixed</code>). The sections have different colored backgrounds, and when they meet the header, the colors of the header change to complement those of the section. There is also a marker to show the current section the user is in, which slides along when the next section arrives.\nTo make it easier for us to get straight to the relevant code, I’ve set up a <a href=\"https://codepen.io/michellebarker/pen/488760bfec40302fcf0e8b7cd3e6093e\">minimal demo</a> with our starting point (before we start using the Intersection Observer API), in case you’d like to follow along.</p>\n<h3>Markup</h3>\n<p>We’ll start with the HTML for our header. This is going to be a fairly simple header with a home link and navigation, nothing especially fancy, but we’re going to use a couple of data attributes: <code>data-header</code> for the header itself (so we can target the element with JS), and three anchor links with the attribute <code>data-link</code>, which will scroll the user to the relevant section when clicked:</p>\n<pre><code>&lt;header data-header&gt;\n  &lt;nav class=\"header__nav\"&gt;\n    &lt;div class=\"header__left-content\"&gt;\n      &lt;a href=\"#0\"&gt;Home&lt;/a&gt;\n    &lt;/div&gt;\n    &lt;ul class=\"header__list\"&gt;\n      &lt;li&gt;\n        &lt;a href=\"#about-us\" data-link&gt;About us&lt;/a&gt;\n      &lt;/li&gt;\n      &lt;li&gt;\n        &lt;a href=\"#flavours\" data-link&gt;The flavours&lt;/a&gt;\n      &lt;/li&gt;\n      &lt;li&gt;\n        &lt;a href=\"#get-in-touch\" data-link&gt;Get in touch&lt;/a&gt;\n      &lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/nav&gt;\n&lt;/header&gt;\n</code></pre>\n\n<p>Next, the HTML for the rest of our page, which is divided up into sections. For brevity, I’ve only included the parts relevant to the article, but the full markup is included in the demo. Each section includes a data attribute specifying the name of the background color, and an <code>id</code> that corresponds to one of the anchor links in the header:</p>\n<pre><code>&lt;main&gt;\n  &lt;section data-section=\"raspberry\" id=\"home\"&gt;\n    &lt;!--Section content--&gt;\n  &lt;/section&gt;\n  &lt;section data-section=\"mint\" id=\"about-us\"&gt;\n    &lt;!--Section content--&gt;\n  &lt;/section&gt;\n  &lt;section data-section=\"vanilla\" id=\"the-flavours\"&gt;\n    &lt;!--Section content--&gt;\n  &lt;/section&gt;\n  &lt;section data-section=\"chocolate\" id=\"get-in-touch\"&gt;\n    &lt;!--Section content--&gt;\n  &lt;/section&gt;\n&lt;/main&gt;\n</code></pre>\n\n<p>We’ll position our header with CSS so that it will stay fixed at the top of the page as the user scrolls:</p>\n<pre><code>header {\n  position: fixed;\n  width: 100%;\n}\n</code></pre>\n\n<p>We’ll also give our sections a minimum height, and center the content. (This code isn’t necessary for the Intersection Observer to work, it’s just for the design.)</p>\n<pre><code>section {\n  padding: 5rem 0;\n  min-height: 100vh;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n</code></pre>\n\n<h3>iframe Warning</h3>\n<p>While building this Codepen demo, I ran into a perplexing issue where my Intersection Observer code that <em>should</em> have worked perfectly was failing to fire the callback at the correct point of the intersection but instead firing when the target element intersected with the viewport edge. After a bit of head-scratching, I realized that this was because in Codepen the content is loaded within an iframe, which is treated differently. (See the section of the MDN docs on <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\">Clipping and the intersection rectangle</a> for full details.)</p>\n<p>As a workaround, in the demo we can wrap our markup in another element, which will act as the scrolling container — the root in our IO options — rather than the browser viewport, as we might expect:</p>\n<pre><code>&lt;div class=\"scroller\" data-scroller&gt;\n  &lt;header data-header&gt;\n    &lt;!--Header content--&gt;\n  &lt;/header&gt;\n  &lt;main&gt;\n    &lt;!--Sections--&gt;\n  &lt;/main&gt;\n&lt;/div&gt;\n</code></pre>\n\n<p>If you want to see how to use the viewport as the root instead for the same demo, this is included in the <a href=\"https://github.com/mbarker84/smashing-io-header\">Github repository</a>.</p>\nCSS\n<p>In our CSS we’ll define some custom properties for the colors we’re using. We’ll also define two additional custom properties for the header text and background colors, and set some initial values. (We’re going to update these two custom properties for the different sections later on.)</p>\n<pre><code>:root {\n  --mint: #5ae8d5;\n  --chocolate: #573e31;\n  --raspberry: #f2308e;\n  --vanilla: #faf2c8;\n\n  --headerText: var(--vanilla);\n  --headerBg: var(--raspberry);\n}\n</code></pre>\n\n<p>We’ll use these custom properties in our header:</p>\n<pre><code>header {\n  background-color: var(--headerBg);\n  color: var(--headerText);\n}\n</code></pre>\n\n<p>We’ll also set the colors for our different sections. I’m using the data attributes as the selectors, but you could just as easily use a class if you prefer.</p>\n<pre><code>[data-section=\"raspberry\"] {\n  background-color: var(--raspberry);\n  color: var(--vanilla);\n}\n\n[data-section=\"mint\"]  {\n  background-color: var(--mint);\n  color: var(--chocolate);\n}\n\n[data-section=\"vanilla\"] {\n  background-color: var(--vanilla);\n  color: var(--chocolate);\n}\n\n[data-section=\"chocolate\"] {\n  background-color: var(--chocolate);\n  color: var(--vanilla);\n}\n</code></pre>\n\n<p>We can also set some styles for our header when each section is in view:</p>\n<pre><code>/* Header */\n[data-theme=\"raspberry\"]  {\n  --headerText: var(--raspberry);\n  --headerBg: var(--vanilla);\n}\n\n[data-theme=\"mint\"] {\n  --headerText: var(--mint);\n  --headerBg: var(--chocolate);\n}\n\n[data-theme=\"chocolate\"]  {\n  --headerText: var(--chocolate);\n  --headerBg: var(--vanilla);\n}\n</code></pre>\n\n<p>There’s a stronger case for using data attributes here because we’re going to toggle the <code>data-theme</code> attribute of the header upon each intersection.</p>\nCreating The Observer\n<p>Now that we have the basic HTML and CSS for our page set up, we can create an observer to watch for each of our sections coming into view. We want to fire a callback whenever a section comes into contact with the bottom of the header as we’re scrolling down the page. This means we need to set a negative root margin that corresponds to the height of the header.</p>\n<pre><code>const header = document.querySelector('[data-header]')\nconst sections = [...document.querySelectorAll('[data-section]')]\nconst scrollRoot = document.querySelector('[data-scroller]')\n\nconst options = {\n  root: scrollRoot,\n  rootMargin: `${header.offsetHeight * -1}px`,\n  threshold: 0\n}\n</code></pre>\n\n<p>We’re setting a threshold of <em>0</em>, as we want it to fire if <em>any</em> part of the section is intersecting with the root margin.</p>\n<p>First of all, we’ll create a callback to change the <code>data-theme</code> value of the header. (This is more straightforward than adding and removing classes, especially when our header element may have other classes applied.)</p>\n<pre><code>/* The callback that will fire on intersection */\nconst onIntersect = (entries) =&gt; {\n  entries.forEach((entry) =&gt; {\n    const theme = entry.target.dataset.section\n    header.setAttribute('data-theme', theme)\n  })\n}\n</code></pre>\n\n<p>Then we’ll create the observer to watch for the sections intersecting:</p>\n<pre><code>/* Create the observer */\nconst observer = new IntersectionObserver(onIntersect, options)\n\n/* Set our observer to observe each section */\nsections.forEach((section) =&gt; {\n  observer.observe(section)\n})\n</code></pre>\n\n<p>Now we should see our header colors update when each section meets the header.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/poPgpjZ\">Happy Face Ice Cream Parlour – Step 2</a> by <a href=\"https://codepen.io/michellebarker\">Michelle Barker</a>.</p>\n<p>However, you might notice that the colors aren’t updating correctly as we scroll down. In fact, the header is updating with the previous section’s colors each time! Scrolling upwards, on the other hand, it works perfectly. We need to determine the scroll direction and change the behavior accordingly.</p>\n<h3>Finding The Scroll Direction</h3>\n<p>We’ll set a variable in our JS for the direction of scroll, with an initial value of <code>'up'</code>, and another for the last known scroll position (<code>prevYPosition</code>). Then, within the callback, if the scroll position is greater than the previous value, we can set the <code>direction</code> value as <code>'down'</code>, or <code>'up'</code> if vice versa.</p>\n<pre><code>let direction = 'up'\nlet prevYPosition = 0\n\nconst setScrollDirection = () =&gt; {\n  if (scrollRoot.scrollTop &gt; prevYPosition) {\n    direction = 'down'\n  } else {\n    direction = 'up'\n  }\n\n  prevYPosition = scrollRoot.scrollTop\n}\n\nconst onIntersect = (entries, observer) =&gt; {\n  entries.forEach((entry) =&gt; {\n    setScrollDirection()\n\n    /* ... */\n  })\n}\n</code></pre>\n\n<p>We’ll also create a new function to update the header colors, passing in the target section as an argument:</p>\n<pre><code>const updateColors = (target) =&gt; {\n  const theme = target.dataset.section\n  header.setAttribute('data-theme', theme)\n}\n\nconst onIntersect = (entries) =&gt; {\n  entries.forEach((entry) =&gt; {\n    setScrollDirection()\n    updateColors(entry.target)\n  })\n}\n</code></pre>\n\n<p>So far we should see no change to the behavior of our header. But now that we know the scroll direction, we can pass in a different target for our <code>updateColors()</code> function. If the scroll direction is up, we’ll use the entry target. If it’s down, we’ll use the next section (if there is one).</p>\n<pre><code>const getTargetSection = (target) =&gt; {\n  if (direction === 'up') return target\n\n  if (target.nextElementSibling) {\n    return target.nextElementSibling\n  } else {\n    return target\n  }\n}\n\nconst onIntersect = (entries) =&gt; {\n  entries.forEach((entry) =&gt; {\n    setScrollDirection()\n\n    const target = getTargetSection(entry.target)\n    updateColors(target)\n  })\n}\n</code></pre>\n\n<p>There’s one more issue, however: the header will update not only when the section hits the header, but when the next element comes into view at the bottom of the viewport. This is because our observer fires the callback twice: once as the element is entering, and again as it’s leaving.</p>\n<p>To determine whether the header should update, we can use the <code>isIntersecting</code> key from the <code>entry</code> object. Let’s create another function to return a boolean value for whether the header colors should update:</p>\n<pre><code>const shouldUpdate = (entry) =&gt; {\n  if (direction === 'down' &amp;&amp; !entry.isIntersecting) {\n    return true\n  }\n\n  if (direction === 'up' &amp;&amp; entry.isIntersecting) {\n    return true\n  }\n\n  return false\n}\n</code></pre>\n\n<p>We’ll update our <code>onIntersect()</code> function accordingly:</p>\n<pre><code>const onIntersect = (entries) =&gt; {\n  entries.forEach((entry) =&gt; {\n    setScrollDirection()\n\n    /* Do nothing if no need to update */\n    if (!shouldUpdate(entry)) return\n\n    const target = getTargetSection(entry.target)\n    updateColors(target)\n  })\n}\n</code></pre>\n\n<p>Now our colors should update correctly. We can set a CSS transition, so that the effect is a little nicer:</p>\n<pre><code>header {\n  transition: background-color 200ms, color 200ms;\n}\n</code></pre>\n\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/bGWEaEa\">Happy Face Ice Cream Parlour – Step 3</a> by <a href=\"https://codepen.io/michellebarker\">Michelle Barker</a>.</p>\nAdding The Dynamic Marker\n<p>Next we’ll add a marker to the header that updates its position as we scroll to the different sections. We can use a pseudo-element for this, so we don’t need to add anything to our HTML. We’ll give it some simple CSS styling to position it at the top left of the header, and give it a background color. We’re using <code>currentColor</code> for this, as it will take on the value of the header text color:</p>\n<pre><code>header::after {\n  content: '';\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 0.4rem;\n  background-color: currentColor;\n}\n</code></pre>\n\n<p>We can use a custom property for the width, with a default value of 0. We’ll also use a custom property for the translate x value. We’re going to set the values for these in our callback function as the user scrolls.</p>\n<pre><code>header::after {\n  content: '';\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 0.4rem;\n  width: var(--markerWidth, 0);\n  background-color: currentColor;\n  transform: translate3d(var(--markerLeft, 0), 0, 0);\n}\n</code></pre>\n\n<p>Now we can write a function that will update the width and position of the marker at the point of intersection:</p>\n<pre><code>const updateMarker = (target) =&gt; {\n  const id = target.id\n\n  /* Do nothing if no target ID */\n  if (!id) return\n\n  /* Find the corresponding nav link, or use the first one */\n  let link = headerLinks.find((el) =&gt; {\n    return el.getAttribute('href') === `#${id}`\n  })\n\n  link = link || headerLinks[0]\n\n  /* Get the values and set the custom properties */\n  const distanceFromLeft = link.getBoundingClientRect().left\n\n  header.style.setProperty('--markerWidth', `${link.clientWidth}px`)\n  header.style.setProperty('--markerLeft', `${distanceFromLeft}px`)\n}\n</code></pre>\n\n<p>We can call the function at the same time we update the colors:</p>\n<pre><code>const onIntersect = (entries) =&gt; {\n  entries.forEach((entry) =&gt; {\n    setScrollDirection()\n\n    if (!shouldUpdate(entry)) return\n\n    const target = getTargetSection(entry.target)\n    updateColors(target)\n    updateMarker(target)\n  })\n}\n</code></pre>\n\n<p>We’ll also need to set an initial position for the marker, so it doesn’t just appear out of nowhere. When the document is loaded, we’ll call the <code>updateMarker()</code> function, using the first section as the target:</p>\n<pre><code>document.addEventListener('readystatechange', e =&gt; {\n  if (e.target.readyState === 'complete') {\n    updateMarker(sections[0])\n  }\n})\n</code></pre>\n\n<p>Finally, let’s add a CSS transition so that the marker slides across the header from one link to the next. As we’re transitioning the <code>width</code> property, we can use <code>will-change</code> to enable the browser to <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/will-change\">perform optimizations</a>.</p>\n<pre><code>header::after {\n  transition: transform 250ms, width 200ms, background-color 200ms;\n  will-change: width;\n}\n</code></pre>\n\nSmooth Scrolling\n<p>For a final touch, it would be nice if, when a user clicks a link, they’re scrolled smoothly down the page, instead of it jumping to the section. These days we can do it right in our CSS, no JS required! For a more accessible experience, it’s a good idea to respect the user's motion preferences by only implementing smooth scrolling if they haven’t specified a preference for reduced motion in their system settings:</p>\n<pre><code>@media (prefers-reduced-motion: no-preference) {\n  .scroller {\n    scroll-behavior: smooth;\n  }\n}\n</code></pre>\n\nFinal Demo\n<p>Putting all the above steps together results in the complete demo.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/XWRXVXQ\">Happy Face Ice Cream Parlour – Intersection Observer example</a> by <a href=\"https://codepen.io/michellebarker\">Michelle Barker</a>.</p>\nBrowser Support\n<p>Intersection Observer is <a href=\"https://caniuse.com/?search=intersection%20observer\">widely supported</a> in modern browsers. Where necessary it can be <a href=\"https://github.com/w3c/IntersectionObserver\">polyfilled</a> for older browsers — but I prefer to take a progressive enhancement approach where possible. In the case of our header, it would not be vastly detrimental to the user experience to provide a simple, unchanging version for non-supporting browsers.</p>\n<p>To detect if Intersection Observer is supported, we can use the following:</p>\n<div>\n <pre><code>if ('IntersectionObserver' in window &amp;&amp; 'IntersectionObserverEntry' in window &amp;&amp; 'intersectionRatio' in window.IntersectionObserverEntry.prototype) {\n  /<em> Code to execute if IO is supported </em>/\n} else {\n  /<em> Code to execute if not supported </em>/\n}\n</code></pre>\n</div>\n\nResources\n<p>Read more about Intersection Observer:</p>\n<ul>\n<li>Extensive documentation, with some practical examples from <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\">MDN</a></li>\n<li>Intersection Observer <a href=\"https://codepen.io/michellebarker/full/xxwLpRG\">visualiser tool</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API/Timing_element_visibility\">Timing Element Visibility with the Intersection Observer API</a> – another tutorial from MDN, that looks at how IO can be used to track ad visibility</li>\n<li><a href=\"https://www.smashingmagazine.com/2018/01/deferring-lazy-loading-intersection-observer-api/\">This article</a> by Denys Mishunov covers some other uses for IO, including lazy-loading assets. Although that’s less necessary now (thanks to the <code>loading</code> attribute), there’s still plenty to learn here.</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"fef1e79cb1a985855a2893a822e8bfa6593105b141f081f2a67ac3a27bd7614d","category":"Tech"}