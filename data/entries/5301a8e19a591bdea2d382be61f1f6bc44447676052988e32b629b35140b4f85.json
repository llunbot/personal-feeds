{"title":"Agents for Amazon Bedrock now support memory retention and code interpretation (preview)","link":"https://aws.amazon.com/blogs/aws/agents-for-amazon-bedrock-now-support-memory-retention-and-code-interpretation-preview/","date":1720627483000,"content":"<p>With <a href=\"https://aws.amazon.com/bedrock/agents/\">Agents for Amazon Bedrock</a>, <a href=\"https://aws.amazon.com/ai/generative-ai/\">generative artificial intelligence (AI)</a> applications can run multistep tasks across different systems and data sources. A couple of months back, we <a href=\"https://aws.amazon.com/blogs/aws/agents-for-amazon-bedrock-introducing-a-simplified-creation-and-configuration-experience/\">simplified the creation and configuration</a> of agents. Today, we are introducing in preview two new fully managed capabilities:</p> \n<p><strong>Retain memory across multiple interactions</strong> – Agents can now retain a summary of their conversations with each user and be able to provide a smooth, adaptive experience, especially for complex, multistep tasks, such as user-facing interactions and enterprise automation solutions like booking flights or processing insurance claims.</p> \n<p><strong>Support for code interpretation</strong> – Agents can now dynamically generate and run code snippets within a secure, sandboxed environment and be able to address complex use cases such as data analysis, data visualization, text processing, solving equations, and optimization problems. To make it easier to use this feature, we also added the ability to upload documents directly to an agent.</p> \n<p>Let’s see how these new capabilities work in more detail.</p> \n<p><span><strong>Memory retention across multiple interactions<br /> </strong></span>With memory retention, you can build agents that learn and adapt to each user’s unique needs and preferences over time. By maintaining a persistent memory, agents can pick up right where the users left off, providing a smooth flow of conversations and workflows, especially for complex, multistep tasks.</p> \n<p>Imagine a user booking a flight. Thanks to the ability to retain memory, the agent can learn their travel preferences and use that knowledge to streamline subsequent booking requests, creating a personalized and efficient experience. For example, it can automatically propose the right seat to a user or a meal similar to their previous choices.</p> \n<p>Using memory retention to be more context-aware also simplifies business process automation. For example, an agent used by an enterprise to process customer feedback can now be aware of previous and on-going interactions with the same customer without having to handle custom integrations.</p> \n<p>Each user’s conversation history and context are securely stored under a unique memory identifier (ID), ensuring complete separation between users. With memory retention, it’s easier to build agents that provide seamless, adaptive, and personalized experiences that continuously improve over time. Let’s see how this works in practice.</p> \n<p><span><strong>Using memory retention in Agents for Amazon Bedrock<br /> </strong></span>In the <a href=\"https://console.aws.amazon.com/bedrock\">Amazon Bedrock console</a>, I choose <strong>Agents</strong> from the <strong>Builder Tools</strong> section of the navigation pane and start creating an agent.</p> \n<p>For the agent, I use <strong>agent-book-flight</strong> as the name with this as description:</p> \n<p><code>Help book a flight.</code></p> \n<p>Then, in the agent builder, I select the <a href=\"https://aws.amazon.com/bedrock/claude/\">Anthropic’s Claude 3 Sonnet</a> model and enter these instructions:</p> \n<p><code>To book a flight, you should know the origin and destination airports and the day and time the flight takes off.</code></p> \n<p>In <strong>Additional settings</strong>, I enable <strong>User input</strong> to allow the agent to ask clarifying questions to capture necessary inputs. This will help when a request to book a flight misses some necessary information such as the origin and destination or the date and time of the flight.</p> \n<p>In the new <strong>Memory</strong> section, I enable memory to generate and store a session summary at the end of each session and use the default 30 days for memory duration.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/07/09/bedrock-agents-memory-settings-1.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/07/09/bedrock-agents-memory-settings-1.png\" alt=\"Console screenshot.\" width=\"1412\" height=\"768\" /></a></p> \n<p>Then, I add an action group to search and book flights. I use <strong>search-and-book-flights</strong> as name and this description:</p> \n<p><code>Search for flights between two destinations on a given day and book a specific flight.</code></p> \n<p>Then, I choose to define the action group with function details and then to create a new Lambda function. The Lambda function will implement the business logic for all the functions in this action group.</p> \n<p>I add two functions to this action group: one to search for flights and another to book flights.</p> \n<p>The first function is <strong>search-for-flights</strong> and has this description:</p> \n<p><code>Search for flights on a given date between two destinations.</code></p> \n<p>All parameters of this function are required and of type string. Here are the parameters’ names and descriptions:</p> \n<p><strong>origin_airport –</strong> <code>Origin IATA airport code</code><strong><br /> destination_airport – </strong><code>Destination IATA airport code</code><strong><br /> date –</strong> <code>Date of the flight in YYYYMMDD format</code></p> \n<p>The second function is <strong>book-flight</strong> and uses this description:</p> \n<p><code>Book a flight at a given date and time between two destinations.</code></p> \n<p>Again, all parameters are required and of type string. These are the names and descriptions for the parameters:</p> \n<p><strong>origin_airport</strong> – <code>Origin IATA airport code</code><br /> <strong>destination_airport</strong> – <code>Destination IATA airport code</code><br /> <strong>date</strong> – <code>Date of the flight in YYYYMMDD format</code><br /> <strong>time</strong> – <code>Time of the flight in HHMM format</code></p> \n<p>To complete the creation of the agent, I choose <strong>Create</strong>.</p> \n<p>To access the source code of the Lambda function, I choose the <strong>search-and-book-flights</strong> action group and then <strong>View</strong> (near the <strong>Select Lambda function</strong> settings). Normally, I’d use this Lambda function to integrate with an existing system such as a travel booking platform. In this case, I use this code to simulate a booking platform for the agent.</p> \n<pre><code>import json\nimport random\nfrom datetime import datetime, time, timedelta\n\n\ndef convert_params_to_dict(params_list):\n    params_dict = {}\n    for param in params_list:\n        name = param.get(\"name\")\n        value = param.get(\"value\")\n        if name is not None:\n            params_dict[name] = value\n    return params_dict\n\n\ndef generate_random_times(date_str, num_flights, min_hours, max_hours):\n    # Set seed based on input date\n    seed = int(date_str)\n    random.seed(seed)\n\n    # Convert min_hours and max_hours to minutes\n    min_minutes = min_hours * 60\n    max_minutes = max_hours * 60\n\n    # Generate random times\n    random_times = set()\n    while len(random_times) &lt; num_flights:\n        minutes = random.randint(min_minutes, max_minutes)\n        hours, mins = divmod(minutes, 60)\n        time_str = f\"{hours:02d}{mins:02d}\"\n        random_times.add(time_str)\n\n    return sorted(random_times)\n\n\ndef get_flights_for_date(date):\n    num_flights = random.randint(1, 6) # Between 1 and 6 flights per day\n    min_hours = 6 # 6am\n    max_hours = 22 # 10pm\n    flight_times = generate_random_times(date, num_flights, min_hours, max_hours)\n    return flight_times\n    \n    \ndef get_days_between(start_date, end_date):\n    # Convert string dates to datetime objects\n    start = datetime.strptime(start_date, \"%Y%m%d\")\n    end = datetime.strptime(end_date, \"%Y%m%d\")\n    \n    # Calculate the number of days between the dates\n    delta = end - start\n    \n    # Generate a list of all dates between start and end (inclusive)\n    date_list = [start + timedelta(days=i) for i in range(delta.days + 1)]\n    \n    # Convert datetime objects back to \"YYYYMMDD\" string format\n    return [date.strftime(\"%Y%m%d\") for date in date_list]\n\n\ndef lambda_handler(event, context):\n    print(event)\n    agent = event['agent']\n    actionGroup = event['actionGroup']\n    function = event['function']\n    param = convert_params_to_dict(event.get('parameters', []))\n\n    if actionGroup == 'search-and-book-flights':\n        if function == 'search-for-flights':\n            flight_times = get_flights_for_date(param['date'])\n            body = f\"On {param['date']} (YYYYMMDD), these are the flights from {param['origin_airport']} to {param['destination_airport']}:\\n{json.dumps(flight_times)}\"\n        elif function == 'book-flight':\n            body = f\"Flight from {param['origin_airport']} to {param['destination_airport']} on {param['date']} (YYYYMMDD) at {param['time']} (HHMM) booked and confirmed.\"\n        elif function == 'get-flights-in-date-range':\n            days = get_days_between(param['start_date'], param['end_date'])\n            flights = {}\n            for day in days:\n                flights[day] = get_flights_for_date(day)\n            body = f\"These are the times (HHMM) for all the flights from {param['origin_airport']} to {param['destination_airport']} between {param['start_date']} (YYYYMMDD) and {param['end_date']} (YYYYMMDD) in JSON format:\\n{json.dumps(flights)}\"\n        else:\n            body = f\"Unknown function {function} for action group {actionGroup}.\"\n    else:\n        body = f\"Unknown action group {actionGroup}.\"\n    \n    # Format the output as expected by the agent\n    responseBody =  {\n        \"TEXT\": {\n            \"body\": body\n        }\n    }\n\n    action_response = {\n        'actionGroup': actionGroup,\n        'function': function,\n        'functionResponse': {\n            'responseBody': responseBody\n        }\n\n    }\n\n    function_response = {'response': action_response, 'messageVersion': event['messageVersion']}\n    print(f\"Response: {function_response}\")\n\n    return function_response</code></pre> \n<p>I prepare the agent to test it in the console and ask this question:</p> \n<p><code>Which flights are available from London Heathrow to Rome Fiumicino on July 20th, 2024?</code></p> \n<p>The agent replies with a list of times. I choose <strong>Show trace</strong> to get more information about how the agent processed my instructions.</p> \n<p>In the <strong>Trace</strong> tab, I explore the trace steps to understand the chain of thought used by the agent’s orchestration. For example, here I see that the agent handled the conversion of the airport names to codes (LHR for London Heathrow, FCO for Rome Fiumicino) before calling the Lambda function.</p> \n<p>In the new <strong>Memory</strong> tab, I see what’s the content of the memory. The console uses a specific test memory ID. In an application, to keep memory separated for each user, I can use a different memory ID for every user.</p> \n<p>I look at the list of flights and ask to book one:</p> \n<p><code>Book the one at 6:02pm.</code></p> \n<p>The agent replies confirming the booking.</p> \n<p>After a few minutes, after the session has expired, I see a summary of my conversation in the <strong>Memory</strong> tab.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/07/09/bedrock-agents-memory-first-conversation-1.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/07/09/bedrock-agents-memory-first-conversation-1.png\" alt=\"Console screenshot.\" width=\"2312\" height=\"1224\" /></a></p> \n<p>I choose the broom icon to start with a new conversation and ask a question that, by itself, doesn’t provide a full context to the agent:</p> \n<p><code>Which other flights are available on the day of my flight?</code></p> \n<p>The agent recalls the flight that I booked from our previous conversation. To provide me with an answer, the agent asks me to confirm the flight details. Note that the Lambda function is just a simulation and didn’t store the booking information in any database. The flight details were retrieved from the agent’s memory.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/07/09/bedrock-agents-memory-second-conversation-2.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/07/09/bedrock-agents-memory-second-conversation-2.png\" alt=\"Console screenshot.\" width=\"2308\" height=\"1418\" /></a></p> \n<p>I confirm those values and get the list of the other flights with the same origin and destination on that day.</p> \n<p><code>Yes, please.</code></p> \n<p>To better demonstrate the benefits of memory retention, let’s call the agent using the <a href=\"https://aws.amazon.com/sdk-for-python/\">AWS SDK for Python (Boto3)</a>. To do so, I first need to create an agent alias and version. I write down the agent ID and the alias ID because they are required when invoking the agent.</p> \n<p>In the agent invocation, I add the new <code>memoryId</code> option to use memory. By including this option, I get two benefits:</p> \n<ul> \n <li>The memory retained for that <code>memoryId</code> (if any) is used by the agent to improve its response.</li> \n <li>A summary of the conversation for the current session is retained for that <code>memoryId</code> so that it can be used in another session.</li> \n</ul> \n<p>Using an AWS SDK, I can also get the content or delete the content of the memory for a specific <code>memoryId</code>.</p> \n<pre><code>import random\nimport string\nimport boto3\nimport json\n\nDEBUG = False # Enable debug to see all trace steps\nDATE_FORMAT = \"%Y-%m-%d %H:%M:%S\"\n\nAGENT_ID = 'URSVOGLFNX'\nAGENT_ALIAS_ID = 'JHLX9ERCMD'\n\nSESSION_ID_LENGTH = 10\nSESSION_ID = \"\".join(\n    random.choices(string.ascii_uppercase + string.digits, k=SESSION_ID_LENGTH)\n)\n\n# A unique identifier for each user\nMEMORY_ID = 'danilop-92f79781-a3f3-4192-8de6-890b67c63d8b' \nbedrock_agent_runtime = boto3.client('bedrock-agent-runtime', region_name='us-east-1')\n\n\ndef invoke_agent(prompt, end_session=False):\n    response = bedrock_agent_runtime.invoke_agent(\n        agentId=AGENT_ID,\n        agentAliasId=AGENT_ALIAS_ID,\n        sessionId=SESSION_ID,\n        inputText=prompt,\n        memoryId=MEMORY_ID,\n        enableTrace=DEBUG,\n        endSession=end_session,\n    )\n\n    completion = \"\"\n\n    for event in response.get('completion'):\n        if DEBUG:\n            print(event)\n        if 'chunk' in event:\n            chunk = event['chunk']\n            completion += chunk['bytes'].decode()\n\n    return completion\n\n\ndef delete_memory():\n    try:\n        response = bedrock_agent_runtime.delete_agent_memory(\n            agentId=AGENT_ID,\n            agentAliasId=AGENT_ALIAS_ID,\n            memoryId=MEMORY_ID,\n        )\n    except Exception as e:\n        print(e)\n        return None\n    if DEBUG:\n        print(response)\n\n\ndef get_memory():\n    response = bedrock_agent_runtime.get_agent_memory(\n        agentId=AGENT_ID,\n        agentAliasId=AGENT_ALIAS_ID,\n        memoryId=MEMORY_ID,\n        memoryType='SESSION_SUMMARY',\n    )\n    memory = \"\"\n    for content in response['memoryContents']:\n        if 'sessionSummary' in content:\n            s = content['sessionSummary']\n            memory += f\"Session ID {s['sessionId']} from {s['sessionStartTime'].strftime(DATE_FORMAT)} to {s['sessionExpiryTime'].strftime(DATE_FORMAT)}\\n\"\n            memory += s['summaryText'] + \"\\n\"\n    if memory == \"\":\n        memory = \"&lt;no memory&gt;\"\n    return memory\n\n\ndef main():\n    print(\"Delete memory? (y/n)\")\n    if input() == 'y':\n        delete_memory()\n\n    print(\"Memory content:\")\n    print(get_memory())\n\n    prompt = input('&gt; ')\n    if len(prompt) &gt; 0:\n        print(invoke_agent(prompt, end_session=False)) # Start a new session\n        invoke_agent('end', end_session=True) # End the session\n\nif __name__ == \"__main__\":\n    main()</code></pre> \n<p>I run the Python script from my laptop. I choose to delete the current memory (even if it should be empty for now) and then ask to book a morning flight on a specific date.</p> \n<p><code>Delete memory? (y/n)</code><br /> <code>y</code><br /> <code>Memory content:</code><br /> <code>&lt;no memory&gt;</code><br /> <code>&gt; Book me on a morning flight on July 20th, 2024 from LHR to FCO.</code><br /> <code>I have booked you on the morning flight from London Heathrow (LHR) to Rome Fiumicino (FCO) on July 20th, 2024 at 06:44.</code></p> \n<p>I wait a couple of minutes and run the script again. The script creates a new session every time it’s run. This time, I don’t delete memory and see the summary of my previous interaction with the same <code>memoryId</code>. Then, I ask on which date my flight is scheduled. Even though this is a new session, the agent finds the previous booking in the content of the memory.</p> \n<p><code>Delete memory? (y/n)</code><br /> <code>n</code><br /> <code>Memory content:</code><br /> <code>Session ID MM4YYW0DL2 from 2024-07-09 15:35:47 to 2024-07-09 15:35:58</code><br /> <code>The user's goal was to book a morning flight from LHR to FCO on July 20th, 2024. The assistant booked a 0644 morning flight from LHR to FCO on the requested date of July 20th, 2024. The assistant successfully booked the requested morning flight for the user. The user requested a morning flight booking on July 20th, 2024 from London Heathrow (LHR) to Rome Fiumicino (FCO). The assistant booked a 0644 flight for the specified route and date.</code></p> \n<p><code>&gt; Which date is my flight on? </code><br /> <code>I recall from our previous conversation that you booked a morning flight from London Heathrow (LHR) to Rome Fiumicino (FCO) on July 20th, 2024. Please confirm if this date of July 20th, 2024 is correct for the flight you are asking about.</code></p> \n<p>Yes, that’s my flight!</p> \n<p>Depending on your use case, memory retention can help track previous interactions and preferences from the same user and provide a seamless experience across sessions.</p> \n<p>A session summary includes a general overview and the points of view of the user and the assistant. For a short session as this one, this can cause some repetition.</p> \n<p><span><strong>Code interpretation support<br /> </strong></span>Agents for Amazon Bedrock now supports code interpretation, so that agents can dynamically generate and run code snippets within a secure, sandboxed environment, significantly expanding the use cases they can address, including complex tasks such as data analysis, visualization, text processing, equation solving, and optimization problems.</p> \n<p>Agents are now able to process input files with diverse data types and formats, including CSV, XLS, YAML, JSON, DOC, HTML, MD, TXT, and PDF. Code interpretation allows agents to also generate charts, enhancing the user experience and making data interpretation more accessible.</p> \n<p>Code interpretation is used by an agent when the large language model (LLM) determines it can help solve a specific problem more accurately and does not support by design scenarios where users request arbitrary code generation. For security, each user session is provided with an isolated, sandboxed code runtime environment.</p> \n<p>Let’s do a quick test to see how this can help an agent handle complex tasks.</p> \n<p><span><strong>Using code interpretation in Agents for Amazon Bedrock<br /> </strong></span>In the <a href=\"https://console.aws.amazon.com/bedrock\">Amazon Bedrock console</a>, I select the same agent from the previous demo (<strong>agent-book-flight</strong>) and choose <strong>Edit in Agent Builder</strong>. In the agent builder, I enable <strong>Code Interpreter</strong> under <strong>Additional Settings</strong> and save.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/07/09/bedrock-agents-code-interpreter-settings-1.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/07/09/bedrock-agents-code-interpreter-settings-1.png\" alt=\"Console screenshot.\" width=\"1362\" height=\"346\" /></a></p> \n<p>I prepare the agent and test it straight in the console. First, I ask a mathematical question.</p> \n<p><code>Compute the sum of the first 10 prime numbers.</code></p> \n<p>After a few seconds, I get the answer from the agent:</p> \n<p><code>The sum of the first 10 prime numbers is 129.</code></p> \n<p>That’s accurate. Looking at the traces, the agent built and ran this Python program to compute what I asked:</p> \n<pre><code>import math\n\ndef is_prime(n):\n    if n &lt; 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\nprimes = []\nn = 2\nwhile len(primes) &lt; 10:\n    if is_prime(n):\n        primes.append(n)\n    n += 1\n    \nprint(f\"The first 10 prime numbers are: {primes}\")\nprint(f\"The sum of the first 10 prime numbers is: {sum(primes)}\")</code></pre> \n<p>Now, let’s go back to the <strong>agent-book-flight</strong> agent. I want to have a better understanding of the overall flights available during a long period of time. To do so, I start by adding a new function to the same action group to get all the flights available in a date range.</p> \n<p>I name the new function <strong>get-flights-in-date-range</strong> and use this description:</p> \n<p><code>Get all the flights between two destinations for each day in a date range.</code></p> \n<p>All the parameters are required and of type string. These are the parameters names and descriptions:</p> \n<p><strong>origin_airport</strong> – <code>Origin IATA airport code</code><br /> <strong>destination_airport</strong> – <code>Destination IATA airport code</code><br /> <strong>start_date – </strong><code>Start date of the flight in YYYYMMDD format</code><strong><br /> </strong><strong>end_date</strong> – <code>End date of the flight in YYYYMMDD format</code></p> \n<p>If you look at the Lambda function code I shared earlier, you’ll find that it already supports this agent function.</p> \n<p>Now that the agent has a way to extract more information with a single function call, I ask the agent to visualize flight information data in a chart:</p> \n<p><code>Draw a chart with the number of flights each day from JFK to SEA for the first ten days of August, 2024.</code></p> \n<p>The agent reply includes a chart:</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/07/09/bedrock-agents-code-interpreter-chart-1.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/07/09/bedrock-agents-code-interpreter-chart-1.png\" alt=\"Console screenshot.\" width=\"978\" height=\"1436\" /></a></p> \n<p>I choose the link to download the image on my computer:</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/07/09/flights_chart-1.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/07/09/flights_chart-1.png\" alt=\"Flight chart.\" width=\"1000\" height=\"600\" /></a></p> \n<p>That’s correct. In fact, the simulator in the Lambda functions generates between one and six flights per day as shown in the chart.</p> \n<p><strong><span>Using code interpretation with attached files<br /> </span></strong>Because code interpretation allows agents to process and extract information from data, we introduced the capability to include documents when invoking an agent. For example, I have an Excel file with the number of flights booked for different flights:</p> \n<table> \n <tbody> \n  <tr> \n   <td><strong>Origin</strong></td> \n   <td><strong>Destination</strong></td> \n   <td><strong>Number of flights</strong></td> \n  </tr> \n  <tr> \n   <td>LHR</td> \n   <td>FCO</td> \n   <td>636</td> \n  </tr> \n  <tr> \n   <td>FCO</td> \n   <td>LHR</td> \n   <td>456</td> \n  </tr> \n  <tr> \n   <td>JFK</td> \n   <td>SEA</td> \n   <td>921</td> \n  </tr> \n  <tr> \n   <td>SEA</td> \n   <td>JFK</td> \n   <td>544</td> \n  </tr> \n </tbody> \n</table> \n<p>Using the clip icon in the test interface, I attach the file and ask (the agent replies in <strong>bold</strong>):</p> \n<p><code>What is the most popular route? And the least one?</code></p> \n<p><strong>Based on the analysis, the most popular route is JFK -&gt; SEA with 921 bookings, and the least popular route is FCO -&gt; LHR with 456 bookings.</strong></p> \n<p><code>How many flights in total have been booked?</code></p> \n<p><strong>The total number of booked flights across all routes is 2557.</strong></p> \n<p><code>Draw a chart comparing the % of flights booked for these routes compared to the total number.</code></p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/07/03/bookings_chart.png\"><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2024/07/03/bookings_chart.png\" alt=\"Chart generated with Code Interpreter\" width=\"841\" height=\"547\" /></a></p> \n<p>I can look at the traces to see the Python code used to extract information from the file and pass it to the agent. I can attach more than one file and use different file formats. These options are available in AWS SDKs to let agents use files in your applications.</p> \n<p><span><strong>Things to Know<br /> </strong></span>Memory retention is available in preview in all <a href=\"https://aws.amazon.com/about-aws/global-infrastructure/regions_az/\">AWS Regions</a> where <a href=\"https://aws.amazon.com/bedrock/agents/\">Agents for Amazon Bedrocks</a> and Anthropic’s Claude 3 Sonnet or Haiku (the models supported during the preview) are available. Code interpretation is available in preview in the US East (N. Virginia), US West (Oregon), and Europe (Frankfurt) Regions.</p> \n<p>There are no additional costs during the preview for using memory retention and code interpretation with your agents. When using agents with these features, normal model use charges apply. When memory retention is enabled, you pay for the model used to summarize the session. For more information, see the <a href=\"https://aws.amazon.com/bedrock/pricing/\">Amazon Bedrock Pricing</a> page.</p> \n<p>To learn more, see the <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/agents.html\">Agents for Amazon Bedrock section of the User Guide</a>. For deep-dive technical content and to discover how others are using generative AI in their solutions, visit <a href=\"https://community.aws/generative-ai?trk=4a84f0b4-a654-4729-9e51-6d6dc54134f2&amp;sc_channel=el\">community.aws</a>.</p> \n<p>— <a href=\"https://twitter.com/danilop\">Danilo</a></p>","author":"Danilo Poccia","siteTitle":"AWS News Blog","siteHash":"6093e072e4117ec22616e844cb857d03ca62c57a411a8affc77cb5e8b6b15bf6","entryHash":"5301a8e19a591bdea2d382be61f1f6bc44447676052988e32b629b35140b4f85","category":"Tech"}