{"title":"Building Future-Proof High-Performance Websites With Astro Islands And Headless CMS","link":"https://smashingmagazine.com/2023/02/building-future-proof-high-performance-websites-astro-islands-headless-cms-storyblok/","date":1677087000000,"content":"<p>This article is a sponsored by <a href=\"https://www.storyblok.com/?utm_source=smashmagazine&amp;utm_medium=article&amp;utm_campaign=astro_islands_headless_cms\">Storyblok</a></p>\n<p>Nowadays, web performance is one of <em>the</em> crucial factors for the success of any online project. Most of us have probably experienced the situation that you left a website due to its unbearable slowness. This is certainly frustrating for a website’s user, but even more so for its owner: in fact, there is a direct correlation between web performance and business revenue which has been corroborated time and again in a plethora of case studies.</p>\n<p>As developers, optimizing web performance must therefore be an integral part of our value proposition. However, before moving on, let’s actually define the term. According to the <a href=\"https://developer.mozilla.org/en-US/docs/Learn/Performance/What_is_web_performance\">MDN Web Docs</a>, “web performance is the objective measurement and perceived user experience of a website or application”. Primarily, it involves optimizing a site’s initial overall load time, making the site interactive as soon as possible, and ensuring it is enjoyable to use throughout.</p>\n<p>Achieving an excellent <em>measurable</em> performance as well as an outstanding <em>perceived</em> performance certainly constitutes a potentially very strenuous challenge for developers, especially when dealing with increasingly complex, large-scale websites. Fortunately, while it is easy to get lost in the subtle details of performance optimization measures, there are a few factors that should be the focus points of our efforts due to their extraordinarily high impact. One of these is image optimization, a topic that has been thoroughly covered in ‘A Guide To Image Optimization On Jamstack Sites’ <a href=\"https://www.smashingmagazine.com/2022/11/guide-image-optimization-jamstack-sites/\">by my colleague Alba Silvente</a>.</p>\n<p>Another key factor? Shipping less JavaScript (JS). A large JS bundle size takes longer to be transmitted, parsed, and executed. As a consequence, the initial page load and <a href=\"https://developer.chrome.com/en/docs/lighthouse/performance/interactive/\">Time to Interactive</a> can be delayed quite significantly. In recent years, we have witnessed the rise of extremely powerful JS frontend frameworks that offer client-side rendering and strive for an app-like experience. While their versatility, their features, and their developer experience is impressive by all means, they all share one major disadvantage in regard to performance optimization: their JS bundle size is comparably heavy, negatively impacting both the initial page load and the time-to-interactive quite substantially.</p>\n<p>Depending on the type of your project, the question arises whether a less JS-centric approach might be feasible. In fact, if you think of your average content-driven marketing website, you would probably conclude that only a fraction of the functionality <em>actually</em> relies on JavaScript, whereas the majority of the site could probably be rendered as static HTML.</p>\n<p>And that is precisely where Astro enters the game, shipping <em>zero</em> JS by default and letting you partially hydrate only those components that de facto rely on interactivity. Importantly, Astro accomplishes all of that without sacrificing the wonderful developer experience (DX) that we have been getting spoiled by, but actually even improving it. Let’s take a closer look.</p>\nIntroducing Astro\n<p><a href=\"https://docs.astro.build/en/concepts/why-astro/\">Astro defines itself as an</a> “all-in-one web framework for building fast, content-focused websites”. One of its key features is that it replaces unused JS with HTML on the server, effectively resulting in zero JavaScript runtime out-of-the-box. This, in turn, leads to very fast load times and quicker interactivity. Notably, Astro explicitly states that it is specifically designed for content-driven websites, such as marketing, documentation, or eCommerce sites. The Astro team transparently acknowledges that other frameworks may be a much better fit if your project classifies as a web application rather than a mostly content-driven site.</p>\n<p>Moreover, Astro provides a powerful <a href=\"https://docs.astro.build/en/concepts/islands/\">Islands architecture</a> that utilizes the technical concept of partial hydration. In a nutshell, this allows you to hydrate only those components that you actually need to be interactive. Importantly, this happens in isolation, leaving the rest of the site as static HTML. All in all, the impact on web performance is huge, making developers’ lives a lot easier along the way. And it gets even better: it is possible to bring your own framework. Thus, you could effortlessly use, for example, Vue, Svelte or React components in your Astro project.</p>\n<p>Speaking of isolated islands, it is worth pointing out that developers actually rarely work alone: most larger-scale web projects typically rely on close collaboration between teams of developers and content creators. Therefore, let’s explore how going Headless with Storyblok can improve the experience and productivity of everyone involved.</p>\nIntroducing Storyblok\n<p>Storyblok is a powerful headless CMS that meets the requirements of developers and content creators alike. Completely framework-agnostic, you can connect Storyblok and your favorite technology within minutes. Storyblok’s <a href=\"https://www.storyblok.com/docs/editor-guides/visual-editor?utm_source=smashmagazine&amp;utm_medium=article&amp;utm_campaign=astro_islands_headless_cms\">Visual Editor</a> allows you to create and manage your content with ease, even when dealing with complex layouts. Furthermore, localizing and personalizing your content becomes a breeze. Beyond that, Storyblok’s API-first design allows you to create outstanding cross-platform experiences.</p>\n<p>Let’s explore in a case study how we can effectively combine the power of Astro and Storyblok.</p>\nCase Study: Interactive Components In Storyblok And Astro\n<p>In this example, we will create a simple landing page consisting of a hero component and a tabbed content component. Whereas the former will be a basic Astro component, the latter will be rendered as a dynamic island. In order to demonstrate the flexibility of this technology stack, we will examine how to render the tabbed content component using both Vue and Svelte.</p>\n<p>This is what we will build:</p>\n<a href=\"https://files.smashing.media/articles/building-future-proof-high-performance-websites-astro-islands-headless-cms-storyblok/1-case-study-result.gif\"><img src=\"https://files.smashing.media/articles/building-future-proof-high-performance-websites-astro-islands-headless-cms-storyblok/1-case-study-result.gif\" /></a>(<a href=\"https://files.smashing.media/articles/building-future-proof-high-performance-websites-astro-islands-headless-cms-storyblok/1-case-study-result.gif\">Large preview</a>)\n\n<h3>Step 1: Create The Astro Project And The Storyblok Space</h3>\n<p>Once we’ve created an account on <a href=\"https://www.storyblok.com/?utm_source=smashmagazine&amp;utm_medium=article&amp;utm_campaign=astro_islands_headless_cms\">Storyblok</a> (the Community plan is free forever), we can create a new space.</p>\n<p><img src=\"https://files.smashing.media/articles/building-future-proof-high-performance-websites-astro-islands-headless-cms-storyblok/2-new-space.png\" /></p>\n<p>Now, we can copy and run the command to run Storyblok’s CLI in order to quickly create a project that is connected to your fresh new space:</p>\n<pre><code>npx @storyblok/create-demo@latest --key &lt;your-access-token&gt;\n</code></pre>\n\n<p>You can copy the complete command, including your personal access token, from the <strong>Get Started</strong> section of your space:</p>\n<p><img src=\"https://files.smashing.media/articles/building-future-proof-high-performance-websites-astro-islands-headless-cms-storyblok/3-create-demo-cli.png\" /></p>\n<p>In the scaffolding steps, choose Astro, the package manager of your choice, the region of your space, and a local folder for your project. Now, in your chosen folder, you can run <code>npm install &amp;&amp; npm run dev</code> to install all dependencies and launch the development server.</p>\n<p>For the Storyblok Visual Editor to work, we need to go to <strong>Settings &gt; Visual Editor</strong> and specify <code>https://127.0.0.1:3000/</code> as the default environment.</p>\n<p><img src=\"https://files.smashing.media/articles/building-future-proof-high-performance-websites-astro-islands-headless-cms-storyblok/4-set-up-visual-editor.png\" /></p>\n<p>Next, let’s go to the <strong>Content</strong> section and open our <strong>Home</strong> story. Here, we need to open the <strong>Entry configuration</strong> and set the <strong>Real path</strong> to <code>/</code> in order for <code>src/pages/index.astro</code> to be able to load this story correctly.</p>\n<p><img src=\"https://files.smashing.media/articles/building-future-proof-high-performance-websites-astro-islands-headless-cms-storyblok/5-set-real-path.png\" /></p>\n<p>After having saved, you should now see the page being rendered correctly in the Visual Editor.</p>\n<p><img src=\"https://files.smashing.media/articles/building-future-proof-high-performance-websites-astro-islands-headless-cms-storyblok/6-hello-world.png\" /></p>\n<p>Perfect, we’re ready to move on.</p>\n<h3>Step 2: Create The Hero Component In Storyblok</h3>\n<p>In the <strong>Block Library</strong>, which you can easily access from within your <strong>Home</strong> story, you will find four default components. Let’s delete all of the nestable blocks (<strong>Grid</strong>, <strong>Teaser</strong>, and <strong>Feature</strong>). For our case study, we just need the <strong>Page</strong> content type block.</p>\n<p>Note: In order to learn more about nestable and content type blocks, you can read the <a href=\"https://www.storyblok.com/docs/guide/essentials/content-structures#component?utm_source=smashmagazine&amp;utm_medium=article&amp;utm_campaign=astro_islands_headless_cms\">Structures of Content tutorial</a>.</p>\n<p>Now, we can create the first component that we will need for our case study: A <strong>nestable</strong> block called Hero (<code>hero</code>) and the following fields:</p>\n<ul>\n<li><code>caption</code> (Text)</li>\n<li><code>image</code> (Asset &gt; Images)</li>\n</ul>\n<p><img src=\"https://files.smashing.media/articles/building-future-proof-high-performance-websites-astro-islands-headless-cms-storyblok/7-hero-schema.png\" /></p>\n<p>Next, close the <strong>Block Library</strong>, delete the instances of the <strong>Teaser</strong> and <strong>Grid</strong> blocks, and create a <strong>Hero</strong>, providing any caption and image of your choice.</p>\n<h3>Step 3: Create The Hero Component In Astro</h3>\n<p>The next step is to create a matching counterpart for our <strong>Hero</strong> component in our Astro project. Let’s open up the project.</p>\n<p>First of all, let’s modify <code>astro.config.mjs</code> in order to register our <strong>Hero</strong> component properly:</p>\n<div>\n\n <pre><code>storyblok({\n  accessToken: '&lt;your-access-token&gt;', // ideally, you would want to use an environment variable for the token\n  components: {\n    page: 'storyblok/Page',\n    hero: 'storyblok/Hero',\n  },\n})\n</code></pre>\n</div>\n\n<p>Next, let’s delete the <strong>Grid</strong>, <strong>Feature</strong> and <strong>Teaser</strong> components in <code>src/storyblok</code> and create a new <code>src/storyblok/Hero.astro</code> component with the following content:</p>\n<div>\n\n <pre><code>---\nimport { storyblokEditable } from '@storyblok/astro'\n\nconst { blok } = Astro.props\n---\n\n&lt;section\n  {...storyblokEditable(blok)}\n  class='relative w-full h-[50vh] min-h-[400px] max-h-[800px] flex items-center justify-center'\n&gt;\n  &lt;h2 class='relative z-10 text-white text-7xl'&gt;{blok.caption}&lt;/h2&gt;\n  &lt;img\n    src={blok.image?.filename}\n    alt={blok.image?.alt}\n    class='absolute top-0 left-0 object-cover w-full h-full z-0'\n  /&gt;\n&lt;/section&gt;\n</code></pre>\n</div>\n\n<p>Having taken care of that, the <strong>Hero</strong> block should now be displayed correctly in your <strong>Home</strong> story. In this particular case, we are using a native Astro component, which means that this component will be rendered as static HTML, requiring <em>zero</em> JS!</p>\n<p>Amazing, but what happens if you actually need interactivity on your frontend? This is precisely where dynamic islands come into play, which we will explore next.</p>\n<h3>Step 4: Create The Tabbed Content Component In Storyblok</h3>\n<p>Let’s proceed by creating the blocks that we need for our tabbed content component, which will have a slightly more complex setup.</p>\n<p>First of all, we want to create a new nestable block <strong>Tabbed Content Entry</strong> (<code>tabbed_content_entry</code>) with the following fields:</p>\n<ul>\n<li><code>headline</code> (Text)</li>\n<li><code>description</code> (Textarea)</li>\n<li><code>image</code> (Asset &gt; Images)</li>\n</ul>\n<p><img src=\"https://files.smashing.media/articles/building-future-proof-high-performance-websites-astro-islands-headless-cms-storyblok/8-tabbed-content-entry-schema.png\" /></p>\n<p>This nestable block will be used in superordinate nestable block called <strong>Tabbed Content</strong> (<code>tabbed_content</code>) consisting of these fields:</p>\n<ul>\n<li><code>entries</code> (Blocks &gt; Allow only <code>tabbed_content_entry</code> components to be inserted)</li>\n<li><code>directive</code> (Single-Option &gt; Source: Self) with the key-value pair options: load → <code>load</code> and idle → <code>idle</code>, and visible → <code>visible</code> (Default: <code>idle</code>)</li>\n</ul>\n<p><img src=\"https://files.smashing.media/articles/building-future-proof-high-performance-websites-astro-islands-headless-cms-storyblok/9-tabbed-content-schema.png\" /></p>\n<p>The <code>entries</code> field is used to allow nesting of the previously created <strong>Tabbed Content Entry</strong> nestable blocks. In order to prevent any kind of block could get inserted, we can limit it to blocks of the type <code>tabbed_content_entry</code>.</p>\n<p>Additionally, the <code>directive</code> field is used to take advantage of <a href=\"https://docs.astro.build/en/reference/directives-reference/#client-directives\">Astro’s client directives</a>, which determine if and when a framework component should be hydrated. Utilizing the single-option field type in Storyblok enables content creators to choose whether this particular instance of the component should be hydrated with the highest priority (<code>load</code>), after the initial page load has been completed (<code>idle</code>), or as soon as the component instance actually enters the viewport (<code>visible</code>).</p>\n<p>Utilizing Astro’s <code>visible</code> directive would result in the biggest performance gain as long as the component is below the fold. As the default option, we will use Astro’s <code>idle</code> directive, hydrating the component immediately on page load. However, in all cases, the rest of our landing page will remain as static HTML. As a result, the out-of-the-box performance should theoretically always be superior when compared to alternative frameworks.</p>\n<p>Before moving on, we can use our newly created <strong>Tabbed Content</strong> component and insert three example entries in the <code>entries</code> field.</p>\n<h3>Step 5: Create The Tabbed Content Component In Astro</h3>\n<p>First of all, let’s register our <strong>Tabbed Content</strong> component in our <code>astro.config.mjs</code>:</p>\n<div>\n\n <pre><code>storyblok({\n  accessToken: '&lt;your-access-token&gt;',\n  components: {\n    page: 'storyblok/Page',\n    hero: 'storyblok/Hero',\n    tabbed_content: 'storyblok/TabbedContent',\n  },\n}),\n</code></pre>\n</div>\n\n<p>Next, let’s create <code>storyblok/TabbedContent.astro</code> with the following preliminary content:</p>\n<div>\n\n <pre><code>---\nimport { storyblokEditable } from '@storyblok/astro'\n\nconst { blok } = Astro.props\n---\n\n&lt;section {...storyblokEditable(blok)}&gt;&lt;/section&gt;\n</code></pre>\n</div>\n\n<p>This will serve as our wrapper component, wherein we can subsequently import the actual component using the UI framework of our choice and dynamically assign a client directive derived from the value we receive from Storyblok. </p>\n<h3>Step 6: Render the Tabbed Content Component using Vue</h3>\n<p>With everything in place, we can now start building our tabbed content component using Vue. First, we need to install Vue in our project. Fortunately, Astro makes that very simple for us. All we have to do is to run the following command:</p>\n<pre><code>npx astro add vue\n</code></pre>\n\n<p>Next, let’s create a new Vue component (<code>storyblok/TabbedContent.vue</code>) with the following content:</p>\n<div>\n\n <pre><code>&lt;script setup lang=\"ts\"&gt;\nimport { ref } from 'vue'\nconst props = defineProps({ blok: Object })\n\nconst activeTab = ref(0)\n\nconst setActiveTab = (index) =&gt; {\n  activeTab.value = index\n}\n\nconst tabWidth = ref(100 / props.blok.entries.length)\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;ul class=\"relative border-b border-gray-900 mb-8 flex\"&gt;\n    &lt;li\n      v-for=\"(entry, index) in blok.entries\"\n      :key=\"entry._uid\"\n      :style=\"'width:' + tabWidth + '%'\"\n    &gt;\n      &lt;button\n        @click.prevent=\"setActiveTab(index)\"\n        class=\"cursor-pointer p-3 text-center\"\n        :class=\"index === activeTab ? 'font-bold' : ''\"\n      &gt;\n        {{ entry.headline }}\n      &lt;/button&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n  &lt;section\n    v-for=\"(entry, index) in blok.entries\"\n    :key=\"entry._uid\"\n    :id=\"'entry-' + entry._uid\"\n  &gt;\n    &lt;div v-if=\"index === activeTab\" class=\"grid grid-cols-2 gap-12\"&gt;\n      &lt;div&gt;\n        &lt;p&gt;{{ entry.description }}&lt;/p&gt;\n        &lt;a\n          :href=\"entry.link?.cached_url\"\n          class=\"inline-flex bg-gray-900 text-white py-3 px-6 mt-6\"\n          &gt;Explore {{ entry.headline }}&lt;/a\n        &gt;\n      &lt;/div&gt;\n      &lt;img :src=\"entry.image?.filename\" :alt=\"entry.image?.alt\" /&gt;\n    &lt;/div&gt;\n  &lt;/section&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\nul:after {\n  content: '';\n  @apply absolute bottom-0 left-0 h-0.5 bg-gray-900 transition-all duration-500;\n  width: v-bind(tabWidth + '%');\n  margin-left: v-bind(activeTab * tabWidth + '%');\n}\n&lt;/style&gt;\n</code></pre>\n</div>\n\n<p>Finally, we can import this component in <code>TabbedContent.astro</code>, pass the whole <code>blok</code> object as a property and assign the client directive based on the value we receive from Storyblok.</p>\n<div>\n\n <pre><code>---\nimport { storyblokEditable } from '@storyblok/astro'\nimport TabbedContent from './TabbedContent.vue'\n\nconst { blok } = Astro.props\n---\n\n&lt;section {...storyblokEditable(blok)} class='container py-12'&gt;\n  {blok.directive === 'load' &amp;&amp; &lt;TabbedContent blok={blok} client:load /&gt;}\n  {blok.directive === 'idle' &amp;&amp; &lt;TabbedContent blok={blok} client:idle /&gt;}\n  {blok.directive === 'visible' &amp;&amp; &lt;TabbedContent blok={blok} client:visible /&gt;}\n&lt;/section&gt;\n</code></pre>\n</div>\n\n<p>Furthermore, our Astro wrapper component is the right place to assign a client directive to the Vue component. Since we would like to give the content creators the possibility to choose between different directives, we need to assign them based on the value we retrieve from Storyblok.</p>\n<p>Our tabbed content component will now be rendered correctly. Using Astro’s dynamic islands and hydration directives can tremendously boost your site’s performance, and combined with Storyblok, you provide content creators with straightforward and easy-to-use possibilities to tap into the power of this next-gen approach. </p>\n<p>Let’s conclude our case study by examining how to render the very same component with Svelte (or any other popular framework <a href=\"https://docs.astro.build/en/core-concepts/framework-components/\">supported by Astro</a>).</p>\n<h3>Step 7: Render The Tabbed Content Component Using Svelte</h3>\n<p>First of all, as before, we need to install Svelte in our Astro project. Again, we can easily accomplish that by running the following command:</p>\n<pre><code>npx astro add svelte\n</code></pre>\n\n<p>Now, we can create the Svelte component (<code>storyblok/TabbedContent.svelte</code>) with the following content:</p>\n<div>\n\n <pre><code>&lt;script&gt;\n  export let blok\n\n  let tabWidth = 100 / blok.entries.length\n  let activeTab = 0\n  let marginLeft = 0\n\n  const setActiveTab = (index) =&gt; {\n    activeTab = index\n    marginLeft = activeTab * tabWidth\n  }\n&lt;/script&gt;\n\n&lt;ul\n  class=\"relative border-b border-gray-900 mb-8 flex\"\n  style=\"--tab-width: {tabWidth}%; --margin-left: {marginLeft}%;\"\n&gt;\n  {#each blok.entries as entry, index (entry._uid)}\n    &lt;li style=\"width: var(--tab-width)\"&gt;\n      &lt;button\n        class=\"{index === activeTab\n          ? 'font-bold'\n          : ''} w-full cursor-pointer p-3 text-center\"\n        on:click={() =&gt; setActiveTab(index)}&gt;{entry.headline}&lt;/button\n      &gt;\n    &lt;/li&gt;\n  {/each}\n&lt;/ul&gt;\n{#each blok.entries as entry, index (entry._uid)}\n  {#if index === activeTab}\n    &lt;section id={entry._uid}&gt;\n      &lt;div class=\"grid grid-cols-2 gap-12\"&gt;\n        &lt;div&gt;\n          &lt;p&gt;{entry.description}&lt;/p&gt;\n          &lt;a\n            href={entry.link?.cached_url}\n            class=\"inline-flex bg-gray-900 text-white py-3 px-6 mt-6\"\n            &gt;Explore {entry.headline}&lt;/a\n          &gt;\n        &lt;/div&gt;\n        &lt;img src={entry.image?.filename} alt={entry.image?.alt} /&gt;\n      &lt;/div&gt;\n    &lt;/section&gt;\n  {/if}\n{/each}\n\n&lt;style&gt;\n  ul:after {\n    content: '';\n    @apply absolute bottom-0 left-0 h-0.5 bg-gray-900 transition-all duration-500;\n    width: var(--tab-width);\n    margin-left: var(--margin-left);\n  }\n&lt;/style&gt;\n</code></pre>\n</div>\n\n<p>The only change that we have to make in order to load the Svelte component instead of the Vue component can easily be completed by simply changing the import in <code>TabbedContent.astro</code>:</p>\n<pre><code>//import TabbedContent from './TabbedContent.vue'\nimport TabbedContent from './TabbedContent.svelte'\n</code></pre>\n\n<p>And that’s it! Everything else can remain the same. Amazingly, our tabbed content component still works but is now using Svelte instead of Vue. Since Astro makes it possible to pass down the <code>blok</code> object, containing all of the data coming from Storyblok, as a property to the different framework components, we can simply reuse all of the information in various environments. </p>\nWrapping Up\n<p>With Astro, you as a developer benefit from phenomenal DX, mind-blowing performance out of the box, and a high degree of flexibility thanks to the possibility to bring your own component framework (or even combine multiple component frameworks) and the availability of integrations. Moreover, Astro is highly future-proof: Considering moving from Vue to Svelte? From React to Vue? Astro makes the transition seamless, keeping the foundation of your project the same.</p>\n<p>With Storyblok, your clients or fellow colleagues from the content marketing team get to enjoy a high degree of autonomy and flexibility, effectively utilizing the full potential of your Astro code base. Landing pages can be created in a matter of mere minutes, and dynamic, interactive components will have no negative impact on their performance.</p>\n<p>Taking everything into account, Astro and Storyblok may very well be the last technology stack you will ever need for your content-driven website projects.</p>\n<h4>Resources</h4>\n<ul>\n<li><a href=\"https://github.com/manuelschroederdev/astro-case-study-smashing-mag\">Astro Case Study Smashing Magazine</a> on GitHub</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"160f30303d29ebecaabfc8040fb896c82d21442d1f8d7ebe9713af027f3aa456","category":"Tech"}