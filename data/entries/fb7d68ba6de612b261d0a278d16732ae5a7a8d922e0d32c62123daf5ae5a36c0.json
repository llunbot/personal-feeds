{"title":"Recreating YouTube’s Ambient Mode Glow Effect","link":"https://smashingmagazine.com/2023/07/recreating-youtube-ambient-mode-glow-effect/","date":1690200000000,"content":"<p>I noticed a charming effect on YouTube’s video player while using its dark theme some time ago. The <strong>background around the video would change</strong> as the video played, creating a lush glow around the video player, making an otherwise bland background a lot more interesting.</p>\n<p><img src=\"https://files.smashing.media/articles/recreating-youtube-ambient-mode-glow-effect/youtube-ambient-glow-example.png\" /></p>\n<p>This effect is called <a href=\"https://support.google.com/youtube/answer/12827017?hl=en&amp;co=GENIE.Platform%3DDesktop\">Ambient Mode</a>. The feature was released sometime in 2022, and YouTube describes it like this:</p>\n<blockquote>“Ambient mode uses a lighting effect to make watching videos in the Dark theme more immersive by casting gentle colors from the video into your screen’s background.”<br />— YouTube</blockquote>\n\n<p>It is an incredibly subtle effect, especially when the video’s colors are dark and have less contrast against the dark theme’s background.</p>\n<p><img src=\"https://files.smashing.media/articles/recreating-youtube-ambient-mode-glow-effect/youtube-video-purple-glow.png\" /></p>\n<p>Curiosity hit me, and I set out to replicate the effect on my own. After digging around YouTube’s convoluted DOM tree and source code in DevTools, I hit an obstacle: all the magic was hidden behind the HTML <code>&lt;canvas&gt;</code> element and bundles of mangled and minified JavaScript code.</p>\n<p><img src=\"https://files.smashing.media/articles/recreating-youtube-ambient-mode-glow-effect/devtools-inspector-canvas-element-highlighted.png\" /></p>\n<p>Despite having very little to go on, I decided to reverse-engineer the code and share my process for creating an ambient glow around the videos. I prefer to keep things simple and accessible, so this article won’t involve complicated color sampling algorithms, although we will utilize them via different methods.</p>\n<p>Before we start writing code, I think it’s a good idea to revisit the HTML Canvas element and see why and how it is used for this little effect.</p>\nHTML Canvas\n<p>The HTML <code>&lt;canvas&gt;</code> element is a <strong>container element on which we can draw graphics with JavaScript</strong> using its own <strong>Canvas API</strong> and <strong>WebGL API</strong>. Out of the box, a <code>&lt;canvas&gt;</code> is empty — a blank canvas, if you will — and the aforementioned Canvas and WebGL APIs are used to fill the <code>&lt;canvas&gt;</code> with content.</p>\n<p>HTML <code>&lt;canvas&gt;</code> is not limited to presentation; we can also make interactive graphics with them that respond to standard mouse and keyboard events.</p>\n<p>But SVG can also do most of that stuff, right? That’s true, but <strong><code>&lt;canvas&gt;</code> is more performant than SVG because it doesn’t require any additional DOM nodes</strong> for drawing paths and shapes the way SVG does. Also, <strong><code>&lt;canvas&gt;</code> is easy to update</strong>, which makes it ideal for more complex and performance-heavy use cases, like YouTube’s Ambient Mode.</p>\n<p>As you might expect with many HTML elements, <code>&lt;canvas&gt;</code> accepts attributes. For example, we can give our drawing space a <code>width</code> and <code>height</code>:</p>\n<pre><code>&lt;canvas width=\"10\" height=\"6\" id=\"js-canvas\"&gt;&lt;/canvas&gt;\n</code></pre>\n\n<p>Notice that <code>&lt;canvas&gt;</code> is not a self-closing tag, like an <code>&lt;iframe&gt;</code> or <code>&lt;img&gt;</code>. We can add content between the opening and closing tags, which is rendered only when the browser cannot render the canvas. This can also be useful for making the element more accessible, which we’ll touch on later.</p>\n<p>Returning to the <code>width</code> and <code>height</code> attributes, they define the <code>&lt;canvas&gt;</code>’s coordinate system. Interestingly, we can apply a responsive width using relative units in CSS, but the <code>&lt;canvas&gt;</code> still respects the set coordinate system. We are working with pixel graphics here, so stretching a smaller canvas in a wider container results in a blurry and pixelated image.</p>\n<p><img src=\"https://files.smashing.media/articles/recreating-youtube-ambient-mode-glow-effect/youtube-ambient-mode-video-canvas.png\" /></p>\n<p><strong>The downside of <code>&lt;canvas&gt;</code> is its accessibility.</strong> All of the content updates happen in JavaScript in the background as the DOM is not updated, so we need to put effort into making it accessible ourselves. One approach (of many) is to create a <a href=\"https://www.oreilly.com/library/view/html5-canvas-2nd/9781449335847/ch01s12.html\">Fallback DOM</a> by placing standard HTML elements <em>inside</em> the <code>&lt;canvas&gt;</code>, then manually updating them to reflect the current content that is displayed on the canvas.</p>\n<p><img src=\"https://files.smashing.media/articles/recreating-youtube-ambient-mode-glow-effect/youtube-ambient-glow-text.png\" /></p>\n<p>Numerous canvas frameworks — including ZIM, Konva, and Fabric, to name a few — are designed for complex use cases that can simplify the process with a plethora of abstractions and utilities. ZIM’s framework has <a href=\"https://drabstract.medium.com/your-guide-to-accessibility-on-the-canvas-with-javascript-ff58074c30c8\">accessibility features</a> built into its interactive components, which makes developing accessible <code>&lt;canvas&gt;</code>-based experiences a bit easier.</p>\n<p>For this example, we’ll use the Canvas API. We will also use the element for decorative purposes (i.e., it doesn’t introduce any new content), so we won’t have to worry about making it accessible, but rather safely hide the <code>&lt;canvas&gt;</code> from assistive devices.</p>\n<p>That said, we will still need to disable — or minimize — the effect for those who have enabled reduced motion settings at the system or browser level.</p>\n<code>requestAnimationFrame</code>\n<p>The <code>&lt;canvas&gt;</code> element can handle the rendering part of the problem, but we need to somehow <strong>keep the <code>&lt;canvas&gt;</code> in sync with the playing <code>&lt;video&gt;</code></strong>and make sure that the <code>&lt;canvas&gt;</code> updates with each video frame. We’ll also need to stop the sync if the video is paused or has ended.</p>\n<p>We could use <code>setInterval</code> in JavaScript and rig it to run at <code>60fps</code> to match the video’s playback rate, but that approach comes with some <a href=\"https://researchhubs.com/post/computing/javascript/requestAnimationFrame.html\">problems and caveats</a>. Luckily, there is a better way of handling a function that must be called on so often.</p>\n<p>That is where the <code>requestAnimationFrame</code> method comes in. It instructs the browser to <strong>run a function before the next repaint</strong>. That function runs asynchronously and returns a number that represents the request ID. We can then use the ID with the <code>cancelAnimationFrame</code> function to instruct the browser to stop running the previously scheduled function.</p>\n<pre><code>let requestId;\n\nconst loopStart = () =&gt; {\n  /* ... */\n\n  /* Initialize the infinite loop and keep track of the requestId */\n  requestId = window.requestAnimationFrame(loopStart);\n};\n\nconst loopCancel = () =&gt; {\n  window.cancelAnimationFrame(requestId);\n  requestId = undefined;\n};\n</code></pre>\n\n<p>Now that we have all our bases covered by learning how to keep our update loop and rendering performant, we can start working on the Ambient Mode effect!</p>\nThe Approach\n<p>Let’s briefly outline the steps we’ll take to create this effect.</p>\n<p>First, we must <strong>render the displayed video frame on a canvas</strong> and keep everything in sync. We’ll render the frame onto a smaller canvas (resulting in a pixelated image). When an image is downscaled, the important and most-dominant parts of an image are preserved at the cost of losing small details. <strong>By reducing the image to a low resolution, we’re reducing it to the most dominant colors and details</strong>, effectively doing something similar to color sampling, albeit not as accurately.</p>\n<p><img src=\"https://files.smashing.media/articles/recreating-youtube-ambient-mode-glow-effect/youtube-ambient-glow-downscale.png\" /></p>\n<p>Next, we’ll <strong>blur the canvas</strong>, which blends the pixelated colors. We will place the canvas behind the video using CSS absolute positioning.</p>\n<p><img src=\"https://files.smashing.media/articles/recreating-youtube-ambient-mode-glow-effect/youtube-ambient-glow-blur.png\" /></p>\n<p>And finally, we’ll apply additional CSS to make the glow effect a bit more subtle and as close to YouTube’s effect as possible.</p>\n<p><img src=\"https://files.smashing.media/articles/recreating-youtube-ambient-mode-glow-effect/youtube-ambient-glow-styling.png\" /></p>\nHTML Markup\n<p>First, let’s start by setting up the markup. We’ll need to wrap the <code>&lt;video&gt;</code> and <code>&lt;canvas&gt;</code> elements in a parent container because that allows us to contain the absolute positioning we will be using to position the <code>&lt;canvas&gt;</code> behind the <code>&lt;video&gt;</code>. But more on that in a moment.</p>\n<p>Next, we will set a fixed <code>width</code> and <code>height</code> on the <code>&lt;canvas&gt;</code>, although the element will remain responsive. By setting the <code>width</code> and <code>height</code> attributes, we define the coordinate space in CSS pixels. The video’s frame is <code>1920</code>×<code>720</code>, so we will draw an image that is <code>10</code>×<code>6</code> pixels image on the canvas. As we’ve seen in the previous examples, we’ll get a pixelated image with dominant colors somewhat preserved.</p>\n<div>\n<pre><code>&lt;section class=\"wrapper\"&gt;\n  &lt;video controls muted class=\"video\" id=\"js-video\" src=\"video.mp4\"&gt;&lt;/video&gt;\n  &lt;canvas width=\"10\" height=\"6\" aria-hidden=\"true\" class=\"canvas\" id=\"js-canvas\"&gt;&lt;/canvas&gt;\n&lt;/section&gt;\n</code></pre>\n</div>\n\n\n\nSyncing <code>&lt;canvas&gt;</code> And <code>&lt;video&gt;</code>\n<p>First, let’s start by setting up our variables. We need the <strong><code>&lt;canvas&gt;</code>’s rendering context</strong> to draw on it, so saving it as a variable is useful, and we can do that by using JavaScript’s <code>getCanvasContext</code> function. We’ll also use a variable called <code>step</code> to keep track of the request ID of the <code>requestAnimationFrame</code> method.</p>\n<pre><code>const video = document.getElementById(\"js-video\");\nconst canvas = document.getElementById(\"js-canvas\");\nconst ctx = canvas.getContext(\"2d\");\n\nlet step; // Keep track of requestAnimationFrame id\n</code></pre>\n\n<p>Next, we’ll <strong>create the drawing and update loop functions.</strong> We can actually draw the current video frame on the <code>&lt;canvas&gt;</code> by passing the <code>&lt;video&gt;</code> element to the <code>drawImage</code> function, which takes four values corresponding to the video’s starting and ending points in the <code>&lt;canvas&gt;</code> coordinate system, which, if you remember, is mapped to the <code>width</code> and <code>height</code> attributes in the markup. It’s that simple!</p>\n<pre><code>const draw = () =&gt; {\n  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n};\n</code></pre>\n\n<p>Now, all we need to do is create the loop that calls the <code>drawImage</code> function while the video is playing, as well as a function that cancels the loop.</p>\n<pre><code>const drawLoop = () =&gt; {\n  draw();\n  step = window.requestAnimationFrame(drawLoop);\n};\n\nconst drawPause = () =&gt; {\n  window.cancelAnimationFrame(step);\n  step = undefined;\n};\n</code></pre>\n\n<p>And finally, we need to create two main functions that <strong>set up and clear event listeners</strong> on page load and unload, respectively. These are all of the video events we need to cover:</p>\n<ul>\n<li><strong><code>loadeddata</code></strong>: This fires when the first frame of the video loads. In this case, we only need to draw the current frame onto the canvas.</li>\n<li><strong><code>seeked</code></strong>: This fires when the video finishes seeking and is ready to play (i.e., the frame has been updated). In this case, we only need to draw the current frame onto the canvas.</li>\n<li><strong><code>play</code></strong>: This fires when the video starts playing. We need to start the loop for this event.</li>\n<li><strong><code>pause</code></strong>: This fires when the video is paused. We need to stop the loop for this event.</li>\n<li><strong><code>ended</code></strong>: This fires when the video stops playing when it reaches its end. We need to stop the loop for this event.</li>\n</ul>\n<pre><code>const init = () =&gt; {\n  video.addEventListener(\"loadeddata\", draw, false);\n  video.addEventListener(\"seeked\", draw, false);\n  video.addEventListener(\"play\", drawLoop, false);\n  video.addEventListener(\"pause\", drawPause, false);\n  video.addEventListener(\"ended\", drawPause, false);\n};\n\nconst cleanup = () =&gt; {\n  video.removeEventListener(\"loadeddata\", draw);\n  video.removeEventListener(\"seeked\", draw);\n  video.removeEventListener(\"play\", drawLoop);\n  video.removeEventListener(\"pause\", drawPause);\n  video.removeEventListener(\"ended\", drawPause);\n};\n\nwindow.addEventListener(\"load\", init);\nwindow.addEventListener(\"unload\", cleanup);\n</code></pre>\n\n<p>Let’s check out what we’ve achieved so far with the variables, functions, and event listeners we have configured.</p>\n<p><img src=\"https://files.smashing.media/articles/recreating-youtube-ambient-mode-glow-effect/blurred-background-canvas-matches-video-frame.png\" /></p>\nCreating A Reusable Class\n<p>Let’s make this code <strong>reusable</strong> by converting it to an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes\">ES6 class</a> so that we can create a new instance for any <code>&lt;video&gt;</code> and <code>&lt;canvas&gt;</code> pairing.</p>\n<pre><code>class VideoWithBackground {\n  video;\n  canvas;\n  step;\n  ctx;\n\n  constructor(videoId, canvasId) {\n    this.video = document.getElementById(videoId);\n    this.canvas = document.getElementById(canvasId);\n\n    window.addEventListener(\"load\", this.init, false);\n    window.addEventListener(\"unload\", this.cleanup, false);\n  }\n\n  draw = () =&gt; {\n    this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);\n  };\n\n  drawLoop = () =&gt; {\n    this.draw();\n    this.step = window.requestAnimationFrame(this.drawLoop);\n  };\n\n  drawPause = () =&gt; {\n    window.cancelAnimationFrame(this.step);\n    this.step = undefined;\n  };\n\n  init = () =&gt; {\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.ctx.filter = \"blur(1px)\";\n\n    this.video.addEventListener(\"loadeddata\", this.draw, false);\n    this.video.addEventListener(\"seeked\", this.draw, false);\n    this.video.addEventListener(\"play\", this.drawLoop, false);\n    this.video.addEventListener(\"pause\", this.drawPause, false);\n    this.video.addEventListener(\"ended\", this.drawPause, false);\n  };\n\n  cleanup = () =&gt; {\n    this.video.removeEventListener(\"loadeddata\", this.draw);\n    this.video.removeEventListener(\"seeked\", this.draw);\n    this.video.removeEventListener(\"play\", this.drawLoop);\n    this.video.removeEventListener(\"pause\", this.drawPause);\n    this.video.removeEventListener(\"ended\", this.drawPause);\n  };\n    }\n</code></pre>\n\n<p>Now, we can create a new instance by passing the <code>id</code> values for the <code>&lt;video&gt;</code> and <code>&lt;canvas&gt;</code> elements into a <code>VideoWithBackground()</code> class:</p>\n<pre><code>const el = new VideoWithBackground(\"js-video\", \"js-canvas\");\n</code></pre>\n\nRespecting User Preferences\n<p>Earlier, we briefly discussed that we would need to disable or minimize the effect’s motion for users who prefer reduced motion. We have to consider that for decorative flourishes like this.</p>\n<p>The easy way out? We can detect the user’s motion preferences with the <code>prefers-reduced-motion</code> media query and completely hide the decorative canvas if reduced motion is the preference.</p>\n<pre><code>@media (prefers-reduced-motion: reduce) {\n  .canvas {\n    display: none !important;\n  }\n}\n</code></pre>\n\n<p>Another way we respect reduced motion preferences is to use JavaScript’s <code>matchMedia</code> function to detect the user’s preference and prevent the necessary event listeners from registering.</p>\n<pre><code>constructor(videoId, canvasId) {\n  const mediaQuery = window.matchMedia(\"(prefers-reduced-motion: reduce)\");\n\n  if (!mediaQuery.matches) {\n    this.video = document.getElementById(videoId);\n    this.canvas = document.getElementById(canvasId);\n\n    window.addEventListener(\"load\", this.init, false);\n    window.addEventListener(\"unload\", this.cleanup, false);\n  }\n}\n</code></pre>\n\nFinal Demo\n<p>We’ve created a reusable ES6 class that we can use to create new instances. Feel free to check out and play around with the completed demo.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/ZEmRXPy\">Youtube video glow effect  - dominant color [forked]</a> by <a href=\"https://codepen.io/AdrianBece\">Adrian Bece</a>.</p>\nCreating A React Component\n<p>Let’s migrate this code to the React library, as there are key differences in the implementation that are worth knowing if you plan on using this effect in a React project.</p>\n<h3>Creating A Custom Hook</h3>\n<p>Let’s start by creating a custom React hook. Instead of using the <code>getElementById</code> function for selecting DOM elements, we can access them with a <code>ref</code> on the <code>useRef</code> hook and assign it to the <code>&lt;canvas&gt;</code> and <code>&lt;video&gt;</code> elements.</p>\n<p>We’ll also reach for the <code>useEffect</code> hook to initialize and clear the event listeners to ensure they only run once all of the necessary elements have mounted.</p>\n<p>Our custom hook must return the <code>ref</code> values we need to attach to the <code>&lt;canvas&gt;</code> and <code>&lt;video&gt;</code> elements, respectively.</p>\n<pre><code>import { useRef, useEffect } from \"react\";\n\nexport const useVideoBackground = () =&gt; {\n  const mediaQuery = window.matchMedia(\"(prefers-reduced-motion: reduce)\");\n  const canvasRef = useRef();\n  const videoRef = useRef();\n\n  const init = () =&gt; {\n    const video = videoRef.current;\n    const canvas = canvasRef.current;\n    let step;\n\n    if (mediaQuery.matches) {\n      return;\n    }\n\n    const ctx = canvas.getContext(\"2d\");\n\n    ctx.filter = \"blur(1px)\";\n\n    const draw = () =&gt; {\n      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n    };\n\n    const drawLoop = () =&gt; {\n      draw();\n      step = window.requestAnimationFrame(drawLoop);\n    };\n\n    const drawPause = () =&gt; {\n      window.cancelAnimationFrame(step);\n      step = undefined;\n    };\n\n    // Initialize\n    video.addEventListener(\"loadeddata\", draw, false);\n    video.addEventListener(\"seeked\", draw, false);\n    video.addEventListener(\"play\", drawLoop, false);\n    video.addEventListener(\"pause\", drawPause, false);\n    video.addEventListener(\"ended\", drawPause, false);\n\n    // Run cleanup on unmount event\n    return () =&gt; {\n      video.removeEventListener(\"loadeddata\", draw);\n      video.removeEventListener(\"seeked\", draw);\n      video.removeEventListener(\"play\", drawLoop);\n      video.removeEventListener(\"pause\", drawPause);\n      video.removeEventListener(\"ended\", drawPause);\n    };\n  };\n\n  useEffect(init, []);\n\n  return {\n    canvasRef,\n    videoRef,\n  };\n};\n</code></pre>\n\n<h3>Defining The Component</h3>\n<p>We’ll use similar markup for the actual component, then call our custom hook and attach the <code>ref</code> values to their respective elements. We’ll make the component configurable so we can pass any <code>&lt;video&gt;</code> element attribute as a prop, like <code>src</code>, for example.</p>\n<div>\n<pre><code>import React from \"react\";\nimport { useVideoBackground } from \"../hooks/useVideoBackground\";\n\nimport \"./VideoWithBackground.css\";\n\nexport const VideoWithBackground = (props) =&gt; {\n  const { videoRef, canvasRef } = useVideoBackground();\n\n  return (\n    &lt;section className=\"wrapper\"&gt;\n      &lt;video ref={ videoRef } controls className=\"video\" { ...props } /&gt;\n      &lt;canvas width=\"10\" height=\"6\" aria-hidden=\"true\" className=\"canvas\" ref={ canvasRef } /&gt;\n    &lt;/section&gt;\n  );\n};\n</code></pre>\n</div>\n\n<p>All that’s left to do is to call the component and pass the video URL to it as a prop.</p>\n<div>\n<pre><code>import { VideoWithBackground } from \"../components/VideoWithBackground\";\n\nfunction App() {\n  return (\n    &lt;VideoWithBackground src=\"<a href=\"http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4&quot;\">http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\"</a> /&gt;\n  );\n}\n\nexport default App;\n</code></pre>\n</div>\n\nConclusion\n<p>We combined the HTML <code>&lt;canvas&gt;</code> element and the corresponding Canvas API with JavaScript’s <code>requestAnimationFrame</code> method to create the same charming — but performance-intensive — visual effect that makes YouTube’s Ambient Mode feature. We found a way to draw the current <code>&lt;video&gt;</code> frame on the <code>&lt;canvas&gt;</code>, keep the two elements in sync, and position them so that the blurred <code>&lt;canvas&gt;</code> sits properly behind the <code>&lt;video&gt;</code>.</p>\n<p>We covered a few other considerations in the process. For example, we established the <code>&lt;canvas&gt;</code> as a decorative image that can be removed or hidden when a user’s system is set to a reduced motion preference. Further, we considered the maintainability of our work by establishing it as a reusable ES6 class that can be used to add more instances on a page. Lastly, we converted the effect into a component that can be used in a React project.</p>\n<p>Feel free to play around with the finished <a href=\"https://codepen.io/smashingmag/pen/ZEmRXPy\">demo</a>. I encourage you to continue building on top of it and share your results with me in the comments, or, similarly, you can reach out to me on <a href=\"https://twitter.com/AdrianBeceDev\">Twitter</a>. I’d love to hear your thoughts and see what you can make out of it!</p>\n<h3>References</h3>\n<ul>\n<li>“<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas\"><code>&lt;canvas&gt;</code>: The Graphics Canvas element</a>” (MDN)</li>\n<li>“<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\">Window: <code>requestAnimationFrame()</code> method</a>” (MDN)</li>\n<li>“<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D\"><code>CanvasRenderingContext2D</code></a>” (MDN)</li>\n<li>“<a href=\"https://blog.youtube/news-and-events/an-updated-look-and-feel-for-youtube/\">Ready for our close up: An updated look and feel for YouTube</a>,” Nate Koechley (YouTube Blog)</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"fb7d68ba6de612b261d0a278d16732ae5a7a8d922e0d32c62123daf5ae5a36c0","category":"Tech"}