{"title":"5 steps to set up Vault for widespread adoption at your org","link":"https://www.hashicorp.com/blog/5-steps-to-set-up-vault-for-widespread-adoption-at-your-org","date":1724846400000,"content":"<p>Once you’ve introduced HashiCorp Vault into your organization, the next step is to encourage developers and other teams to use it in their applications and services, while also helping them through their migration process. We’ve seen successful Vault adoption initiatives across small to very large companies (<a href=\"https://www.youtube.com/watch?v=Ns8LOF1HIs0\">like</a> <a href=\"https://www.hashicorp.com/resources/keep-it-secret-safe-everywhere-2-years-vault-enterprise-adobe\">Adobe</a>), and we know which internal developer enablement practices work best. </p>\n\n<p>This blog post outlines steps to drive the adoption of Vault within your internal developer community and sets the foundation for scaling secrets management over time. Based on your application ecosystem, the post will help you identify which <a href=\"https://developer.hashicorp.com/vault/tutorials/getting-started/getting-started-secrets-engines\">secrets engines</a> and <a href=\"https://developer.hashicorp.com/vault/docs/auth\">authentication methods</a> to enable, and it will help you evaluate whether a <a href=\"https://developer.hashicorp.com/vault/docs/agent-and-proxy/agent\">Vault Agent</a> or <a href=\"https://developer.hashicorp.com/vault/api-docs/libraries\">client library</a> (language-specific SDK) approach is the best way for your application to retrieve secrets.</p>\n<img src=\"https://www.datocms-assets.com/2885/1724712113-2024-vaultdev-steps.png\" alt=\"Five\" /><h2>Discover existing applications and secrets</h2>\n\n<p>Ideally, before introducing Vault to development teams, you should first <strong>conduct a discovery exercise</strong> to investigate secret usage and application configuration in your environment. Knowing how services currently use secrets helps you plan for how to set up Vault and create education materials for development teams. This provides critical information on how developers can best adopt Vault.</p>\n\n<p><strong>For each application, record:</strong> </p>\n\n<ul>\n<li>Where it runs</li>\n<li>Its programming language </li>\n<li>Its framework</li>\n</ul>\n\n<p>The runtime determines the Vault auth method you should use. \nThe application’s framework and interaction with secrets determine whether you use an SDK or Vault Agent for the application to retrieve secrets from Vault. </p>\n\n<h3>Make a list of the types of secrets</h3>\n\n<p>Make a list of the secret types — such as API tokens, certificates, and passwords — used by the application. The list doesn’t need to be exhaustive, but identifying the most common types of secrets will help you select the right secrets engines.</p>\n\n<h3>Learn how the application retrieves and uses each secret</h3>\n\n<p>Many applications rely on environment variable injection, but separate processes inject the secrets into the application environment. For example, Amazon ECS tasks can <a href=\"https://docs.aws.amazon.com/AmazonECS/latest/developerguide/secrets-envvar-secrets-manager.html\">set environment variables that reference secrets in AWS Secrets Manager</a>. While not always possible, documenting how the secrets get injected helps you choose whether to use Vault Agent or an SDK for an application.</p>\n\n<h3>Identify how the application handles secret rotation</h3>\n\n<p>Do you need to manually restart it if a password changes or will the application automatically refresh any connections using the secret? While you may discover that most applications use long-lived, static secrets, you might find others using auto-rotation managed by a cloud service provider. This information will help determine whether the application can handle the rotation of a secret with minimal downtime.</p>\n\n<h3>Document any availability requirements for the application</h3>\n\n<p>Some applications require minimal downtime and are not allowed to restart because they are considered critical for business operations or have legacy architecture that does not support high availability. Other times, an application has sufficient replicas to serve requests and allow a rolling start of instances.</p>\n\n<p>This table provides a template for discovery and assessment of applications (An editable version of the table exists on <a href=\"https://gist.github.com/joatmon08/1abc3f05355fbccaf4328beaac85431e#file-discovery-md\">GitHub</a>):</p>\n<img src=\"https://www.datocms-assets.com/2885/1724712159-2024-vaultdev-discoverytable.png\" alt=\"Application\" /><p>You do not have to survey every application in your organization, but getting a representative sample helps you identify application candidates for Vault migration. Identifying the most common runtime, framework, and secret types used by your applications will help your platform team determine the general settings for auth methods and secrets engines to enable in a typical Vault namespace. </p>\n\n<h2>Decide developer access to Vault</h2>\n\n<p>After completing the discovery step, you can decide how you want developers to interact with Vault. </p>\n\n<h3>Outline Vault namespaces</h3>\n\n<p>If you use HCP Vault or Vault Enterprise, you can isolate developer access to specific Vault namespaces. This pattern of <a href=\"https://www.google.com/url?q=https://www.youtube.com/watch?v%3DuVgDprrbqBM&amp;sa=D&amp;source=docs&amp;ust=1722435415340595&amp;usg=AOvVaw2kDR2MdPi7Z3tyPxuseb3c\">delegated administrator management</a> lets developers configure Vault themselves, with some constraints. </p>\n\n<p>To design a namespace hierarchy, you can use our <a href=\"https://developer.hashicorp.com/vault/tutorials/enterprise/namespace-structure\">recommendations</a>. Otherwise, you will need to organize and standardize the paths to your Vault secrets. <a href=\"https://www.youtube.com/watch?v=WSaVvmCFcBs\">Christopher McNabb's HashiTalks presentation</a> offers a great example of how to establish Vault secret naming conventions using API paths.</p>\n\n<h3>Use a custom interface to Vault or auth method alternative</h3>\n\n<p>If possible, <strong>avoid offering direct developer access to Vault</strong>. Use your own interface, such as a ticketing system, custom CLI, <a href=\"https://developer.hashicorp.com/hcp/docs/waypoint\">HCP Waypoint</a>, or <a href=\"https://developer.hashicorp.com/terraform/tutorials/aws-get-started/infrastructure-as-code\">infrastructure as code</a> to enable developers to update Vault. This lets you standardize and audit how developers store secrets in Vault while leveraging existing developer platform interfaces. </p>\n\n<p>If you do not have a custom interface and need to enable developer access to Vault, choose an auth method that aligns with your existing identity provider (IdP) for defining development team groups (e.g. <a href=\"https://developer.hashicorp.com/vault/docs/auth/okta\">Okta auth method</a>, <a href=\"https://developer.hashicorp.com/vault/docs/auth/ldap\">LDAP auth method</a>, whichever system you use). </p>\n\n<h3>Use Vault policies and policy templating</h3>\n\n<p><a href=\"https://developer.hashicorp.com/vault/docs/concepts/policies\">Vault policies</a> tied to groups should provide write access to specific paths and read access to secrets engines and auth methods. Use <a href=\"https://developer.hashicorp.com/vault/tutorials/policies/policy-templating\">policy templating</a> to scale your efforts to maintain and define policies.</p>\n\n<h3>Offer flexible migration support</h3>\n\n<p>Developer access to Vault should support the initial migration of existing secrets, but your developer interaction approach may change over time. Some development teams will want to use different secrets engines after the the initial migration. Adding a workflow to grant temporary administrative access to specific development teams that need to use less-common secrets engines makes it easier for developers with outlier use cases to adopt Vault.</p>\n\n<h2>Build an application landing zone</h2>\n\n<p>An application landing zone is an environment that is secure, repeatable, and highly customized to your organization. Similar to cloud landing zones (<a href=\"https://docs.aws.amazon.com/prescriptive-guidance/latest/migration-aws-environment/understanding-landing-zones.html\">AWS</a>, <a href=\"https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ready/landing-zone/\">Azure</a>, <a href=\"https://cloud.google.com/architecture/landing-zones\">Google Cloud</a>), an application landing zone for Vault contains the minimum required features for your teams and applications to get started with Vault. This includes items such as a <a href=\"https://developer.hashicorp.com/vault/tutorials/enterprise/namespace-structure\">namespace</a>, the key-value secrets engine, <a href=\"https://developer.hashicorp.com/vault/docs/concepts/policies#templated-policies\">templated policies</a>, machine authentication methods, and human authentication methods. Use the data collected during the discovery step to identify the initial set of secrets engines and authentication methods to enable by default in the application landing zone.</p>\n\n<h3>Use a landing zone accelerator</h3>\n\n<p>A landing zone accelerator lets platform teams quickly create application landing zones. Accelerators can be built as <a href=\"https://developer.hashicorp.com/terraform/language/modules/develop\">HashiCorp Terraform modules</a> or with scripts. The accelerator interface could be managed through HCP Waypoint or your own interface, such as a ticketing system. </p>\n\n<p>Depending on your organization’s strategy, the accelerator can follow a self-service approach, allowing end users to onboard themselves to Vault. The application landing zone accelerator should handle the initial configuration and setup of Vault authentication and <a href=\"https://developer.hashicorp.com/vault/tutorials/enterprise/namespace-structure\">mounts</a>. Additionally, the accelerator should configure third-party platforms like AWS, Azure, Google Cloud, or Kubernetes.</p>\n\n<h3>Add new golden patterns to landing zones</h3>\n\n<p>An application landing zone provides a standardized framework for adopting Vault at scale and should evolve with your organization's needs over time. For example, you can observe the usage of early Vault adopters and build new golden patterns into the landing zone to better onboard the rest of the organization.</p>\n\n<h2>Migrate secrets, update application</h2>\n\n<p>Most applications need to have some refactoring before using Vault because they do not currently support live reloading of new secrets. As a result, applications or their deployment manifests will need additional code or configuration to recognize new secrets from Vault. We recommend that you start with a non-critical application to test your Vault integration process and iron out any issues. </p>\n\n<p><strong>Choose an application that:</strong></p>\n\n<ul>\n<li>Depends on one (or very few) static secrets</li>\n<li>Uses a framework or runtime with Vault integration support (<a href=\"https://developer.hashicorp.com/vault/integrations\">see list</a>)</li>\n<li>Can handle some downtime</li>\n</ul>\n\n<p>The first step involves migrating your secrets for that application into Vault.</p>\n\n<h3>Migrating secrets</h3>\n\n<p>Above we suggested that you pick an application with very few static secrets to migrate. An application with fewer static secrets means you learn the process of transferring the secrets into Vault and minimize the blast radius if the application refactor does not succeed on the first try. Eventually, you need to duplicate the migration process for the application’s secrets for both non-production and production Vault clusters. Note that you likely will need to copy only the latest version of the secret into Vault, not the previous versions.</p>\n\n<p>If the application references secrets that are automatically rotated by a cloud service provider (such as a database username and password), copy the secret into Vault and manage it as a <a href=\"https://developer.hashicorp.com/vault/tutorials/db-credentials/database-creds-rotation#static-roles\">static role</a> (if possible) or key-value secret. Using a static role with an existing username and password ensures that you can rotate the password with Vault at a future date. If the database secrets engine does not support static roles, use key-value to store the username and password. <a href=\"https://developer.hashicorp.com/vault/tutorials/getting-started/getting-started-dynamic-secrets\">Dynamic secrets</a> have leases, which an application must handle differently. Over time, you may consider <a href=\"https://www.hashicorp.com/blog/why-we-need-dynamic-secrets\">replatforming static secrets to dynamic ones</a>.</p>\n\n<table>\n  <tr>\n   <td><strong>Type of secret</strong>\n   </td>\n   <td><strong>Vault secrets engine</strong>\n   </td>\n   <td><strong>Assessment notes</strong>\n   </td>\n  </tr>\n  <tr>\n   <td>Static\n   </td>\n   <td>Key-value\n   </td>\n   <td>Use if static secrets are manually rotated or if a secrets engine does not exist for your secret type. \n   </td>\n  </tr>\n  <tr>\n   <td>Database\n   </td>\n   <td><a href=\"https://developer.hashicorp.com/vault/docs/secrets/databases\">Database secrets engine</a>\n   </td>\n   <td>If the password is automatically rotated by the cloud service provider, consider using static roles to preserve the current username and password and minimize application refactoring.\n   </td>\n  </tr>\n  <tr>\n   <td>Automatically rotated by cloud service provider or custom automation\n   </td>\n   <td>Secrets engine for target (if supported by Vault) or <a href=\"https://developer.hashicorp.com/vault/docs/secrets/kv\">KV secrets engine</a>\n   </td>\n   <td>Review the <a href=\"https://developer.hashicorp.com/vault/docs/secrets\">secrets engines</a> supported by Vault. If there is no secrets engine, migrate the initial credentials to the <a href=\"https://developer.hashicorp.com/vault/docs/secrets/kv\">KV secrets engine</a> and turn off the automatic rotation by the cloud service provider.\n   </td>\n  </tr>\n  <tr>\n   <td>Dynamic\n   </td>\n   <td>Secrets engine for target\n   </td>\n   <td>Requires some refactoring of the application to reload new credentials. Application must self-reload or have external automation to restart it in order to retrieve new credentials. \n   </td>\n  </tr>\n  <tr>\n   <td>Encryption keys\n   </td>\n   <td><a href=\"https://developer.hashicorp.com/vault/docs/secrets/transit\">Transit</a> or <a href=\"https://developer.hashicorp.com/vault/docs/secrets/transform\">transform</a> secrets engine\n   </td>\n   <td>Requires refactoring to interface with Vault using a <a href=\"https://developer.hashicorp.com/vault/api-docs/libraries\">client library</a> (SDK).\n   </td>\n  </tr>\n</table>\n\n<h3>Updating the application</h3>\n\n<p>Ideally, you want to minimize the overall refactoring effort. However, if you maintain consistent development practices across your application teams, such as the use of standardized frameworks like Spring Boot, or retrieve all application configurations from a configuration server, you may be better served taking a <strong>Vault-aware approach</strong> to updating your applications for Vault. This is the more refactor-heavy option in which you refactor your application to interface directly with Vault. </p>\n\n<p>If these strict development practices are not part of your application delivery process, we generally recommend taking a <strong>Vault-agnostic approach</strong> by deploying Vault Agent or one of the Kubernetes integrations (<a href=\"https://www.hashicorp.com/blog/kubernetes-vault-integration-via-sidecar-agent-injector-vs-csi-provider\">see comparison</a>) with your application. These utilities handle Vault authentication and secret reloading into environment variables or a file, and they require only minor code additions.</p>\n\n<h3>About Vault-aware direct integration</h3>\n\n<p>For direct integration with Vault, you will need to use a <a href=\"https://developer.hashicorp.com/vault/api-docs/libraries\">Vault client library</a> (also known as SDKs) to request secrets from Vault and handle reloading them. As mentioned before, this increases the overall refactoring effort for the application. One scenario in which you need to use a client library and implement a Vault-aware integration includes encrypting <a href=\"https://developer.hashicorp.com/vault/tutorials/encryption-as-a-service/eaas-spring-demo\">application data using the Vault transit secrets engine</a>. </p>\n\n<p>Another Vault-aware scenario involves an application that interfaces with an existing secrets manager. In this case, you will need to refactor your code to change the secrets manager to Vault as part of the application properties. You’ll want to look for tutorials on reloading secrets in your specific application framework. For example, if you use Spring Boot, this <a href=\"https://developer.hashicorp.com/vault/tutorials/app-integration/spring-reload-secrets\">tutorial on reloading secrets in Spring applications</a> would help you identify what code requires refactoring.</p>\n\n<p>Using a client library to connect the application to Vault requires additional guidance from your security team, as they will need to verify software dependencies. Some, but not all, client libraries handle application reloads for new credentials or Vault token refreshes. Application teams will have to implement this logic themselves.</p>\n\n<p>If you have to write your own code to reload the application, you can deploy <a href=\"https://developer.hashicorp.com/vault/docs/agent-and-proxy/proxy\">Vault proxy</a> to handle the initial authentication, which eliminates the need for Vault authentication logic in your application code. Vault proxy enables the application to connect to the API proxy to retrieve secrets from Vault.</p>\n\n<h3>About Vault Agent</h3>\n\n<p>Vault Agent runs as a separate process and handles the authentication, retrieval, and injection of secrets from Vault. Vault Agent can also restart the application with new secrets using the <code><a href=\"https://developer.hashicorp.com/vault/docs/agent-and-proxy/agent/template#exec\">exec directive</a></code> command, either by issuing a <a href=\"https://www.hashicorp.com/blog/refresh-secrets-for-kubernetes-applications-with-vault-agent\">termination signal or API request</a> to the application. It's often the preferred Vault integration approach when you don’t require a Vault-aware approach and you don’t use an orchestrator like Kubernetes or HashiCorp Nomad. If you do use one of those orchestrators, read their sections below.</p>\n\n<h3>For Kubernetes users</h3>\n\n<p>If you are on Kubernetes, you may prefer to use <a href=\"https://developer.hashicorp.com/vault/docs/platform/k8s/vso\">Vault Secrets Operator</a> as a more direct integration between Vault and Kubernetes. If your test application for Vault integration runs on Kubernetes, try <a href=\"https://developer.hashicorp.com/vault/docs/platform/k8s/vso/installation\">deploying the Vault Secrets Operator</a> onto the Kubernetes cluster and defining <a href=\"https://developer.hashicorp.com/vault/docs/platform/k8s/vso/api-reference\">custom resources</a> to synchronize secrets from Vault into <a href=\"https://kubernetes.io/docs/concepts/configuration/secret/\">Kubernetes Secrets</a>. You don’t need to refactor the application deployment manifest if it references the Kubernetes secret and injects secrets into environment variables. This approach requires a minimal level of effort.</p>\n\n<h3>For HashiCorp Nomad users</h3>\n\n<p>If your application runs on <a href=\"https://www.nomadproject.io/\">HashiCorp Nomad</a>, configure the <a href=\"https://developer.hashicorp.com/nomad/docs/integrations/vault\">Nomad-Vault integration</a> to securely inject secrets into your application.</p>\n\n<p>If you do not have Nomad in your environment, or you run on virtual machines, consider using Vault Agent or a proxy for applications that do not run on Kubernetes. </p>\n\n<table>\n  <tr>\n   <td><strong>Runtime</strong>\n   </td>\n   <td><strong>Integration approach</strong>\n   </td>\n   <td><strong>Vault-aware/Vault-agnostic</strong>\n   </td>\n   <td><strong>Refactoring effort required</strong>\n   </td>\n  </tr>\n  <tr>\n   <td>Nomad\n   </td>\n   <td>Nomad-Vault integration\n   </td>\n   <td>Agnostic\n   </td>\n   <td>Nomad job definition\n   </td>\n  </tr>\n  <tr>\n   <td>Kubernetes\n   </td>\n   <td>Vault Secrets Operator\n<p>\nOther options: <a href=\"https://www.hashicorp.com/blog/kubernetes-vault-integration-via-sidecar-agent-injector-vs-csi-provider\">Vault Agent sidecar injector or CSI driver</a>\n   </p></td>\n   <td>Agnostic\n   </td>\n   <td>Additional custom resources\n   </td>\n  </tr>\n  <tr>\n   <td>Any\n   </td>\n   <td>Vault Agent\n   </td>\n   <td>Agnostic\n   </td>\n   <td>Application reload of secrets from environment or file\n   </td>\n  </tr>\n  <tr>\n   <td>Any\n   </td>\n   <td>Client library\n<p>\nOptional: Deploy Vault proxy for authentication\n   </p></td>\n   <td>Aware\n   </td>\n   <td>Code implementation for reload of:\n<ul>\n\n<li>Vault token\n\n</li><li>Secrets\n\n<p>\nRequired for encryption/decryption with transit secrets engine.\n</p></li>\n</ul>\n   </td>\n  </tr>\n</table>\n\n<h3>Another option: Secret sync</h3>\n\n<p>If you encounter significant obstacles that prevent the application from using Vault Agent or a client library, consider using <a href=\"https://developer.hashicorp.com/vault/docs/sync\">secrets sync</a>. This Vault Enterprise and HCP Vault Secrets feature allows teams to define their secrets in Vault and synchronize them to a target API, such as a cloud service provider’s secrets manager or CI/CD framework (e.g. AWS Secrets Manager, GitHub Actions, etc.). With secrets sync, applications can use existing interfaces without refactoring, while you secure and track secrets in Vault.</p>\n\n<h3>Take note of issues encountered</h3>\n\n<p>As you copy the secrets to Vault and refactor the application or its deployment manifests, you will incur downtime when restarting the application to retrieve the new secret. If an application does not reload after you’ve rotated the secrets, you may also have to add application logic to handle a reload gracefully. Applications using Vault Agent should reload once configuration properties change or include handling for graceful shutdowns when getting a termination signal. Document the steps for refactoring and any gaps you identify in provisioning the application landing zone, configuring secrets engines, and refactoring the application.</p>\n\n<h2>Organize internal developer advocacy</h2>\n\n<p>Properly supporting developer adoption of Vault requires documentation and education on how to use Vault properly in your organization. After the initial refactor, create documentation and tutorials for any patterns you employed specific to your applications. Our <a href=\"https://developer.hashicorp.com/vault/tutorials/app-integration\">tutorials and documentation on application integration with Vault</a> are a great place to start, but you should also create custom materials for your organization. Our videos on reloading <a href=\"https://youtu.be/Q1MzpFAplbA?si=LprdQpDpAlcUuyg9\">static</a> and <a href=\"https://youtu.be/E9XDfOVNN2U?si=Fy5Lv11q3E_b9mJk\">dynamic</a> secrets in Spring applications are great examples of developer-enablement content.</p>\n\n<p>The documentation you provide should include:</p>\n\n<ul>\n<li>Onboarding your development team to use Vault\n\n<ul>\n<li>Description of the default developer Vault policy, such as read-only or write for static secrets</li>\n<li>Parameters to access a given Vault namespace or secrets path</li>\n<li>“Break-glass” instructions if developers must access Vault directly</li>\n</ul></li>\n<li>How to store static secrets</li>\n<li>How to enable and configure dynamic secrets engines</li>\n<li>Create code examples for static and dynamic secrets using client libraries, Vault Agent, Vault proxy, or another controller</li>\n</ul>\n\n<p>Many organizations create workshops, brown bag sessions, coding challenges, and hackathons to support the initial application refactor and expand adoption. We also recommend regular office hours to help development teams use Vault. Offering regular onboarding support to development teams helps encourage Vault adoption, identify new usage trends (such as popular secrets engines), and correct unsustainable patterns. Consistent feedback from your developer community helps you evolve secrets management as a platform product offering and provide standard patterns to manage secrets across applications.</p>\n\n<h2>Grow Vault usage</h2>\n\n<p>After you onboard an initial set of applications to use Vault, think about whether you need to create any new documentation or features for the next set of applications. For example, you may want to expand the default set of secrets engines you enable for developers, such as <a href=\"https://developer.hashicorp.com/vault/docs/secrets/ssh\">SSH</a> or <a href=\"https://developer.hashicorp.com/vault/docs/secrets/pki\">PKI</a> secrets engines. If application developers need the ability to encrypt and decrypt payloads, you may also want to enable the transit secrets engine. Note that the transit secrets engine requires applications to use a <a href=\"https://developer.hashicorp.com/vault/tutorials/encryption-as-a-service/eaas-spring-demo\">client library</a> to encrypt and decrypt application data. </p>\n\n<p>Your initial secrets management landing zone will likely change over time as more developers onboard. As more developers become familiar with storing and retrieving secrets from Vault, consider refactoring application <a href=\"https://developer.hashicorp.com/well-architected-framework/security/security-cicd-vault\">CI/CD pipelines to retrieve secrets from Vault</a>. </p>\n\n<p>For static secrets that have an expiration or rotation interval, such as certificates or database credentials, consider introducing dynamic secrets engines. Dynamic secrets work differently than rotated or static secrets, as they involve a new set of usernames or passwords each time. </p>\n\n<p>The Vault-agnostic approach tracks the expiration time of the old secret. The Vault-aware approach requires the application to track the lifecycle of secrets and request a new secret before the old one expires. As a result, dynamic secrets engines require additional application refactoring to track the expiration of secrets.</p>\n\n<p>Besides working with application teams, be sure to include security stakeholders when discussing the time-to-live for dynamic secrets and specific configuration options for the secrets engine. For example, the security team responsible for certificate management should provide input on which intermediate certificate authority to use for certificates. In the case of dynamic database credentials, the database team should participate in deciding the database policy attached to the secret (such as allowing read-only access to the database) and tuning the database to create and delete users.</p>\n\n<h2>Learn more</h2>\n\n<p>For more information on Vault, review our <a href=\"https://developer.hashicorp.com/vault/docs/secrets\">documentation on secrets engines</a> and <a href=\"https://developer.hashicorp.com/vault/docs/auth\">authentication methods</a>. As you set up Vault, review our <a href=\"https://developer.hashicorp.com/vault/tutorials/recommended-patterns\">guides on recommended patterns</a>. When refactoring an application, reference our <a href=\"https://developer.hashicorp.com/vault/tutorials/app-integration\">tutorials on integrating applications using Vault Agent or SDKs</a>.</p>\n","author":"Michael Kosir","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"f339c4d02729c70e3c75448940b7a479e35301e6c5a58d929eac28e3c0280a33","category":"Tech"}