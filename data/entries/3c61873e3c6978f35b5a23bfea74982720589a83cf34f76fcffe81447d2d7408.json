{"title":"What Removing Object Properties Tells Us About JavaScript","link":"https://smashingmagazine.com/2023/10/removing-object-properties-javascript/","date":1698066000000,"content":"<p>A group of contestants are asked to complete the following task:</p>\n<blockquote>Make <code>object1</code> similar to <code>object2</code>.</blockquote>\n\n<pre><code>let object1 = {\n  a: \"hello\",\n  b: \"world\",\n  c: \"!!!\",\n};\n\nlet object2 = {\n  a: \"hello\",\n  b: \"world\",\n};\n</code></pre>\n\n<p>Seems easy, right? Simply delete the <code>c</code> property to match <code>object2</code>. Surprisingly, each person described a different solution:</p>\n<ul>\n<li><strong>Contestant A:</strong> “I set <code>c</code> to <code>undefined</code>.”</li>\n<li><strong>Contestant B:</strong> “I used the <code>delete</code> operator.”</li>\n<li><strong>Contestant C:</strong> “I deleted the property through a <code>Proxy</code> object.”</li>\n<li><strong>Contestant D:</strong> “I avoided mutation by using object destructuring.”</li>\n<li><strong>Contestant E:</strong> “I used <code>JSON.stringify</code> and <code>JSON.parse</code>.”</li>\n<li><strong>Contestant F:</strong> “We rely on Lodash at my company.”</li>\n</ul>\n<p>An awful lot of answers were given, and they all seem to be valid options. So, who is “right”? Let’s dissect each approach.</p>\nContestant A: “I Set <code>c</code> To <code>undefined</code>.”\n<p>In JavaScript, accessing a non-existing property returns <code>undefined</code>.</p>\n<pre><code>const movie = {\n  name: \"Up\",\n};\n\nconsole.log(movie.premiere); // undefined\n</code></pre>\n\n<p>It’s easy to think that setting a property to <code>undefined</code> removes it from the object. But if we try to do that, we will observe a small but important detail:</p>\n<pre><code>const movie = {\n  name: \"Up\",\n  premiere: 2009,\n};\n\nmovie.premiere = undefined;\n\nconsole.log(movie);\n</code></pre>\n\n<p>Here is the output we get back:</p>\n<pre><code>{name: 'up', premiere: undefined}\n</code></pre>\n\n<p>As you can see, <code>premiere</code> still exists inside the object even when it is <code>undefined</code>. This approach doesn’t actually delete the property but rather changes its value. We can confirm that using the <code>hasOwnProperty()</code> method:</p>\n<pre><code>const propertyExists = movie.hasOwnProperty(\"premiere\");\n\nconsole.log(propertyExists); // true\n</code></pre>\n\n<p>But then why, in our first example, does accessing <code>object.premiere</code> return <code>undefined</code> if the property doesn’t exist in the object? Shouldn’t it throw an error like when accessing a non-existing variable?</p>\n<pre><code>console.log(iDontExist);\n\n// Uncaught ReferenceError: iDontExist is not defined\n</code></pre>\n\n<p>The answer lies in how <code>ReferenceError</code> behaves and what a reference is in the first place.</p>\n<blockquote>A <strong>reference</strong> is a resolved name binding that indicates where a value is stored. It consists of three components: a <strong>base value</strong>, the <strong>referenced name</strong>, and a <strong>strict reference flag</strong>.</blockquote>\n\n<p>For a <code>user.name</code> reference, the base value is the object, <code>user</code>, while the referenced name is the string, <code>name</code>, and the strict reference flag is <code>false</code> if the code isn't in <code>strict mode</code>.</p>\n<p>Variables behave differently. They don’t have a parent object, so their base value is an <em>environment record</em>, i.e., a unique base value assigned each time the code is executed.</p>\n<p>If we try to access something that doesn’t have a base value, JavaScript will throw a <code>ReferenceError</code>. However, if a base value is found, but the referenced name doesn’t point to an existing value, JavaScript will simply assign the value <code>undefined</code>.</p>\n<blockquote>“The Undefined type has exactly one value, called <strong>undefined</strong>. Any variable that has not been assigned a value has the value <strong>undefined</strong>.”<br /><br />— <a href=\"https://262.ecma-international.org/14.0/#sec-ecmascript-language-types-undefined-type\">ECMAScript Specification</a></blockquote>\n\n<p>We could spend an entire article just addressing <code>undefined</code> shenanigans!</p>\nContestant B: “I Used The <code>delete</code> Operator.”\n<p>The <code>delete</code> operator’s sole purpose is to remove a property from an object, returning <code>true</code> if the element is successfully removed.</p>\n<pre><code>const dog = {\n  breed: \"bulldog\",\n  fur: \"white\",\n};\n\ndelete dog.fur;\n\nconsole.log(dog); // {breed: 'bulldog'}\n</code></pre>\n\n<p>Some caveats come with the <code>delete</code> operator that we have to take into consideration before using it. First, the <code>delete</code> operator can be used to remove an element from an array. However, it leaves an empty slot inside the array, which may cause unexpected behavior since properties like <code>length</code> aren’t updated and still count the open slot.</p>\n<pre><code>const movies = [\"Interstellar\", \"Top Gun\", \"The Martian\", \"Speed\"];\n\ndelete movies[2];\n\nconsole.log(movies); // ['Interstellar', 'Top Gun', empty, 'Speed']\n\nconsole.log(movies.length); // 4\n</code></pre>\n\n<p>Secondly, let’s imagine the following nested object:</p>\n<pre><code>const user = {\n  name: \"John\",\n  birthday: {day: 14, month: 2},\n};\n</code></pre>\n\n<p>Trying to remove the <code>birthday</code> property using the <code>delete</code> operator will work just fine, but there is a common misconception that doing this frees up the memory allocated for the object.</p>\n<p>In the example above, <code>birthday</code> is a property holding a nested object. Objects in JavaScript behave differently from primitive values (e.g., numbers, strings, and booleans) as far as how they are stored in memory. They are stored and copied “by reference,” while primitive values are copied independently as a whole value.</p>\n<p>Take, for example, a primitive value such as a string:</p>\n<pre><code>let movie = \"Home Alone\";\nlet bestSeller = movie;\n</code></pre>\n\n<p>In this case, each variable has an independent space in memory. We can see this behavior if we try to reassign one of them:</p>\n<pre><code>movie = \"Terminator\";\n\nconsole.log(movie); // \"Terminator\"\n\nconsole.log(bestSeller); // \"Home Alone\"\n</code></pre>\n\n<p>In this case, reassigning <code>movie</code> doesn't affect <code>bestSeller</code> since they are in two different spaces in memory. Properties or variables holding objects (e.g., regular objects, arrays, and functions) are references pointing to a single space in memory. <strong>If we try to copy an object, we are merely duplicating its reference.</strong></p>\n<pre><code>let movie = {title: \"Home Alone\"};\nlet bestSeller = movie;\n\nbestSeller.title = \"Terminator\";\n\nconsole.log(movie); // {title: \"Terminator\"}\n\nconsole.log(bestSeller); // {title: \"Terminator\"}\n</code></pre>\n\n<p>As you can see, they are now objects, and reassigning a <code>bestSeller</code> property also changes the <code>movie</code> result. Under the hood, JavaScript looks at the actual object in memory and performs the change, and both references point to the changed object.</p>\n<p>Knowing how objects behave “by reference,” we can now understand how using the <code>delete</code> operator doesn’t free space in memory.</p>\n<p>The process in which programming languages free memory is called <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Garbage_collection\"><em>garbage collection</em></a>. In JavaScript, memory is freed for an object when there are no more references and it <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_management#garbage_collection\">becomes unreachable</a>. So, using the <code>delete</code> operator may make the property’s space eligible for collection, but there may be more references preventing it from being deleted from memory.</p>\n<p>While we’re on the topic, it’s worth noting that there is a bit of a <a href=\"https://stackoverflow.com/questions/59431589/javascript-performance-constraints-of-delete-keyword\">debate around the <code>delete</code> operator’s impact on performance</a>. You can follow the rabbit trail from the link, but I’ll go ahead and spoil the ending for you: the difference in performance is so negligible that it wouldn’t pose a problem in the vast majority of use cases. Personally, I consider the operator’s idiomatic and straightforward approach a win over a minuscule hit to performance.</p>\n<p>That said, an argument can be made against using <code>delete</code> since it mutates an object. In general, it’s a good practice to avoid mutations since they may lead to unexpected behavior where a variable doesn’t hold the value we assume it has.</p>\nContestant C: “I Deleted The Property Through A <code>Proxy</code> Object.”\n<p>This contestant was definitely a show-off and used a proxy for their answer. A proxy is a way to insert some middle logic between an object’s common operations, like getting, setting, defining, and, yes, deleting properties. It works through the <code>Proxy</code> constructor that takes two parameters:</p>\n<ul>\n<li><strong><code>target</code>:</strong> The object from where we want to create a proxy.</li>\n<li><strong><code>handler</code>:</strong> An object containing the middle logic for the operations.</li>\n</ul>\n<p>Inside the <code>handler</code>, we define methods for the different operations, called <em>traps</em>, because they intercept the original operation and perform a custom change. The constructor will return a <code>Proxy</code> object — an object identical to the <code>target</code> — but with the added middle logic.</p>\n<pre><code>const cat = {\n  breed: \"siamese\",\n  age: 3,\n};\n\nconst handler = {\n  get(target, property) {\n    return `cat's ${property} is ${target[property]}`;\n  },\n};\n\nconst catProxy = new Proxy(cat, handler);\n\nconsole.log(catProxy.breed); // cat's breed is siamese\n\nconsole.log(catProxy.age); // cat's age is 3\n</code></pre>\n\n<p>Here, the <code>handler</code> modifies the getting operation to return a custom value.</p>\n<p>Say we want to log the property we are deleting to the console each time we use the <code>delete</code> operator. We can add this custom logic through a proxy using the <code>deleteProperty</code> trap.</p>\n<pre><code>const product = {\n  name: \"vase\",\n  price: 10,\n};\n\nconst handler = {\n  deleteProperty(target, property) {\n    console.log(`Deleting property: ${property}`);\n  },\n};\n\nconst productProxy = new Proxy(product, handler);\n\ndelete productProxy.name; // Deleting property: name\n</code></pre>\n\n<p>The name of the property is logged in the console but throws an error in the process:</p>\n<div>\n<pre><code>Uncaught TypeError: 'deleteProperty' on proxy: trap returned falsish for property 'name'\n</code></pre>\n</div>\n\n<p>The error is thrown because the handler didn’t have a <code>return</code> value. That means it defaults to <code>undefined</code>. In strict mode, if the <code>delete</code> operator returns <code>false</code>, it will throw an error, and <code>undefined</code>, being a falsy value, triggers this behavior.</p>\n<p>If we try to return <code>true</code> to avoid the error, we will encounter a different sort of issue:</p>\n<pre><code>// ...\n\nconst handler = {\n  deleteProperty(target, property) {\n    console.log(`Deleting property: ${property}`);\n\n    return true;\n  },\n};\n\nconst productProxy = new Proxy(product, handler);\n\ndelete productProxy.name; // Deleting property: name\n\nconsole.log(productProxy); // {name: 'vase', price: 10}\n</code></pre>\n\n<p>The property isn’t deleted!</p>\n<p>We replaced the <code>delete</code> operator’s default behavior with this code, so it doesn’t remember it has to “delete” the property.</p>\n<p>This is where <code>Reflect</code> comes into play.</p>\n<blockquote><code>Reflect</code> is a global object with a collection of all the internal methods of an object. Its methods can be used as normal operations anywhere, but it’s meant to be used inside a proxy.</blockquote>\n\n<p>For example, we can solve the issue in our code by returning <code>Reflect.deleteProperty()</code> (i.e., the <code>Reflect</code> version of the <code>delete</code> operator) inside of the handler.</p>\n<pre><code>const product = {\n  name: \"vase\",\n  price: 10,\n};\n\nconst handler = {\n  deleteProperty(target, property) {\n    console.log(`Deleting property: ${property}`);\n\n    return Reflect.deleteProperty(target, property);\n  },\n};\n\nconst productProxy = new Proxy(product, handler);\n\ndelete productProxy.name; // Deleting property: name\n\nconsole.log(product); // {price: 10}\n</code></pre>\n\n<p>It is worth calling out that certain objects, like <code>Math</code>, <code>Date</code>, and <code>JSON</code>, have properties that cannot be deleted using the <code>delete</code> operator or any other method. These are “non-configurable” object properties, meaning that they cannot be reassigned or deleted. If we try to use the <code>delete</code> operator on a non-configurable property, it will fail silently and return <code>false</code> or throw an error if we are running our code in strict mode.</p>\n<pre><code>\"use strict\";\n\ndelete Math.PI;\n</code></pre>\n\n<p>Output:</p>\n<pre><code>Uncaught TypeError: Cannot delete property 'PI' of #&lt;Object&gt;\n</code></pre>\n\n<p>If we want to avoid errors with the <code>delete</code> operator and non-configurable properties, we can use the <code>Reflect.deleteProperty()</code> method since it doesn’t throw an error when trying to delete a non-configurable property — even in strict mode — because it fails silently.</p>\n<p>I assume, however, that you would prefer knowing when you are trying to delete a global object rather than avoiding the error.</p>\nContestant D: “I Avoided Mutation By Using Object Destructuring.”\n<blockquote><strong>Object destructuring</strong> is an assignment syntax that extracts an object’s properties into individual variables. It uses a curly braces notation (<code>{}</code>) on the left side of an assignment to tell which of the properties to get.</blockquote>\n\n<pre><code>const movie = {\n  title: \"Avatar\",\n  genre: \"science fiction\",\n};\n\nconst {title, genre} = movie;\n\nconsole.log(title); // Avatar\n\nconsole.log(genre); // science fiction\n</code></pre>\n\n<p>It also works with arrays using square brackets (<code>[]</code>):</p>\n<pre><code>const animals = [\"dog\", \"cat\", \"snake\", \"elephant\"];\n\nconst [a, b] = animals;\n\nconsole.log(a); // dog\n\nconsole.log(b); // cat\n</code></pre>\n\n<p>The spread syntax (<code>...</code>) is sort of like the opposite operation because it encapsulates several properties into an object or an array if they are single values.</p>\n<p>We can use object destructuring to unpack the values of our object and the spread syntax to keep only the ones we want:</p>\n<pre><code>const car = {\n  type: \"truck\",\n  color: \"black\",\n  doors: 4\n};\n\nconst {color, ...newCar} = car;\n\nconsole.log(newCar); // {type: 'truck', doors: 4}\n</code></pre>\n\n<p>This way, we avoid having to mutate our objects and the potential side effects that come with it!</p>\n<p>Here’s an edge case with this approach: deleting a property only when it’s <code>undefined</code>. Thanks to the flexibility of object destructuring, we can delete properties when they are <code>undefined</code> (or <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Falsy\">falsy</a>, to be exact).</p>\n<p>Imagine you run an online store with a vast database of products. You have a function to find them. Of course, it will need some parameters, perhaps the product name and category.</p>\n<pre><code>const find = (product, category) =&gt; {\n  const options = {\n    limit: 10,\n    product,\n    category,\n  };\n\n  console.log(options);\n\n  // Find in database...\n};\n</code></pre>\n\n<p>In this example, the product <code>name</code> has to be provided by the user to make the query, but the <code>category</code> is optional. So, we could call the function like this:</p>\n<pre><code>find(\"bedsheets\");\n</code></pre>\n\n<p>And since a <code>category</code> is not specified, it returns as <code>undefined</code>, resulting in the following output:</p>\n<pre><code>{limit: 10, product: 'beds', category: undefined}\n</code></pre>\n\n<p>In this case, we shouldn’t use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters\">default parameters</a> because we aren’t looking for one specific category.</p>\n<p>Notice how the database could incorrectly assume that we are querying products in a category called <code>undefined</code>! That would lead to an empty result, which is an unintended side effect. Even though many databases will filter out the <code>undefined</code> property for us, it would be better to sanitize the options before making the query. A cool way to dynamically remove an <code>undefined</code> property is through object destructing along with the <code>AND</code> operator (<code>&amp;&amp;</code>).</p>\n<p>Instead of writing <code>options</code> like this:</p>\n<pre><code>const options = {\n  limit: 10,\n  product,\n  category,\n};\n</code></pre>\n\n<p>...we can do this instead:</p>\n<pre><code>const options = {\n  limit: 10,\n  product,\n  ...(category &amp;&amp; {category}),\n};\n</code></pre>\n\n<p>It may seem like a complex expression, but after understanding each part, it becomes a straightforward one-liner. What we are doing is taking advantage of the <code>&amp;&amp;</code> operator.</p>\n<p>The <code>AND</code> operator is mostly used in conditional statements to say,</p>\n<blockquote>If <code>A</code> and <code>B</code> are <code>true</code>, then do this.</blockquote>\n\n<p>But at its core, it evaluates two expressions from left to right, returning the expression on the left if it is <em>falsy</em> and the expression on the right if they are both <em>truthy</em>. So, in our prior example, the <code>AND</code> operator has two cases:</p>\n<ol>\n<li><code>category</code> is <code>undefined</code> (or <em>falsy</em>);</li>\n<li><code>category</code> is defined.</li>\n</ol>\n<p>In the first case where it is <em>falsy</em>, the operator returns the expression on the left, <code>category</code>. If we plug <code>category</code> inside the rest of the object, it evaluates this way:</p>\n<pre><code>const options = {\n  limit: 10,\n\n  product,\n\n  ...category,\n};\n</code></pre>\n\n<p>And if we try to destructure any falsy value inside an object, they will be destructured into nothing:</p>\n<pre><code>const options = {\n  limit: 10,\n  product,\n};\n</code></pre>\n\n<p>In the second case, since the operator is <em>truthy</em>, it returns the expression on the right, <code>{category}</code>. When plugged into the object, it evaluates this way:</p>\n<pre><code>const options = {\n  limit: 10,\n  product,\n  ...{category},\n};\n</code></pre>\n\n<p>And since <code>category</code> is defined, it is destructured into a normal property:</p>\n<pre><code>const options = {\n  limit: 10,\n  product,\n  category,\n};\n</code></pre>\n\n<p>Put it all together, and we get the following <code>betterFind()</code> function:</p>\n<pre><code>const betterFind = (product, category) =&gt; {\n  const options = {\n    limit: 10,\n    product,\n    ...(category &amp;&amp; {category}),\n  };\n\n  console.log(options);\n\n  // Find in a database...\n};\n\nbetterFind(\"sofas\");\n</code></pre>\n\n<p>And if we don’t specify any <code>category</code>, it simply does not appear in the final <code>options</code> object.</p>\n<pre><code>{limit: 10, product: 'sofas'}\n</code></pre>\n\n\n\nContestant E: “I Used <code>JSON.stringify</code> And <code>JSON.parse</code>.”\n<p>Surprisingly to me, there is a way to remove a property by reassigning it to <code>undefined</code>. The following code does exactly that:</p>\n<pre><code>let monitor = {\n  size: 24,\n  screen: \"OLED\",\n};\n\nmonitor.screen = undefined;\n\nmonitor = JSON.parse(JSON.stringify(monitor));\n\nconsole.log(monitor); // {size: 24}\n</code></pre>\n\n<p>I sort of lied to you since we are employing some JSON shenanigans to pull off this trick, but we can learn something useful and interesting from them.</p>\n<p>Even though JSON takes direct inspiration from JavaScript, it differs in that it has a strongly typed syntax. It doesn’t allow functions or <code>undefined</code> values, so using <code>JSON.stringify()</code> will omit all non-valid values during conversion, resulting in JSON text without the <code>undefined</code> properties. From there, we can parse the JSON text back to a JavaScript object using the <code>JSON.parse()</code> method.</p>\n<p>It’s important to know the limitations of this approach. For example, <code>JSON.stringify()</code> skips functions and throws an error if either a circular reference (i.e., a property is referencing its parent object) or a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt\"><code>BigInt</code></a> value is found.</p>\nContestant F: “We Rely On Lodash At My Company.”\n<p>It’s worth noting that utility libraries such as Lodash.js, Underscore.js, or Ramda also provide methods to delete — or <code>pick()</code> — properties from an object. We won’t go through different examples for each library since their documentation already does an excellent job of that.</p>\nConclusion\n<p>Back to our initial scenario, which contestant is right?</p>\n<p>The answer: <strong>All of them!</strong> Well, except for the first contestant. Setting a property to <code>undefined</code> just isn’t an approach we want to consider for removing a property from an object, given all of the other ways we have to go about it.</p>\n<p>Like most things in development, the most “correct” approach depends on the situation. But what’s interesting is that behind each approach is a lesson about the very nature of JavaScript. Understanding all the ways to delete a property in JavaScript can teach us fundamental aspects of programming and JavaScript, such as memory management, garbage collection, proxies, JSON, and object mutation. That’s quite a bit of learning for something seemingly so boring and trivial!</p>\n<h4>Further Reading On SmashingMag</h4>\n<ul>\n<li>“<a href=\"https://www.smashingmagazine.com/2023/02/discovering-primitive-objects-javascript-part1/\">Discovering Primitive Objects In JavaScript (Part 1)</a>,” Kirill Myshkin</li>\n<li>“<a href=\"https://www.smashingmagazine.com/2023/06/primitive-objects-javascript-part-2/\">Primitive Objects In JavaScript: When To Use Them (Part 2)</a>,” Kirill Myshkin</li>\n<li>“<a href=\"https://www.smashingmagazine.com/2019/09/reintroduction-destructuring-assignment/\">A Re-Introduction To Destructuring Assignment</a>,” Laurie Barth</li>\n<li>“<a href=\"https://www.smashingmagazine.com/2022/11/document-object-model-geometry-guide/\">Document Object Model (DOM) Geometry: A Beginner’s Introduction And Guide</a>,” Pearl Akpan</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"3c61873e3c6978f35b5a23bfea74982720589a83cf34f76fcffe81447d2d7408","category":"Tech"}