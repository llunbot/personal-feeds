{"title":"AWS Cloud Control API, a Uniform API to Access AWS & Third-Party Services","link":"https://aws.amazon.com/blogs/aws/announcing-aws-cloud-control-api/","date":1633028685000,"content":"<p>Today, I am happy to announce the availability of <a href=\"https://aws.amazon.com/cloudcontrolapi\">AWS Cloud Control API</a> a set of common application programming interfaces (APIs) that are designed to make it easy for developers to manage their AWS and third-party services.</p> \n<p>AWS delivers the broadest and deepest portfolio of cloud services. Builders leverage these to build any type of cloud infrastructure. It started with <a href=\"https://aws.amazon.com/s3/\">Amazon Simple Storage Service (Amazon S3)</a> <a href=\"https://aws.amazon.com/blogs/aws/amazon-s3s-15th-birthday-it-is-still-day-1-after-5475-days-100-trillion-objects/\">15 years ago</a> and grew over 200+ services. Each AWS service has a specific API with its own vocabulary, input parameters, and error reporting. For example, you use the <span>S3</span> <code>CreateBucket</code> API to create an <a href=\"https://aws.amazon.com/s3/\">Amazon Simple Storage Service (Amazon S3)</a> bucket and the <a href=\"https://aws.amazon.com/ec2/\">Amazon Elastic Compute Cloud (Amazon EC2)</a> <code>RunInstances</code> API to create an <span>EC2</span> instances.</p> \n<p>Some of you use AWS APIs to build infrastructure-as-code, some to inspect and automatically improve your security posture, some others for configuration management, or to provision and to configure high performance compute clusters. The use cases are countless.</p> \n<p>As applications and infrastructures become increasingly sophisticated and you work across more AWS services, it becomes increasingly difficult to learn and manage distinct APIs. This challenge is exacerbated when you also use third-party services in your infrastructure, since you have to build and maintain custom code to manage both the AWS and third-party services together.</p> \n<p><span>Cloud Control API</span> is a standard set of APIs to Create, Read, Update, Delete, and List (CRUDL) resources across hundreds of AWS Services (more being added) and <a href=\"https://console.aws.amazon.com/cloudformation/home?region=us-east-1#/registry/public-extensions?visibility=PUBLIC&amp;type=RESOURCE&amp;category=THIRD_PARTY\">dozens of third-party services</a> (and growing).</p> \n<p>It exposes five common verbs (<code>CreateResource</code>, <code>GetResource</code>, <code>UpdateResource</code>, <code>DeleteResource</code>, <code>ListResource</code>) to manage the lifecycle of services. For example, to create an <a href=\"https://aws.amazon.com/ecs/\">Amazon Elastic Container Service (Amazon ECS)</a> cluster or an <a href=\"https://aws.amazon.com/lambda/\">AWS Lambda</a> function, you call the same <code>CreateResource</code> API, passing as parameters the type and attributes of the resource you want to create: an <a href=\"https://aws.amazon.com/ecs\">Amazon ECS</a> cluster or an <span>Lambda</span> function. The input parameters are defined by an unified resource model using JSON. Similarly, the return types and error messages are uniform across all verbs and all resources.</p> \n<p><span>Cloud Control API</span> provides support for hundreds of AWS resources today, and we will continue to add support for existing AWS resources across services such as <a href=\"https://aws.amazon.com/ec2/\">Amazon Elastic Compute Cloud (Amazon EC2)</a> and <a href=\"https://aws.amazon.com/s3/\">Amazon Simple Storage Service (Amazon S3)</a> in the coming months. It will support new AWS resources typically on the day of launch.</p> \n<p>Until today, when I want to get the details about an <span>Lambda</span> function or a <a href=\"https://aws.amazon.com/kinesis/\">Amazon Kinesis</a> stream, I use the <code>get-function</code> API to call Lambda and the <code>describe-stream</code> API to call <a href=\"https://aws.amazon.com/kinesis/\">Kinesis</a>. Notice in the example below how different these two API calls are: they have different names, different naming conventions, different JSON outputs, etc.</p> \n<pre><code>aws lambda get-function --function-name TictactoeDatabaseCdkStack\n{\n    \"Configuration\": {\n        \"FunctionName\": \"TictactoeDatabaseCdkStack\",\n        \"FunctionArn\": \"arn:aws:lambda:us-west-2:0123456789:function:TictactoeDatabaseCdkStack\",\n        \"Runtime\": \"nodejs14.x\",\n        \"Role\": \"arn:aws:iam::0123456789:role/TictactoeDatabaseCdkStack\",\n        \"Handler\": \"framework.onEvent\",\n        \"CodeSize\": 21539,\n        \"Timeout\": 900,\n        \"MemorySize\": 128,\n        \"LastModified\": \"2021-06-07T11:26:39.767+0000\",\n\n...\n\naws kinesis describe-stream --stream-name AWSNewsBlog\n{\n    \"StreamDescription\": {\n        \"Shards\": [\n            {\n                \"ShardId\": \"shardId-000000000000\",\n                \"HashKeyRange\": {\n                    \"StartingHashKey\": \"0\",\n                    \"EndingHashKey\": \"340282366920938463463374607431768211455\"\n                },\n                \"SequenceNumberRange\": {\n                    \"StartingSequenceNumber\": \"49622132796672989268327879810972713309953024040638611458\"\n                }\n            }\n        ],\n        \"StreamARN\": \"arn:aws:kinesis:us-west-2:012345678901:stream/AWSNewsBlog\",\n        \"StreamName\": \"AWSNewsBlog\",\n        \"StreamStatus\": \"ACTIVE\",\n        \"RetentionPeriodHours\": 24,\n        \"EncryptionType\": \"NONE\",\n        \"KeyId\": null,\n        \"StreamCreationTimestamp\": \"2021-09-17T14:58:20+02:00\"\n    }\n}\t\n</code></pre> \n<p>In contrast, when using the <span>Cloud Control API</span>, I use a single API name <code>get-resource</code>, and I receive a consistent output.</p> \n<pre><code>aws cloudcontrol get-resource        \\\n    --type-name AWS::Kinesis::Stream \\\n    --identifier NewsBlogDemo\n{\n   \"TypeName\": \"AWS::Kinesis::Stream\",\n   \"ResourceDescription\": {\n      \"Identifier\": \"NewsBlogDemo\",\n      \"Properties\": \"{\\\"Arn\\\":\\\"arn:aws:kinesis:us-west-2:486652066693:stream/NewsBlogDemo\\\",\\\"RetentionPeriodHours\\\":168,\\\"Name\\\":\\\"NewsBlogDemo\\\",\\\"ShardCount\\\":3}\"\n   }\n}\t\n</code></pre> \n<p>Similary, to create the resource above I used the <code>create-resource</code> API.</p> \n<pre><code>\naws cloudcontrol create-resource    \\\n   --type-name AWS::Kinesis::Stream \\\n   --desired-state \"{\"Name\": \"NewsBlogDemo\",\"RetentionPeriodHours\":168, \"ShardCount\":3}\"\n</code></pre> \n<p>In my opinion, there are three types of builders that are going to adopt <span>Cloud Control API</span>:</p> \n<p><strong><span>Builders</span><br /> </strong>The first community is <strong>builders</strong> using AWS Services APIs to manage their infrastructure or their customer’s infrastructure. The ones requiring usage of low-level AWS Services APIs rather than higher level tools. For example, I know companies that manages AWS infrastructures on behalf of their clients. Many developed solutions to list and describe all resources deployed in their client’s AWS Accounts, for management and billing purposes. Often, they built specific tools to address their requirements, but find it hard to keep up with new AWS Services and features. <span>Cloud Control API</span> simplifies this type of tools by oﬀering a consistent, resource-centric approach. It makes easier to keep up with new AWS Services and features.</p> \n<p>Another example: <a href=\"https://www.stedi.com/\">Stedi</a> is a developer-focused platform for building automated Electronic Data Interchange (EDI) solutions that integrate with any business system. “We have a strong focus on infrastructure as code (IaC) within Stedi and have been looking for a programmatic way to discover and delete legacy cloud resources that are no longer managed through <span>CloudFormation</span> – helping us reduce complexity and manage cost,” said <a href=\"https://www.linkedin.com/in/olafconijn/\">Olaf Conjin</a>, Serverless Engineer at Stedi, Inc. “With <span>AWS Cloud Control API</span>, our teams can easily list each of these legacy resources, cross-reference them against <span>CloudFormation</span> managed resources, apply additional logic and delete the legacy resources. By deleting these unused legacy resources using <span>Cloud Control API</span>, we can manage our cloud spend in a simpler and faster manner. <span>Cloud Control API</span> allows us to remove the need to author and maintain custom code to discover and delete each type of resource, helping us improve our developer velocity”.</p> \n<p><span><strong>APN Partners<br /> </strong></span>The second community that benefits from <span>Cloud Control API</span> is<strong> <a href=\"https://aws.amazon.com/partners/\">APN Partners</a></strong>, such as <a href=\"https://www.hashicorp.com\">HashiCorp</a> (maker of <a href=\"https://www.hashicorp.com/products/terraform\">Terraform</a>) and <a href=\"https://www.pulumi.com\">Pulumi</a>, and other APN Partners offering solutions that relies on AWS Services APIs. When AWS releases a new service or feature, our partner’s engineering teams need to learn, integrate, and test a new set of AWS Service APIs to expose it in their offerings. This is a time consuming process and often leads to a lag between the AWS release and the availability of the service or feature in their solution. With the new <span>Cloud Control API</span>, partners are now able to build a unique REST API code base, using unified API verbs, common input parameters, and common error types. They just have to merge the standardized pre-defined uniform resource model to interact with new AWS Services exposed as REST resources.</p> \n<p><strong><span>Launch Partners</span><br /> </strong>HashiCorp and Pulumi are our launch partners, both solutions are integrated with <span>Cloud Control API</span> today.</p> \n<p><a href=\"https://www.hashicorp.com\"><strong>HashiCorp</strong></a> provides cloud infrastructure automation software that enables organizations to provision, secure, connect, and run any infrastructure for any application. “<span>AWS Cloud Control API</span> makes it easier for our teams to build solutions to integrate with new and existing AWS services,” said <a href=\"https://www.linkedin.com/in/jamesbayer/\">James Bayer</a> – EVP Product, HashiCorp. “Integrating HashiCorp Terraform with <span>AWS Cloud Control API</span> means developers are able to use the newly released AWS features and services, typically on the day of launch.”</p> \n<p><a href=\"https://www.pulumi.com\"><strong>Pulumi</strong></a>’s new AWS Native Provider, powered by the <span>AWS Cloud Control API</span>, “gives Pulumi’s users faster access to the latest AWS innovations, typically the day they launch, without any need for us to manually implement support,” said <a href=\"https://www.linkedin.com/in/joejduffy/\">Joe Duffy</a>, CEO at Pulumi. “The full surface area of AWS resources provided by <span>AWS Cloud Control API</span> can now be automated from familiar languages like Python, TypeScript, .NET, and Go, with standard IDEs, package managers, and test frameworks, with high fidelity and great quality. Using this new provider, developers and infrastructure teams can develop and ship modern AWS applications and infrastructure faster and with more confidence than ever before.”</p> \n<p>To learn more about HashiCorp and Pulumi’s integration with <span>Cloud Control API</span>, refer to their blog post and announcements. I will add the links here as soon as they are available.</p> \n<p><span><strong>AWS Customers<br /> </strong></span>The third type of builders that will benefit from <span>Cloud Control API</span> is <strong>AWS customers</strong> using solution such as Terraform or Pulumi. You can benefit from <span>Cloud Control API</span> too. For example, when using the new Terraform AWS Cloud Control <a href=\"https://www.terraform.io/docs/language/providers/index.html\">provider</a> or Pulumi’s AWS Native Provider, you can benefit from availability of new AWS Services and features typically on the day of launch.</p> \n<p>Now that you understand the benefits, let’s see <span>Cloud Control API</span> in action.</p> \n<p><span><strong>How It Works?<br /> </strong></span>To start using <span>Cloud Control API</span>, I first make sure I use the latest <a href=\"https://aws.amazon.com/cli/\">AWS Command Line Interface (CLI)</a> version. Depending on how the CLI was installed, <a href=\"https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html\">there are different methods to update the CLI</a>. <span>Cloud Control API</span> is available from our <a href=\"https://aws.amazon.com/tools/\">AWS SDKs</a> as well.</p> \n<p>To create an <a href=\"https://aws.amazon.com/lambda/\">AWS Lambda</a> function, I first create an <code>index.py</code> handler, I zip it, and upload the zip file to one of my private bucket. I pay attention that the S3 bucket is in the same AWS Region where I will create the Lambda function:</p> \n<pre><code>cat &lt;&lt; EOF &gt; index.py  \nheredoc&gt; import json \ndef lambda_handler(event, context):\n    return {\n        'statusCode': 200,\n        'body': json.dumps('Hello from Lambda!')\n    }\nEOF\n\nzip index.zip index.py\naws s3 cp index.zip s3://private-bucket-seb/index.zip</code></pre> \n<p>Then, I call the <code>create-resource</code> API, passing the same set of arguments as required by the corresponding <span>CloudFormation</span> resource. In this example, the <code>Code</code>, <code>Role</code>, <code>Runtime</code>, and <code>Handler</code> arguments are mandatory, as per the <span>CloudFormation</span> <a href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html\">AWS::Lambda::Function documentation</a>.</p> \n<pre><code>aws cloudcontrol create-resource          \\\n       --type-name AWS::Lambda::Function   \\\n       --desired-state '{\"Code\":{\"S3Bucket\":\"private-bucket-seb\",\"S3Key\":\"index.zip\"},\"Role\":\"arn:aws:iam::0123456789:role/lambda_basic_execution\",\"Runtime\":\"python3.9\",\"Handler\":\"index.lambda_handler\"}' \\\n       --client-token 123\n\n\n{\n    \"ProgressEvent\": {\n        \"TypeName\": \"AWS::Lambda::Function\",\n        \"RequestToken\": \"56a0782b-2b26-491c-b082-18f63d571bbd\",\n        \"Operation\": \"CREATE\",\n        \"OperationStatus\": \"IN_PROGRESS\",\n        \"EventTime\": \"2021-09-26T12:05:42.210000+02:00\"\n    }\n}</code></pre> \n<p>I may call the same command again to get the status or to learn about an eventual error:</p> \n<pre><code>aws cloudcontrol create-resource          \\\n       --type-name AWS::Lambda::Function   \\\n       --desired-state '{\"Code\":{\"S3Bucket\":\"private-bucket-seb\",\"S3Key\":\"index.zip\"},\"Role\":\"arn:aws:iam::0123456789:role/lambda_basic_execution\",\"Runtime\":\"python3.9\",\"Handler\":\"index.lambda_handler\"}' \\\n       --client-token 123\n\n{\n    \"ProgressEvent\": {\n        \"TypeName\": \"AWS::Lambda::Function\",\n        \"Identifier\": \"ukjfq7sqG15LvfC30hwbRAMfR-96K3UNUCxNd9\",\n        \"RequestToken\": \"f634b21d-22ed-41bb-9612-8740297d20a3\",\n        \"Operation\": \"CREATE\",\n        \"OperationStatus\": \"SUCCESS\",\n        \"EventTime\": \"2021-09-26T19:46:46.643000+02:00\"\n    }\n}\n</code></pre> \n<p>Here, the <code>OperationStatus</code> is SUCCESS and the function name is <code>ukjfq7sqG15LvfC30hwbRAMfR-96K3UNUCxNd9</code> (I can pass my own name if I want something more descriptive :-) )</p> \n<p>I then invoke the Lambda function to ensure it works as expected:</p> \n<pre><code>aws lambda invoke \\\n    --function-name ukjfq7sqG15LvfC30hwbRAMfR-96K3UNUCxNd9 \\\n    out.txt &amp;&amp; cat out.txt &amp;&amp; rm out.txt \n\n{\n    \"StatusCode\": 200,\n    \"ExecutedVersion\": \"$LATEST\"\n}\n{\"statusCode\": 200, \"body\": \"\\\"Hello from Lambda!\\\"\"}</code></pre> \n<p>When finished, I delete the Lambda function using <span>Cloud Control API</span>:</p> \n<pre><code>aws cloudcontrol delete-resource \\\n     --type-name AWS::Lambda::Function \\\n     --identifier ukjfq7sqG15LvfC30hwbRAMfR-96K3UNUCxNd9 \n{\n    \"ProgressEvent\": {\n        \"TypeName\": \"AWS::Lambda::Function\",\n        \"Identifier\": \"ukjfq7sqG15LvfC30hwbRAMfR-96K3UNUCxNd9\",\n        \"RequestToken\": \"8923991d-72b3-4981-8160-4d9a585965a3\",\n        \"Operation\": \"DELETE\",\n        \"OperationStatus\": \"IN_PROGRESS\",\n        \"EventTime\": \"2021-09-26T20:06:22.013000+02:00\"\n    }\n}</code></pre> \n<p><span><strong>Idempotency<br /> </strong></span>You might have noticed the <code>client-token</code> parameter I passed to the <code>create-resource</code> API call. <code>Create</code>, <code>Update</code>, and <code>Delete</code> requests all accept a <code>ClientToken</code>, which is used to ensure <a href=\"https://en.wikipedia.org/wiki/Idempotence\">idempotency</a> of the request.</p> \n<ul> \n <li>We recommend <strong>always</strong> passing a client token. This will disambiguate requests in case a retry is needed. Otherwise, you may encounter unexpected errors like <code>ConcurrentOperationException</code> or <code>AlreadyExists</code>.</li> \n <li>We recommend that client tokens always be unique for every single request, such as by passing a <a href=\"https://en.wikipedia.org/wiki/Universally_unique_identifier\">UUID</a>.</li> \n</ul> \n<p><span><strong>One More Thing<br /> </strong></span>At the heart of <span>AWS Cloud Control API</span> source of data, there is the <a href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/registry.html\">CloudFormation Public Registry</a>, which my colleague <a href=\"https://twitter.com/bellevuesteve\">Steve</a> <a href=\"https://aws.amazon.com/blogs/aws/introducing-a-public-registry-for-aws-cloudformation/\">announced</a> earlier this month in <a href=\"https://aws.amazon.com/blogs/aws/introducing-a-public-registry-for-aws-cloudformation/\">this blog</a> post. It allows anyone to expose a set of AWS resources through <span>CloudFormation</span> and <span>AWS CDK</span>. This is the mechanism AWS Service teams are now using to release their services and features as <span>CloudFormation</span> and <span>AWS CDK</span> resources. Multiple third-party vendors are also publishing their solutions in the CloudFormation Public Registry. All resources published are <a href=\"https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/resource-type-model.html\">modelled</a> with a standard schema that defines the resource, its properties, and their attributes in a uniform way.</p> \n<p><span>AWS Cloud Control API</span> is a CRUDL API layer on top of resources published in the CloudFormation Public Registry. Any resource published in the registry exposes its attributes with standard JSON schemas. The resource can then be created, updated, deleted, or listed using <span>Cloud Control API</span> with no additional work.</p> \n<p>For example, imagine I decide to expose a public <span>CloudFormation</span> stack to let any AWS customer create VPN servers, based on <span>EC2</span> instances. I model the VPNServer resource type and publish it in the CloudFormation Public Registry. With no additional work on my side, my custom resource “VPNServer” is now available to all AWS customers through the <span>Cloud Control API</span> REST API. Not only, it is also automatically available through solutions like Hashicorp’s Terraform and Pulumi, and potentially others who adopt Cloud Control API in the future.</p> \n<p>It is worth mentioning <span>Cloud Control API</span> is not aimed at replacing the traditional AWS service-level APIs. They are still there and will always be there, but we think that <span>Cloud Control API</span> is easier and more consistent to use and you should use it for new apps.</p> \n<p><span><strong>Availability and Pricing<br /> </strong></span><span>Cloud Control API</span> is available in all AWS Regions, except China.</p> \n<p>You will only pay for the usage of underlying AWS resources, such as a <a href=\"https://aws.amazon.com/cloudwatch/\">CloudWatch</a> logs or <span>Lambda</span> functions invocations, or pay for the number of handler operations and handler operation duration associated with using third-party resources (such as Datadog monitors or MongoDB Atlas clusters). There are no minimum fees and no required upfront commitments.</p> \n<p>I can’t wait to discover what you are going to build on top of this <a href=\"https://docs.aws.amazon.com/cloudcontrolapi/latest/userguide/what-is-cloudcontrolapi.html\">new Cloud Control API</a>. Go build!</p> \n<a href=\"https://twitter.com/sebsto\">-- seb</a>","author":"Sébastien Stormacq","siteTitle":"AWS News Blog","siteHash":"6093e072e4117ec22616e844cb857d03ca62c57a411a8affc77cb5e8b6b15bf6","entryHash":"72b1b467132985403725bca8c15247f2ac2c43cdc2322a011c433aae72e4d5fc","category":"Tech"}