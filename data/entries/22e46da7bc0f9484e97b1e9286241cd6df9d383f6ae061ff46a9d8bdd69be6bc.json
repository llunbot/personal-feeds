{"title":"Next.js Wildcard Subdomains","link":"https://smashingmagazine.com/2021/11/nextjs-wildcard-subdomains/","date":1637317800000,"content":"<p>A ‚Äúwildcard‚Äù? What in the world? Great question, these types of domain stem from <em>Wildcard DNS Records</em> which look like this:</p>\n<pre><code>*.example.               3600     TXT   \"Wild! You have found a wildcard.\"\n</code></pre>\n\n<p>When used, this DNS record will cause any subdomain that matches with the wildcard to hold a <code>TXT</code> value of: ‚ÄúWild! You have found a wildcard.‚Äù</p>\n<p>For example, if this was set on the domain <code>smashingmagazine.com</code>, <code>apples.example.smashingmagazine.com</code> and <code>oranges.example.smashingmagazine.com</code> would both return the above TXT value. The same principle can be applied to CNAME &amp; A records as well.</p>\nWild Use Cases For Wildcards\n<p>Wildcards can be used for a wide range of things. For now, let‚Äôs focus on where they can be applied in combination with Next.js:</p>\n<ol>\n<li><strong>Providing Hosted Services</strong><br />The most common use of wildcard domains is to provide users of hosted services their own space with a unique subdomain. For example, if I was building a platform for restaurants to host digital ordering platforms with the domain <code>menus.abc</code>, I would be able to offer Dom‚Äôs Pizzeria <code>domspizzeria.menus.abc</code> and Magical Prata the domain <code>magicalprata.menus.abc</code>. The benefit of this is that it gives each of these establishments their enclosed space which they can customize and build out. This space can act as its own website ‚Äî not tied to anything.</li>\n<li><strong>Hosting Content And Personal Portfolios</strong><br />Wildcards can also be used as a space for hosting content in portfolios, giving a sense of individuality to these portfolios, an example of this would be how Medium provides subdomains for the authors.</li>\n<li><strong>Wilder More Creative Use Cases</strong><br />You can‚Äôt define these use cases, but there are many creative use cases of these styles of domains. For example, later in this article, we‚Äôll be developing a web toy that flips a webpage upside down making it readable for Australians. </li>\n</ol>\nThe Caveats Of Wildcards With Next.js\n<p><em>Sigh.</em> Unfortunately, using wildcards isn‚Äôt perfect there are a couple of drawbacks:</p>\n<ul>\n<li><strong>No More Static-Site Generation (and ISR)</strong><br />Unfortunately, there aren‚Äôt any special systems to provide custom statically generated pages for different wildcard subdomains like you may with dynamic routing for example (where you have <code>[slug].js</code> files).</li>\n<li><strong>Difficulties with Development</strong><br />When developing locally, it can be a pain to simulate wildcard domains and we‚Äôll be touching on this a fair bit later on in this article but it is something important to keep in mind.</li>\n<li><strong>Limited Deployment Platforms</strong><br />Vercel supports Wildcard Domains, however, other Jamstack oriented platforms do not all support wildcard domains. For example, Netlify limits the feature to a select group of users on the Pro plan.</li>\n</ul>\nBuilding With Wildcards\n<p>With all this talk, let‚Äôs look at building with these domains. We‚Äôll be focusing on three places where you can get the wildcard:</p>\n<ol>\n<li><a href=\"#server-side-in-getserversideprops\">Server Side In <code>getServerSideProps</code></a>,</li>\n<li><a href=\"#client-side-with-useeffect\">Client Side With <code>useEffect</code></a>,</li>\n<li><a href=\"#server-side-on-api-routes-and-edge-functions\"><a href=\"link\">Server Side On API Routes And Edge Functions</a></a>.</li>\n</ol>\n<h3>Server Side In <code>getServerSideProps</code></h3>\n<p>This is the most commonplace in which you will need to extract the wildcard, you can use this on pages where you need to render completely different content for different wildcards. As discussed above, this can not be done through static site generation so we must do it on server-side rendered pages.</p>\n<p>The <code>getServerSideProps</code> is passed a context object, in this object you can access the HTTP request object using <code>context.req</code>. In this request object, you can access the hostname at <code>headers.host</code>, which will return a string such as <code>example.yourdomain.com</code>. We can split the string into an array across each period and then access the first item in said array. In code, that looks like this:</p>\n<pre><code>export async function getServerSideProps(context) {\n  let wildcard = context.req.headers.host.split(\".\")[0];\n  wildcard =\n    wildcard != \"yourdomain\"\n      ? process.env.NODE_ENV != \"development\"\n        ? wildcard\n        : process.env.TEST_WILDCARD\n      : \"home\";\n  return { props: { wildcard } };\n}</code></pre>\n\n<p>As you can see in this piece of code, we do an extra set processing on the wildcard if it‚Äôs the base domain we set the wildcard to <code>home</code> (if taking user input, this is a case you will need to handle) and if we are testing on localhost we can test out other wildcards. In our default export function, which renders our page we can use a switch statement to handle the wildcards:</p>\n<pre><code>export default function App(props) {\n  switch(props.wildcard) {\n    case \"home\":\n      return &lt;div&gt;Welcome to the home page!&lt;/div&gt;;\n      break;\n    default:\n      return &lt;div&gt;The wild card is: {props.wildcard}.&lt;/div&gt;;\n  }\n}</code></pre>\n\n<h3>Client Side With <code>useEffect</code></h3>\n<p>If you only want to make small modifications to each page on a different wildcard, you can avoid using server-side rendering by using the <code>useEffect</code> hook on the client-side. This approach will be rather similar to how we did it in <code>getServerSideProps</code>, except we will be relying on <code>window.location.hostname</code>. Using <code>window</code> means that the initial server render won‚Äôt be able to access the information, so we must wrap it within a <code>useEffect</code> hook that runs on the client-side. Here‚Äôs how that code looks like:</p>\n<pre><code>// useEffect and useState must be imported from 'react'\n\nconst [wildcard, setWildcard] = useState(\"\")\n  useEffect(() =&gt; {\n    setWildcard(window.location.hostname.split(\".\")[0])\n  }, [])</code></pre>\n\n<p>This approach, however, is far from perfect as there is a delay between the page‚Äôs first render and the wildcard being available. Therefore, if you are making drastic changes based on the wildcard then the changes will be jarring for your user. This may also hurt your cumulative layout shift measure on your web vitals. With this in mind, I highly recommend limiting your use of this approach to adaptations that would be off-sight from the viewer on the initial load. An example would be a branded footer, on a technical documentation page. It is, of course, still handy to know.</p>\n<h3>Server Side On API Routes And Edge Functions</h3>\n<p>API routes are another area where you may want to access a wildcard from. Fortunately, the same request object we discussed in the above section on <code>getServerSideProps</code> is also available when using a Node.js API route with Next.js. We can access it like this:</p>\n<pre><code>export default (req, res) =&gt; {\n  let wildcard = req.headers.host.split(\".\")[0];\n  wildcard =\n    wildcard != \"yourdomain\"\n      ? process.env.NODE_ENV != \"development\"\n        ? wildcard\n        : process.env.TEST_WILDCARD\n      : \"home\";\n  res.json({ wildcard: wildcard })\n}</code></pre>\n\n<p>Following this, we can then take certain actions such as fetching different data from your database depending on the wildcard and return that from the API.</p>\n<p>This same logic can be applied to Next.js‚Äô new Edge Functions / Middleware. This enables you to use wildcards in more than one route without duplicating code as well as speeding up the processing as code execution happens on the edge. Whilst the functionality is still in beta, it‚Äôs certainly something to keep an eye on.</p>\n<pre><code>// _middleware.js\nexport function middleware(req) {\n  let wildcard = req.headers.get(\"host\").split(\".\")[0];\n  console.log(wildcard);\n  wildcard =\n    wildcard != \"yourdomain\"\n      ? process.env.NODE_ENV != \"development\"\n        ? wildcard\n        : process.env.TEST_WILDCARD\n      : \"home\";\n  console.log(process.env.TEST_WILDCARD);\n  return new Response(JSON.stringify({ wildcard: wildcard }), {\n    status: 200,\n    headers: { \"Content-Type\": \"application/json\" },\n  });\n}</code></pre>\n\n\n\nThe ü¶òAussie-izer\n<p>Now that we‚Äôve explored the theory of this strategy, let‚Äôs explore how we put it into practice. In this section, we‚Äôll be taking this approach to build a project that flips websites upside down (well, websites that are using a .com domain and aren‚Äôt subdomains) called the ü¶òAussie-izer.</p>\n<p>To get started, we‚Äôre going to want to run <code>yarn init</code> and then <code>yarn add next react react-dom</code>, and finish up by adding these standard scripts to our <code>package.json</code>:</p>\n<pre><code>\"scripts\": {\n  \"dev\": \"next dev\",\n  \"build\": \"next build\",\n  \"start\": \"next start\",\n  \"lint\": \"next lint\"\n}</code></pre>\n\n<p>As soon as we‚Äôve got a standard Next.js project set up, we‚Äôre going to want to create the only code file we‚Äôll need for this project: <code>pages/index.js</code>.</p>\n<p>First, we‚Äôll want to add the <code>getServerSideProps</code> function in which we‚Äôll extract the wildcard (as I‚Äôll be hosting this at <code>aussieizer.sampoder.com</code>) that‚Äôs what I‚Äôll be evaluating to <code>home</code> as:</p>\n<pre><code>export async function getServerSideProps(context) {\n  let wildcard = context.req.headers.host.split(\".\")[0];\n  wildcard =\n    wildcard != \"aussieizer\"\n      ? wildcard != \"localhost:3000\"\n        ? wildcard\n        : process.env.TEST_WILDCARD\n      : \"home\";\n  return { props: { wildcard } };\n}</code></pre>\n\n<p>We‚Äôll then be using that wildcard, to render an iFrame to fill that page (by flipping iFrame over to create the effect), with our <code>src</code> being set to <code>{`https://${props.wildcard}.com`}</code>. We‚Äôll use a switch case, as we discussed above, to render a small helper page if they visit the home page:</p>\n<div>\n<pre><code>export default function App(props) {\n  switch (props.wildcard) {\n    case \"home\":\n      return (\n        &lt;div&gt;\n          Welcome to the Aussie-izer! This only works for .com domains. If you\n          want to Aussie-ize{\" \"}\n          &lt;a href=\"<a href=\"https://example.com&quot;&gt;https://example.com&lt;/a\">https://example.com\"&gt;https://example.com&lt;/a</a>&gt; visit{\" \"}\n          &lt;a href=\"<a href=\"https://example.aussieizer.sampoder.com&quot;\">https://example.aussieizer.sampoder.com\"</a>&gt;\n            <a href=\"https://example.aussieizer.sampoder.com\">https://example.aussieizer.sampoder.com</a>\n          &lt;/a&gt;.\n        &lt;/div&gt;\n      );\n      break;\n    default:\n      return (\n        &lt;iframe\n          src={<code>https://${props.wildcard}.com</code>}\n          style={{\n            transform: \"rotate(180deg)\",\n            border: \"none\",\n            height: \"100vh\",\n            width: \"100%\",\n            overflow: \"hidden\",\n          }}\n          frameBorder=\"0\"\n          scrolling=\"yes\"\n          seamless=\"seamless\"\n          height=\"100%\"\n          width=\"100%\"\n        &gt;&lt;/iframe&gt;\n      );\n  }\n}</code></pre>\n</div>\n\n<p>And we‚Äôre ready to go! The live version is available at <a href=\"https://aussieizer.sampoder.com\">https://aussieizer.sampoder.com</a> and the source code can be found at <a href=\"https://github.com/sampoder/aussie-izer/\">https://github.com/sampoder/aussie-izer/</a>. </p>\nHosting/Deployment\n<p>If you‚Äôre hosting on a custom server, wildcard domains will be a breeze to set up through DNS. However, a great part about using Jamstack is being able to host on services such as Vercel or Netlify; these services have their own domain management systems.</p>\n<h3>Vercel</h3>\n<p>Vercel supports wildcard domains out of the box ‚Äî for all accounts. To use them, first visit the <code>Domains</code> section of your deployment‚Äôs <code>Settings</code> tab. Next, you‚Äôll want to enter your domain by using a <code>*</code> to signify the wildcard.</p>\n<p>For the above example, I entered:</p>\n<pre><code>*.aussieizer.sampoder.com</code></pre>\n\n<p>You most likely will also want to add your root domain (<code>aussieizer.sampoder.com</code>, in my case) to be able to provide a homepage or some instructions, however, that could also be a separate codebase.</p>\n<h3>Netlify</h3>\n<p>Netlify limits their wildcards feature to Pro accounts; if you have a Pro account, you will need to email their support staff for them to then enable the option on your account. It will show up in the domain settings page once enabled.</p>\n<h3>Render</h3>\n<p>Render also offers wildcard domains to all users. Simply enter a domain with a <code>*</code> (signifying your wildcard) in the <code>Add Custom Domain</code> input on the custom domains section of your site‚Äôs settings page which will enable the wildcard. Please note that Render will require you to add additional records to your DNS so that they can issue a <code>LetsEncrypt</code> SSL certificate (exact instructions will be shown to you when you input your wildcard domain).</p>\nThat‚Äôs It!\n<p>Wildcard domains often go under the radar ‚Äî I hope you enjoyed exploring them with me. Thank you!</p>\n<p><em>Also: FYI Australians do not actually see upside down.</em></p>\n<h3>Further Reading On Smashing Magazine</h3>\n<ul>\n<li>‚Äú<a href=\"https://www.smashingmagazine.com/2021/05/evolution-jamstack/\">The Evolution Of Jamstack</a>,‚Äù Mathias Biilmann</li>\n<li>‚Äú<a href=\"https://www.smashingmagazine.com/2021/07/global-local-styling-nextjs/\">Global vs. Local Styling In Next.js</a>,‚Äù Alexander Dubovoy</li>\n<li>‚Äú<a href=\"https://www.smashingmagazine.com/2021/06/breaking-down-bulky-builds-netlify-nextjs/\">Breaking Down Bulky Builds With Netlify And Next.js</a>,‚Äù Atila Fassina</li>\n<li>‚Äú<a href=\"https://www.smashingmagazine.com/2020/08/smashing-podcast-episode-23/\">What Is Next.js?</a>,‚Äù Smashing Podcast episode with Guillermo Rauch</li>\n<li>‚Äú<a href=\"https://www.smashingmagazine.com/2020/11/smashing-podcast-episode-29/\">How Does Netlify Dogfood The Jamstack?</a>,‚Äù Smashing Podcast episode with Leslie Cohn-Wein</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine ‚Äî For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"22e46da7bc0f9484e97b1e9286241cd6df9d383f6ae061ff46a9d8bdd69be6bc","category":"Tech"}