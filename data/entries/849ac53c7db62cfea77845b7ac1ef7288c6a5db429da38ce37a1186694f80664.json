{"title":"WaterBear: Building A Free Platform For Impactful Documentaries (Part 2)","link":"https://smashingmagazine.com/2023/10/waterbear-building-free-platform-documentaries-part2/","date":1696269600000,"content":"<p>In my <a href=\"https://www.smashingmagazine.com/2023/09/waterbear-building-free-platform-impactful-documentaries-part1/\">previous article</a>, I talked about Waterbear, a significant project I worked on as a newly-appointed lead developer, and the lessons I learned leading a team for the first time. In this second article, I’ll go over some key technical highlights from the project. Before we start, let’s quickly remind ourselves what WaterBear is all about and what makes it so interesting.</p>\n<p><a href=\"https://www.waterbear.com\">WaterBear</a> is a free platform bringing together inspiration and action with <strong>award-winning high-production environmental documentaries</strong> covering various topics, from animals and climate change to people and communities. The WaterBear team produces their own original films and documentaries and hosts curated films and content from various high-profile partners, including award-winning filmmakers, large brands, and significant non-governmental organizations (NGOs), like Greenpeace, WWF, The Jane Goodall Institute, Ellen MacArthur Foundation, Nikon, and many others.</p>\n<p><img src=\"https://files.smashing.media/articles/waterbear-building-free-platform-documentaries-part2/1-waterbear-homepage.png\" /></p>\n<p>For context, I am currently working at a software development company called <a href=\"https://q.agency/\">Q Agency</a> based in Zagreb, Croatia. We collaborated with WaterBear and its partner companies to build a <strong>revamped and redesigned version of WaterBear’s web and mobile app</strong> from the ground up using modern front-end technologies.</p>\n<p>In the first article, I briefly discussed the technical stack that includes a React-based front-end framework, <a href=\"https://nextjs.org/\">Next.js</a> for the web app, Sanity CMS, Firebase Auth, and Firestore database. Definitely read up on the strategy and reasoning behind this stack in the first article if you missed it.</p>\n<p>Now, let’s dive into the technical features and best practices that my team adopted in the process of building the WaterBear web app. I plan on sharing specifically <strong>what I learned from performance and accessibility practices as a first-time lead developer of a team</strong>, as well as what I wish I had known before we started.</p>\nImage Optimization\n<p>Images are pieces of content in many contexts, and they are a very important and prominent part of the WaterBear app’s experience, from video posters and category banners to partner logos and campaign image assets.</p>\n<p><img src=\"https://files.smashing.media/articles/waterbear-building-free-platform-documentaries-part2/2-waterbear-image-cards-carousel-ui-elements.png\" /></p>\n<p>I think that if you are reading this article, you likely know the tightrope walk between striking, immersive imagery and performant user experiences we do as front-enders. Some of you may have even grimaced at the heavy use of images in that last screenshot. My team measured the impact, noting that on the first load, this video category page serves up as many as 14 images. Digging a little deeper, we saw those images account for approximately 85% of the total page size.</p>\n<p><img src=\"https:/files.smashing.media/articles/waterbear-building-free-platform-documentaries-part2/3-unoptimized-full-size-image.jpg\" /></p>\n<p>That’s not insignificant and demands attention. WaterBear’s product is visual in nature, so it’s understandable that images are going to play a large role in its web app experience. Even so, 85% of the experience feels heavy-handed.</p>\n<p>So, my team knew early on that we would be leveraging as many image optimization techniques as we could that would help improve how quickly the page loads. If you want to know everything there is to optimize images, I wholeheartedly recommend Addy Osami’s <a href=\"https://www.smashingmagazine.com/printed-books/image-optimization/\"><em>Image Optimization</em></a> for a treasure trove of insightful advice, tips, and best practices that helped us improve WaterBear’s performance.</p>\n<p>Here is how we tackled the challenge.</p>\n<h3>Using CDN For Caching And WebP For Lighter File Sizes</h3>\n<p>As I mentioned a little earlier, our stack includes Sanity’s CMS. It offers a robust content delivery network (CDN) <a href=\"https://www.sanity.io/docs/asset-cdn\">out of the box</a>, which serves two purposes: (1) optimizing image assets and (2) caching them. Members of the WaterBear team are able to upload unoptimized high-quality image assets to Sanity, which ports them to the CDN, and from there, we instruct the CDN to run appropriate optimizations on those images — things like compressing the files to their smallest size without impacting the visual experience, then caching them so that a user doesn’t have to download the image all over again on subsequent views.</p>\n<p>Requesting the optimized version of the images in Sanity boils down to adding query variables to image links like this:</p>\n<p><code>https://cdn.sanity.io/.../image.jpg?w=1280&amp;q=70&amp;auto=format</code></p>\n<p>Let’s break down the query variables:</p>\n<ul>\n<li><code>w</code> sets the width of the image. In the example above, we have set the width to <code>1280px</code> in the query.</li>\n<li><code>q</code> sets the compression quality of the image. We landed on 70% to balance the need for visual quality with the need for optimized file sizes.</li>\n<li><code>format</code> sets the image format, which is set to <code>auto</code>, allowing Sanity to determine the best type of image format to use based on the user’s browser capabilities.</li>\n</ul>\n<p>Notice how all of that comes from a URL that is mapped to the CDN to fetch a JPG file. It’s pretty magical how a completely unoptimized image file can be transformed into a fully optimized version that serves as a completely different file with the use of a few parameters.</p>\n<p>In many cases, the <code>format</code> will be returned as a WebP file. We made sure to use WebP because it yields <a href=\"https://web.dev/serve-images-webp/\">significant savings</a> in terms of file size. Remember that unoptimized 1.2 MB image from earlier? It’s a mere 146 KB after the optimizations.</p>\n<p><img src=\"https://files.smashing.media/articles/waterbear-building-free-platform-documentaries-part2/4-optimized-image.jpg\" /></p>\n<p>And all 14 image requests are smaller than that one unoptimized image!</p>\n<p><img src=\"https://files.smashing.media/articles/waterbear-building-free-platform-documentaries-part2/5-table-image-requests-otimized.png\" /></p>\n<p>The fact that images still account for 85% of the page weight is a testament to just how heavy of a page we are talking about.</p>\n<p>Another thing we have to consider when talking about modern image formats is browser support. Although <a href=\"https://caniuse.com/webp\">WebP is widely supported</a> and has been a staple for some time now, my team decided to provide an optimized fallback JPG just in case. And again, <strong>Sanity automatically detects the user’s browser capabilities</strong>. This way, we serve the WebP version only if Sanity knows the browser supports it and only provide the optimized fallback file if WebP support isn’t there. It’s great that we don’t have to make that decision ourselves!</p>\n<p>Have you heard of AVIF? It’s another modern image format that promises potential savings even greater than WebP. If I’m being honest, I would have preferred to use it in this project, but Sanity unfortunately does not support it, at least at the time of this article. There’s a <a href=\"https://github.com/sanity-io/image-url/issues/26\">long-running ticket to add support</a>, and I’m holding hope we get it.</p>\n<p>Would we have gone a different route had we known about the lack of AVIF support earlier? <a href=\"https://github.com/sanity-io/image-url/issues/26\">Cloudinary supports it</a>, for example. I don’t think so. Sanity’s tightly coupled CDN integration is too great of a developer benefit, and as I said, I’m hopeful Sanity will give us that support in the future. But that is certainly the sort of consideration I wish I would have had early on, and now I have that in my back pocket for future projects. </p>\n<h3>Tackling The Largest Contentful Paint (LCP)</h3>\n<p>LCP is the biggest element on the page that a user sees on the initial load. You want to optimize it because it’s the first impression a user has with the page. It ought to load as soon as possible while everything under it can wait a moment.</p>\n<p>For us, images are most definitely part of the LCP. By giving more consideration to the banner images we load at the top of the page, we can serve that component a little faster for a better experience. There are a couple of modern image attributes that can help here: <code>loading</code> and <a href=\"https://web.dev/fetch-priority/#summary\"><code>fetchpriority</code></a>.</p>\n<p>We used <strong>an <code>eager</code> loading strategy</strong> paired with a high <code>fetchpriority</code> on the images. This provides the browser with a couple of hints that this image is super important and that we want it early in the loading process.</p>\n<pre><code>&lt;!-- Above-the-fold Large Contentful Paint image --&gt;\n&lt;img\n  loading=\"eager\"\n  fetchpriority=\"high\"\n  alt=\"...\"\n  src=\"...\"\n  width=\"1280\"\n  height=\"720\"\n  class=\"...\"\n/&gt;\n</code></pre>\n\n<p>We also made use of preloading in the document <code>&lt;head&gt;</code>, indicating to the browser that we want to <code>preload</code> images during page load, again, with <code>high</code> priority, using <a href=\"https://nextjs.org/docs/pages/api-reference/components/image#priority\">Next.js image preload options</a>.</p>\n<pre><code>&lt;head&gt;\n  &lt;link\n    rel=\"preload\"\n    as=\"image\"\n    href=\"...\"\n    fetchpriority=\"high\"\n  /&gt;\n&lt;/head&gt;\n</code></pre>\n\n<p>Images that are “below the fold” can be de-prioritized and downloaded only when the user actually needs it. <a href=\"https://www.smashingmagazine.com/search/?q=Lazy%20load\">Lazy loading</a> is a common technique that instructs the browser to load particular images once they enter the viewport. It’s only <a href=\"https://css-tricks.com/native-lazy-loading/\">fairly recently</a> that it’s become a feature baked directly into HTML with the <code>loading</code> attribute:</p>\n<pre><code>&lt;!-- Below-the-fold, low-priority image --&gt;\n&lt;img\n  decoding=\"async\"\n  loading=\"lazy\"\n  src=\"...\"\n  alt=\"...\"\n  width=\"250\"\n  height=\"350\"\n/&gt;\n</code></pre>\n\n<p>This cocktail of strategies made a noticeable difference in how quickly the page loads. On those image-heavy <a href=\"https://www.waterbear.com/watch/category/animals\">video category pages</a> alone, it helped us reduce the image download size and number of image requests by <strong>almost 80% on the first load!</strong> Even though the page will grow in size as the user scrolls, that weight is only added if it passes through the browser viewport.</p>\n<p><img src=\"https://files.smashing.media/articles/waterbear-building-free-platform-documentaries-part2/6-lazy-loading-strategy.png\" /></p>\n<h3>In Progress: Implementing <code>srcset</code></h3>\n<p>My team is incredibly happy with how much performance savings we’ve made so far. But there’s no need to stop there! Every millisecond counts when it comes to page load, and we are still planning additional work to optimize images even further.</p>\n<p>The task we’re currently planning will implement the <code>srcset</code> attribute on images. This is not a “new” technique by any means, but it is certainly a component of modern performance practices. It’s also a <a href=\"https://web.dev/learn/design/responsive-images/#responsive-images-with-srcset\">key component in responsive design</a>, as it instructs browsers to use certain versions of an image at different viewport widths.</p>\n<p>We’ve held off on this work only because, for us, the other strategies represented the lowest-hanging fruit with the most impact. Looking at an image element that uses <code>srcset</code> in the HTML shows it’s not the easiest thing to read. Using it requires a certain level of art direction because the dimensions of an image at one screen size may be completely different than those at another screen size. In other words, there are additional considerations that come with this strategy.</p>\n<p>Here’s how we’re planning to approach it. We want to avoid loading high-resolution images on small screens like phones and tablets. With the <code>srcset</code> attribute, we can specify separate image sources depending on the device’s screen width. With the <code>sizes</code> attribute, we can instruct the browser which image to load depending on the media query.</p>\n<p>In the end, our image markup should look something like this:</p>\n<pre><code>&lt;img\n  width=\"1280\"\n  height=\"720\"\n  srcset=\"\n    https://cdn.sanity.io/.../image.jpg?w=568&amp;...   568w,\n    https://cdn.sanity.io/.../image.jpg?w=768&amp;...   768w,\n    https://cdn.sanity.io/.../image.jpg?w=1280&amp;... 1280w\n  \"\n  sizes=\"(min-width: 1024px) 1280px, 100vw\"\n  src=\"https://cdn.sanity.io/.../image.jpg?w=1280&amp;...\"\n/&gt;\n</code></pre>\n\n<p>In this example, we specify a set of three images: </p>\n<ol>\n<li>Small: <code>568px</code>,</li>\n<li>Medium: <code>768px</code>,</li>\n<li>Large: <code>1280px</code>.</li>\n</ol>\n<p>Inside the <code>sizes</code> attribute, we’re telling the browser to use the largest version of the image if the screen width is above <code>1024px</code> wide. Otherwise, it should default to selecting an appropriate image out of the three available versions based on the full device viewport width (<code>100vw</code>) — and will do so <strong>without downloading the other versions</strong>. Providing different image files to the right devices ought to help enhance our performance a bit more than it already is.</p>\nImproving CMS Performance With TanStack Query\n<p>The majority of content on WaterBear comes from Sanity, the CMS behind the web app. This includes video categories, video archives, video pages, the partners’ page, and campaign landing pages, among others. Users will constantly navigate between these pages, frequently returning to the same category or landing page.</p>\n<p>This provided my team with an opportunity to introduce <strong>query caching</strong> and avoid repeating the same request to the CMS and, as a result, optimize our page performance even more. We used <a href=\"https://tanstack.com/query/v4/docs/react/overview\">TanStack Query</a> (formerly known as <code>react-query</code>) for both fetching data and query caching.</p>\n<pre><code>const { isLoading, error, data } = useQuery( /* Options */ )\n</code></pre>\n\n<p>TanStack Query caches each request according to the <a href=\"https://tanstack.com/query/v4/docs/react/guides/query-keys\">query key</a> we assign to it. The <strong>query key in TanStack Query is an array,</strong> where the first element is a query name and the second element is an object containing all values the query depends on, e.g., pagination, filters, query variables, and so on.</p>\n<p>Let’s say we are fetching a list of videos depending on the video category page URL slug. We can filter those results by video duration. The query key might look something like this basic example:</p>\n<pre><code>const { isLoading, error, data } = useQuery(\n  {\n    queryKey: [\n      'video-category-list',\n      { slug: categorySlug, filterBy: activeFilter }\n    ],\n  queryFn: () =&gt; /* ... */\n  }\n)\n</code></pre>\n\n<p>These query keys might look confusing at first, but they’re similar to the dependency arrays for React’s <a href=\"https://css-tricks.com/intro-to-react-hooks/#aa-create-side-effects-with-useeffect\"><code>useEffect</code> hook</a>. Instead of running a function when something in the dependency array changes, it runs a query with new parameters and returns a new state. TanStack Query comes with its dedicated <a href=\"https://tanstack.com/query/v4/docs/react/devtools\">DevTools</a> package. It displays all sorts of useful information about the query that helps debug and optimize them without hassle.</p>\n<p>Let’s see the query caching in action. In the following video, notice how data loads instantly on repeated page views and repeated filter changes. Compare that to the first load, where there is a slight delay and a loading state before data is shown.</p>\n<p><img src=\"https://files.smashing.media/articles/waterbear-building-free-platform-documentaries-part2/7-focus-state-green-outline.png\" /></p>\n<p>We’re probably not even covering all of our bases! It’s so tough to tell without ample user testing. It’s a conflicting situation where you want to do everything you can while realistically completing the project with the resources you have and proceed with intention.</p>\n<p>We made sure to include a label on interactive elements like buttons, especially ones where the icon is the only content. For that case, we added <a href=\"https://www.a11yproject.com/posts/how-to-hide-content/\">visually hidden</a> text while allowing it to be read by assistive devices. We also made sure to <a href=\"https://www.smashingmagazine.com/2021/05/accessible-svg-patterns-comparison/\">hide the SVG</a> icon from the assistive devices as SVG doesn’t add any additional context for assistive devices.</p>\n<div>\n<pre><code>&lt;!-- Icon button markup with descriptive text for assistive devices --&gt;\n&lt;button type=\"button\" class=\"...\"&gt;\n  &lt;svg aria-hidden=\"true\" xmlns=\"...\" width=\"22\" height=\"22\" fill=\"none\"&gt;...&lt;/svg\n  &gt;&lt;span class=\"visually-hidden\"&gt;Open filters&lt;/span&gt;\n&lt;/button&gt;\n</code></pre>\n</div>\n\n<pre><code>.visually-hidden {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  overflow: hidden;\n  white-space: nowrap;\n  clip: rect(0 0 0 0);\n  -webkit-clip-path: inset(50%);\n  clip-path: inset(50%);\n}\n</code></pre>\n\n<p>Supporting keyboard navigation was one of our accessibility priorities, and we had no trouble with it. We made sure to use proper HTML markup and avoid potential pitfalls like adding a click event to meaningless <code>div</code> elements, which is unfortunately so easy to do in React.</p>\n<p>We did, however, hit an obstacle with modals as users were able to move focus outside the modal component and continue interacting with the main page while the modal was in its open state, which isn’t possible with the default pointer and touch interaction. For that, we implemented focus traps using the <a href=\"https://www.npmjs.com/package/focus-trap-react\">focus-trap-react library</a> to keep the focus on modals while they’re opened, then restore focus back to an active element once the modal is closed.</p>\n<p><img src=\"https://files.smashing.media/articles/waterbear-building-free-platform-documentaries-part2/8-focus-trapping.png\" /></p>\nDynamic Sitemaps\n<p><strong>Sitemaps tell search engines</strong> <a href=\"https://developers.google.com/search/docs/crawling-indexing/sitemaps/build-sitemap\"><strong>which pages to crawl</strong></a>. This is faster than just letting the crawler discover internal links on its own while crawling the pages.</p>\n<p>The importance of sitemaps in the case of WaterBear is that the team regularly publishes new content — content we want to be indexed for crawlers as soon as possible by adding those new links to the top of the sitemap. We don’t want to rebuild and redeploy the project every time new content has been added to Sanity, so <strong>dynamic server-side sitemaps were our logical choice</strong>.</p>\n<p>We used the <a href=\"https://www.npmjs.com/package/next-sitemap\">next-sitemap</a> plugin for Next.js, which has allowed us to easily configure the sitemap generation process for both static and dynamic pages. We used the plugin alongside custom Sanity queries that fetch the latest content from the CMS and quickly generate a fresh sitemap for each request. That way, we made sure that the latest videos get indexed as soon as possible.</p>\n<p>Let’s say the WaterBear team publishes a page for a video named <em>My Name is Salt</em>. That gets added to a freshly generated XML sitemap:</p>\n<p><img src=\"https://files.smashing.media/articles/waterbear-building-free-platform-documentaries-part2/9-example-dynamic-sitemap-latest-video-content.png\" /></p>\n<p>Now, it’s indexed for search engines to scoop up and use in search results:</p>\n<p><img src=\"https://files.smashing.media/articles/waterbear-building-free-platform-documentaries-part2/10-indexed-video-sitemap.png\" /></p>\nUntil Next Time…\n<p>In this article, I shared some insights about <a href=\"https://www.waterbear.com/\">WaterBear</a>’s tech stack and some performance optimization techniques we applied while building it.</p>\n<p>Images are used very prominently on many page types on WaterBear, so we used CDN with caching, loading strategies, preloading, and the WebP format to optimize image loading performance. We relied on Sanity for the majority of content management, and we expected repeating page views and queries on a single session, prompting us to implement query caching with TanStack Query.</p>\n<p>We made sure to improve basic accessibility on the fly by styling focus states, enabling full keyboard navigation, assigning labels to icon buttons, providing alt text for images, and using focus traps on modal elements.</p>\n<p>Finally, we covered how my team handled dynamic server-side rendered sitemaps using the next-sitemap plugin for Next.js.</p>\n<p>Again, this was my first big project as lead developer of a team. There’s so much that comes with the territory. Not only are there internal processes and communication hurdles to establish a collaborative team environment, but there’s the technical side of things, too, that requires balancing priorities and making tough decisions. I hope my learning journey gives you something valuable to consider in your own work. I know that my team isn’t the only one with these sorts of challenges, and sharing the lessons I learned from this particular experience probably resonates with some of you reading this.</p>\n<p>Please be sure to check out the full work we did on WaterBear. It’s available on the <a href=\"https://www.waterbear.com/\">web</a>, <a href=\"https://play.google.com/store/apps/details?id=com.waterbearnetwork.waterbear&amp;hl=en_US&amp;pli=1\">Android,</a> and <a href=\"https://apps.apple.com/us/app/waterbear/id1461149595\">iOS</a>. And, if you end up watching a documentary while you’re at it, let me know if it inspired you to take action on a cause!</p>\n<h3>References</h3>\n<ul>\n<li><a href=\"https://web.dev/fast/#optimize-your-images\">Fast load times</a> (web.dev)</li>\n<li>“<a href=\"https://www.a11yproject.com/posts/how-to-hide-content/\">Hide Content</a>,” Dave Rupert (The A11Y Project)</li>\n<li>“<a href=\"https://web.dev/serve-images-webp/\">Use WebP images</a>,” Katie Hempenius (web.dev)</li>\n<li>“<a href=\"https://www.smashingmagazine.com/2021/05/accessible-svg-patterns-comparison/\">Accessible SVGs: Perfect Patterns For Screen Reader Users</a>,” Carie Fisher</li>\n<li><a href=\"https://tanstack.com/query/v4/docs/react/overview\">TanStack Query Documentation</a></li>\n</ul>\n<p><em>Many thanks to WaterBear and Q Agency for helping out with this two-part article series and making it possible. I really would not have done this without their support. I would also like to commend everyone who worked on the project for their outstanding work! You have taught me so much so far, and I am grateful for it.</em></p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"849ac53c7db62cfea77845b7ac1ef7288c6a5db429da38ce37a1186694f80664","category":"Tech"}