{"title":"Help us choose the final syntax for Masonry in CSS","link":"https://webkit.org/blog/16026/css-masonry-syntax/","date":1729533609000,"content":"<p>Back in April 2024, we <a href=\"https://webkit.org/blog/15269/help-us-invent-masonry-layouts-for-css-grid-level-3/\">wrote about “Masonry” layout in CSS</a> and the ongoing work to bring this feature to browsers. In it, we described a debate about whether or not the full power of CSS Grid (subgrid, spanning, explicit placement, and <em>all</em> the options for track sizing) should be combined with the packed layout currently accomplished with tools like <a href=\"https://masonry.desandro.com/\">masonry.js</a>. Some believed that the full complexity wasn’t necessary, or even practical to implement, and that a simpler feature focused on solving the classic Masonry use case would be better. There were very practical performance concerns about the feasibility of integrating with the full power and flexibility of Grid track sizing. Could browser engines handle Grid + Masonry while remaining lightning fast?</p>\n<p>We <a href=\"https://webkit.org/blog/15269/help-us-invent-masonry-layouts-for-css-grid-level-3/#we-want-to-hear-from-you\">asked</a> you to help us by joining the debate. Thanks to <a href=\"https://github.com/w3c/csswg-drafts/issues/10233\">everyone who shared</a> their thoughts, use cases, diagrams, and demos. Your feedback is valuable and helps us move the conversation forward.</p>\n<p>Over the last six months, the key performance concerns have been addressed. Yes, it is possible to integrate Masonry layout with the full power of CSS Grid. Our engineers at Apple have been hard at work collaborating with our colleagues at Google and the CSS Working Group (CSSWG) to go through all the details.</p>\n<figure><img loading=\"lazy\" src=\"https://webkit.org/wp-content/uploads/masonry-demo.png\" alt=\"Demo of simply masonry-style layout, with numbers showing the order of items in the layout. Also, a header on the page shows the code used to make this layout, along with controls to try other variations. \" width=\"1590\" height=\"968\" srcset=\"https://webkit.org/wp-content/uploads/masonry-demo.png 1590w, https://webkit.org/wp-content/uploads/masonry-demo-300x183.png 300w, https://webkit.org/wp-content/uploads/masonry-demo-1024x623.png 1024w, https://webkit.org/wp-content/uploads/masonry-demo-768x468.png 768w, https://webkit.org/wp-content/uploads/masonry-demo-1536x935.png 1536w\" /><figcaption>Our April 2024 <a href=\"https://webkit.org/blog/15269/help-us-invent-masonry-layouts-for-css-grid-level-3/\">article on Grid level 3</a> includes walkthroughs of <a href=\"https://webkit.org/demos/grid3/\">four demos</a> with 23 variations. Try them out in <a href=\"https://developer.apple.com/safari/resources/\">Safari Technology Preview</a>, in Safari 17.x or 18.x (after checking “CSS Masonry Layout” at Develop &gt; Feature Flags), or in Firefox 77+ (after enabling its flag).</figcaption></figure>\n<p>Once we’d proven that it is possible — and with your help, that it is a good idea to infuse this new feature with the full power of Grid — the CSSWG resolved to adopt mixed track-sizing for masonry-style layouts in September. It’s a fantastic milestone! With this consensus, the CSSWG <a href=\"https://www.w3.org/blog/CSS/2024/09/24/css-grid-3-fpwd/\">published</a> a First Public Working Draft of <a href=\"https://www.w3.org/TR/css-grid-3/\">CSS Grid Layout Module Level 3</a>.</p>\n<h2><a name=\"the-remaining-debate-over-syntax\"></a>The remaining debate over syntax</h2>\n<p>At this point, there’s one major question remaining — what should the syntax be? Currently, <a href=\"https://www.w3.org/TR/css-grid-3/\">the specification</a> is drafted with two options, going head-to-head — the “Grid Integrated” option and the “Grid Independent” option. (To make it clearer which is which, we’re going to call them the “Just Use Grid” option and the “New Masonry Layout” option throughout this article.)</p>\n<p>The syntactical decision depends on how we conceive of this feature and its future. Is this an extension of CSS Grid, leveraging existing Grid properties? Or should it be treated as something completely different, with its own set of new properties and new default values? You’ll be able to code the same layouts either way. The functionality will be the same.</p>\n<p>Recently folks from Chrome wrote an <a href=\"https://developer.chrome.com/blog/masonry-syntax\">article about their perspective</a>:</p>\n<blockquote><p>\n  The Chrome team still believes that a separate masonry syntax would be the best way to proceed. While the biggest performance issue mentioned in our previous post is resolved, there are still concerns around syntax, initial values, and how easy a version combined with grid would be to learn.\n</p></blockquote>\n<p>Rachel Andrew added additional arguments in <a href=\"https://rachelandrew.co.uk/archives/2024/09/21/masonry-and-good-defaults/\">her blog post</a> in favor of the New Masonry Layout option:</p>\n<blockquote><p>\n  My opinion is, as it was in 2020, that defining masonry as part of grid would be a mistake… Good defaults make things easier to teach… good defaults mean less configuration.\n</p></blockquote>\n<p>Their argument is that developers won’t have to write as much code as they would if this feature becomes part of CSS Grid. By resetting the formatting context, the all-new properties can have new default values more suited for Masonry layouts, making it faster and easier, especially when coding the kind of classic Masonry layout made popular by <a href=\"https://www.pinterest.com/today/best/find-your-nature-aesthetic/120596/\">Pinterest</a>. You won’t have to override the defaults invented for CSS Grid.</p>\n<p>The article from the Chrome team lists many side-by-side examples to prove their point. Here’s <a href=\"https://developer.chrome.com/blog/masonry-syntax#with_display_masonry\">the first one</a>, defining a symmetrical 3-column masonry layout in each syntax:</p>\n<p><strong>New Masonry Layout</strong></p>\n<pre><code><span>.masonry</span> {\n  <span>display</span>: <span>masonry</span>;\n  <span>masonry-template-tracks</span>: <span>repeat</span>(<span>3</span>, <span>1</span><span>fr</span>);\n  <span>gap</span>: <span>10px</span>;\n}\n</code></pre>\n<p><strong>Just Use Grid</strong></p>\n<figure>\n<pre><code><span>.masonry</span> {\n  <span>display</span>: <span>grid</span>;\n  <span>grid-template-columns</span>: <span>repeat</span>(<span>3</span>, <span>1</span><span>fr</span>);\n  <span>grid-template-rows</span>: <span>masonry</span>; <span>/* final name TBD */</span>\n  <span>gap</span>: <span>10px</span>;\n}\n</code></pre><figcaption>(We also believe that the value <code>masonry</code> should be renamed. See <a href=\"#footnote-1\">Footnote 1</a>.)</figcaption></figure>\n<p>In all of their examples, the New Masonry Layout option does use one fewer line of code (or shorthands that require fewer values). And being able to write fewer lines of code is a valuable quality.</p>\n<p>Plus, perhaps imagining this new feature as <code>display: masonry</code> just feels, well, neater. It clicks into a simple story about layout on the web: “You’ve got several options: flow, multicolumn, grid, flex, and masonry. Pick which one you want, and use it.” It’s totally understandable why for many people, that can seem like the best route forward.</p>\n<p>When you look at isolated examples like this, with two alternative realities pitted head to head — especially if you have not learned CSS Grid yet — the New Masonry Layout option may look nicer, cleaner, easier to guess what it’s doing.</p>\n<p>But, a real CSS file is never five lines of code. Real life is far more complicated. You might want to code a classic Grid layout up to a breakpoint, and then switch to a masonry-style layout on wider (or narrower) screens. In that case, switching layouts would require <em>more</em> lines of code with the New Masonry Layout option compared to the Just Use Grid option.</p>\n<p>The WebKit team at Apple still strongly believes that separating CSS Grid and masonry-style packed layouts into two separate layout mechanisms would be a mistake. We believe that looking at simplistic code examples in isolation might not be the best way to evaluate this decision. We perceive all of this functionality as part of one layout system that would be best served by united syntax. In this article, we’ll go into why.</p>\n<h2><a name=\"design-principles\"></a>Design Principles</h2>\n<p>Whenever there are tough disagreements like this one, the best way to move forward is to look at the 30,000 foot view — to discuss the larger implications of the choices available. How does a <a href=\"https://en.wikipedia.org/wiki/World_Wide_Web_Consortium\">W3C</a> Working Group do this? By relying on design principles. CSS is a programming language that’s evolved over 30 years. Throughout, it’s been guided by design principles. The CSS Working Group doesn’t have official Design Principles documented the way <a href=\"https://www.w3.org/TR/html-design-principles/\">HTML does</a>. But in 2003, Bert Bos, co-inventor of CSS, wrote down his ideas for <a href=\"https://www.w3.org/People/Bos/DesignGuide/designguide.html\">what makes a good web standard</a>.</p>\n<p>These principles include:</p>\n<ul>\n<li><strong>Simplicity</strong>: Good programming languages have simple, understandable models and syntax. They are both easy to use and powerful enough to directly express developer intent. Languages that are complicated, or whose practical use is convoluted, are hard to understand and use correctly.</li>\n<li><strong>Learnability</strong>: Web technology should be easy for developers to learn. It should be readable without being verbose; re-use familiar syntax for familiar concepts; and, in general, be designed for humans over computers.</li>\n<li><strong>Minimum Redundancy</strong>: “The overlap in functionality between different specifications should be kept small, because it can easily lead to incompatible models.” While some redundancy in functionality can help developers express logic more clearly, incompatible models make technology harder to implement, and are more likely to result in errors.</li>\n<li><strong>Repurposing</strong>: “Adaptation of some existing piece of data for a new purpose” is a core function of the design of the web. The HTML Design Principles calls this “Do not Reinvent the Wheel”. Extend an existing technology instead of inventing something new for the same or similar purpose.</li>\n<li><strong>Use What Is There</strong>: An existing API might not be ideal. Maybe you <a href=\"https://wiki.csswg.org/ideas/mistakes\">wish we could go back and start over</a>. But we can’t. Use what’s there, and forge the best path forward. “Throwing away software that works, although imperfectly, and teaching everybody something new would be a huge waste of resources.”</li>\n<li><strong>Extensibility</strong>: CSS is designed to be extended — its parsing and interpretation rules, its general syntax, and even the specific syntax of its properties and their values — they are all intentionally designed to accommodate future extensions to CSS. It allows for progressive enhancement of an existing page in newer browsers, and for graceful degradation of a newer page in older browsers.</li>\n<li><strong>Design by committee</strong>: “Specifications are created by a committee rather than by a single individual… more pairs of eyes mean more checking for errors, more creativity in finding solutions to problems, and more experience in knowing what worked or didn’t work in the past.”</li>\n</ul>\n<p>In other words, reuse as much as possible of the language that already exists, repurposing things as you go. Keep things as simple as possible. Make it easy to learn. Don’t be redundant in creating more than one way to do things. And have debates like this one in order to find the best solution!</p>\n<p>Let’s look at how these design principles apply to the syntactical decision at hand.</p>\n<h2><a name=\"simplicity-learnability\"></a>Simplicity  |  Learnability</h2>\n<p>The case the folks on the Chrome team are making could be seen as seeking simplicity. As a developer, if you can accomplish a layout in one less line of code, isn’t that simpler? And if you can just use the defaults for the new Masonry properties, instead of needing to override them, surely that’s simpler. Less code. Better defaults. Easier to learn. Right?</p>\n<p>We believe making Masonry a separate display type only seems simpler in isolation: reading snippets of code in a blog post, focusing on a head-to-head battle. But Masonry is not going to live in isolation. We already have CSS Grid.</p>\n<p>Let’s see if we can understand how a unified system for layout feels. What’s it like to have CSS Grid with this addition of new functionality?</p>\n<figure><img loading=\"lazy\" src=\"https://webkit.org/wp-content/uploads/grid-1-layout-light.png\" alt=\"Layout of 16 photos — all squares, in a 4 by 4 grid.\" width=\"960\" height=\"902\" srcset=\"https://webkit.org/wp-content/uploads/grid-1-layout-light.png 960w, https://webkit.org/wp-content/uploads/grid-1-layout-light-300x282.png 300w, https://webkit.org/wp-content/uploads/grid-1-layout-light-768x722.png 768w\" /><img loading=\"lazy\" src=\"https://webkit.org/wp-content/uploads/grid-3-layout-light.png\" alt=\"A layout of 16 photos, of all different aspect ratios, packed into 4 columns, in a masonry-style layout.\" width=\"960\" height=\"902\" srcset=\"https://webkit.org/wp-content/uploads/grid-3-layout-light.png 960w, https://webkit.org/wp-content/uploads/grid-3-layout-light-300x282.png 300w, https://webkit.org/wp-content/uploads/grid-3-layout-light-768x722.png 768w\" /></figure>\n<p>To lay out the square images seen on the left, you can write:</p>\n<pre><code><span>main</span> {\n  <span>display</span>: <span>grid</span>;\n  <span>grid-template-columns</span>: <span>repeat</span>(<span>auto-fit</span>, <span>minmax</span>(<span>14</span><span>rem</span>, <span>1</span><span>fr</span>));\n  <span>grid-template-rows</span>: <span>auto</span>; <span>/* default value, unnecessary to state */</span>\n  <span>gap</span>: <span>1</span><span>rem</span>;\n}\n</code></pre>\n<p>To lay out the images seen on the right, with varying aspect-ratios, you will write:</p>\n<figure>\n<pre><code><span>main</span> {\n  <span>display</span>: <span>grid</span>;\n  <span>grid-template-columns</span>: <span>repeat</span>(<span>auto-fill</span>, <span>minmax</span>(<span>14</span><span>rem</span>, <span>1</span><span>fr</span>));\n  <span>grid-template-rows</span>: <span>collapse</span>; <span>/* final value name TBD */</span>\n  <span>gap</span>: <span>1</span><span>rem</span>;\n}\n</code></pre><figcaption>(In this article, our examples imagine using <code>collapse</code> as the value instead of <code>masonry</code>. See <a href=\"#footnote-1\">Footnote 1</a>.)</figcaption></figure>\n<p>Look at how simple that is. Use the CSS Grid layout system that’s been around for 7+ years, and change one value.</p>\n<p>Let’s look at another example — this time, creating a layout that flows and scrolls sideways. This could feel especially natural for users on a phone or tablet.</p>\n<figure><img loading=\"lazy\" src=\"https://webkit.org/wp-content/uploads/sideways-grid-light.png\" alt=\"iPad with a layout of content flowing across it. Users will scroll it side to side. The content is a set of cards, each containing a painting and information about the painting. In this layout, every card is a rectangle, lining up in a columns as well as rows.\" width=\"1728\" height=\"842\" /></figure>\n<p>To create this layout today, we could use Grid:</p>\n<pre><code><span>main</span> {\n  <span>display</span>: <span>grid</span>;\n  <span>grid-template</span>: <span>\"tall\"</span> <span>2</span><span>fr</span>\n                 <span>\"wide\"</span> <span>1</span><span>fr</span>;\n  <span>grid-auto-flow</span>: <span>column</span>; <span>/* fill by column */</span>\n  <span>height</span>: <span>600px</span>;\n  <span>overflow</span>: <span>scroll</span>;\n}\n<span>.tall-item</span> {\n  <span>grid-row</span>: <span>tall</span>;\n}\n<span>.wide-item</span> {\n  <span>grid-row</span>: <span>wide</span>;\n}\n</code></pre>\n<p>But let’s instead pack the content together instead of having it stretch, since the images have a variety of aspect ratios. With the Just Use Grid option, we just write more one line of code — <code>grid-template-columns: collapse</code>.</p>\n<figure><img loading=\"lazy\" src=\"https://webkit.org/wp-content/uploads/sideways-masonry-light.png\" alt=\"Same iPad with content flowing across it, to scroll it side to side. This time, every card is a rectangle that is just big enough to fit the content, lining up in rows, but things to not line up in columns. It's a staggered layout.\" width=\"1728\" height=\"972\" srcset=\"https://webkit.org/wp-content/uploads/sideways-masonry-light.png 1728w, https://webkit.org/wp-content/uploads/sideways-masonry-light-300x169.png 300w, https://webkit.org/wp-content/uploads/sideways-masonry-light-1024x576.png 1024w, https://webkit.org/wp-content/uploads/sideways-masonry-light-768x432.png 768w, https://webkit.org/wp-content/uploads/sideways-masonry-light-1536x864.png 1536w\" /></figure>\n<pre><code><span>main</span> {\n  <span>display</span>: <span>grid</span>;\n   <span>grid-template-columns</span>: <span>collapse</span>;\n   <span>grid-template</span>: <span>\"tall\"</span> <span>2</span><span>fr</span>\n                  <span>\"wide\"</span> <span>1</span><span>fr</span>;\n  <span>grid-auto-flow</span>: <span>column</span>; <span>/* fill by column */</span>\n  <span>height</span>: <span>600px</span>;\n  <span>overflow</span>: <span>scroll</span>;\n}\n</code></pre>\n<p>It’s an easy transition to go from thinking about CSS Grid to thinking about packed masonry-style layouts, because it’s all part of the same system. Plus, we can easily alter this layout at a breakpoint.</p>\n<p>Now, let’s contrast the developer experience of using the New Masonry Layout option instead.</p>\n<pre><code><span>main</span> {\n <span>display</span>: <span>masonry</span>;\n <span>masonry</span>: <span>\"tall wide\"</span> \n           <span>2</span><span>fr</span>  <span>1</span><span>fr</span>;\n <span>masonry-direction</span>: <span>row</span>; <span>/* grow along the rows */</span>\n <span>height</span>: <span>600px</span>;\n <span>overflow</span>: <span>scroll</span>;\n}\n</code></pre>\n<p>The New Masonry Layout model might make perfect sense in isolation, but in context it requires developers to switch between mental models. It requires remembering how the Grid and Masonry syntaxes are different — flowing to the right being <code>row</code> instead of <code>column</code>; laying out area templates horizontally instead of vertically; calling things <code>-tracks</code> instead of <code>-rows</code> or <code>-columns</code>… these differences add up.</p>\n<p>Developers already struggle with trying to understand the difference between Flexbox and Grid, and when to use which one. Far too many developers are responding to this burden by just using Flexbox for every single thing, and never using Grid. Adding yet another layout mode is liable to compound this challenge.</p>\n<p>Typing out four lines of code instead of three is not a significant developer burden. Having to memorize multiple sets of similar syntax with divergent names, allowable values, and defaults is far more of a burden.</p>\n<h2><a name=\"minimum-redundancy-repurposing-use-what-is-there\"></a>Minimum Redundancy  |  Repurposing  |  Use What Is There</h2>\n<p>One of the guiding principles that drives decisions at the CSS Working Group is to always strive to reuse existing patterns and properties when creating new possibilities.</p>\n<p>For example — when Flexbox was invented, it came with the Alignment properties (<code>justify-content</code>, <code>align-items</code>, etc). Then when Grid came along, those same properties were reused for a similar but slightly different purpose. New properties were added (<code>justify-items</code>) matching the existing pattern (<code>align-items</code>) to extend the feature.</p>\n<p>Same with <code>gap</code>. When multicolumn was invented, a new <code>column-gap</code> property provided a way to define the space between columns. A decade later, when the CSSWG needed a way to define space between grid columns, the <code>column-gap</code> property was repurposed. It got a corresponding <code>row-gap</code> property and a new shorthand, <code>gap</code>, to be more universal, and eventually made its way to Flexbox as well. It took a couple tries, but the CSSWG realized it would be a mistake to keep creating separate gap properties for different contexts — <code>column-gap</code> + <code>grid-gap</code> + <code>flex-gap</code>… It’s better to repurpose what already exists.</p>\n<p>The New Masonry Layout option creates a duplicate set of properties for existing functionality. (Everything in red is new):</p>\n<table>\n<thead>\n<tr>\n<th>Just Use Grid option</th>\n<th>New Masonry Layout option</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>display: grid</code></td>\n<td><code>display: </code><b><code>masonry</code></b></td>\n</tr>\n<tr>\n<td><code>grid-template-columns</code> / <code>grid-template-rows</code></td>\n<td><b><code>masonry-template-tracks</code></b></td>\n</tr>\n<tr>\n<td><code>grid-template-rows: </code><b><code>collapse</code></b> /<br /> <code>grid-template-columns: </code><b><code>collapse</code></b></td>\n<td><b><code>masonry-direction</code></b></td>\n</tr>\n<tr>\n<td><code>grid-auto-flow</code></td>\n<td><b><code>masonry-direction</code></b></td>\n</tr>\n<tr>\n<td><b><code>masonry-fill</code></b></td>\n</tr>\n<tr>\n<td><b><code>masonry-flow</code></b></td>\n</tr>\n<tr>\n<td><code>gap</code></td>\n<td><code>gap</code></td>\n</tr>\n<tr>\n<td><code>grid-column-start</code> / <code>grid-row-start</code></td>\n<td><b><code>masonry-track-start</code></b></td>\n</tr>\n<tr>\n<td><code>grid-column-end</code> / <code>grid-row-end</code></td>\n<td><b><code>masonry-track-end</code></b></td>\n</tr>\n<tr>\n<td><code>grid-column</code> / <code>grid-row</code></td>\n<td><b><code>masonry-track</code></b></td>\n</tr>\n<tr>\n<td><code>grid-template-areas</code></td>\n<td><b><code>masonry-template-areas</code></b></td>\n</tr>\n<tr>\n<td><code>grid-auto-columns</code> / <code>grid-auto-rows</code></td>\n<td><b><code>masonry-auto-tracks</code></b></td>\n</tr>\n<tr>\n<td><code>grid</code></td>\n<td><b><code>masonry</code></b></td>\n</tr>\n<tr>\n<td><b><code>grid-slack</code></b> (name TBD)</td>\n<td><b><code>masonry-slack</code></b> (name TBD)</td>\n</tr>\n</tbody>\n</table>\n<p>It will require developers to memorize a parallel layout system with an entire second set of syntax.</p>\n<p>The Just Use Grid option adds <em>only</em> <em>one new value</em> to CSS. You can create masonry-style layouts by simply using the <code>collapse</code> <sup><a href=\"#footnote-1\">[1]</a></sup> value in a track definition: <code>grid-template-rows: collapse</code> (or <code>grid-template-columns: collapse</code> in the other direction). Basically you’re “collapsing” the rows — useful for a wide variety of use cases.</p>\n<p>By not repurposing what’s already there, New Masonry Layout creates unnecessary redundancy in CSS. The Chrome team asserts that creating a duplicate system is worth it, though, because that allows its details to be tuned for the masonry-layout use case in three ways:</p>\n<ol>\n<li>Tweaking concepts — for example use <code>masonry-direction: column</code> instead of <code>grid-auto-flow: row</code> — so they better match concepts from Masonry frameworks.</li>\n<li>Changing the default values, so developers won’t have to specify what they want as often.</li>\n<li>Introducing specialized functionality that doesn’t currently exist in Grid, like <code>repeat(auto-fill, auto)</code> as a track definition. (We’ll cover this point later in this article.)</li>\n</ol>\n<p>We do not believe the developer burden of 10 extra redundant properties is worth the suggested gains. Yes, the new <code>masonry-*</code> properties can be tailored to masonry-specific use cases. But developers will have to memorize all the differences between the two systems, and master which is which.</p>\n<figure><img loading=\"lazy\" src=\"https://webkit.org/wp-content/uploads/need-for-slack-property.png\" alt=\"Set of images in a staggered layout, each with a number labeling their DOM order. Current order 11, 9, 10, 12. Item 9 sticks up above the rest, higher on the page. Item 10 is a very tiny bit higher than item 11. Item 12 is slightly lower than the rest.\" width=\"1832\" height=\"645\" srcset=\"https://webkit.org/wp-content/uploads/need-for-slack-property.png 1832w, https://webkit.org/wp-content/uploads/need-for-slack-property-300x106.png 300w, https://webkit.org/wp-content/uploads/need-for-slack-property-1024x361.png 1024w, https://webkit.org/wp-content/uploads/need-for-slack-property-768x270.png 768w, https://webkit.org/wp-content/uploads/need-for-slack-property-1536x541.png 1536w\" /><figcaption>Both options do also come with one entirely-new property — the <code>*-slack</code> property — which lets developers tell the browser how picky to be when determining where to place the next item. Without any slack, Item 10 is in the third column, because it’s a <em>tiny</em> bit higher there than if it were placed in the left-most column. With “slack” the browser could be told to ignore those kinds of “tiny” differences, resulting in Item 10 being on the far left, followed Items 9, 11, 12.</figcaption></figure>\n<p>The CSS Working Group does not usually duplicate existing functionality. It instead extends existing functionality for a new purpose. We are not convinced that this circumstance provides a compelling enough reason to deviate from the canonical approach.</p>\n<h2><a name=\"extensibility\"></a>Extensibility</h2>\n<p>The hardest job the CSS Working Group does is to try and predict an unknown future, and make wise decisions that we won’t regret later. This concern was part of <a href=\"https://developer.chrome.com/blog/help-css-nesting/\">long</a> <a href=\"https://developer.chrome.com/blog/help-css-nesting-results/\">debate</a> <a href=\"https://webkit.org/blog/13607/help-choose-from-options-for-css-nesting-syntax/\">about</a> <a href=\"https://developer.chrome.com/blog/help-css-nesting-again/\">CSS</a> <a href=\"https://webkit.org/blog/14571/css-nesting-and-the-cascade/\">Nesting</a> for example — whether or not we were boxing ourselves into a corner that would block future expansion. (In the end, we ended up with a fantastic solution for Nesting.)</p>\n<p>As we debate this decision — to expand CSS Grid, or to create a new display type — we should carefully think through how the choice impacts the future. Which pattern do we want to establish going forward?</p>\n<p>The Just Use Grid option leans into the idea that CSS Grid is a major layout mechanism for web pages, and we should keep expanding it to be more and more powerful. The New Masonry Layout option seems to say, no, we should keep Grid as Grid, and add new segregated display types each time we add more layout capabilities.</p>\n<p>This is the kind of question that can be deeply philosophical and hard to discuss directly. Which direction you like better might just be a gut feeling. So let’s replace the theoretical question with a real example. Let’s imagine something else we might add to CSS layout in the future.</p>\n<h3><a name=\"a-possible-future-feature\"></a>A possible future feature</h3>\n<p>Imagine you’re front-end developer for a website full of articles. And your designer sends over this:</p>\n<figure><img loading=\"lazy\" src=\"https://webkit.org/wp-content/uploads/article-light-scaled.jpg\" alt=\"A typical article layout, with most content in a long wide column. Except headlines jut out to the left. Some images start further left, others extend to the right. Plus text flows around floated images.\" width=\"1665\" height=\"2560\" srcset=\"https://webkit.org/wp-content/uploads/article-light-scaled.jpg 1665w, https://webkit.org/wp-content/uploads/article-light-195x300.jpg 195w, https://webkit.org/wp-content/uploads/article-light-666x1024.jpg 666w, https://webkit.org/wp-content/uploads/article-light-768x1181.jpg 768w, https://webkit.org/wp-content/uploads/article-light-999x1536.jpg 999w, https://webkit.org/wp-content/uploads/article-light-1332x2048.jpg 1332w\" /></figure>\n<p>How will you code this layout in CSS?</p>\n<p>A decade ago, you probably would have reached for negative margins. Put everything in a main column, and then pull certain content (headlines, images) to the left and right, out of the main column, with code like <code>margin-left: -20px</code>.</p>\n<p>Now that 99% of users have <a href=\"https://caniuse.com/css-grid\">support for CSS Grid</a>, you have more options. You can still use negative margins. Or perhaps you’ll make the <code>article</code> element a Grid container, and turn every headline, paragraph, figure, etc into a Grid child. That would give you the ability to line up certain content along certain grid lines. But using Grid causes other problems. Suddenly you’ve got “double margins” — your top and bottom margins stack on top of each other, instead of collapsing. Also, you also can no longer use floats. They just don’t do anything. Every direct element of the <code>article</code> is now a Grid child, in its own separate row.</p>\n<p>What if instead, you could leverage the benefit of <code>grid-template-columns</code>, with its grid lines and and ability to explicitly place content  — but also keep the benefits of flow content, with its floats, collapsing margins, etc. That feels like just the right tool for laying out articles.</p>\n<p>We could stay in a flow layout context AND use features from CSS Grid, like this:</p>\n<pre><code><span>article</span> {\n  <span>display</span>: <span>block</span>; <span>/* default value, unnecessary to state */</span>\n  <span>grid-template-columns</span>: <span>1</span><span>fr</span> <span>1</span><span>fr</span> <span>minmax</span>(<span>15</span><span>ch</span>, <span>30</span><span>ch</span>) <span>minmax</span>(<span>15</span><span>ch</span>, <span>30</span><span>ch</span>) <span>1</span><span>fr</span>;\n  <span>grid-default-column</span>: <span>3</span> / <span>5</span>;\n}\n</code></pre>\n<p>A new property, perhaps named <code>grid-default-column</code>, could let us define the default placement for all the direct children of the article element — in this case, line 3 to line 5. (In fact, such a property would be very handy in CSS Grid for many other use cases, including masonry-style layouts.)</p>\n<figure><img loading=\"lazy\" src=\"https://webkit.org/wp-content/uploads/article-gridlines-light-scaled.jpg\" alt=\"Same article, now with vertical dotted lines drawn to mark where the CSS Grid lines could go.\" width=\"1665\" height=\"2560\" srcset=\"https://webkit.org/wp-content/uploads/article-gridlines-light-scaled.jpg 1665w, https://webkit.org/wp-content/uploads/article-gridlines-light-195x300.jpg 195w, https://webkit.org/wp-content/uploads/article-gridlines-light-666x1024.jpg 666w, https://webkit.org/wp-content/uploads/article-gridlines-light-768x1181.jpg 768w, https://webkit.org/wp-content/uploads/article-gridlines-light-999x1536.jpg 999w, https://webkit.org/wp-content/uploads/article-gridlines-light-1332x2048.jpg 1332w\" />\n</figure>\n<p>Once we have grid lines, we could define placements for the content we want to be elsewhere:</p>\n<pre><code><span>h1</span>, <span>figure</span> {\n  <span>grid-column</span>: <span>1</span> / <span>6</span>;\n}\n<span>h2</span>, <span>h3</span> {\n  <span>grid-column</span>: <span>2</span> / <span>6</span>;\n}\n<span>figure</span><span>.left</span> {\n  <span>grid-column</span>: <span>2</span> / <span>4</span>;\n  <span>float</span>: <span>left</span>; \n}\n<span>figure</span><span>.right</span> {\n  <span>grid-column</span>: <span>4</span> / <span>6</span>;\n  <span>float</span>: <span>right</span>; \n}\n</code></pre>\n<p>It’s a potentially radical idea to use <code>grid-template-columns</code> to define columns, <em>without</em> creating a grid formatting context. (It’s kind of like how you can now use Alignment in flow layout. You <a href=\"https://caniuse.com/mdn-css_properties_align-content_block_context\">no longer have to</a> create a Flexbox or Grid layout context to use <code>align-content</code>.)</p>\n<p>This is just one example of an idea the CSS Working Group might discuss in the future.</p>\n<p>By choosing the Just Use Grid option for masonry-style layouts, that seems to say yes to an idea like this. Let’s keep expanding what’s possible with CSS Grid, our current layout system. Let’s expand CSS Grid to do masonry-style packing. Let’s leverage part of CSS Grid to handle flow layout. Let’s keep creating more capabilities for the layout system we already have.</p>\n<p>The New Masonry Layout option seems to say, ok, any time we want to create another layout pattern, we should do so by creating another new formatting context. This novel idea should not be <code>display: block; grid-template-columns: [track sizes]</code>. Instead, it should be a separate layout system, with its own set of new properties and new default values that better match the purpose at hand. Perhaps like this:</p>\n<pre><code><span>article</span> {\n  <span>display</span>: <span>pillar</span>;\n  <span>pillar-template-columns</span>: <span>1</span><span>fr</span> <span>1</span><span>fr</span> <span>minmax</span>(<span>15</span><span>ch</span>, <span>30</span><span>ch</span>) <span>minmax</span>(<span>15</span><span>ch</span>, <span>30</span><span>ch</span>) <span>1</span><span>fr</span>;\n  <span>pillar-default-column</span>: <span>3</span> / <span>5</span>;\n}\n</code></pre>\n<p>If the CSSWG went in this direction, we’d end up with three sets of grid layout properties. The next time there’s another idea, would we feel compelled to create a fourth copy of the same properties?</p>\n<table>\n<thead>\n<tr>\n<th>Grid</th>\n<th>Masonry</th>\n<th>Pillar</th>\n<th>Another future feature</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>display: grid</code></td>\n<td><code>display: masonry</code></td>\n<td><code>display: pillar</code></td>\n<td><code>display: foobar</code></td>\n</tr>\n<tr>\n<td><code>grid-template-columns</code></td>\n<td><code>masonry-template-tracks</code></td>\n<td><code>pillar-template-columns</code></td>\n<td><code>foobar-template-baz</code></td>\n</tr>\n<tr>\n<td><code>grid-column</code></td>\n<td><code>masonry-track</code></td>\n<td><code>pillar-column</code></td>\n<td><code>foobar-qux</code></td>\n</tr>\n<tr>\n<td><code>grid-template-areas</code></td>\n<td><code>masonry-template-areas</code></td>\n<td><code>pillar-template-areas</code></td>\n<td><code>foobar-template-areas</code></td>\n</tr>\n<tr>\n<td>… etc …</td>\n<td>… etc …</td>\n<td>… etc …</td>\n<td>… etc …</td>\n</tr>\n</tbody>\n</table>\n<p>What’s actually simpler is having one set of syntax to learn, remember and use — even if sometimes that takes four lines of code to do something you could do in three because you need to declare the value you want, instead of relying on customized defaults.</p>\n<p>Also, would the new <code>pillar-default-column</code> property only work inside Pillar Layout, and not also come to Grid or Masonry — causing these separate systems to keep diverging over time?</p>\n<p>The Chrome team believes it’s better for Grid and Masonry to be segregated layout modes so that there is no requirement for them to evolve together. They’ve argued it will be easier to add specialized functionality to Masonry without the hassle of figuring out if the new feature makes sense to “also” add to Grid and vice versa.</p>\n<p>We believe it is better for these layout modes to be intertwined. We want the CSSWG to think through new additions — like <code>grid-default-column</code> — and make them work for the original Grid use cases, the masonry-style layout use cases, and anything else that comes along in the future. We don’t want a new feature for one to get left out of the other because it’s easier to implement in one mode vs the other. We want CSS to be a consistent, coherent, predictable system.</p>\n<h3><a name=\"extending-masonry-with-repeatauto-areas-auto\"></a>Extending Masonry with repeat(auto-areas, auto)</h3>\n<p>This brings us to the final reason (of the three enumerated above) Chrome believes creating a duplicate system of properties for Masonry is a good idea — because then it will be possible to introduce specialized functionality that doesn’t currently exist in Grid. They’ve proposed adding three new track definitions to Masonry —  <code>repeat(auto-areas, auto)</code>,   <code>repeat(auto-fill, auto)</code>, and   <code>repeat(auto-fit, auto)</code>. The first would be the brand new default:</p>\n<pre><code><span>.masonry</span> {\n  <span>display</span>: <span>masonry</span>;\n  <span>masonry-template-tracks</span>: <span>repeat</span>(<span>auto-areas</span>, <span>auto</span>); <span>/* new default value */</span>\n}\n</code></pre>\n<p>There’s excitement about these new track values because people believe they’ll provide a super easy way to create Masonry layouts with even less code. The width of each column (or height of rows) will be figured out automatically, based on the size of the contents. And the number of columns (or rows) could also be figured out automatically.</p>\n<p>Imagine, as a developer, you don’t have to describe the number of columns or the size of columns… just apply <code>display: masonry</code> to your container. The browser looks at your content, calculates all the sizing, makes the needed number of columns, and shazam! You get a classic Masonry layout, just like Pinterest, in <em>one</em> line of code. What could be easier to learn and use? That does sound promising! But we are not convinced that <code>masonry-template-tracks: repeat(auto-areas, auto)</code> will actually deliver the desired experience.</p>\n<p>There are actually two features here, tied together. The new default, and a fallback that becomes the default if the conditions for the first are not met. We have concerns about each. Let’s tackle them one at a time.</p>\n<p>WARNING! This section of this article goes deeper and deeper into concepts that start to get really hard to understand. This is our concern with the current proposal for the New Masonry Layout option. Developers will have to understand <code>auto</code> sizing (and the other concepts we’re about to explain) in order to confidently use it. And this stuff is <em>not</em> easy to understand. But, hey, let’s try…</p>\n<p>First, the new default. The value <code>repeat(auto-areas, auto)</code> automatically assigns <code>auto</code> as the size of the columns, with the number of columns taken from <code>masonry-template-areas</code>:</p>\n<pre><code><span>.masonry</span> {\n  <span>display</span>: <span>masonry</span>;\n  <span>masonry-template-areas</span>: <span>\"a b c\"</span>;\n\n  <span>/* default value, so you don't need to state it */</span>  \n  <span>masonry-template-tracks</span>: <span>repeat</span>(<span>auto-areas</span>, <span>auto</span>);\n}\n</code></pre>\n<p>This is a very good idea. In fact, CSS Grid already has this feature:</p>\n<pre><code><span>.grid-with-auto-sizing</span> {\n  <span>display</span>: <span>grid</span>;\n  <span>grid-template-areas</span>: <span>\"header header\"</span>\n                       <span>\"main  sidebar\"</span>\n                       <span>\"footer footer\"</span>;\n\n  <span>/* default value, so you don't need to state it */</span> \n  <span>grid-auto-columns</span>: <span>auto</span>; \n}\n</code></pre>\n<p>Today, CSS Grid takes the “missing” column sizes from <code>grid-auto-columns</code>, which has the default of <code>auto</code>. There’s no need to invent <code>repeat(auto-areas, ...)</code> to provide the same functionality a second time with completely-different syntax.</p>\n<p>Presumably, the reason for creating this mechanism is so that <code>masonry-template-tracks</code> is set up to have an appealing fallback default that kicks in when no areas are defined.</p>\n<h3><a name=\"extending-masonry-with-repeatauto-fill-auto\"></a>Extending Masonry with repeat(auto-fill, auto)</h3>\n<p>When <code>masonry-template-areas</code> is not in use, the <code>auto-areas</code> behavior is defined to fall back to <code>auto-fill</code>. Since most layouts don’t define areas, the functional default for the New Masonry Layout option is <code>masonry-template-tracks: repeat(auto-fill, auto)</code>. <em>This</em> is the code advocates expect will create the Pinterest layout automagically.</p>\n<p>There is a very interesting idea here. Can we get the browser to figure out how many columns to make, and how big to make those columns, by just looking at the content sizing — with no information from the web developer?</p>\n<p>There’s nothing like this today in CSS Grid. It was previously considered impossible because the browser can’t count the tracks until it knows their size, and it can’t size the tracks until placement is done, but it needs to know the number of tracks in order to do placement. (Creating an impossibly circular loop.) As the Chromium team discussed Masonry, they realized it might actually be possible to do this by making some assumptions that are good enough for typical use cases.</p>\n<p>If you’ve used CSS Grid, you’ve likely coded  <code>repeat(auto-fill, minmax(200px, 1fr)</code>  to tell the browser to create however-many columns are needed fill the available space, where each column is at least 200px wide and flexible. But what does <code>repeat(auto-fill, auto)</code> do?</p>\n<p>Let’s turn to an example. Imagine we have a page of photos to layout with Masonry. And we are using a CMS or a CDN to resize all of our image files to be naturally 600px wide, with varying heights.</p>\n<pre><code><span>&lt;<span>article</span> <span>class</span>=<span>\"container\"</span>&gt;</span>\n  <span>&lt;<span>figure</span>&gt;</span><span>&lt;<span>img</span> <span>width</span>=<span>\"600\"</span> <span>height</span>=<span>\"500\"</span> <span>alt</span>=<span>\"[description]\"</span>&gt;</span><span>&lt;/<span>figure</span>&gt;</span>\n  <span>&lt;<span>figure</span>&gt;</span><span>&lt;<span>img</span> <span>width</span>=<span>\"600\"</span> <span>height</span>=<span>\"300\"</span> <span>alt</span>=<span>\"[description]\"</span>&gt;</span><span>&lt;/<span>figure</span>&gt;</span>\n  <span>&lt;<span>figure</span>&gt;</span><span>&lt;<span>img</span> <span>width</span>=<span>\"600\"</span> <span>height</span>=<span>\"150\"</span> <span>alt</span>=<span>\"[description]\"</span>&gt;</span><span>&lt;/<span>figure</span>&gt;</span>\n  <span>&lt;<span>figure</span>&gt;</span><span>&lt;<span>img</span> <span>width</span>=<span>\"600\"</span> <span>height</span>=<span>\"750\"</span> <span>alt</span>=<span>\"[description]\"</span>&gt;</span><span>&lt;/<span>figure</span>&gt;</span>\n  <span>&lt;<span>figure</span>&gt;</span><span>&lt;<span>img</span> <span>width</span>=<span>\"600\"</span> <span>height</span>=<span>\"400\"</span> <span>alt</span>=<span>\"[description]\"</span>&gt;</span><span>&lt;/<span>figure</span>&gt;</span>\n  <span>&lt;<span>figure</span>&gt;</span><span>&lt;<span>img</span> <span>width</span>=<span>\"600\"</span> <span>height</span>=<span>\"250\"</span> <span>alt</span>=<span>\"[description]\"</span>&gt;</span><span>&lt;/<span>figure</span>&gt;</span>\n  <span>&lt;<span>figure</span>&gt;</span><span>&lt;<span>img</span> <span>width</span>=<span>\"600\"</span> <span>height</span>=<span>\"375\"</span> <span>alt</span>=<span>\"[description]\"</span>&gt;</span><span>&lt;/<span>figure</span>&gt;</span>\n  <span>&lt;<span>figure</span>&gt;</span><span>&lt;<span>img</span> <span>width</span>=<span>\"600\"</span> <span>height</span>=<span>\"360\"</span> <span>alt</span>=<span>\"[description]\"</span>&gt;</span><span>&lt;/<span>figure</span>&gt;</span>\n  <span>&lt;<span>figure</span>&gt;</span><span>&lt;<span>img</span> <span>width</span>=<span>\"600\"</span> <span>height</span>=<span>\"450\"</span> <span>alt</span>=<span>\"[description]\"</span>&gt;</span><span>&lt;/<span>figure</span>&gt;</span>\n  ...etc...\n<span>&lt;/<span>main</span>&gt;</span>\n</code></pre>\n<p>We want the images to be flexible, so we apply a classic responsive design technique:</p>\n<pre><code><span>img</span> {\n  <span>width</span>: <span>100%</span>;\n}\n</code></pre>\n<p>With the proposed defaults for the New Masonry Layout, we should be able to create a masonry-style layout with very little code! That’s the desired magic. We can just write:</p>\n<pre><code><span>.container</span> { \n  <span>display</span>: <span>masonry</span>;\n  <span>gap</span>: <span>10px</span>;\n}\n</code></pre>\n<p>So how does the browser decide how wide to make the columns? And how many columns to make?</p>\n<p>It looks at the images, sees they are 600px wide, and assumes each column should be at least 600px wide. It then counts up how many such columns will fit in the space available.</p>\n<p>Let’s say, at a particular moment, a user adjusts their browser window to be 1600px wide, and with the overall page layout, the <code>.container</code> is 1410px wide. That means there’s space for two columns of 600px wide images, with a 10px gap and 200px left over. As a developer, you can use the Alignment properties to decide what to do with that extra space — start, end, center, space-between, etc. By default, the extra space will be distributed to the columns, so we get two 700px columns.</p>\n<figure><img loading=\"lazy\" src=\"https://webkit.org/wp-content/uploads/magical-1-light.jpg\" alt=\"Two very compressed &amp; grainy images next to each other in a layout of a web page. \" width=\"1600\" height=\"747\" srcset=\"https://webkit.org/wp-content/uploads/magical-1-light.jpg 1600w, https://webkit.org/wp-content/uploads/magical-1-light-300x140.jpg 300w, https://webkit.org/wp-content/uploads/magical-1-light-1024x478.jpg 1024w, https://webkit.org/wp-content/uploads/magical-1-light-768x359.jpg 768w, https://webkit.org/wp-content/uploads/magical-1-light-1536x717.jpg 1536w\" />\n</figure>\n<p>It’s likely you already see the problems. We didn’t intend for our columns to be this big. The images are 600px wide with the expectation they’ll be shrunk down, so they’ll look great on 2x and 3x Retina screens. Instead, our images are being stretched to fill a 700px wide column, making them look terrible. We declared <code>width: 100%</code> on the images, but there’s nothing “pushing on” them to make them smaller than their natural size. This means they’ll be displayed at 1x or less.</p>\n<p>We could try putting a maximum size on the images:</p>\n<pre><code><span>img</span> {\n  <span>width</span>: <span>100%</span>;\n  <span>max-size</span>: <span>200px</span>;\n}\n</code></pre>\n<p>Now the images will look much better on those Retina screens, but the browser will just make all the images fixed at 200px wide, not flexible. They’ll be max size, inside columns that are usually larger. That’s definitely not the desired result.</p>\n<figure><img loading=\"lazy\" src=\"https://webkit.org/wp-content/uploads/magical-2-light.jpg\" alt=\"Five columns of images, where the image does not fill the whole column. Odd extra space is marked with light grey.\" width=\"1600\" height=\"747\" srcset=\"https://webkit.org/wp-content/uploads/magical-2-light.jpg 1600w, https://webkit.org/wp-content/uploads/magical-2-light-300x140.jpg 300w, https://webkit.org/wp-content/uploads/magical-2-light-1024x478.jpg 1024w, https://webkit.org/wp-content/uploads/magical-2-light-768x359.jpg 768w, https://webkit.org/wp-content/uploads/magical-2-light-1536x717.jpg 1536w\" /></figure>\n<p>Let’s instead pretend we have a way to directly tell the browser to display the images as 3x, not 1x. Long ago, CSS proposed an <code>image-resolution</code> property (now-obsolete). Let’s think through how it would work if we size our images like this:</p>\n<pre><code><span>img</span> {\n  <span>width</span>: <span>100%</span>;\n  <span>image-resolution</span>: <span>3</span><span>dppx</span>;\n}\n</code></pre>\n<p>The browser would calculate sizing as if these images are 200px wide (really they’re 600px, displayed at 3x). This would result in fluid columns that are 200px or larger, not too big, containing fluid images that fill the column, with resolution between 2x and 3x. Great! That’s what we want.</p>\n<p>But this technique only works if <em>all</em> of the images are naturally 600px wide. If they have various widths, coming from a less-controlling backend, then the columns will end up the width of whichever image is biggest divided by 3. You can’t predict the outcome. If the largest image is 1500px wide, then the columns start at 500px wide. If the largest image is 2400px, the columns start at 800px. Column sizing depends on which images happen to load. Plus, <code>image-resolution</code> doesn’t currently exist.</p>\n<p>Let’s try a different idea. Instead, we can set a fixed width on the image for the purposes of columns sizing, and then override that size with <code>min-width</code> to make the image fluid. It’s a bit of unexpected backwards logic, but it works.</p>\n<pre><code><span>img</span> {\n  <span>width</span>: <span>200px</span>;\n  <span>min-width</span>: <span>100%</span>;\n}\n</code></pre>\n<p>The browser will make however-many fluid columns fit in the available space, as long as those columns are 200px or wider. The images will be fluid, filling the column width. And the layout will look just like Pinterest!</p>\n<p>Oh wait… this only works if the content consists of just an image, or image with a very short string of text. If the content includes any text long enough to wrap, then we have a new problem.</p>\n<p>Any time a browser uses <code>auto</code> to size a column based on its content’s size, it tries to accommodate the maximum possible size of that content. For text, <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/max-content\">max-content</a> size is the entire width of the string of text, without any wrapping. Imagine this paragraph stretched out to exist all on one line. That’s a very wide box.</p>\n<p>Pinterest itself puts text under every image when anonymous users visit the site. Let’s imagine how the New Masonry Layout option, with its proposed default values, would handle content where each item is a card with both an image and a headline.</p>\n<pre><code><span>&lt;<span>main</span> <span>class</span>=<span>\"container\"</span>&gt;</span>\n  <span>&lt;<span>article</span> <span>class</span>=<span>\"item\"</span>&gt;</span>\n    <span>&lt;<span>img</span> <span>width</span>=<span>\"600\"</span> <span>height</span>=<span>\"450\"</span> <span>alt</span>=<span>\"[description]\"</span>&gt;</span>\n    <span>&lt;<span>h2</span>&gt;</span>Coffee<span>&lt;/<span>h2</span>&gt;</span>\n  <span>&lt;/<span>article</span>&gt;</span>\n  <span>&lt;<span>article</span> <span>class</span>=<span>\"item\"</span>&gt;</span>\n    <span>&lt;<span>img</span> <span>width</span>=<span>\"600\"</span> <span>height</span>=<span>\"700\"</span> <span>alt</span>=<span>\"[description]\"</span>&gt;</span>\n    <span>&lt;<span>h2</span>&gt;</span>We love traveling to get a great cup of coffee, no matter how far<span>&lt;/<span>h2</span>&gt;</span>\n  <span>&lt;/<span>article</span>&gt;</span>\n  ...\n<span>&lt;/<span>main</span>&gt;</span>\n</code></pre>\n<p>The first headline, “Coffee”, is probably going to be less than 200px wide. If the image is set to 200px wide for the purposes of sizing, and the headline is 80px wide, then the max-width of this content is 200px. No problem.</p>\n<p>The second headline, “We love traveling to get a great cup of coffee, no matter how far”, is probably going to be more than 200px wide. If the image is set to 200px wide, and the headline is 676px wide, then the max-width of this content is 676px.</p>\n<p>The browser will look at all the cards, figure out which card has the greatest max-size and use its widest width to calculate the widths of all the columns. In this case, all columns will be 676px wide or wider, getting as big as 1351px. That’s not the result we want.</p>\n<p>We could compensate for this by setting a size on the headline as well, forcing it to wrap. To do so we need to figure out which properties to use… <code>width</code>, <code>min-width</code>, <code>max-width</code>, or a combination?… and which values to set… 200px? larger?… Pop quiz! Can you figure this out?</p>\n<p>Or, let’s back up. A better strategy might be to apply the code that controls sizing to the <code>.item</code> wrapper, instead of the content inside. We still have to use our <code>width: 200px</code> + <code>min-width: 100%</code> trick to make it fluid, though. It won’t default to stretching on its own. Doing so means the Alignment properties (so handy in Grid) no longer have an effect, because we’ve given the items an explicit size of 100%. This also means that if we want to add margins to our items, we have to subtract them out of that 100% ourselves manually, much like we did back in the days of float-based layouts. Say hello to our old frenemy <code>calc(100% - var(--margin-size))</code>.</p>\n<p>Understanding how this works is definitely not easy! It requires a sophisticated understanding of how <code>auto</code> sizing works — arguably the hardest part of layout on the web. The proposed default is often not going to magically work with “only one line of code”. As a developer, you still have to do all the work to control track sizing. The needed CSS is just applied to the items and/or their content instead of the layout container. It’s a return to how it worked when everything was float-based — when we controlled layout by sizing the content.</p>\n<p>CSS Grid massively improves developer experience by letting us create structures where our containers control sizing instead. Track sizing is a much more powerful tool than item sizing — with more ways to define interactions. Plus, by asking the browser to scan all the items to find their sizes, and then calculate the track sizes, it loses the performance advantage of reading the size directly from the defined track value instead.</p>\n<p>But all of that doesn’t mean this idea would never be useful. Our <a href=\"https://webkit.org/demos/grid3/megamenu/\">mega menu demo</a> of a footer of links is a good example of a use case for which <code>repeat(auto-fill, auto)</code> could be helpful. The strings of text are short, there are no images to worry about sizing, and the designer likely wants to avoid wrapping. Auto-sized columns would yield a great result without requiring the developer to adjust content sizing.</p>\n<figure><img src=\"https://webkit.org/wp-content/uploads/image7-megamenu-light.png\" alt=\"a menu with a ton of links, like in a website footer, laid out with Grid Level 3\" /></figure>\n<p>However, laying out short strings of text is not the most common use case. And as we’ve seen, the <code>repeat(auto-fill, auto)</code> value is not useful for the use cases that are most common. It does not make sense to make it the default.</p>\n<p>Also, if the CSSWG determines this is useful enough to do, why not make it work for all of Grid, not just masonry-style layouts? We found workable definitions for the rest of Grid syntax that the Chrome team originally believed to be unworkable in Masonry, so let’s try to find a workable definition for <code>repeat(auto-fill, auto)</code> in Grid as well rather than creating divergence. Doing so is better for developers — more functionality, more consistency, and a unified feature set that’s easier to learn.</p>\n<p>We want CSS layout to be a unified and consistent system. Adding support for <code>auto</code> inside <code>repeat</code> track definitions is a good example of why the masonry-style layout functionality should be part of CSS Grid, so that new ideas are integrated into all of layout, not just one part.</p>\n<h2><a name=\"summary\"></a>Summary</h2>\n<p>In isolation, Masonry as its own display type can seem appealing. It may feel more <a href=\"https://www.w3.org/TR/html-design-principles/#priority-of-constituencies\">theoretically pure</a>. But when looking at integrating it into the entire layout system of CSS, it’s not the best idea. We must consider real sites with real content. We must imagine how this new feature will live inside thousands of lines of code and change with break points. And we should contemplate how our choice impacts future layout possibilities in CSS.</p>\n<p>CSS Design principles should guide this decision, reminding us to value true simplicity and learnability. To strive to repurpose what’s already there, creating minimum redundancy. To make smart architectural decisions regarding extensibility — decisions that expand an integrated network of features that all work predictably together.</p>\n<h2><a name=\"design-by-committee\"></a>Design by committee</h2>\n<p>This is where you come in. As a web developer, you can help the CSS Working Group make this decision.</p>\n<p>We’d love to hear your thoughts. It will be especially helpful if you can diagram a real-world design, and write out all of the code for each of the two options. See which way of actually using this feature you prefer. Find ways to use both classic CSS Grid and the proposals for creating masonry-style layouts to see how it feels to use them together, whether nesting one inside the other or switching things up at a breakpoint. It’s much better to make this decision after using the code, rather than just contemplating it in the abstract.</p>\n<p>We believe this syntactical decision should be made while diving into realistic examples, so we created quite a few at: <a href=\"https://webkit.org/demos/grid3/\">webkit.org/demos/grid3</a>. Test them in Safari Technology Preview, where the Just Use Grid option is on by default. Or turn it on in any version of Safari 17.x or 18.x by checking “CSS Masonry Layout” at Develop &gt; Feature Flags. Or test in Firefox after enabling its flag by typing <code>about:config</code> in the URL, agreeing to risk, searching for “Masonry”, and clicking its icon on the right. (Demos using subgrid may not work correctly in Firefox, but the core functionality will.)</p>\n<p>You can <a href=\"https://github.com/w3c/csswg-drafts/issues/11060\">leave a comment here</a>. Or even better, write your own article about your thoughts, showing off your examples — and then post the URL in a comment. At this point, thoughtful qualitative feedback is much more helpful than sheer quantity of brief opinions.</p>\n<hr />\n<p><a></a><strong>1. FOOTNOTE:</strong> <a href=\"https://webkit.org/blog/15269/help-us-invent-masonry-layouts-for-css-grid-level-3/#p-s-about-the-name\">As described in our previous article</a>, “masonry” is not an ideal name, since it represents a metaphor, and not a direct description of its purpose. It’s also not a universally used name for this kind of layout. Many developers call it “waterfall layout” instead, which is also a metaphor.</p>\n<p>Many of you have made suggestions for a better name. Two have stood out, <code>collapse</code> and <code>pack</code> as in — <code>grid-template-rows: collapse</code> or  <code>grid-template-rows: pack</code>. Which do you like better? Or do you have another suggestion? Comment <a href=\"https://github.com/w3c/csswg-drafts/issues/9733\">on this issue</a> specifically about a new value name (for the Just Use grid option).</p>\n<p>We used <code>grid-template-rows: collapse</code> throughout this article to help imagine what CSS Grid would be like, integrating a new feature for masonry-style layouts. Meanwhile, <code>grid-template-rows: masonry</code> is what you should use today when testing demos in Safari, Safari Technology Preview and Firefox.</p>","author":"","siteTitle":"Blog – WebKit","siteHash":"7f8dbea0b8f53db2e11a2faa08c6dca9954c01638d09a2ce585b77a60d10f7a1","entryHash":"5029a4831498ff09021050197f7258b455be9f819aa5f5be01a2b1c137260939","category":"Tech"}