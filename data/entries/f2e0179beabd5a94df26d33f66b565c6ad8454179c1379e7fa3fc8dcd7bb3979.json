{"title":"3D CSS Flippy Snaps With React And GreenSock","link":"https://smashingmagazine.com/2021/11/3d-css-flippy-snaps-react-greensock/","date":1638189000000,"content":"<p>Naming things is hard, right? Well, ‚ÄúFlippy Snaps‚Äù was the best thing I could come up with. üòÇ I saw an effect like this on TV one evening and made a note to myself to make something similar.</p>\n<p>Although this isn‚Äôt something I‚Äôd look to drop on a website any time soon, it‚Äôs a neat little challenge to make. It fits in with my whole stance on ‚Äú<a href=\"https://www.smashingmagazine.com/2020/11/playfulness-code-supercharge-fun-learning/\">Playfulness in Code</a>‚Äù to learn. Anyway, a few days later, I sat down at the keyboard, and a couple of hours later I had this:</p>\n<blockquote><p>3D CSS Flippy Snaps ‚ú®<br /><br />Tap to flip for another image üëá<br /><br />‚öíÔ∏è <a href=\"https://twitter.com/reactjs?ref_src=twsrc%5Etfw\">@reactjs</a> &amp;&amp; <a href=\"https://twitter.com/greensock?ref_src=twsrc%5Etfw\">@greensock</a> <br />üëâ <a href=\"https://t.co/Na14z40tHE\">https://t.co/Na14z40tHE</a> via <a href=\"https://twitter.com/CodePen?ref_src=twsrc%5Etfw\">@CodePen</a> <a href=\"https://t.co/nz6pdQGpmd\">pic.twitter.com/nz6pdQGpmd</a></p>‚Äî Jhey üêªüõ†Ô∏è‚ú® (@jh3yy) <a href=\"https://twitter.com/jh3yy/status/1457830342413455369?ref_src=twsrc%5Etfw\">November 8, 2021</a></blockquote>\n\n<p>My final demo is a React app, but we don‚Äôt need to dig into using React to explain the mechanics of making this work. We will create the React app once we‚Äôve established how to make things work.</p>\n<p><strong>Note</strong>: <em>Before we get started. It‚Äôs worth noting that the performance of this demo is affected by the grid size and the demos are best viewed in Chromium-based browsers.</em></p>\n<p>Let‚Äôs start by creating a grid. Let‚Äôs say we want a 10 by 10 grid. That‚Äôs 100 cells (This is why React is handy for something like this). Each cell is going to consist of an element that contains the front and back for a flippable card.</p>\n<pre><code>&lt;div class=\"flippy-snap\"&gt;\n  &lt;!-- 100 of these --&gt;\n  &lt;div class=\"flippy-snap__card flippy-card\"&gt;\n    &lt;div class=\"flippy-card__front&gt;&lt;/div&gt;\n    &lt;div class=\"flippy-card__rear&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;</code></pre>\n\n<p>The styles for our grid are quite straightforward. We can use <code>display: grid</code> and use a custom property for the grid size. Here we are defaulting to <code>10</code>.</p>\n<pre><code>.flippy-snap {\n  display: grid;\n  grid-gap: 1px;\n  grid-template-columns: repeat(var(--grid-size, 10), 1fr);\n  grid-template-rows: repeat(var(--grid-size, 10), 1fr);\n}</code></pre>\n\n<p>We won‚Äôt use <code>grid-gap</code> in the final demo, but, it‚Äôs good for seeing the cells easier whilst developing.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/porXNzB\">1. Creating a Grid</a> by <a href=\"https://codepen.io/jh3y\">JHEY</a></p>\n<p>Next, we need to style the sides of our cards and display images. We can do this by leveraging inline CSS custom properties. Let‚Äôs start by updating the markup. We need each card to know its <code>x</code> and <code>y</code> position in the grid.</p>\n<pre><code>&lt;div class=\"flippy-snap\"&gt;\n  &lt;div class=\"flippy-snap__card flippy-card\" style=\"--x: 0; --y: 0;\"&gt;\n    &lt;div class=\"flippy-card__front\"&gt;&lt;/div&gt;\n    &lt;div class=\"flippy-card__rear\"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=\"flippy-snap__card flippy-card\" style=\"--x: 1; --y: 0;\"&gt;\n    &lt;div class=\"flippy-card__front\"&gt;&lt;/div&gt;\n    &lt;div class=\"flippy-card__rear\"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;!-- Other cards --&gt;\n&lt;/div&gt;</code></pre>\n\n<p>For the demo, I'm using <code>Pug</code> to generate this for me. You can see the compiled HTML by clicking ‚ÄúView Compiled HTML‚Äù in the demo.</p>\n<pre><code>- const GRID_SIZE = 10\n- const COUNT = Math.pow(GRID_SIZE, 2)\n.flippy-snap\n  - for(let f = 0; f &lt; COUNT; f++)\n    - const x = f % GRID_SIZE  \n    - const y = Math.floor(f / GRID_SIZE)\n    .flippy-snap__card.flippy-card(style=`--x: ${x}; --y: ${y};`)\n      .flippy-card__front\n      .flippy-card__rear</code></pre>\n\n<p>Then we need some styles. </p>\n<pre><code>.flippy-card {\n  --current-image: url(\"https://random-image.com/768\");\n  --next-image: url(\"https://random-image.com/124\");\n  height: 100%;\n  width: 100%;\n  position: relative;\n}\n.flippy-card__front,\n.flippy-card__rear {\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  backface-visibility: hidden;\n  background-image: var(--current-image);\n  background-position: calc(var(--x, 0) * -100%) calc(var(--y, 0) * -100%);\n  background-size: calc(var(--grid-size, 10) * 100%);\n}\n.flippy-card__rear {\n  background-image: var(--next-image);\n  transform: rotateY(180deg) rotate(180deg);\n}</code></pre>\n\n<p>The rear of the card gets its position using a combination of rotations via <code>transform</code>. But, the interesting part is how we show the image part for each card. In this demo, we are using a custom property to define the URLs for two images. And then we set those as the <code>background-image</code> for each card face.</p>\n<p>But the trick is how we define the <code>background-size</code> and <code>background-position</code>. Using the custom properties <code>--x</code> and <code>--y</code> we multiply the value by <code>-100%</code>. And then we set the <code>background-size</code> to <code>--grid-size</code> multiplied by <code>100%</code>. This gives displays the correct part of the image for a given card.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/gOxNLPz\">2. Adding an Image</a> by <a href=\"https://codepen.io/jh3y\">JHEY</a></p>\n<p>You may have noticed that we had <code>--current-image</code> and <code>--next-image</code>. But, currently, there is no way to see the next image. For that, we need a way to flip our cards. We can use another custom property for this.</p>\n<p>Let‚Äôs introduce a <code>--count</code> property and set a <code>transform</code> for our cards:</p>\n<pre><code>.flippy-snap {\n  --count: 0;\n  perspective: 50vmin;\n}\n.flippy-card {\n  transform: rotateX(calc(var(--count) * -180deg));\n  transition: transform 0.25s;\n  transform-style: preserve-3d;\n}</code></pre>\n\n<p>We can set the <code>--count</code> property on the containing element. Scoping means all the cards can pick up that value and use it to <code>transform</code> their rotation on the x-axis. We also need to set <code>transform-style: preserve-3d</code> so that we see the back of the cards. Setting a <code>perspective</code> gives us that 3D perspective.</p>\n<p>This demo lets you update the <code>--count</code> property value so you can see the effect it has.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/LYjKbZW\">3. Turning Cards</a> by <a href=\"https://codepen.io/jh3y\">JHEY</a></p>\n<p>At this point, you could wrap it up there and set a simple click handler that increments <code>--count</code> by one on each click.</p>\n<pre><code>const SNAP = document.querySelector('.flippy-snap')\nlet count = 0\nconst UPDATE = () =&gt; SNAP.style.setProperty('--count', count++)\nSNAP.addEventListener('click', UPDATE)</code></pre>\n\n<p>Remove the <code>grid-gap</code> and you‚Äôd get this. Click the snap to flip it.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/eYEwBdN\">4. Boring Flips</a> by <a href=\"https://codepen.io/jh3y\">JHEY</a></p>\n<p>Now we have the basic mechanics worked out, it‚Äôs time to turn this into a React app. There‚Äôs a bit to break down here.</p>\n<pre><code>const App = () =&gt; {\n  const [snaps, setSnaps] = useState([])\n  const [disabled, setDisabled] = useState(true)\n  const [gridSize, setGridSize] = useState(9)\n  const snapRef = useRef(null)\n\n  const grabPic = async () =&gt; {\n    const pic = await fetch('https://source.unsplash.com/random/1000x1000')\n    return pic.url\n  }\n\n  useEffect(() =&gt; {\n    const setup = async () =&gt; {\n      const url = await grabPic()\n      const nextUrl = await grabPic()\n      setSnaps([url, nextUrl])\n      setDisabled(false)\n    }\n    setup()\n  }, [])\n\n  const setNewImage = async count =&gt; {\n    const newSnap = await grabPic()\n    setSnaps(\n      count.current % 2 !== 0 ? [newSnap, snaps[1]] : [snaps[0], newSnap]\n    )\n    setDisabled(false)\n  }\n\n  const onFlip = async count =&gt; {\n    setDisabled(true)\n    setNewImage(count)\n  }\n\n  if (snaps.length !== 2) return &lt;h1 className=\"loader\"&gt;Loading...&lt;/h1&gt;\n\n  return (\n    &lt;FlippySnap\n      gridSize={gridSize}\n      disabled={disabled}\n      snaps={snaps}\n      onFlip={onFlip}\n      snapRef={snapRef}\n    /&gt;\n  )\n}</code></pre>\n\n<p>Our <code>App</code> component handles grabbing images and passing them to our <code>FlippySnap</code> component. That‚Äôs the bulk of what‚Äôs happening here. For this demo, we‚Äôre grabbing images from <a href=\"https://source.unsplash.com\">Unsplash</a>.</p>\n<pre><code>const grabPic = async () =&gt; {\n  const pic = await fetch('https://source.unsplash.com/random/1000x1000')\n  return pic.url\n}\n\n// Initial effect grabs two snaps to be used by FlippySnap\nuseEffect(() =&gt; {\n  const setup = async () =&gt; {\n    const url = await grabPic()\n    const nextUrl = await grabPic()\n    setSnaps([url, nextUrl])\n    setDisabled(false)\n  }\n  setup()\n}, [])</code></pre>\n\n<p>If there aren‚Äôt two snaps to show, then we show a ‚ÄúLoading...‚Äù message.</p>\n<pre><code>if (snaps.length !== 2) return &lt;h1 className=\"loader\"&gt;Loading...&lt;/h1&gt;</code></pre>\n\n<p>If we are grabbing a new image, we need to disable <code>FlippySnap</code> so we can‚Äôt spam-click it.</p>\n<pre><code>&lt;FlippySnap\n  gridSize={gridSize}\n  disabled={disabled} // Toggle a \"disabled\" prop to stop spam clicks\n  snaps={snaps}\n  onFlip={onFlip}\n  snapRef={snapRef}\n/&gt;</code></pre>\n\n<p>We‚Äôre letting <code>App</code> dictate the snaps that get displayed by <code>FlippySnap</code> and in which order. On each flip, we grab a new image, and depending on how many times we‚Äôve flipped, we set the correct snaps. The alternative would be to set the snaps and let the component figure out the order.</p>\n<pre><code>const setNewImage = async count =&gt; {\n  const newSnap = await grabPic() // Grab the snap\n  setSnaps(\n    count.current % 2 !== 0 ? [newSnap, snaps[1]] : [snaps[0], newSnap]\n  ) // Set the snaps based on the current \"count\" which we get from FlippySnap\n  setDisabled(false) // Enable clicks again\n}\n\nconst onFlip = async count =&gt; {\n  setDisabled(true) // Disable so we can't spam click\n  setNewImage(count) // Grab a new snap to display\n}</code></pre>\n\n<p>How might <code>FlippySnap</code> look? There isn‚Äôt much to it at all!</p>\n<pre><code>const FlippySnap = ({ disabled, gridSize, onFlip, snaps }) =&gt; {\n  const CELL_COUNT = Math.pow(gridSize, 2)\n  const count = useRef(0)\n\n  const flip = e =&gt; {\n    if (disabled) return\n    count.current = count.current + 1\n    if (onFlip) onFlip(count)\n  }\n\n  return (\n    &lt;button\n      className=\"flippy-snap\"\n      ref={containerRef}\n      style={{\n        '--grid-size': gridSize,\n        '--count': count.current,\n        '--current-image': `url('${snaps[0]}')`,\n        '--next-image': `url('${snaps[1]}')`,\n      }}\n      onClick={flip}&gt;\n      {new Array(CELL_COUNT).fill().map((cell, index) =&gt; {\n        const x = index % gridSize\n        const y = Math.floor(index / gridSize)\n        return (\n          &lt;span\n            key={index}\n            className=\"flippy-card\"\n            style={{\n              '--x': x,\n              '--y': y,\n            }}&gt;\n            &lt;span className=\"flippy-card__front\"&gt;&lt;/span&gt;\n            &lt;span className=\"flippy-card__rear\"&gt;&lt;/span&gt;\n          &lt;/span&gt;\n        )\n      })}\n    &lt;/button&gt;\n  )\n}</code></pre>\n\n<p>The component handles rendering all the cards and setting the inline custom properties. The <code>onClick</code> handler for the container increments the <code>count</code>. It also triggers the <code>onFlip</code> callback. If the state is currently <code>disabled</code>, it does nothing. That flip of the <code>disabled</code> state and grabbing a new snap triggers the flip when the component re-renders.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/wvqLdGY\">5. React Foundation</a> by <a href=\"https://codepen.io/jh3y\">JHEY</a></p>\n<p>We have a React component that will now flip through images for as long as we want to keep requesting new ones. But, that flip transition is a bit boring. To spice it up, we‚Äôre going to make use of <a href=\"https://greensock.com\">GreenSock</a> and its utilities. In particular, the ‚Äú<a href=\"https://greensock.com/docs/v3/GSAP/UtilityMethods/distribute\">distribute</a>‚Äù utility. This will allow us to distribute the delay of flipping our cards in a grid-like burst from wherever we click. To do this, we‚Äôre going to use GreenSock to animate the <code>--count</code> value on each card.</p>\n<p>It‚Äôs worth noting that we have a choice here. We could opt to apply the styles with GreenSock. Instead of animating the <code>--count</code> property value, we could animate <code>rotateX</code>. We could do this based on the <code>count</code> ref we have. And this also goes for any other things we choose to animate with GreenSock in this article. It‚Äôs down to preference and use case. You may feel that updating the custom property value makes sense. The benefit being that you don‚Äôt need to update any JavaScript to get a different styled behavior. We could change the CSS to use <code>rotateY</code> for example.</p>\n<p>Our updated <code>flip</code> function could look like this:</p>\n<div>\n<pre><code>const flip = e =&gt; {\n  if (disabled) return\n  const x = parseInt(e.target.parentNode.getAttribute('data-snap-x'), 10)\n  const y = parseInt(e.target.parentNode.getAttribute('data-snap-y'), 10)\n  count.current = count.current + 1\n  gsap.to(containerRef.current.querySelectorAll('.flippy-card'), {\n    '--count': count.current,\n    delay: gsap.utils.distribute({\n      from: [x / gridSize, y / gridSize],\n      amount: gridSize / 20,\n      base: 0,\n      grid: [gridSize, gridSize],\n      ease: 'power1.inOut',\n    }),\n    duration: 0.2,\n    onComplete: () =&gt; {\n      // At this point update the images\n      if (onFlip) onFlip(count)\n    },\n  })\n}</code></pre>\n</div>\n\n<p>Note how we‚Äôre getting an <code>x</code> and <code>y</code> value by reading attributes of the clicked card. For this demo, we‚Äôve opted for adding some <code>data</code> attributes to each card. These attributes communicate a card's position in the grid. We‚Äôre also using a new <code>ref</code> called <code>containerRef</code>. This is so we reference only the cards for a <code>FlippySnap</code> instance when using GreenSock.</p>\n<pre><code>{new Array(CELL_COUNT).fill().map((cell, index) =&gt; {\n  const x = index % gridSize\n  const y = Math.floor(index / gridSize)\n  return (\n    &lt;span\n      className=\"flippy-card\"\n      data-snap-x={x}\n      data-snap-y={y}\n      style={{\n        '--x': x,\n        '--y': y,\n      }}&gt;\n      &lt;span className=\"flippy-card__front\"&gt;&lt;/span&gt;\n      &lt;span className=\"flippy-card__rear\"&gt;&lt;/span&gt;\n    &lt;/span&gt;\n  )\n})}</code></pre>\n\n<p>Once we get those <code>x</code> and <code>y</code> values, we can make use of them in our animation. Using <code>gsap.to</code> we want to animate the <code>--count</code> custom property for every <code>.flippy-card</code> that‚Äôs a child of <code>containerRef</code>.</p>\n<p>To distribute the delay from where we click, we set the value of <code>delay</code> to use <code>gsap.utils.distribute</code>. The <code>from</code> value of the <code>distribute</code> function takes an Array containing ratios along the x and y axis. To get this, we divide <code>x</code> and <code>y</code> by <code>gridSize</code>. The <code>base</code> value is the initial value. For this, we want <code>0</code> delay on the card we click. The <code>amount</code> is the largest value. We've gone for <code>gridSize / 20</code> but you could experiment with different values. Something based on the <code>gridSize</code> is a good idea though. The <code>grid</code> value tells GreenSock the grid size to use when calculating distribution. Last but not least, the <code>ease</code> defines the ease of the <code>delay</code> distribution.</p>\n<pre><code>gsap.to(containerRef.current.querySelectorAll('.flippy-card'), {\n  '--count': count.current,\n  delay: gsap.utils.distribute({\n    from: [x / gridSize, y / gridSize],\n    amount: gridSize / 20,\n    base: 0,\n    grid: [gridSize, gridSize],\n    ease: 'power1.inOut',\n  }),\n  duration: 0.2,\n  onComplete: () =&gt; {\n    // At this point update the images\n    if (onFlip) onFlip(count)\n  },\n})</code></pre>\n\n<p>As for the rest of the animation, we are using a flip duration of <code>0.2</code> seconds. And we make use of <code>onComplete</code> to invoke our callback. We pass the flip <code>count</code> to the callback so it can use this to determine snap order. Things like the duration of the flip could get configured by passing in different <code>props</code> if we wished.</p>\n<p>Putting it all together gives us this:</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/VwzJbpM\">6. Distributed Flips with GSAP</a> by <a href=\"https://codepen.io/jh3y\">JHEY</a></p>\n<p>Those that like to push things a bit might have noticed that we can still ‚Äúspam‚Äù click the snap. And that‚Äôs because we don‚Äôt disable <code>FlippySnap</code> until GreenSock has completed. To fix this, we can use an internal ref that we toggle at the start and end of using GreenSock.</p>\n<div>\n<pre><code>const flipping = useRef(false) // New ref to track the flipping state\n\nconst flip = e =&gt; {\n  if (disabled || flipping.current) return\n  const x = parseInt(e.target.parentNode.getAttribute('data-snap-x'), 10)\n  const y = parseInt(e.target.parentNode.getAttribute('data-snap-y'), 10)\n  count.current = count.current + 1\n  gsap.to(containerRef.current.querySelectorAll('.flippy-card'), {\n    '--count': count.current,\n    delay: gsap.utils.distribute({\n      from: [x / gridSize, y / gridSize],\n      amount: gridSize / 20,\n      base: 0,\n      grid: [gridSize, gridSize],\n      ease: 'power1.inOut',\n    }),\n    duration: 0.2,\n    onStart: () =&gt; {\n      flipping.current = true\n    },\n    onComplete: () =&gt; {\n      // At this point update the images\n      flipping.current = false\n      if (onFlip) onFlip(count)\n    },\n  })\n}</code></pre>\n</div>\n\n<p>And now we can no longer spam click our <code>FlippySnap</code>!</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/jOLjmXE\">7. No Spam Clicks</a> by <a href=\"https://codepen.io/jh3y\">JHEY</a></p>\n<p>Now it‚Äôs time for some extra touches. At the moment, there‚Äôs no visual sign that we can click our <code>FlippySnap</code>. What if when we hover, the cards raise towards us? We could use <code>onPointerOver</code> and use the ‚Äúdistribute‚Äù utility again.</p>\n<pre><code>const indicate = e =&gt; {\n  const x = parseInt(e.currentTarget.getAttribute('data-snap-x'), 10)\n  const y = parseInt(e.currentTarget.getAttribute('data-snap-y'), 10)\n  gsap.to(containerRef.current.querySelectorAll('.flippy-card'), {\n    '--hovered': gsap.utils.distribute({\n      from: [x / gridSize, y / gridSize],\n      base: 0,\n      amount: 1,\n      grid: [gridSize, gridSize],\n      ease: 'power1.inOut'\n    }),\n    duration: 0.1,\n  })\n}</code></pre>\n\n<p>Here, we are setting a new custom property on each card named <code>--hovered</code>. This is set to a value from <code>0</code> to <code>1</code>. Then within our CSS, we are going to update our card styles to watch for the value.</p>\n<pre><code>.flippy-card {\n  transform: translate3d(0, 0, calc((1 - (var(--hovered, 1))) * 5vmin))\n             rotateX(calc(var(--count) * -180deg));\n}</code></pre>\n\n<p>Here we are saying that a card will move on the z-axis at most <code>5vmin</code>.</p>\n<p>We then apply this to each card using the <code>onPointerOver</code> prop.</p>\n<pre><code>{new Array(CELL_COUNT).fill().map((cell, index) =&gt; {\n  const x = index % gridSize\n  const y = Math.floor(index / gridSize)\n  return (\n    &lt;span\n      onPointerOver={indicate}\n      className=\"flippy-card\"\n      data-snap-x={x}\n      data-snap-y={y}\n      style={{\n        '--x': x,\n          '--y': y,\n      }}&gt;\n      &lt;span className=\"flippy-card__front\"&gt;&lt;/span&gt;\n      &lt;span className=\"flippy-card__rear\"&gt;&lt;/span&gt;\n    &lt;/span&gt;\n  )\n})}</code></pre>\n\n<p>And when our pointer leaves our <code>FlippySnap</code> we want to reset our card positions.</p>\n<pre><code>\nconst reset = () =&gt; {\n  gsap.to(containerRef.current.querySelectorAll('.flippy-card'), {\n    '--hovered': 1,\n    duration: 0.1,\n  })\n}</code></pre>\n\n<p>And we can apply this with the <code>onPointerLeave</code> prop.</p>\n<pre><code>&lt;button\n  className=\"flippy-snap\"\n  ref={containerRef}\n  onPointerLeave={reset}\n  style={{\n    '--grid-size': gridSize,\n    '--count': count.current,\n    '--current-image': `url('${snaps[0]}')`,\n    '--next-image': `url('${snaps[1]}')`,\n  }}\n  onClick={flip}&gt;</code></pre>\n\n<p>Put that all together and we get something like this. Try moving your pointer over it.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/wvqLdZL\">8. Visual Inidication with Raised Cards</a> by <a href=\"https://codepen.io/jh3y\">JHEY</a></p>\n<p>What next? How about a loading indicator so we know when our <code>App</code> is grabbing the next image? We can render a loading spinner when our <code>FlippySnap</code> is <code>disabled</code>.</p>\n<pre><code>{disabled &amp;&amp; &lt;span className='flippy-snap__loader'&gt;&lt;/span&gt;}</code></pre>\n\n<p>He styles for which could make a rotating circle.</p>\n<pre><code>.flippy-snap__loader {\n  border-radius: 50%;\n  border: 6px solid #fff;\n  border-left-color: #000;\n  border-right-color: #000;\n  position: absolute;\n  right: 10%;\n  bottom: 10%;\n  height: 8%;\n  width: 8%;\n  transform: translate3d(0, 0, 5vmin) rotate(0deg);\n  animation: spin 1s infinite;\n}\n@keyframes spin {\n  to {\n    transform: translate3d(0, 0, 5vmin) rotate(360deg);\n  }\n}</code></pre>\n\n<p>And this gives us a loading indicator when grabbing a new image.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/qBXzmzx\">9. Add Loading Indicator</a> by <a href=\"https://codepen.io/jh3y\">JHEY</a></p>\nThat‚Äôs it!\n<p>That‚Äôs how we can create a <code>FlippySnap</code> with React and GreenSock. It‚Äôs fun to make things that we may not create on a day-to-day basis. Demos like this can pose different challenges and can level up your problem-solving game.</p>\n<p>I took it a little further and added a slight parallax effect along with some audio. You can also configure the grid size! (Big grids affect performance though.)</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/QWMXgLb\">3D CSS Flippy Snaps v2 (React &amp;&amp; GSAP)</a> by <a href=\"https://codepen.io/jh3y\">JHEY</a></p>\n<p><em>It‚Äôs worth noting that this demo works best in Chromium-based browsers.</em></p>\n<p>So, where would you take it next? I‚Äôd like to see if I can recreate it with Three.js next. That would address the performance. üòÖ </p>\n<p>Stay Awesome!   ï‚Ä¢·¥•‚Ä¢ î</p>","author":"","siteTitle":"Articles on Smashing Magazine ‚Äî For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"f2e0179beabd5a94df26d33f66b565c6ad8454179c1379e7fa3fc8dcd7bb3979","category":"Tech"}