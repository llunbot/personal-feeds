{"title":"Testing HashiCorp Terraform","link":"https://www.hashicorp.com/blog/testing-hashicorp-terraform","date":1705410000000,"content":"<p>How do you know if you can run <code>terraform apply</code> to your infrastructure without negatively affecting critical business applications? You can run <code>terraform validate</code> and <code>terraform plan</code> to check your configuration, but will that be enough? Whether you’ve updated some HashiCorp Terraform configuration or a new version of a <a href=\"https://developer.hashicorp.com/terraform/tutorials/modules/module?utm_offer=ARTICLE_PAGE&amp;utm_source=WEBSITE&amp;utm_medium=WEB_BLOG\">module</a>, you want to catch errors quickly before you apply any changes to production infrastructure. </p>\n\n<p>In this post, I’ll discuss some testing strategies for HashiCorp Terraform configuration and modules so that you can <code>terraform apply</code> with greater confidence. As a HashiCorp Developer Advocate, I’ve compiled some advice to help Terraform users learn how infrastructure tests fit into their organization’s development practices, the differences in testing modules versus configuration, and approaches to manage the cost of testing.</p>\n\n<p>I included a few testing examples with <a href=\"https://developer.hashicorp.com/terraform/cli/test\">Terraform’s native testing framework</a>. No matter which tool you use, you can generalize the approaches outlined in this post to your overall infrastructure testing strategy. In addition to the testing tools and approaches in this post, you can find other perspectives and examples in the references at the end.</p>\n\n<h2>The testing pyramid</h2>\n\n<p>In theory, you might decide to align your infrastructure testing strategy with the test pyramid, which groups tests by type, scope, and granularity. The testing pyramid suggests that engineers write fewer tests in the categories at the top of the pyramid, and more tests in the categories at the bottom. Higher-level tests in the pyramid take more time to run and cost more due to the higher number of resources you have to configure and create.</p>\n<img src=\"https://www.datocms-assets.com/2885/1614617558-terraformtestingpyramid.png\" alt=\"Test\" /><p>In reality, your tests may not perfectly align with the pyramid shape. The pyramid offers a common framework to describe what scope a test can cover to verify configuration and infrastructure resources. I’ll start at the bottom of the pyramid with unit tests and work my way up the pyramid to end-to-end tests. Manual testing involves spot-checking infrastructure for functionality and can have a high cost in time and effort.</p>\n\n<h2>Linting and formatting</h2>\n\n<p>While not on the test pyramid, you often encounter tests to verify the hygiene of your Terraform configuration. Use <code>terraform fmt -check</code> and <code>terraform validate</code> to format and validate the correctness of your Terraform configuration.</p>\n\n<p>When you collaborate on Terraform, you may consider testing the Terraform configuration for a set of standards and best practices. Build or use a linting tool to analyze your Terraform configuration for specific best practices and patterns. For example, a linter can verify that your teammate defines a Terraform variable for an instance type instead of hard-coding the value.</p>\n\n<h2>Unit tests</h2>\n\n<p>At the bottom of the pyramid, unit tests verify individual resources and configurations for expected values. They should answer the question, “Does my configuration or plan contain the correct metadata?” Traditionally, unit tests should run independently, without external resources or API calls.</p>\n\n<p>For additional test coverage, you can use any programming language or testing tool to parse the Terraform configuration in HashiCorp Configuration Language (HCL) or JSON and check for statically defined parameters, such as provider attributes with defaults or hard-coded values. However, none of these tests verify correct variable interpolation, list iteration, or other configuration logic. As a result, I usually write additional unit tests to parse the plan representation instead of the Terraform configuration.</p>\n\n<p>Configuration parsing does not require active infrastructure resources or authentication to an infrastructure provider. However, unit tests against a Terraform plan require Terraform to authenticate to your infrastructure provider and make comparisons. These types of tests overlap with security testing done via <a href=\"https://www.hashicorp.com/blog/why-policy-as-code\">policy as code</a> because you check attributes in Terraform configuration for the correct values.</p>\n\n<p>For example, your Terraform module parses the IP address from an AWS instance’s <a href=\"https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/instance#private_dns\">DNS name</a> and outputs a list of IP addresses to a local file. At a glance, you don’t know if it correctly replaces the hyphens and retrieves the IP address information.</p>\n<pre><code>variable \"services\" {\n  type = map(object({\n    node = string\n    kind = string\n  }))\n  description = \"List of services and their metadata\"\n}\n\nvariable \"service_kind\" {\n  type        = string\n  description = \"Service kind to search\"\n}\n\nlocals {\n  ip_addresses = toset([\n    for service, service_data in var.services :\n    replace(replace(split(\".\", service_data.node)[0], \"ip-\", \"\"), \"-\", \".\") if service_data.kind == var.service_kind\n  ])\n}\n\nresource \"local_file\" \"ip_addresses\" {\n  content  = jsonencode(local.ip_addresses)\n  filename = \"./${var.service_kind}.hcl\"\n}</code></pre><p>You could pass an example set of services and run <code>terraform plan</code> to manually check that your module retrieves only the TCP services and outputs their IP addresses. However, as you or your team adds to this module, you may break the module’s ability to retrieve the correct services and IP addresses. Writing unit tests ensures that the logic of searching for services based on <code>kind</code> and retrieving their IP addresses remains functional throughout a module’s lifecycle.</p>\n\n<p>This example uses two sets of unit tests written in <code>terraform test</code> to check the logic generating the service’s IP addresses for each service kind. The first set of tests verify the file contents will have two IP addresses for TCP services, while the second set of tests check that the file contents will have one IP address for the HTTP service:</p>\n<pre><code>variables {\n  services = {\n    \"service_0\" = {\n      kind = \"tcp\"\n      node = \"ip-10-0-0-0\"\n    },\n    \"service_1\" = {\n      kind = \"http\"\n      node = \"ip-10-0-0-1\"\n    },\n    \"service_2\" = {\n      kind = \"tcp\"\n      node = \"ip-10-0-0-2\"\n    },\n  }\n}\n\nrun \"get_tcp_services\" {\n  variables {\n    service_kind = \"tcp\"\n  }\n\n  command = plan\n\n  assert {\n    condition     = jsondecode(local_file.ip_addresses.content) == [\"10.0.0.0\", \"10.0.0.2\"]\n    error_message = \"Parsed `tcp` services should return 2 IP addresses, 10.0.0.0 and 10.0.0.2\"\n  }\n\n  assert {\n    condition     = local_file.ip_addresses.filename == \"./tcp.hcl\"\n    error_message = \"Filename should include service kind `tcp`\"\n  }\n}\n\nrun \"get_http_services\" {\n  variables {\n    service_kind = \"http\"\n  }\n\n  command = plan\n\n  assert {\n    condition     = jsondecode(local_file.ip_addresses.content) == [\"10.0.0.1\"]\n    error_message = \"Parsed `http` services should return 1 IP address, 10.0.0.1\"\n  }\n\n  assert {\n    condition     = local_file.ip_addresses.filename == \"./http.hcl\"\n    error_message = \"Filename should include service kind `http`\"\n  }\n}</code></pre><p>I set some mock values for a set of services in the <code>services</code> variable. The tests include <code>command = plan</code> to check attributes in the Terraform plan without applying any changes. As a result, the unit tests do not create the local file defined in the module.</p>\n\n<p>The example demonstrates positive testing, where I test the input works as expected. Terraform’s testing framework also supports negative testing, where you might expect a validation to fail for an incorrect input. Use the <code><a href=\"https://developer.hashicorp.com/terraform/language/tests#expecting-failures\">expect_failures</a></code> attribute to capture the error.</p>\n\n<p>If you do not want to use the native testing framework in Terraform, you can use HashiCorp Sentinel, a programming language, or your configuration testing tool of choice to parse the plan representation in JSON and verify your Terraform logic. </p>\n\n<p>Besides testing attributes in the Terraform plan, unit tests can validate:</p>\n\n<ul>\n<li>Number of resources or attributes generated by <a href=\"https://developer.hashicorp.com/terraform/tutorials/configuration-language/for-each\"><code>for_each</code></a> or <a href=\"https://developer.hashicorp.com/terraform/tutorials/configuration-language/count\"><code>count</code></a></li>\n<li>Values generated by <a href=\"https://developer.hashicorp.com/terraform/language/expressions/for\"><code>for</code> expressions</a></li>\n<li>Values generated by <a href=\"https://developer.hashicorp.com/terraform/language/functions\">built-in functions</a></li>\n<li>Dependencies between modules</li>\n<li>Values associated with interpolated values</li>\n<li>Expected variables or outputs marked as sensitive</li>\n</ul>\n\n<p>If you wish to unit test infrastructure by simulating a <code>terraform apply</code> without creating resources, you can choose to use mocks. Some cloud service providers offer community tools that mock the APIs for their service offerings. Beware that not all mocks accurately reflect the behavior and configuration of their target API.</p>\n\n<p>Overall, unit tests run very quickly and provide rapid feedback. As an author of a Terraform module or configuration, you can use unit tests to communicate the expected values of configuration to other collaborators in your team and organization. Since unit tests run independently of infrastructure resources, they have a virtually zero cost to run frequently.</p>\n\n<h2>Contract tests</h2>\n\n<p>At the next level from the bottom of the pyramid, contract tests check that a configuration using a Terraform module passes properly formatted inputs. Contract tests answer the question, “Does the expected input to the module match what I think I should pass to it?”</p>\n\n<p>Contract tests ensure that the contract between a Terraform configuration’s expected inputs to a module and the module’s actual inputs has not been broken. Most contract testing in Terraform helps the module <em>consumer</em> by communicating how the author expects someone to use their module. If you expect someone to use your module in a specific way, use a combination of <a href=\"https://developer.hashicorp.com/terraform/language/expressions/custom-conditions#preconditions-and-postconditions\">input variable validations, preconditions, and postconditions</a> to validate the combination of inputs and surface the errors.</p>\n\n<p>For example, use a custom input variable validation rule to ensure that an AWS load balancer’s listener rule receives a valid integer range for its priority:</p>\n<pre><code>variable \"listener_rule_priority\" {\n type        = number\n default     = 1\n description = \"Priority of listener rule between 1 to 50000\"\n validation {\n   condition     = var.listener_rule_priority &gt; 0 &amp;&amp; var.listener_rule_priority &lt; 50000\n   error_message = \"The priority of listener_rule must be between 1 to 50000.\"\n }\n}</code></pre><p>As a part of input validation, you can use Terraform’s rich language syntax to validate variables with an <a href=\"https://developer.hashicorp.com/terraform/language/expressions/type-constraints#structural-types\">object structure</a> to enforce that the module receives the correct fields. This module example uses a map to represent a service object and its expected attributes:</p>\n<pre><code>variable \"services\" {\n  type = map(object({\n    node = string\n    kind = string\n  }))\n  description = \"List of services and their metadata\"\n}</code></pre><p>In addition to custom validation rules, you can use <a href=\"https://developer.hashicorp.com/terraform/language/expressions/custom-conditions#preconditions-and-postconditions\">preconditions and postconditions</a> to verify specific resource attributes defined by the module consumer. For example, you cannot use a validation rule to check if the address blocks overlap. Instead, use a precondition to verify that your IP addresses do not overlap with networks in HashiCorp Cloud Platform (HCP) and your AWS account:</p>\n<pre><code>resource \"hcp_hvn\" \"main\" {\n  hvn_id         = var.name\n  cloud_provider = \"aws\"\n  region         = local.hcp_region\n  cidr_block     = var.hcp_cidr_block\n\n  lifecycle {\n    precondition {\n      condition     = var.hcp_cidr_block != var.vpc_cidr_block\n      error_message = \"HCP HVN must not overlap with VPC CIDR block\"\n    }\n  }\n\n}</code></pre><p>Contract tests catch misconfigurations in modules before applying them to live infrastructure resources. You can use them to check for correct identifier formats, naming standards, attribute types (such as private or public networks), and value constraints such as character limits or password requirements.</p>\n\n<p>If you do not want to use custom conditions in Terraform, you can use HashiCorp Sentinel, a programming language, or your configuration testing tool of choice. Maintain these contract tests in the module repository and pull them into each Terraform configuration that uses the module using a CI framework. When someone references the module in their configuration and pushes a change to version control, the contract tests run against the plan representation before you apply.</p>\n\n<p>Unit and contract tests may require extra time and effort to build, but they allow you to catch configuration errors <em>before</em> running <code>terraform apply</code>. For larger, more complex configurations with many resources, you should not manually check individual parameters. Instead, use unit and contract tests to quickly automate the verification of important configurations and set a foundation for collaboration across teams and organizations. Lower-level tests communicate system knowledge and expectations to teams that need to maintain and update Terraform configuration. </p>\n\n<h2>Integration tests</h2>\n\n<p>With lower-level tests, you do not need to create external resources to run them, but the top half of the pyramid includes tests that require active infrastructure resources to run properly. Integration tests check that a configuration using a Terraform module passes properly formatted inputs. They answer the question, “Does this module or configuration create the resources successfully?” A <code>terraform apply</code> offers limited integration testing because it creates and configures resources while managing dependencies. You should write additional tests to check for configuration parameters on the active resource.</p>\n\n<p>In my example, I add a new <code>terraform test</code> to apply the configuration and create the file. Then, I verify that the file exists on my filesystem. The integration test creates the file using a <code>terraform apply</code> and removes the file after issuing a <code>terraform destroy</code>.</p>\n<pre><code>run \"check_file\" {\n  variables {\n    service_kind = \"tcp\"\n  }\n\n  command = apply\n\n  assert {\n    condition     = fileexists(\"${var.service_kind}.hcl\")\n    error_message = \"File `${var.service_kind}.hcl` does not exist\"\n  }\n\n}</code></pre><p>Should you verify every parameter that Terraform configures on a resource? You could, but it may not be the best use of your time and effort. Terraform providers include <a href=\"https://developer.hashicorp.com/terraform/plugin/framework/acctests\">acceptance tests</a> that resources properly create, update, and delete with the right configuration values. Instead, use integration tests to verify that Terraform outputs include the correct values or number of resources. They also test infrastructure configuration that can only be verified after a <code>terraform apply</code>, such as invalid configurations, nonconformant passwords, or results of <code>for_each</code> iteration.</p>\n\n<p>When choosing an integration testing framework outside of <code>terraform test</code>, consider the existing integrations and languages within your organization. Integration tests help you determine whether or not to update your module version and ensure they run without errors. </p>\n\n<p>Since you have to set up and tear down the resources, you will find that integration tests can take 15 minutes or more to complete, depending on the resource. As a result, implement as much unit and contract testing as possible to fail quickly on wrong configurations instead of waiting for resources to create and delete.</p>\n\n<h2>End-to-end tests</h2>\n\n<p>After you apply your Terraform changes to production, you need to know whether or not you’ve affected end-user functionality.  End-to-end tests answer the question, “Can someone use the infrastructure system successfully?”</p>\n\n<p>For example, application developers and operators should still be able to retrieve a secret from HashiCorp Vault after you upgrade the version. End-to-end tests can verify that changes did not break expected functionality. To check that you’ve upgraded Vault properly, you can create an example secret, retrieve the secret, and delete it from the cluster.</p>\n\n<p>I usually write an end-to-end test using a <a href=\"https://developer.hashicorp.com/terraform/language/checks\">Terraform check</a> to verify that any updates I make to a HashiCorp Cloud Platform (HCP) Vault cluster return a healthy, unsealed status:</p>\n<pre><code>check \"hcp_vault_status\" {\n\n data \"http\" \"vault_health\" {\n   url = \"${hcp_vault_cluster.main.vault_public_endpoint_url}/v1/sys/health\"\n }\n\n assert {\n   condition     = data.http.vault_health.status_code == 200 || data.http.vault_health.status_code == 473\n   error_message = \"${data.http.vault_health.url} returned an unhealthy status code\"\n }\n\n}</code></pre><p>Besides a <code>check</code> block, you can write end-to-end tests in any programming language or testing framework. This usually includes an API call to check an endpoint after creating infrastructure. End-to-end tests usually depend on an entire system, including networks, compute clusters, load balancers, and more. As a result, these tests usually run against long-lived development or production environments.</p>\n\n<h2>Testing Terraform modules</h2>\n\n<p>When you test Terraform modules, you want enough verification to ensure a new, stable release of the module for use across your organization. To ensure sufficient test coverage, write unit, contract, and integration tests for modules.</p>\n\n<p>A module delivery pipeline starts with a <code>terraform plan</code> and then runs unit tests (and if applicable, contract tests) to verify the expected Terraform resources and configurations. Then, run <code>terraform apply</code> and the integration tests to check that the module can still run without errors. After running integration tests, destroy the resources and release a new module version.</p>\n<img src=\"https://www.datocms-assets.com/2885/1705090874-module_testing.png\" alt=\"Pipeline\" /><p>The <a href=\"https://developer.hashicorp.com/terraform/cloud-docs/registry/test\">Terraform Cloud private registry</a> offers a branch-based publishing workflow that includes automated testing. If you use <code>terraform test</code> for your modules, the private registry automatically runs those tests before releasing a module.</p>\n\n<p>When testing modules, consider the cost and test coverage of module tests. Conduct module tests in a different project or account so that you can independently track the cost of your module testing and ensure module resources do not overwrite environments. On occasion, you can omit integration tests because of their high financial and time cost. Spinning up databases and clusters can take half an hour or more. When you’re constantly pushing changes, you might even create multiple test instances.</p>\n\n<p>To manage the cost, run integration tests after merging feature branches and select the minimum number of resources you need to test the module. If possible, avoid creating entire systems. Module testing applies mostly to immutable resources because of its create and delete sequence. The tests cannot accurately represent the end state of brownfield (existing) resources because they do not test updates. As a result, it provides confidence in the module’s successful usage but not necessarily in applying module updates to live infrastructure environments.</p>\n\n<h2>Testing Terraform configuration</h2>\n\n<p>Compared to modules, Terraform configuration applied to environments should include end-to-end tests to check for end-user functionality of infrastructure resources. Write unit, integration, and end-to-end tests for configuration of active environments. </p>\n\n<p>The unit tests do not need to cover the configuration in modules. Instead, focus on unit testing any configuration not associated with modules. Integration tests can check that changes successfully run in a long-lived development environment, and end-to-end tests verify the environment’s initial functionality.</p>\n\n<p>If you use feature branching, merge your changes and apply them to a production environment. In production, run end-to-end tests against the system to confirm system availability.</p>\n<img src=\"https://www.datocms-assets.com/2885/1705090944-configuration_testing.png\" alt=\"Pipeline\" /><p>Failed changes to active environments will affect critical business systems. In its ideal form, a long-running development environment that accurately mimics production can help you catch potential problems. From a practical standpoint, you may not always have a development environment that fully replicates a production environment because of cost concerns and the difficulty of replicating user traffic. As a result, you usually run a scaled-down version of production to save money.</p>\n\n<p>The difference between development and production will affect the outcome of your tests, so be aware of which tests may be more important for flagging errors or disruptive to run. Even if configuration tests have less accuracy in development, they can still catch a number of errors and help you practice applying and rolling back changes before production.</p>\n\n<h2>Conclusion</h2>\n\n<p>Depending on your system’s cost and complexity, you can apply a variety of testing strategies to Terraform modules and configuration. While you can write tests in your programming language or testing framework of choice, you can also use the testing frameworks and constructs built into Terraform for unit, contract, integration, and end-to-end testing.</p>\n\n<table>\n  <tr>\n   <td><strong>Test type</strong>\n   </td>\n   <td><strong>Use case</strong>\n   </td>\n   <td><strong>Terraform configuration</strong>\n   </td>\n  </tr>\n  <tr>\n   <td>Unit test\n   </td>\n   <td>Modules, configuration\n   </td>\n   <td><code><a href=\"https://developer.hashicorp.com/terraform/language/tests\">terraform test</a></code>\n   </td>\n  </tr>\n  <tr>\n   <td>Contract test\n   </td>\n   <td>Modules\n   </td>\n   <td><a href=\"https://developer.hashicorp.com/terraform/language/expressions/custom-conditions#input-variable-validation\">Input variable validation</a>\n<p>\n<a href=\"https://developer.hashicorp.com/terraform/language/expressions/custom-conditions#preconditions-and-postconditions\">Preconditions/postconditions</a>\n   </p></td>\n  </tr>\n  <tr>\n   <td>Integration test\n   </td>\n   <td>Modules, configuration\n   </td>\n   <td><code><a href=\"https://developer.hashicorp.com/terraform/language/tests\">terraform test</a></code>\n   </td>\n  </tr>\n  <tr>\n   <td>End-to-end test\n   </td>\n   <td>Configuration\n   </td>\n   <td><a href=\"https://developer.hashicorp.com/terraform/language/expressions/custom-conditions#checks-with-assertions\">Check blocks</a>\n   </td>\n  </tr>\n</table>\n\n<p>This post has explained the different types of tests and how you can apply them to catch errors in Terraform configurations and modules before production, and how to incorporate them into pipelines. Your Terraform testing strategy does not need to be a perfect test pyramid. At the very least, automate some tests to reduce the time you need to manually verify changes and check for errors before they reach production.</p>\n\n<p>Check out our tutorial on how to <a href=\"https://developer.hashicorp.com/terraform/tutorials/configuration-language/test\">Write Terraform tests</a> to learn about writing Terraform tests for unit and integration testing and running them in the Terraform Cloud private module registry. For more information on using checks, <a href=\"https://developer.hashicorp.com/terraform/tutorials/configuration-language/checks\">Use checks to validate infrastructure</a> offers a more in-depth example. If you want to learn about writing tests for security and policy, review our documentation on <a href=\"https://docs.hashicorp.com/sentinel/terraform\">Sentinel</a>.</p>\n","author":"Rosemary Wang","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"0dc93e4cb21121e8955f020b84856926064e957ce3beae4bba5d01928a7b68f0","category":"Tech"}