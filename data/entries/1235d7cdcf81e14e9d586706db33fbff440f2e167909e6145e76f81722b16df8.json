{"title":"Announcing Interop 2026","link":"https://webkit.org/blog/17818/announcing-interop-2026/","date":1770915659000,"content":"<p>Exciting news for web developers, designers, and browser enthusiasts alike — <a href=\"https://wpt.fyi/interop-2026\">Interop 2026</a> is here, continuing the mission of improving cross-browser interoperability. For the fifth year in a row, we are pleased to collaborate with <a href=\"https://web.dev/blog/interop-2026\">Google</a>, <a href=\"https://igalia.com/news/interop-2026.html\">Igalia</a>, <a href=\"https://blogs.windows.com/msedgedev/2026/02/12/microsoft-edge-and-interop-2026/\">Microsoft</a>, and <a href=\"https://hacks.mozilla.org/2026/02/launching-interop-2026/\">Mozilla</a> to make web technology more consistent and reliable across our browsers.</p>\n<h3><a name=\"introducing-interop-2026\"></a>Introducing Interop 2026</h3>\n<p>Making your website work in every browser can be a challenge, especially if browser engines have implemented the same web technology in slightly different ways. The Interop Project tackles this challenge by bringing the major browser engines together to improve the same set of features during the same year. Each feature is judged on whether or not it fully aligns with its official web standard — the formal technical specifications that define how each web technology should work. This helps accelerate progress toward a more reliable, consistent platform to build on.</p>\n<p>Safari has already implemented many of the features included in Interop 2026. In fact, we were the first browser to ship <code>contrast-color()</code>, Media pseudo-classes, <code>shape()</code>, and Scoped Custom Element Registries. Plus, we have support for Anchor Positioning, Style Queries, Custom Highlights, Scroll Snap, View Transitions and much more. We’re excited that these technologies are being included as focus areas in Interop 2026, ensuring they get implemented across all browsers and any remaining interoperability gaps are closed.</p>\n<p>We will also be focused on adding support for the following features: advanced <code>attr()</code>, the <code>getAllRecords()</code> method for IndexedDB, WebTransport, and the JavaScript Promise Integration API for Wasm. Together, these four areas make up 20% of the Interop 2026 score. They are exciting new features that solve real needs.</p>\n<h3><a name=\"focus-areas-for-2026\"></a>Focus Areas for 2026</h3>\n<p>The Interop Project measures interoperability through Web Platform Tests — automated tests that check whether browsers conform to web standards. Interop 2026 is ambitious, covering twenty focus areas. Fifteen are brand new. And five are carryovers from <a href=\"https://wpt.fyi/interop-2025\">Interop 2025</a>.</p>\n<ul>\n<li><a href=\"#anchor-positioning\">Anchor Positioning</a></li>\n<li><a href=\"#advanced-attr\">Advanced <code>attr()</code></a></li>\n<li><a href=\"#container-style-queries\">Container Style Queries</a></li>\n<li><a href=\"#contrast-color\"><code>contrast-color()</code></a></li>\n<li><a href=\"#custom-highlights\">Custom Highlights</a></li>\n<li><a href=\"#dialog-and-popover-additions\">Dialog and popover additions</a></li>\n<li><a href=\"#fetch-uploads-and-ranges\">Fetch Uploads and Ranges</a></li>\n<li><a href=\"#getallrecords-for-indexeddb\"><code>getAllRecords()</code> for IndexedDB</a></li>\n<li><a href=\"#jspi-for-wasm\">JSPI for Wasm</a></li>\n<li><a href=\"#media-pseudo-classes\">Media pseudo-classes</a></li>\n<li><a href=\"#navigation-api\">Navigation API</a></li>\n<li><a href=\"#scoped-custom-element-registries\">Scoped Custom Element Registries</a></li>\n<li><a href=\"#scroll-driven-animations\">Scroll-driven Animations</a></li>\n<li><a href=\"#scroll-snap\">Scroll Snap</a></li>\n<li><a href=\"#shape\"><code>shape()</code></a></li>\n<li><a href=\"#view-transitions\">View Transitions</a></li>\n<li><a href=\"#web-compat\">Web Compat</a></li>\n<li><a href=\"#webrtc\">WebRTC</a></li>\n<li><a href=\"#webtransport\">WebTransport</a></li>\n<li><a href=\"#css-zoom\">CSS Zoom</a></li>\n</ul>\n<h2><a name=\"anchor-positioning\"></a>Anchor positioning</h2>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Guides/Anchor_positioning\">Anchor positioning</a> is a carryover from Interop 2025, where significant progress was made to empower developers to position elements relative to each other. This year’s focus will be on clarifying the spec, resolving test issues, and increasing the reliability of this powerful layout feature.</p>\n<h2><a name=\"advanced-attr\"></a>Advanced attr()</h2>\n<p>The CSS <a href=\"https://developer.mozilla.org/docs/Web/CSS/attr\"><code>attr()</code></a> function lets you bridge the gap between structural data and visual presentation by pulling values directly from HTML attributes into your CSS, making styles more dynamic and context-aware without the overhead of JavaScript. While <code>attr()</code> has long been supported for the <code>content</code> property, advanced <code>attr()</code> extends it to work across all CSS properties with type conversion — letting you use HTML attribute values as colors, lengths, angles, and other data types. Now that security concerns have been worked through in the specification, browser makers are united in our excitement to ship this long-awaited capability with strong interoperability.</p>\n<h2><a name=\"container-style-queries\"></a>Container style queries</h2>\n<p>Style queries let you apply styles conditionally, based on the value of a custom property (aka, variable) as defined at a certain container. Similar to how Container size queries let your CSS respond to the size of the container, style queries let it respond to theme values, state flags, and other contextual data.</p>\n<pre><code><span>@container</span> <span>style</span>(<span>--theme</span>: <span>dark</span>) {\n  .<span>card</span> {\n    <span>background</span>: <span>#1a1a1a</span>;\n    <span>color</span>: <span>#ffffff</span>;\n  }\n}\n</code></pre>\n<p>Style queries started shipping in recent years, including in Safari 18.0. Interop 2026 will help ensure this powerful tool works consistently everywhere.</p>\n<h2><a name=\"contrast-color\"></a>contrast-color()</h2>\n<p>The <a href=\"https://developer.mozilla.org/docs/Web/CSS/color_value/contrast-color\"><code>contrast-color()</code></a> function in CSS returns a color — either black or white. It puts the burden on the browser to choose whichever has higher contrast with the color specified in the function.</p>\n<pre><code><span>.button</span> {\n  <span>background</span>: <span>var</span>(<span>--brand-color</span>);\n  <span>color</span>: <span>contrast-color</span>(<span>var</span>(<span>--brand-color</span>));\n}\n</code></pre>\n<p>By having the browser make the choice, you can architect your design system in a simpler fashion. You don’t need to manually define every color pairing. Safari and Firefox both shipped support in 2025, and now Interop 2026 will ensure this powerful function works consistently across all browsers.</p>\n<p>Note, <code>contrast-color()</code> does not magically solve all accessibility concerns. Read about all the details in <a href=\"https://webkit.org/blog/16929/contrast-color/\"><em>How to have the browser pick a contrasting color in CSS</em></a>.</p>\n<h2><a name=\"custom-highlights\"></a>Custom Highlights</h2>\n<p>The <a href=\"https://developer.mozilla.org/docs/Web/API/CSS_Custom_Highlight_API\">CSS Custom Highlight API</a> lets you style arbitrary text ranges without adding extra elements to the DOM. Using JavaScript, you create a highlight range, then style it with the pseudo-elements.</p>\n<p>The <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Selectors/::highlight\"><code>::highlight()</code></a> pseudo-element is perfect for highlighting in-page search results, customizing syntax highlighting in code editors, creating an app that allows collaborative editing with user cursors, or any situation where you need to visually mark text without changing the document structure. The <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Selectors/::target-text\"><code>::target-text</code></a> pseudo-element styles the text that’s scrolled to when a user taps a <a href=\"https://developer.mozilla.org/en-US/docs/Web/URI/Reference/Fragment/Text_fragments\">link with a text fragment</a>.</p>\n<p>With implementations progressing across browsers, Interop 2026 ensures these highlighting capabilities work consistently, giving you reliable tools for text-based interactions.</p>\n<h2><a name=\"dialog-and-popover-additions\"></a>Dialog and popover additions</h2>\n<p>The <a href=\"https://developer.mozilla.org/docs/Web/HTML/Element/dialog\"><code>&lt;dialog&gt;</code></a> element and <a href=\"https://developer.mozilla.org/docs/Web/API/Popover_API\">popover</a> attribute have transformed how developers build overlays on the web. Dialog was part of Interop 2022 and Popover was in Interop 2024. This year, three recent enhancements to these features make up this focus area for Interop 2026.</p>\n<p>The <code>closedby</code> attribute lets you control how users can dismiss dialogs:</p>\n<pre><code><span>&lt;<span>dialog</span> <span>closedby</span>=<span>\"any\"</span>&gt;</span>\n<span>&lt;!-- Can be closed by clicking outside or pressing Escape --&gt;</span>\n<span>&lt;/<span>dialog</span>&gt;</span>\n</code></pre>\n<p>The <code>popover=\"hint\"</code> attribute creates subordinate popovers that don’t dismiss other auto popovers — perfect for tooltips:</p>\n<pre><code><span>&lt;<span>div</span> <span>popover</span>=<span>\"hint\"</span> <span>id</span>=<span>\"tooltip\"</span>&gt;</span>\n  This tooltip won’t close the menu!\n<span>&lt;/<span>div</span>&gt;</span>\n</code></pre>\n<p>The <code>:open</code> pseudo-class matches elements with open states, working with <code>&lt;dialog&gt;</code>, <code>&lt;details&gt;</code>, and <code>&lt;select&gt;</code>:</p>\n<pre><code><span>dialog</span><span>:open</span> {\n  <span>animation</span>: <span>slideIn</span> <span>0.3s</span>;\n}\n</code></pre>\n<p>Together, these additions make building accessible, user-friendly UI overlays easier than ever.</p>\n<h2><a name=\"fetch-uploads-and-ranges\"></a>Fetch uploads and ranges</h2>\n<p>The <a href=\"https://developer.mozilla.org/docs/Web/API/Fetch_API\"><code>fetch()</code></a> method is getting three new powerful capabilities for handling uploads and partial content.</p>\n<p>ReadableStream request bodies enable true streaming uploads, letting you upload large files or real-time data without loading everything into memory first:</p>\n<pre><code><span>await</span> <span>fetch</span>(<span>'/upload'</span>, {\n  <span>method</span><span>:</span> <span>'POST'</span>,\n  <span>body</span><span>:</span> <span>readableStream</span>,\n  <span>duplex</span><span>:</span> <span>'half'</span>\n});\n</code></pre>\n<p>Enhanced <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FormData\">FormData</a> support improves multipart uploads and responses.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Range\">Range header</a> support allows partial content requests, essential for video streaming and resumable downloads:</p>\n<pre><code><span>fetch</span>(<span>'/video.mp4'</span>, {\n  <span>headers</span><span>:</span> { <span>'Range'</span><span>:</span> <span>'bytes=0-1023'</span> }\n});\n</code></pre>\n<p>These enhancements bring <code>fetch()</code> up to par with more specialized APIs, reducing the need for custom solutions.</p>\n<h2><a name=\"getallrecords-for-indexeddb\"></a>getAllRecords() for IndexedDB</h2>\n<p><a href=\"https://developer.mozilla.org/docs/Web/API/IndexedDB_API\">IndexedDB</a> is a low-level API that lets you store large amounts of structured data in the browser, including files and blobs. It’s been supported in browsers for <a href=\"https://caniuse.com/?search=indexdb\">many years</a>.</p>\n<p>Now, IndexedDB is getting a significant performance boost with the new <a href=\"https://developer.mozilla.org/docs/Web/API/IDBObjectStore/getAllRecords\"><code>getAllRecords()</code></a> methods for <code>IDBObjectStore</code> and <code>IDBIndex</code>. These methods allow you to retrieve records in batches and in reverse order:</p>\n<pre><code><span>const</span> <span>records</span> <span>=</span> <span>await</span> <span>objectStore</span>.<span>getAllRecords</span>({\n  <span>query</span><span>:</span> <span>IDBKeyRange</span>.<span>bound</span>(<span>'A'</span>, <span>'M'</span>),\n  <span>count</span><span>:</span> <span>100</span>,\n  <span>direction</span><span>:</span> <span>'prev'</span>\n});\n</code></pre>\n<p>It’s just this new method that’s being included in Interop 2026. The score only reports the percentage of <code>getAllRecords()</code> tests that are passing  — not all IndexDB tests.</p>\n<h2><a name=\"jspi-for-wasm\"></a>JSPI for Wasm</h2>\n<p><a href=\"https://webassembly.org/\">WebAssembly</a> has opened the door for running high-performance applications in the browser — games, productivity tools, scientific simulations, and more. But there’s been a fundamental mismatch. Many of these applications were originally written for environments where operations like file I/O or network requests are synchronous (blocking), while the web is fundamentally asynchronous.</p>\n<p>The <a href=\"https://v8.dev/blog/jspi\">JavaScript Promise Integration API (JSPI)</a> bridges this gap. It lets WebAssembly code that expects synchronous operations work smoothly with JavaScript’s Promise-based async APIs, without requiring you to rewrite the entire application. This means you can port existing C, C++, or Rust applications to the web more easily, unlocking a wider range of software that can run in the browser.</p>\n<p>Interop 2026 will ensure JSPI works consistently across browsers, making WebAssembly a more viable platform for complex applications.</p>\n<h2><a name=\"media-pseudo-classes\"></a>Media pseudo-classes</h2>\n<p>We’ve proposed media pseudo-classes for inclusion in the Interop Project for many years in a row. We are excited that it’s being included this year!</p>\n<p>Seven CSS pseudo-classes let you apply CSS based on the playback state of <code>&lt;audio&gt;</code> and <code>&lt;video&gt;</code> elements:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/docs/Web/CSS/:playing\"><code>:playing</code></a> — media is currently playing</li>\n<li><a href=\"https://developer.mozilla.org/docs/Web/CSS/:paused\"><code>:paused</code></a> — media is paused</li>\n<li><a href=\"https://developer.mozilla.org/docs/Web/CSS/:seeking\"><code>:seeking</code></a> — user is seeking to a new position</li>\n<li><a href=\"https://developer.mozilla.org/docs/Web/CSS/:buffering\"><code>:buffering</code></a> — media is buffering</li>\n<li><a href=\"https://developer.mozilla.org/docs/Web/CSS/:stalled\"><code>:stalled</code></a> — playback has stalled</li>\n<li><a href=\"https://developer.mozilla.org/docs/Web/CSS/:muted\"><code>:muted</code></a> — audio is muted</li>\n<li><a href=\"https://developer.mozilla.org/docs/Web/CSS/:volume-locked\"><code>:volume-locked</code></a> — volume cannot be changed</li>\n</ul>\n<p>These all shipped in Safari many years ago, but without support in any other browser, most developers don’t use them — or even know they exist. Instead developers need JavaScript to sync UI state with media playback state.</p>\n<p>It’s far simpler and more efficient to use media state pseudo-classes in CSS.</p>\n<pre><code><span>video</span><span>:buffering</span>::<span>after</span> {\n  <span>content</span>: <span>\"Loading...\"</span>;\n}\n<span>audio</span><span>:muted</span> {\n  <span>opacity</span>: <span>0.5</span>;\n}\n</code></pre>\n<p>They are especially powerful combined with <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Selectors/:has\"><code>:has()</code></a>, since it unlocks the ability to style anything on the page based on playback state, not just elements that are descendants of the media player.</p>\n<pre><code><span>article</span><span>:has</span>(<span>video</span><span>:playing</span>) {\n  <span>background-color</span>: <span>var</span>(<span>--backgroundColor</span>); \n  <span>color</span>: <span>contrast-color</span>(<span>var</span>(<span>--backgroundColor</span>));\n  <span>transition</span>: <span>background-color</span> <span>0.5s</span> <span>ease</span>;\n}\n</code></pre>\n<p>Learn more about the power of <code>:has()</code> in <em><a href=\"https://webkit.org/blog/13096/css-has-pseudo-class/\">Using :has() as a CSS Parent Selector and much more</a></em>.</p>\n<h2><a name=\"navigation-api\"></a>Navigation API</h2>\n<p>If you’ve built single-page applications, you may have experienced the pain of managing navigation state with <code>history.pushState()</code> and <code>popstate</code> events. <a href=\"https://developer.mozilla.org/docs/Web/API/Navigation_API\">Navigation API</a> gives you a cleaner, more powerful way to intercept and control navigation.</p>\n<p>This focus area is a continuation of Interop 2025, where significant progress was made to empower developers to initiate, intercept, and modify browser navigation actions. This year continues work on interoperability, to get the overall score up from the 92.3% test pass result during Interop 2025. Plus, there’s one new feature being added — the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/NavigationPrecommitController\"><code>precommitHandler</code></a> option. It lets you defer navigation until critical resources are ready, preventing jarring flashes of incomplete content.</p>\n<pre><code><span>navigation</span>.<span>addEventListener</span>(<span>'navigate'</span>, (<span>e</span>) <span>=</span><span>&gt;</span> {\n  <span>e</span>.<span>intercept</span>({\n    <span>async</span> <span>precommitHandler</span>() {\n      <span>// Load critical resources before commit\n</span>      <span>await</span> <span>loadCriticalData</span>();\n    },\n    <span>async</span> <span>handler</span>() {\n      <span>// Render the new view\n</span>      <span>renderPage</span>();\n    }\n  });\n});\n</code></pre>\n<p>Interop 2026 will ensure Navigation API works reliably across browsers, a solid foundation for web applications.</p>\n<h2><a name=\"scoped-custom-element-registries\"></a>Scoped custom element registries</h2>\n<p>Working with web components, you may have run into a frustrating limitation: the global <code>customElements</code> registry only allows one definition per tag name across your entire application. When two different libraries both define a <code>&lt;my-button&gt;</code> component, they conflict.</p>\n<p>The <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry\"><code>CustomElementRegistry()</code></a> constructor solves this by letting you create scoped registries. Different parts of your application — or different shadow roots — can have their own definitions for the same tag name.</p>\n<pre><code><span>const</span> <span>registry</span> <span>=</span> <span>new</span> <span>CustomElementRegistry</span>();\n<span>registry</span>.<span>define</span>(<span>'my-button'</span>, <span>MyButtonV2</span>);\n<span>shadowRoot</span>.<span>registry</span> <span>=</span> <span>registry</span>;\n</code></pre>\n<p>This is especially valuable for microfrontends, component libraries, and any situation where you’re integrating third-party web components.</p>\n<p>Safari 26.0 was the first <a href=\"https://caniuse.com/wf-scoped-custom-element-registries\">browser to ship</a> Scoped custom element registries. Inclusion in Interop 2026 will help ensure this capability works consistently across all browsers.</p>\n<h2><a name=\"scroll-driven-animations\"></a>Scroll-driven Animations</h2>\n<p><a href=\"https://developer.mozilla.org/docs/Web/CSS/CSS_scroll-driven_animations\">Scroll-driven animations</a> let you more easily create animations that respond to scroll position, now entirely in CSS. As a user scrolls, the animation progresses — no JavaScript needed. You can build scroll-triggered reveals, progress indicators, parallax effects, and interactive storytelling experiences.</p>\n<p>Define animations with standard CSS keyframes, then connect them to scroll using <code>animation-timeline</code>:</p>\n<pre><code><span>.reveal</span> {\n  <span>animation</span>: <span>fade-in</span> <span>linear</span> <span>forwards</span>;\n  <span>animation-timeline</span>: <span>view</span>();\n  <span>animation-range</span>: <span>entry</span> <span>0%</span> <span>entry</span> <span>100%</span>;\n}\n\n<span>@keyframes</span> <span>fade-in</span> {\n  <span>from</span> { <span>opacity</span>: <span>0</span>; }\n  <span>to</span> { <span>opacity</span>: <span>1</span>; }\n}\n</code></pre>\n<p>Use <code>view()</code> to trigger animations as elements enter and exit the viewport, or <code>scroll()</code> to tie animations to a scrolling container’s position. Learn much more in <a href=\"https://webkit.org/blog/17101/a-guide-to-scroll-driven-animations-with-just-css/\"><em>A guide to Scroll-driven Animations with just CSS</em></a><em>.</em></p>\n<p>We shipped support for scroll-driven animations in Safari 26.0. Interop 2026 will help ensure this feature works consistently across all browsers.</p>\n<h2><a name=\"scroll-snap\"></a>Scroll Snap</h2>\n<p><a href=\"https://developer.mozilla.org/docs/Web/CSS/CSS_scroll_snap\">CSS Scroll Snap</a> controls the panning and scrolling behavior within a scroll container, creating carousel-like experiences:</p>\n<pre><code><span>.carousel</span> {\n  <span>scroll-snap-type</span>: <span>x</span> <span>mandatory</span>;\n  <span>overflow-x</span>: <span>scroll</span>;\n}\n<span>.carousel</span> &gt; * {\n  <span>scroll-snap-align</span>: <span>center</span>;\n}\n</code></pre>\n<p>Scroll Snap has been <a href=\"https://caniuse.com/css-snappoints\">supported</a> in all modern browsers for many years. But like many of the older CSS specifications, multiple rounds of changes to the specification while early versions were already shipping in browsers created a deep lack of interoperability. With a far more mature web standard, it’s time to circle back and improve interoperability. This is the power of the Interop Project — focusing all the browser teams on a particular feature, and using automated tests to find inconsistencies and disagreements.</p>\n<h2><a name=\"shape\"></a>shape()</h2>\n<p>For years, when you wanted to create a complex clipping path to use with <code>clip-path</code> or <code>shape-outside</code> you’ve been limited to <code>polygon()</code>, which only supports straight lines, or SVG paths, which aren’t responsive to element size changes.</p>\n<p>Now, the <a href=\"https://developer.mozilla.org/docs/Web/CSS/basic-shape/shape\"><code>shape()</code></a> function lets you create complex shapes with path-like commands (<code>move</code>, <code>line</code>, <code>curve</code>). It gives you the best of both worlds — curves like SVG paths, but with percentage-based coordinates that adapt as elements resize.</p>\n<pre><code><span>.element</span> {\n  <span>clip-path</span>: <span>shape</span>(\n    <span>from</span> <span>0%</span> <span>0%</span>,\n    <span>line</span> <span>to</span> <span>100%</span> <span>0%</span>,\n    <span>line</span> <span>to</span> <span>100%</span> <span>100%</span>,\n    <span>curve</span> <span>to</span> <span>0%</span> <span>100%</span> <span>via</span> <span>50%</span> <span>150%</span>,\n    <span>close</span>\n  );\n}\n</code></pre>\n<p>We shipped support for the <code>shape()</code> function in Safari 18.4. And we look forward to Interop 2026 improving browser implementations so you can confidently use it to render of complex, responsive curves.</p>\n<h2><a name=\"view-transitions\"></a>View transitions</h2>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API\">View Transitions</a> was a focus area in Interop 2025, narrowly defined to include <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API\">same-document view transitions</a> and <code>view-transition-class</code>. These features allow for smooth, animated transitions between UI states within a single page, as well as flexible control over styling those transitions.</p>\n<p>While Safari finished Interop 2025 with a score of 99.2% for view transitions, the overall interoperability score is at 90.8% — so the group decided to continue the effort, carrying over the tests from 2025.</p>\n<p>For Interop 2026, the focus area expands to also include <a href=\"https://webkit.org/blog/16967/two-lines-of-cross-document-view-transitions-code-you-can-use-on-every-website-today/\">cross-document view transitions</a>. This allows you to create smooth, animated transitions in the moments between pages as users navigate your site, rather than an abrupt jump when new page loads. Cross-document view transitions shipped in Safari 18.2. Learn more about it in <a href=\"https://webkit.org/blog/16967/two-lines-of-cross-document-view-transitions-code-you-can-use-on-every-website-today/\"><em>Two lines of Cross-Document View Transitions code you can use on every website today</em></a>.</p>\n<h2><a name=\"web-compat\"></a>Web Compat</h2>\n<p>Web compatibility refers to whether or not a real world website works correctly in a particular browser. When a site works in one browser, but not another — that’s a “compat” problem. This focus area is made up of a small collection of Web Platform Tests selected because the fact they fail in some browsers causes real websites to not work <em>in other browsers</em> — thus creating problems for both web developers and users.</p>\n<p>Each time Web Compat has been a focus area as part of the Interop Project, it’s targeted a different set of compat challenges. This year, Interop 2026’s web compatibility work includes:</p>\n<ul>\n<li><a href=\"https://tc39.es/ecma262/#cyclic-module-record\">ESM module loading</a>, ensuring cyclic module records and multiple top-level awaits work consistently.</li>\n<li><a href=\"https://html.spec.whatwg.org/#event-loop-processing-model\">Timing of scroll events relative to animation events</a>, used to make sure scroll and animation events fire in a predictable, interoperable order.</li>\n<li>Support for <a href=\"https://developer.mozilla.org/docs/Web/CSS/user-select\"><code>user-select</code></a>, rather than just <code>-webkit-user-select</code>. It controls whether users can select text. </li>\n</ul>\n<h2><a name=\"webrtc\"></a>WebRTC</h2>\n<p><a href=\"https://developer.mozilla.org/docs/Web/API/WebRTC_API\">WebRTC</a> (Web Real-Time Communication) enables real-time audio, video, and data communication directly between browsers, without requiring plugins or intermediate servers. You can build video conferencing apps, live streaming platforms, peer-to-peer file sharing, and collaborative tools.</p>\n<p>Having reached a 91.6% pass rate, WebRTC continues as a focus area in 2026, building on the progress made during Interop 2025. We’re looking forward to fixing the long tail of interop issues of the main spec for WebRTC.</p>\n<h2><a name=\"webtransport\"></a>WebTransport</h2>\n<p><a href=\"https://developer.mozilla.org/docs/Web/API/WebTransport_API\">WebTransport</a> provides a modern way to transmit data between client and server using the HTTP/3 protocol. It gives you low-latency bidirectional communication with multiple streams over a single connection. You get both unreliable datagram support (like UDP) for speed and reliable stream support (like TCP) for guaranteed delivery.</p>\n<pre><code><span>const</span> <span>transport</span> <span>=</span> <span>new</span> <span>WebTransport</span>(<span>'https://example.com/endpoint'</span>);\n<span>await</span> <span>transport</span>.<span>ready</span>;\n<span>const</span> <span>stream</span> <span>=</span> <span>await</span> <span>transport</span>.<span>createBidirectionalStream</span>();\n<span>// Stream data efficiently\n</span></code></pre>\n<p>WebTransport is ideal for gaming, real-time collaboration tools, and applications where you need more control than WebSocket provides but don’t want to manage WebRTC’s complexity. Being part of Interop 2026 ensures WebTransport works consistently across all browsers, making it a reliable choice for real-time data transmission.</p>\n<h2><a name=\"css-zoom\"></a>CSS Zoom</h2>\n<p>The <a href=\"https://developer.mozilla.org/docs/Web/CSS/zoom\">CSS <code>zoom</code></a> property scales an element and its contents, affecting layout and making the element take up more (or less) space. Unlike <code>transform: scale()</code>, which is purely visual, <code>zoom</code> changes how the element participates in layout.</p>\n<pre><code><span>.card</span> {\n  <span>zoom</span>: <span>1.5</span>; <span>/* Element is 150% larger and takes up more space */</span>\n}\n</code></pre>\n<p>While <code>zoom</code> was supported in browsers for years as a non-standard property, it’s been plagued by inconsistencies in edge cases and how it interacts with other layout features. Now that it’s standardized, CSS zoom returns as a focus area in Interop 2026, continuing from 2025.</p>\n<h2><a name=\"investigation-efforts-a-look-ahead\"></a>Investigation Efforts: A Look Ahead</h2>\n<p>In addition to the focus areas, the Interop Project includes four investigation areas. These are projects where teams gather to assess the current state of testing infrastructure and sort through issues that are blocking progress.</p>\n<h3><a name=\"accessibility-testing\"></a>Accessibility testing</h3>\n<p>Continuing from previous years, the Accessibility Testing investigation aims to work towards generating consistent accessibility trees across browsers. This effort will improve the WPT testing infrastructure for accessibility on top of the foundation from Interop 2024. This work ensures that accessibility features are reliable and consistent, helping developers create more inclusive web experiences.</p>\n<h3><a name=\"jpeg-xl\"></a>JPEG XL</h3>\n<p><a href=\"https://jpegxl.info/\">JPEG XL</a> is a next-generation raster graphics format that supports animation, alpha transparency, and lossy as well as lossless compression. We shipped support for it in Safari 17.0. This investigation will focus on making the feature properly testable by developing comprehensive test suites, opening up the possibility that JPEG XL could be a focus area in the future.</p>\n<h3><a name=\"mobile-testing\"></a>Mobile testing</h3>\n<p>The Mobile Testing investigation continues work started in 2025. This year, we will focus on improving infrastructure for mobile-specific features like dynamic viewport changes which are crucial for building responsive mobile web experience that billions of users rely on every day.</p>\n<h3><a name=\"webvtt\"></a>WebVTT</h3>\n<p>Continuing from 2025, the WebVTT investigation addresses a critical challenge facing the web platform. Developers cite WebVTT’s inconsistent behavior across browsers as a major reason for choosing other subtitling and captioning solutions. Our investment in WebVTT last year primarily consisted of validating and fixing the existing test suite, as well as making any necessary spec changes along the way.  We are excited to continue that effort this year to ensure synchronized text tracks and closed captioning work seamlessly across the web.</p>\n<h2><a name=\"a-more-interoperable-web\"></a>A more interoperable web</h2>\n<p>Interop 2026 brings together twenty focus areas that matter to you as a web developer. Some, like <code>attr()</code> and <code>contrast-color()</code>, give you more flexible ways to architect your CSS. Others, like Scroll-Driven Animations and View Transitions, let you create smoother, more engaging experiences without reaching for JavaScript. Features like WebTransport and the Navigation API give you more powerful tools for building modern web applications.</p>\n<p>Just as important are the focus areas working to fix long-standing inconsistencies — ensuring Scroll Snap works reliably, bringing all browsers up to speed on <code>shape()</code>, and solving real-world compatibility problems that have been frustrating developers and breaking sites.</p>\n<p>The WebKit team is committed to making these features work consistently across all browsers. Whether you’re building a design system, a single-page application, a video streaming platform, or anything in between, Interop 2026 is working to give you a more reliable foundation to build on.</p>\n<p>Here’s to another year of making the web better, together!</p>","author":"","siteTitle":"Blog – WebKit","siteHash":"7f8dbea0b8f53db2e11a2faa08c6dca9954c01638d09a2ce585b77a60d10f7a1","entryHash":"1235d7cdcf81e14e9d586706db33fbff440f2e167909e6145e76f81722b16df8","category":"Tech"}