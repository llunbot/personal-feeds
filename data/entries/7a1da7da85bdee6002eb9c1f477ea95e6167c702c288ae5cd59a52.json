{"title":"Declarative Shadow DOM","link":"https://webkit.org/blog/13851/declarative-shadow-dom/","date":1676311829000,"content":"<p>We’re pleased to announce that support for the declarative shadow DOM API has been added and enabled by default in <a href=\"https://webkit.org/blog/13703/release-notes-for-safari-technology-preview-162/\">Safari Technology Preview 162</a>. To recap, shadow DOM is a part of Web Components, a set of specifications that were initially proposed by Google to enable the creation of reusable widgets and components on the web. Since then these specifications have been integrated into the DOM and HTML standards. <a href=\"https://webkit.org/blog/4096/introducing-shadow-dom-api/\">Shadow DOM</a>, in particular, provides a lightweight encapsulation for DOM trees by allowing a creation of a parallel tree on an element called a “shadow tree” that replaces the rendering of the element without modifying its own DOM tree.</p>\n<p>Up until this point, creating a shadow tree on an element required calling <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/attachShadow\"><code>attachShadow()</code></a> on the element in JavaScript. This meant that this feature was not available when JavaScript is disabled such as in email clients, and it required care to hide the content supposed to be in a shadow tree until relevant scripts are loaded to avoid flush of contents. In addition, many modern websites and web-based applications deploy a technique called “<a href=\"https://en.wikipedia.org/wiki/Server-side_scripting#Server-side_rendering\">server-side rendering</a>” whereby programs running on a web server generate HTML markup with the initial content for web browsers to consume, instead of fetching content over the network once scripts are loaded. This helps reducing page load time and also improves <a href=\"https://en.wikipedia.org/wiki/Search_engine_optimization\">SEO</a> because the page content is readily available for search engine crawlers to consume. Many server-side-rendering technologies try to eliminate the need for JavaScript for the initial rendering to reduce the initial paint latency and progressively enhance the content with interactivity as scripts and related metadata are loaded. This was, unfortunately, not possible when using shadow DOM because of the aforementioned requirement to use <code>attachShadow()</code>.</p>\n<p>Declarative shadow DOM addresses these use cases by providing a mechanism to include shadow DOM content in HTML. In particular, specifying a <code>shadowrootmode</code> content attribute on a <code>template</code> element tells web browsers that the content inside of this <code>template</code> element should be put into a shadow tree attached to its parent element. For example, in the following example, the <code>template</code> element with <code>shadowrootmode</code> will attach a shadow root on <code>some-component</code> element with a text node containing “hello, world.” as its sole child node.</p>\n<pre><code><span>&lt;<span>some-component</span>&gt;</span>\n    <span>&lt;<span>template</span> <span>shadowrootmode</span>=<span>\"closed\"</span>&gt;</span>hello, world.<span>&lt;/<span>template</span>&gt;</span>\n<span>&lt;/<span>some-component</span>&gt;</span>\n</code></pre>\n<p>When scripts are loaded and ready to make this content interactive, the shadow root can be accessed via <code>ElementInternals</code> as follows:</p>\n<pre><code><span>customElements</span>.<span>define</span>(<span>'some-component'</span>, <span>class</span> <span>SomeComponent</span> <span>extends</span> <span>HTMLElement</span> {\n    #<span>internals</span>;\n    <span>constructor</span>() {\n        <span>super</span>();\n        <span>this</span>.#<span>internals</span> <span>=</span> <span>this</span>.<span>attachInternals</span>();\n\n        <span>// This will log \"hello, world.\"\n</span>        <span>console</span>.<span>log</span>(<span>this</span>.#<span>internals</span>.<span>shadowRoot</span>.<span>textContent</span>.<span>trim</span>());\n    }\n});\n</code></pre>\n<p>We designed this API with backwards compatibility in mind. For example, calling <code>attachShadow()</code> on an element with a declarative shadow DOM returns the declaratively attached shadow root with all its children removed instead of failing by throwing an exception. It means that adopting declarative shadow DOM is backwards compatible with existing JavaScript which relies on <code>attachShadow()</code> to create shadow roots. Note that none of the JavaScript parser APIs (such as <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/DOMParser\"><code>DOMParser</code></a> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML\"><code>innerHTML</code></a>) support declarative shadow DOM by default to avoid creating new cross-site scripting vulnerabilities in existing websites that accepts arbitrary template content (since <code>script</code> elements in such content had been previously inert and would not run).</p>\n<p>In addition, we’re introducing the ability to clone shadow roots. Until now, <code>ShadowRoot</code> and its descendant nodes could not be cloned by <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Node/cloneNode\"><code>cloneNode()</code></a> or <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Document/importNode\"><code>importNode()</code></a>. <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/attachShadow\"><code>attachShadow()</code></a> now takes <code>cloneable</code> flag as an option. When this flag is set to true, existing JavaScript API such as <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Node/cloneNode\"><code>cloneNode()</code></a> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Document/importNode\"><code>importNode()</code></a> will clone <code>ShadowRoot</code> when cloning its shadow host. Declarative shadow DOM automatically sets this flag to true so that declarative shadow DOM which appears inside other <code>template</code> elements can be cloned along with its host. In the following example, the outer template element contains an instance of <code>some-component</code> element and its shadow tree content is serialized using declarative shadow DOM. Cloning <code>template1.content</code> with <code>document.importNode(template1.content, true)</code> will clone <code>some-component</code> as well as its (declaratively defined) shadow tree.</p>\n<pre><code><span>&lt;<span>template</span> <span>id</span>=<span>\"template1\"</span>&gt;</span>\n    <span>&lt;<span>some-component</span>&gt;</span>\n        <span>&lt;<span>template</span> <span>shadowrootmode</span>=<span>\"closed\"</span>&gt;</span>hello, world.<span>&lt;/<span>template</span>&gt;</span>\n    <span>&lt;/<span>some-component</span>&gt;</span>\n<span>&lt;/<span>template</span>&gt;</span>\n</code></pre>\n<p>In summary, declarative shadow DOM introduces an exciting new way of defining a shadow tree in HTML, which will be useful for server-side rendering of Web Components as well as in context where JavaScript is disabled such as email clients. This has been a highly requested feature with lots of discussions among browser vendors. We’re happy to report its introduction in <a href=\"https://webkit.org/blog/13703/release-notes-for-safari-technology-preview-162/\">Safari Technology Preview 162</a>.</p>","author":"","siteTitle":"Blog – WebKit","siteHash":"f53db2e11a2faa08c6dca9954c01638d09a2ce585b77a60d10f7a1","entryHash":"7a1da7da85bdee6002eb9c1f477ea95e6167c702c288ae5cd59a52","category":"Tech"}