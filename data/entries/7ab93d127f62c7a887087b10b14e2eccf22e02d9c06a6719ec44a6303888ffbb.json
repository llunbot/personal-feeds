{"title":"Integrating Image-To-Text And Text-To-Speech Models (Part 2)","link":"https://smashingmagazine.com/2024/08/integrating-image-to-text-and-text-to-speech-models-part2/","date":1725008400000,"content":"<p><a href=\"https://www.smashingmagazine.com/2024/07/integrating-image-to-text-and-text-to-speech-models-part1/\">In Part 1</a> of this brief two-part series, we developed an application that turns images into audio descriptions using vision-language and text-to-speech models. We combined an image-to-text that analyses and understands images, generating description, with a text-to-speech model to create an audio description, helping people with sight challenges. We also discussed how to choose the right model to fit your needs.</p>\n<p>Now, we are taking things a step further. Instead of just providing audio descriptions, we are building that can have <strong>interactive conversations</strong> about images or videos. This is known as <strong>Conversational AI</strong> — a technology that lets users talk to systems much like chatbots, virtual assistants, or agents.</p>\n<p>While the first iteration of the app was great, the output still lacked some details. For example, if you upload an image of a dog, the description might be something like “a dog sitting on a rock in front of a pool,” and the app might produce something close but miss additional details such as the dog’s breed, the time of the day, or location.</p>\n<p><img src=\"https://files.smashing.media/articles/integrating-image-to-text-and-text-to-speech-models-part2/1-app-interface.png\" /></p>\n<p>The aim here is simply to build <strong>a more advanced version of the previously built app</strong> so that it not only describes images but also provides more in-depth information and engages users in meaningful conversations about them. </p>\n<p>We’ll use <a href=\"https://llava-vl.github.io\">LLaVA</a>, a model that combines understanding images and conversational capabilities. After building our tool, we’ll explore multimodal models that can handle images, videos, text, audio, and more, all at once to give you even more options and easiness for your applications.</p>\nVisual Instruction Tuning and LLaVA\n<p>We are going to look at visual instruction tuning and the multimodal capabilities of LLaVA. We’ll first explore how visual instruction tuning can enhance the large language models to understand and follow instructions that include visual information. After that, we’ll dive into LLaVA, which brings its own set of tools for image and video processing.</p>\n<h3>Visual Instruction Tuning</h3>\n<p>Visual instruction tuning is a technique that helps large language models (LLMs) understand and follow instructions based on visual inputs. This approach connects language and vision, enabling AI systems to understand and respond to human instructions that involve both text and images. For example, Visual IT enables a model to describe an image or answer questions about a scene in a photograph. This fine-tuning method makes the model more capable of handling these complex interactions effectively. </p>\n<p>There’s a new training approach called <a href=\"https://llavar.github.io/\"><strong>LLaVAR</strong></a> that has been developed, and you can think of it as a tool for handling tasks related to PDFs, invoices, and text-heavy images. It’s pretty exciting, but we won’t dive into that since it is outside the scope of the app we’re making.</p>\n<h3>Examples of Visual Instruction Tuning Datasets</h3>\n<p>To build good models, you need good data — rubbish in, rubbish out. So, here are two datasets that you might want to use to train or evaluate your multimodal models. Of course, you can always add your own datasets to the two I’m going to mention. </p>\n<p><a href=\"https://huggingface.co/datasets/Vision-CAIR/cc_sbu_align?row=0\"><strong>Vision-CAIR</strong></a></p>\n<ul>\n<li><strong>Instruction datasets</strong>: English;</li>\n<li><strong>Multi-task</strong>: Datasets containing multiple tasks;</li>\n<li><strong>Mixed dataset</strong>: Contains both human and machine-generated data.</li>\n</ul>\n<p><img src=\"https://files.smashing.media/articles/integrating-image-to-text-and-text-to-speech-models-part2/2-vision-cair.png\" /></p>\n<p>Vision-CAIR provides a high-quality, well-aligned image-text dataset created using conversations between two bots. This dataset was initially introduced in a paper titled “<a href=\"https://arxiv.org/abs/2304.10592\">MiniGPT-4: Enhancing Vision-Language Understanding with Advanced Large Language Models</a>,” and it provides more detailed image descriptions and can be used with predefined instruction templates for image-instruction-answer fine-tuning.</p>\n<p><img src=\"https://files.smashing.media/articles/integrating-image-to-text-and-text-to-speech-models-part2/3-llava-details-page.png\" /></p>\n<p>There are more multimodal datasets out there, but these two should help you get started if you want to fine-tune your model.</p>\nLet’s Take a Closer Look At LLaVA\n<p>LLaVA (which stands for Large Language and Vision Assistant) is a groundbreaking multimodal model developed by researchers from the University of Wisconsin, Microsoft Research, and Columbia University. The researchers aimed to create a powerful, open-source model that could compete with the best in the field, just like GPT-4, Claude 3, or Gemini, to name a few. For developers like you and me, its open nature is a huge benefit, allowing for easy fine-tuning and integration.</p>\n<p>One of LLaVA’s standout features is its <strong>ability to understand and respond to complex visual information</strong>, even with unfamiliar images and instructions. This is exactly what we need for our tool, as it goes beyond simple image descriptions to engage in meaningful conversations about the content. </p>\n<h3>Architecture</h3>\n<p><img src=\"https://files.smashing.media/articles/integrating-image-to-text-and-text-to-speech-models-part2/4-dataset-interacts-large-language-model.png\" /></p>\n<p>LLaVA’s strength lies in its <strong>smart use of existing models</strong>. Instead of starting from scratch, the researchers used two key models:</p>\n<ul>\n<li><a href=\"https://huggingface.co/laion/CLIP-ViT-L-14-DataComp.XL-s13B-b90K\"><strong>CLIP VIT-L/14</strong></a><br />This is an advanced version of the CLIP (Contrastive Language–Image Pre-training) model developed by OpenAI. CLIP learns visual concepts from natural language descriptions. It can handle any visual classification task by simply being given the names of the visual categories, similar to the “zero-shot” capabilities of GPT-2 and GPT-3.</li>\n<li><a href=\"https://huggingface.co/lmsys/vicuna-13b-v1.3\"><strong>Vicuna</strong></a><br />This is an open-source chatbot trained by fine-tuning <a href=\"https://arxiv.org/abs/2302.13971\">LLaMA</a> on 70,000 user-shared conversations collected from <a href=\"https://sharegpt.com\">ShareGPT</a>. Training Vicuna-13B costs around $300, and it performs exceptionally well, even when compared to other models like <a href=\"https://crfm.stanford.edu/2023/03/13/alpaca.html\">Alpaca</a>.</li>\n</ul>\n<p><img src=\"https://files.smashing.media/articles/integrating-image-to-text-and-text-to-speech-models-part2/5-answers-alpaca-vicuna.png\" /></p>\n<p>These components make LLaVA highly effective by combining state-of-the-art visual and language understanding capabilities into a single powerful model, perfectly suited for applications requiring both visual and conversational AI. </p>\n<h3>Training</h3>\n<p>LLaVA’s training process involves two important stages, which together enhance its ability to understand user instructions, interpret visual and language content, and provide accurate responses. Let’s detail what happens in these two stages:</p>\n<ol>\n<li><strong>Pre-training for Feature Alignment</strong><br />LLaVA ensures that its visual and language features are aligned. The goal here is to update the projection matrix, which acts as a bridge between the CLIP visual encoder and the Vicuna language model. This is done using a subset of the CC3M dataset, allowing the model to map input images and text to the same space. This step ensures that the language model can effectively understand the context from both visual and textual inputs.</li>\n<li><strong>End-to-End Fine-Tuning</strong><br />The entire model undergoes fine-tuning. While the visual encoder’s weights remain fixed, the projection layer and the language model are adjusted. </li>\n</ol>\n<p>The second stage is tailored to specific application scenarios:</p>\n<ul>\n<li><strong>Instructions-Based Fine-Tuning</strong><br />For general applications, the model is fine-tuned on a dataset designed for following instructions that involve both visual and textual inputs, making the model versatile for everyday tasks.</li>\n<li><strong>Scientific reasoning</strong><br />For more specialized applications, particularly in science, the model is fine-tuned on data that requires complex reasoning, helping the model excel at answering detailed scientific questions.</li>\n</ul>\n<p>Now that we’re keen on what LLaVA is and the role it plays in our applications, let’s turn our attention to the next component we need for our work, Whisper.</p>\nUsing Whisper For Text-To-Speech\n<p>In this chapter, we’ll check out Whisper, a great model for turning text into speech. Whisper is <strong>accurate</strong> and <strong>easy to use</strong>, making it perfect for adding natural-sounding voice responses to our app. We’ve used Whisper in a different article, but here, we’re going to use a new version — <strong>large v3</strong>. This updated version of the model offers even better performance and speed.</p>\n<h3>Whisper large-v3</h3>\n<p>Whisper was developed by OpenAI, which is the same folks behind ChatGPT. Whisper is a pre-trained model for automatic speech recognition (ASR) and speech translation. The original Whisper was trained on 680,000 hours of labeled data.</p>\n<p>Now, what’s different with Whisper large-v3 compared to other models? In my experience, it comes down to the following:</p>\n<ul>\n<li><strong>Better inputs</strong><br />Whisper large-v3 uses 128 Mel frequency bins instead of 80. Think of Mel frequency bins as a way to break down audio into manageable chunks for the model to process. More bins mean finer detail, which helps the model better understand the audio.</li>\n<li><strong>More training</strong><br />This specific Whisper version was trained on 1 million hours of weakly labeled audio and 4 million hours of pseudo-labeled audio that was collected from Whisper large-v2. From there, the model was trained for 2.0 epochs over this mix.</li>\n</ul>\n<p>Whisper models come in different sizes, from tiny to large. Here’s a table comparing the differences and similarities:</p>\n<table>\n    <thead>\n        <tr>\n            <th>Size</th>\n            <th>Parameters</th>\n      <th>English-only</th>\n      <th>Multilingual</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>tiny</td>\n            <td>39 M</td>\n      <td>✅</td>\n      <td>✅</td>\n        </tr>\n        <tr>\n            <td>base</td>\n            <td>74 M</td>\n      <td>✅</td>\n      <td>✅</td>\n        </tr>\n        <tr>\n            <td>small</td>\n            <td>244 M</td>\n      <td>✅</td>\n      <td>✅</td>\n        </tr>\n        <tr>\n            <td>medium</td>\n            <td>769 M</td>\n      <td>✅</td>\n      <td>✅</td>\n        </tr>\n        <tr>\n            <td>large</td>\n            <td>1550 M</td>\n      <td>❌</td>\n      <td>✅</td>\n        </tr>\n    \n        <tr>\n            <td>large-v2</td>\n            <td>1550 M</td>\n      <td>❌</td>\n      <td>✅</td>\n        </tr>\n  \n        <tr>\n            <td>large-v3</td>\n            <td>1550 M</td>\n      <td>❌</td>\n      <td>✅</td>\n        </tr>\n    </tbody>\n</table>\n\n\n\nIntegrating LLaVA With Our App\n<p>Alright, so we’re going with LLaVA for image inputs, and this time, we’re adding video inputs, too. This means the app can handle both images and videos, making it more versatile.</p>\n<p>We’re also keeping the speech feature so you can hear the assistant’s replies, which makes the interaction even more engaging. How cool is that?</p>\n<p>For this, we’ll use Whisper. We’ll stick with the Gradio framework for the app’s visual layout and user interface. You can, of course, always swap in other models or frameworks — the main goal is to get a working prototype.</p>\n<h3>Installing and Importing the Libraries</h3>\n<p>We will start by installing and importing all the required libraries. This includes the transformers libraries for loading the LLaVA and Whisper models, <code>bitsandbytes</code> for quantization, <code>gtts</code>, and <code>moviepy</code> to help in processing video files, including frame extraction.</p>\n<pre><code>#python\n!pip install -q -U transformers==4.37.2\n!pip install -q bitsandbytes==0.41.3 accelerate==0.25.0\n!pip install -q git+https://github.com/openai/whisper.git\n!pip install -q gradio\n!pip install -q gTTS\n!pip install -q moviepy\n</code></pre>\n\n<p>With these installed, we now need to import these libraries into our environment so we can use them. We’ll use <a href=\"https://colab.research.google.com/#\"><code>colab</code></a> for that:</p>\n<pre><code>#python\nimport torch\nfrom transformers import BitsAndBytesConfig, pipeline\nimport whisper\nimport gradio as gr\nfrom gtts import gTTS\nfrom PIL import Image\nimport re\nimport os\nimport datetime\nimport locale\nimport numpy as np\nimport nltk\nimport moviepy.editor as mp\n\nnltk.download('punkt')\nfrom nltk import sent_tokenize\n\n# Set up locale\nos.environ[\"LANG\"] = \"en_US.UTF-8\"\nos.environ[\"LC_ALL\"] = \"en_US.UTF-8\"\nlocale.setlocale(locale.LC_ALL, 'en_US.UTF-8')\n</code></pre>\n\n<h3>Configuring Quantization and Loading the Models</h3>\n<p>Now, let’s set up a 4-bit quantization to make the LLaVA model more efficient in terms of performance and memory usage.</p>\n<pre><code>#python\n\n# Configuration for quantization\nquantization_config = BitsAndBytesConfig(\n  load_in_4bit=True,\n  bnb_4bit_compute_dtype=torch.float16\n)\n\n# Load the image-to-text model\nmodel_id = \"llava-hf/llava-1.5-7b-hf\"\npipe = pipeline(\"image-to-text\",\n  model=model_id,\n  model_kwargs={\"quantization_config\": quantization_config})\n\n# Load the whisper model\nDEVICE = \"cuda\" if torch.cuda.is_available() else \"cpu\"\nmodel = whisper.load_model(\"large-v3\", device=DEVICE)\n</code></pre>\n\n<p>In this code, we’ve configured the quantization to four bits, which reduces memory usage and improves performance. Then, we load the LLaVA model with these settings. Finally, we load the whisper model, selecting the device based on GPU availability for better performance.</p>\n<p><strong>Note</strong>: <em>We’re using <a href=\"https://huggingface.co/llava-hf/llava-1.5-7b-hf\">llava-v1.5-7b</a> as the model. Please feel free to explore <a href=\"https://huggingface.co/collections/liuhaotian/llava-15-653aac15d994e992e2677a7e\">other versions of the model</a>. For Whisper, we’re loading the “large” size, but you can also switch to another size like “medium” or “small” for your experiments.</em></p>\n<p>To get our assistant up and running, we need to implement five essential functions:</p>\n<ol>\n<li>Handling conversations,</li>\n<li>Converting images to text,</li>\n<li>Converting videos to text,</li>\n<li>Transcribing audio,</li>\n<li>Converting text to speech.</li>\n</ol>\n<p>Once these are in place, we will create another function to tie all this together seamlessly. The following sections provide the code that defines each function.</p>\n<h3>Conversation History</h3>\n<p>We’ll start by setting up the conversation history and a function to log it:</p>\n<div>\n<pre><code>#python\n\n# Initialize conversation history\nconversation_history = []\n\ndef writehistory(text):\n  \"\"\"Write history to a log file.\"\"\"\n  tstamp = datetime.datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n  logfile = f'{tstamp}_log.txt'\n  with open(logfile, 'a', encoding='utf-8') as f:\n    f.write(text + '\\n')\n</code></pre>\n</div>\n\n<h3>Image to Text</h3>\n<p>Next, we’ll create a function to convert images to text using LLaVA and iterative prompts.</p>\n<div>\n<pre><code>#python\ndef img2txt(input_text, input_image):\n  \"\"\"Convert image to text using iterative prompts.\"\"\"\n  try:\n    image = Image.open(input_image)\n\n    if isinstance(input_text, tuple):\n      input_text = input_text[0]  # Take the first element if it's a tuple\n\n      writehistory(f\"Input text: {input_text}\")\n      prompt = \"USER: &lt;image&gt;\\n\" + input_text + \"\\nASSISTANT:\"\n      while True:\n        outputs = pipe(image, prompt=prompt, generate_kwargs={\"max_new_tokens\": 200})\n\n          if outputs and outputs[0][\"generated_text\"]:\n            match = re.search(r'ASSISTANT:\\s*(.*)', outputs[0][\"generated_text\"])\n            reply = match.group(1) if match else \"No response found.\"\n            conversation_history.append((\"User\", input_text))\n            conversation_history.append((\"Assistant\", reply))\n            prompt = \"USER: \" + reply + \"\\nASSISTANT:\"\n            return reply  # Only return the first response for now\n          else:\n            return \"No response generated.\"\n  except Exception as e:\n    return str(e)\n</code></pre>\n</div>\n\n<h3>Video to Text</h3>\n<p>We’ll now create a function to convert videos to text by extracting frames and analyzing them.</p>\n<div>\n<pre><code>#python\ndef vid2txt(input_text, input_video):\n  \"\"\"Convert video to text by extracting frames and analyzing.\"\"\"\n  try:\n    video = mp.VideoFileClip(input_video)\n    frame = video.get_frame(1)  # Get a frame from the video at the 1-second mark\n    image_path = \"temp_frame.jpg\"\n    mp.ImageClip(frame).save_frame(image_path)\n    return img2txt(input_text, image_path)\n  except Exception as e:\n    return str(e)\n</code></pre>\n</div>\n\n<h3>Audio Transcription</h3>\n<p>Let’s add a function to transcribe audio to text using Whisper.</p>\n<pre><code>#python\ndef transcribe(audio_path):\n  \"\"\"Transcribe audio to text using Whisper model.\"\"\"\n  if not audio_path:\n    return ''\n\n  audio = whisper.load_audio(audio_path)\n  audio = whisper.pad_or_trim(audio)\n  mel = whisper.log_mel_spectrogram(audio).to(model.device)\n  options = whisper.DecodingOptions()\n  result = whisper.decode(model, mel, options)\n  return result.text\n</code></pre>\n\n<h3>Text to Speech</h3>\n<p>Lastly, we create a function to convert text responses into speech.</p>\n<pre><code>#python\ndef text_to_speech(text, file_path):\n  \"\"\"Convert text to speech and save to file.\"\"\"\n  language = 'en'\n  audioobj = gTTS(text=text, lang=language, slow=False)\n  audioobj.save(file_path)\n  return file_path\n</code></pre>\n\n<p>With all the necessary functions in place, we can create the main function that ties everything together:</p>\n<div>\n<pre><code>#python\n\ndef chatbot_interface(audio_path, image_path, video_path, user_message):\n  \"\"\"Process user inputs and generate chatbot response.\"\"\"\n  global conversation_history\n\n  # Handle audio input\n  if audio_path:\n    speech_to_text_output = transcribe(audio_path)\n  else:\n    speech_to_text_output = \"\"\n\n  # Determine the input message\n  input_message = user_message if user_message else speech_to_text_output\n\n  # Ensure input_message is a string\n  if isinstance(input_message, tuple):\n    input_message = input_message[0]\n\n  # Handle image or video input\n  if image_path:\n    chatgpt_output = img2txt(input_message, image_path)\n  elif video_path:\n      chatgpt_output = vid2txt(input_message, video_path)\n  else:\n    chatgpt_output = \"No image or video provided.\"\n\n  # Add to conversation history\n  conversation_history.append((\"User\", input_message))\n  conversation_history.append((\"Assistant\", chatgpt_output))\n\n  # Generate audio response\n  processed_audio_path = text_to_speech(chatgpt_output, \"Temp3.mp3\")\n\n  return conversation_history, processed_audio_path\n</code></pre>\n</div>\n\n<h3>Using Gradio For The Interface</h3>\n<p>The final piece for us is to create the layout and user interface for the app. Again, we’re using <a href=\"https://www.gradio.app\">Gradio</a> to build that out for quick prototyping purposes.</p>\n<div>\n<pre><code>#python\n\n# Define Gradio interface\niface = gr.Interface(\n  fn=chatbot_interface,\n  inputs=[\n    gr.Audio(type=\"filepath\", label=\"Record your message\"),\n    gr.Image(type=\"filepath\", label=\"Upload an image\"),\n    gr.Video(label=\"Upload a video\"),\n    gr.Textbox(lines=2, placeholder=\"Type your message here...\", label=\"User message (if no audio)\")\n  ],\n  outputs=[\n    gr.Chatbot(label=\"Conversation\"),\n    gr.Audio(label=\"Assistant's Voice Reply\")\n  ],\n  title=\"Interactive Visual and Voice Assistant\",\n  description=\"Upload an image or video, record or type your question, and get detailed responses.\"\n)\n\n# Launch the Gradio app\niface.launch(debug=True)\n</code></pre>\n</div>\n\n<p>Here, we want to let users record or upload their audio prompts, type their questions if they prefer, upload videos, and, of course, have a conversation block.</p>\n<p>Here’s a preview of how the app will look and work:</p>\n<p><img src=\"https://files.smashing.media/articles/integrating-image-to-text-and-text-to-speech-models-part2/6-app-preview.png\" /></p>\nLooking Beyond LLaVA\n<p>LLaVA is a great model, but there are even greater ones that don’t require a separate ASR model to build a similar app. These are called multimodal or “any-to-any” models. They are designed to process and integrate information from multiple modalities, such as text, images, audio, and video. Instead of just combining vision and text, these models can do it all: image-to-text, video-to-text, text-to-speech, speech-to-text, text-to-video, and image-to-audio, just to name a few. It makes everything simpler and less of a hassle.</p>\n<h3>Examples of Multimodal Models that Handle Images, Text, Audio, and More</h3>\n<p>Now that we know what multimodal models are, let’s check out some cool examples. You may want to integrate these into your next personal project.</p>\n<h4>CoDi</h4>\n<p>So, the first on our list is <a href=\"https://codi-gen.github.io\"><strong>CoDi</strong></a> or <strong>Composable Diffusion</strong>. This model is pretty versatile, not sticking to any one type of input or output. It can take in text, images, audio, and video and turn them into different forms of media. Imagine it as a sort of AI that’s not tied down by specific tasks but can handle a mix of data types seamlessly.</p>\n<p><img src=\"https://files.smashing.media/articles/integrating-image-to-text-and-text-to-speech-models-part2/7-codi.png\" /></p>\n<p>CoDi was developed by researchers from the University of North Carolina and Microsoft Azure. It uses something called <a href=\"https://arxiv.org/abs/2206.01714\">Composable Diffusion</a> to sync different types of data, like aligning audio perfectly with the video, and it <strong>can generate outputs that weren’t even in the original training data</strong>, making it super flexible and innovative. </p>\n<h4>ImageBind</h4>\n<p>Now, let’s talk about <a href=\"https://imagebind.metademolab.com\"><strong>ImageBind</strong></a>, a model from Meta. This model is like a multitasking genius, capable of binding together data from six different modalities all at once: images, video, audio, text, depth, and even thermal data.</p>\n<a href=\"https://files.smashing.media/articles/integrating-image-to-text-and-text-to-speech-models-part2/9-imagebind.gif\"><img src=\"https://files.smashing.media/articles/integrating-image-to-text-and-text-to-speech-models-part2/8-imagebind-800w.gif\" /></a>Source: <a href=\"https://imagebind.metademolab.com/\">Meta AI</a>. (<a href=\"https://files.smashing.media/articles/integrating-image-to-text-and-text-to-speech-models-part2/9-imagebind.gif\">Large preview</a>)\n\n<p>ImageBind doesn’t need explicit supervision to understand how these data types relate. It’s great for creating systems that use <strong>multiple types of data</strong> to enhance our understanding or create immersive experiences. For example, it could combine 3D sensor data with <a href=\"https://intorobotics.com/what-is-an-imu/\">IMU data</a> to design virtual worlds or enhance memory searches across different media types.</p>\n<h4>Gato</h4>\n<p><a href=\"https://deepmind.google/discover/blog/a-generalist-agent/\"><strong>Gato</strong></a> is another fascinating model. It’s built to be a generalist agent that can handle a wide range of tasks using the same network. Whether it’s playing games, chatting, captioning images, or controlling a robot arm, Gato can do it all.</p>\n<p>The key thing about Gato is its ability to <strong>switch between different types of tasks and outputs using the same model</strong>.  </p>\n<p><img src=\"https://files.smashing.media/articles/integrating-image-to-text-and-text-to-speech-models-part2/10-gato.png\" /></p>\n<h4>GPT-4o</h4>\n<p>The next on our list is <a href=\"https://openai.com/index/hello-gpt-4o/\"><strong>GPT-4o</strong></a>; GPT-4o is a groundbreaking multimodal large language model (MLLM) developed by OpenAI. It can handle any mix of text, audio, image, and video inputs and give you text, audio, and image outputs. It’s super quick, responding to audio inputs in just 232ms to 320ms, almost like a real conversation.</p>\n<p>There’s a smaller version of the model called <a href=\"https://openai.com/index/gpt-4o-mini-advancing-cost-efficient-intelligence/\">GPT-4o Mini</a>. Small models are becoming a trend, and this one shows that even small models can perform really well. Check out this evaluation to see how the small model stacks up against other large models. </p>\n<p><img src=\"https://files.smashing.media/articles/integrating-image-to-text-and-text-to-speech-models-part2/11-model-evaluation-scores-open-ai.jpeg\" /></p>\nConclusion\n<p>We covered a lot in this article, from setting up LLaVA for handling both images and videos to incorporating Whisper large-v3 for top-notch speech recognition. We also explored the versatility of multimodal models like CoDi or GPT-4o, showcasing their potential to handle various data types and tasks. These models can make your app more robust and capable of handling a range of inputs and outputs seamlessly.</p>\n<p>Which model are you planning to use for your next app? Let me know in the comments!</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"7ab93d127f62c7a887087b10b14e2eccf22e02d9c06a6719ec44a6303888ffbb","category":"Tech"}