{"title":"How To Build An Amazon Product Scraper With Node.js","link":"https://smashingmagazine.com/2021/10/building-amazon-product-scraper-nodejs/","date":1635418800000,"content":"<p>Have you ever been in a position where you need to intimately know the market for a particular product? Maybe you’re launching some software and need to know how to price it. Or perhaps you already have your own product on the market and want to see which features to add for a competitive advantage. Or maybe you just want to buy something for yourself and want to make sure you get the best bang for your buck.</p>\n<p>All these situations have one thing in common: <strong>you need accurate data to make the correct decision</strong>. Actually, there’s another thing they share. All scenarios can benefit from the use of a web scraper.</p>\n<p>Web scraping is the practice of extracting large amounts of web data through the use of software. So, in essence, it’s a way to automate the tedious process of hitting ‘copy’ and then ‘paste’ 200 times. Of course, a bot can do that in the time it took you to read this sentence, so it’s not only less boring but a lot faster, too.</p>\n<p>But the burning question is: <strong>why would someone want to scrape Amazon pages?</strong></p>\n<p>You’re about to find out! But first of all, I’d like to make something clear right now — while the act of scraping publicly available data is legal, Amazon has some measures to prevent it on their pages. As such, I urge you always to be mindful of the website while scraping, take care not to damage it, and follow ethical guidelines.</p>\n<p><strong>Recommended Reading</strong>: <em>“<a href=\"https://www.smashingmagazine.com/2021/03/ethical-scraping-dynamic-websites-nodejs-puppeteer/?_ga=2.15642294.1444307489.1635259323-795034014.1634556544\">The Guide To Ethical Scraping Of Dynamic Websites With Node.js And Puppeteer</a>” by Andreas Altheimer</em></p>\nWhy You Should Extract Amazon Product Data\n<p>Being the largest online retailer on the planet, it’s safe to say that if you want to buy something, you can probably get it on Amazon. So, it goes without saying just how big of a data treasure trove the website is.</p>\n<p>When scraping the web, your primary question should be what to do with all that data. While there are many individual reasons, it boils down to two prominent use cases: optimizing your products and finding the best deals.</p>\n<p>Let’s start with the first scenario. Unless you’ve designed a truly innovative new product, the chances are that you can already find something at least similar on Amazon. Scraping those product pages can net you invaluable data such as:</p>\n<ul>\n<li><strong>The competitors’ pricing strategy</strong><br />So, that you can adjust your prices to be competitive and understand how others handle promotional deals;</li>\n<li><strong>Customer opinions</strong><br />To see what your future client base cares about most and how to improve their experience;</li>\n<li><strong>Most common features</strong><br />To see what your competition offers to know which functionalities are crucial and which can be left for later.</li>\n</ul>\n<p>In essence, Amazon has everything you need for a deep market and product analysis. You’ll be better prepared to design, launch, and expand your product lineup with that data.</p>\n<p>The second scenario can apply to both businesses and regular people. The idea is pretty similar to what I mentioned earlier. You can scrape the prices, features, and reviews of all the products you could choose, and so, you’ll be able to pick the one that offers the most benefits for the lowest price. After all, who doesn’t like a good deal? </p>\n<p>Not all products deserve this level of attention to detail, but it can make a massive difference with expensive purchases. Unfortunately, while the benefits are clear, many difficulties go along with scraping Amazon.</p>\nThe Challenges Of Scraping Amazon Product Data\n<p>Not all websites are the same. As a rule of thumb, the more complex and widespread a website is, the harder it is to scrape it. Remember when I said that Amazon was the most prominent e-commerce site? Well, that makes it both extremely popular and reasonably complex.</p>\n<p>First off, Amazon knows how scraping bots act, so the website has countermeasures in place. Namely, if the scraper follows a predictable pattern, sending requests at fixed intervals, faster than a human could or with almost identical parameters, Amazon will notice and block the IP. Proxies can solve this problem, but I didn’t need them since we won’t be scraping too many pages in the example.</p>\n<p>Next, Amazon deliberately uses varying page structures for their products. That is to say, that if you inspect the pages for different products, there’s a good chance that you’ll find significant differences in their structure and attributes. The reason behind this is quite simple. You need to <strong>adapt your scraper’s code for a specific system</strong>, and if you use the same script on a new kind of page, you’d have to rewrite parts of it. So, they’re essentially making you work more for the data.</p>\n<p>Lastly, Amazon is a vast website. If you want to gather large amounts of data, running the scraping software on your computer might turn out to take way too much time for your needs. This problem is further consolidated by the fact that going too fast will get your scraper blocked. So, if you want loads of data quickly, you’ll need a truly powerful scraper.</p>\n<p>Well, that’s enough talk about problems, let’s focus on solutions!</p>\nHow To Build A Web Scraper For Amazon\n<p>To keep things simple, we’ll take a step-by-step approach to writing the code. Feel free to work in parallel with the guide.</p>\n<h3>Look for the data we need</h3>\n<p>So, here’s a scenario: I’m moving in a few months to a new place, and I’ll need a couple of new shelves to hold books and magazines. I want to know all my options and get as good of a deal as I can. So, let’s go to the Amazon market, search for “shelves”, and see what we get.</p>\n<p>The URL for this search and the page we’ll be scraping is <a href=\"https://www.amazon.com/s?crid=36QNR0DBY6M7J&amp;k=shelves&amp;ref=glow_cls&amp;refresh=1&amp;sprefix=s%2Caps%2C309\">here</a>.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/24b88181-3bb5-4c72-8ad7-d7f6e2657d9d/2-building-amazon-product-scraper-nodejs.png\" /></p>\n<p>Ok, let’s take stock of what we have here. Just by glancing at the page, we can get a good picture about:</p>\n<ul>\n<li>how the shelves look;</li>\n<li>what the package includes;</li>\n<li>how customers rate them;</li>\n<li>their price;</li>\n<li>the link to the product;</li>\n<li>a suggestion for a cheaper alternative for some of the items.</li>\n</ul>\n<p>That’s more than we could ask for!</p>\n<h3>Get the required tools</h3>\n<p>Let’s ensure we have all the following tools installed and configured before continuing to the next step.</p>\n<ul>\n<li><strong>Chrome</strong><br />We can download it from <a href=\"https://support.google.com/chrome/answer/95346?co=GENIE.Platform%3DDesktop&amp;hl=en\">here</a>.</li>\n<li><strong>VSCode</strong><br />Follow the instructions on <a href=\"https://code.visualstudio.com/docs/introvideos/basics\">this page</a> to install it on your specific device.</li>\n<li><strong>Node.js</strong><br />Before starting using Axios or Cheerio, we need to install Node.js and the Node Package Manager. The easiest way to install Node.js and NPM is to get one of the installers from the <a href=\"https://nodejs.org/en/download/\">Node.Js official source</a> and run it.</li>\n</ul>\n<p>Now, let’s create a new NPM project. Create a new folder for the project and run the following command:</p>\n<pre><code>npm init -y</code></pre>\n\n<p>To create the web scraper, we need to install a couple of dependencies in our project:</p>\n<ul>\n<li><a href=\"https://cheerio.js.org/\">Cheerio</a><br />An open-source library that helps us extract useful information by parsing markup and providing an API for manipulating the resulting data. Cheerio allows us to select tags of an HTML document by using selectors: <code>$(\"div\")</code>. This specific selector helps us pick all <code>&lt;div&gt;</code> elements on a page. To install Cheerio, please run the following command in the projects’ folder:</li>\n</ul>\n<pre><code>npm install cheerio</code></pre>\n\n<ul>\n<li><a href=\"https://www.npmjs.com/package/axios\">Axios</a><br />A JavaScript library used to make HTTP requests from Node.js. </li>\n</ul>\n<pre><code>npm install axios</code></pre>\n\n<h3>Inspect the page source</h3>\n<p>In the following steps, we will learn more about how the information is organized on the page. The idea is to get a better understanding of what we can scrape from our source.</p>\n<p>The developer tools help us interactively explore the website’s Document Object Model (DOM). We will use the developer tools in Chrome, but you can use any web browser you’re comfortable with.</p>\n<p>Let’s open it by right-clicking anywhere on the page and selecting the “Inspect” option:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d89a036c-82a9-4fc5-86de-b63dbd1d0cc5/1-building-amazon-product-scraper-nodejs.png\" /></p>\n<p>This will open up a new window containing the source code of the page. As we have said before, we are looking to scrape every shelf’s information.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c068c4bd-32c5-4ced-b9cd-a71bca793d2a/3-building-amazon-product-scraper-nodejs.png\" /></p>\n<p>As we can see from the screenshot above, the containers that hold all the data have the following classes:</p>\n<pre><code>sg-col-4-of-12 s-result-item s-asin sg-col-4-of-16 sg-col sg-col-4-of-20</code></pre>\n\n<p>In the next step, we will use Cheerio to select all the elements containing the data we need.</p>\n<h3>Fetch the data</h3>\n<p>After we installed all the dependencies presented above, let’s create a new <code>index.js</code> file and type the following lines of code:</p>\n<div>\n<pre><code>const axios = require(\"axios\");\nconst cheerio = require(\"cheerio\");\n\nconst fetchShelves = async () =&gt; {\n   try {\n       const response = await axios.get('<a href=\"https://www.amazon.com/s?crid=36QNR0DBY6M7J&amp;k=shelves&amp;ref=glow_cls&amp;refresh=1&amp;sprefix=s%2Caps%2C309')\">https://www.amazon.com/s?crid=36QNR0DBY6M7J&amp;k=shelves&amp;ref=glow_cls&amp;refresh=1&amp;sprefix=s%2Caps%2C309')</a>;\n\n       const html = response.data;\n\n       const $ = cheerio.load(html);\n\n       const shelves = [];\n\n $('div.sg-col-4-of-12.s-result-item.s-asin.sg-col-4-of-16.sg-col.sg-col-4-of-20').each((_idx, el) =&gt; {\n           const shelf = $(el)\n           const title = shelf.find('span.a-size-base-plus.a-color-base.a-text-normal').text()\n\n           shelves.push(title)\n       });\n\n       return shelves;\n   } catch (error) {\n       throw error;\n   }\n};\n\nfetchShelves().then((shelves) =&gt; console.log(shelves));</code></pre>\n</div>\n\n<p>As we can see, we import the dependencies we need on the first two lines, and then we create a <code>fetchShelves()</code> function that, using Cheerio, gets all the elements containing our products’ information from the page.</p>\n<p>It iterates over each of them and pushes it to an empty array to get a better-formatted result.</p>\n<p>The <code>fetchShelves()</code> function will only return the product’s title at the moment, so let’s get the rest of the information we need. Please add the following lines of code after the line where we defined the variable <code>title</code>.</p>\n<div>\n<pre><code>const image = shelf.find('img.s-image').attr('src')\n\nconst link = shelf.find('a.a-link-normal.a-text-normal').attr('href')\n\nconst reviews = shelf.find('div.a-section.a-spacing-none.a-spacing-top-micro &gt; div.a-row.a-size-small').children('span').last().attr('aria-label')\n\nconst stars = shelf.find('div.a-section.a-spacing-none.a-spacing-top-micro &gt; div &gt; span').attr('aria-label')\n\nconst price = shelf.find('span.a-price &gt; span.a-offscreen').text()\n\n\n    let element = {\n        title,\n        image,\n        link: <code>https://amazon.com${link}</code>,\n        price,\n    }\n\n    if (reviews) {\n        element.reviews = reviews\n    }\n\n    if (stars) {\n        element.stars = stars\n    }</code></pre>\n</div>\n\n<p>And replace <code>shelves.push(title)</code> with <code>shelves.push(element)</code>.</p>\n<p>We are now selecting all the information we need and adding it to a new object called <code>element</code>. Every element is then pushed to the <code>shelves</code> array to get a list of objects containing just the data we are looking for. </p>\n<p>This is how a <code>shelf</code> object should look like before it is added to our list:</p>\n<div>\n<pre><code>  {\n    title: 'SUPERJARE Wall Mounted Shelves, Set of 2, Display Ledge, Storage Rack for Room/Kitchen/Office - White',\n    image: '<a href=\"https://m.media-amazon.com/images/I/61fTtaQNPnL._AC_UL320_.jpg'\">https://m.media-amazon.com/images/I/61fTtaQNPnL._AC_UL320_.jpg'</a>,\n    link: '<a href=\"https://amazon.com/gp/slredirect/picassoRedirect.html/ref=pa_sp_btf_aps_sr_pg1_1?ie=UTF8&amp;adId=A03078372WABZ8V6NFP9L&amp;url=%2FSUPERJARE-Mounted-Floating-Shelves-Display%2Fdp%2FB07H4NRT36%2Fref%3Dsr_1_59_sspa%3Fcrid%3D36QNR0DBY6M7J%26dchild%3D1%26keywords%3Dshelves%26qid%3D1627970918%26refresh%3D1%26sprefix%3Ds%252Caps%252C309%26sr%3D8-59-spons%26psc%3D1&amp;qualifier=1627970918&amp;id=3373422987100422&amp;widgetName=sp_btf'\">https://amazon.com/gp/slredirect/picassoRedirect.html/ref=pa_sp_btf_aps_sr_pg1_1?ie=UTF8&amp;adId=A03078372WABZ8V6NFP9L&amp;url=%2FSUPERJARE-Mounted-Floating-Shelves-Display%2Fdp%2FB07H4NRT36%2Fref%3Dsr_1_59_sspa%3Fcrid%3D36QNR0DBY6M7J%26dchild%3D1%26keywords%3Dshelves%26qid%3D1627970918%26refresh%3D1%26sprefix%3Ds%252Caps%252C309%26sr%3D8-59-spons%26psc%3D1&amp;qualifier=1627970918&amp;id=3373422987100422&amp;widgetName=sp_btf'</a>,\n    price: '$32.99',\n    reviews: '6,171',\n    stars: '4.7 out of 5 stars'\n  }</code></pre>\n</div>\n\n<h3>Format the data</h3>\n<p>Now that we have managed to fetch the data we need, it’s a good idea to save it as a <code>.CSV</code> file to improve readability. After getting all the data, we will use the <code>fs</code> module provided by Node.js and save a new file called <code>saved-shelves.csv</code> to the project’s folder. Import the <code>fs</code> module at the top of the file and copy or write along the following lines of code:</p>\n<div>\n<pre><code>let csvContent = shelves.map(element =&gt; {\n   return Object.values(element).map(item =&gt; <code>\"${item}\"</code>).join(',')\n}).join(\"\\n\")\n\nfs.writeFile('saved-shelves.csv', \"Title, Image, Link, Price, Reviews, Stars\" + '\\n' + csvContent, 'utf8', function (err) {\n   if (err) {\n     console.log('Some error occurred - file either not saved or corrupted.')\n   } else{\n     console.log('File has been saved!')\n   }\n})</code></pre>\n</div>\n\n<p>As we can see, on the first three lines, we format the data we have previously gathered by joining all the values of a shelve object using a comma. Then, using the <code>fs</code> module, we create a file called <code>saved-shelves.csv</code>, add a new row that contains the column headers, add the data we have just formatted and create a callback function that handles the errors.</p>\n<p>The result should look something like this:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8de8902c-3c52-41f7-ac93-90be6f68dd52/5-building-amazon-product-scraper-nodejs.png\" /></p>\nBonus Tips!\n<h3>Scraping Single Page Applications</h3>\n<p>Dynamic content is becoming the standard nowadays, as websites are more complex than ever before. To provide the best user experience possible, <strong>developers must adopt different load mechanisms for dynamic content</strong>, making our job a little more complicated. If you don’t know what that means, imagine a browser lacking a graphical user interface. Luckily, there is <a href=\"https://github.com/puppeteer/puppeteer\">✨Puppeteer✨</a> — the magical Node library that provides a high-level API to control a Chrome instance over the DevTools Protocol. Still, it offers the same functionality as a browser, but it must be controlled programmatically by typing a couple of lines of code. Let’s see how that works.</p>\n<p>In the previously created project, install the Puppeteer library by running <code>npm install puppeteer</code>, create a new <code>puppeteer.js</code> file, and copy or write along the following lines of code:</p>\n<pre><code>const puppeteer = require('puppeteer')\n\n(async () =&gt; {\n try {\n   const chrome = await puppeteer.launch()\n   const page = await chrome.newPage()\n   await page.goto('https://www.reddit.com/r/Kanye/hot/')\n   await page.waitForSelector('.rpBJOHq2PR60pnwJlUyP0', { timeout: 2000 })\n\n   const body = await page.evaluate(() =&gt; {\n     return document.querySelector('body').innerHTML\n   })\n\n   console.log(body)\n\n   await chrome.close()\n } catch (error) {\n   console.log(error)\n }\n})()</code></pre>\n\n<p>In the example above, we create a Chrome instance and open up a new browser page that is required to go to <a href=\"https://www.reddit.com/r/Kanye/hot/\">this link</a>. In the following line, we tell the headless browser to wait until the element with the class <code>rpBJOHq2PR60pnwJlUyP0</code> appears on the page. We have also specified <strong>how long the browser should wait</strong> for the page to load (2000 milliseconds).</p>\n<p>Using the <code>evaluate</code> method on the <code>page</code> variable, we instructed Puppeteer to execute the Javascript snippets within the page’s context just after the element was finally loaded. This will allow us to access the page’s HTML content and return the page’s body as the output. We then close the Chrome instance by calling the <code>close</code> method on the <code>chrome</code> variable. The resulted work should consist of all the dynamically generated HTML code. This is how Puppeteer can help us <strong>load dynamic HTML content</strong>.</p>\n<p>If you don’t feel comfortable using Puppeteer, note that there are a couple of alternatives out there, like NightwatchJS, NightmareJS, or CasperJS. They are slightly different, but in the end, the process is pretty similar.</p>\n<h3>Setting <code>user-agent</code> Headers</h3>\n<p><code>user-agent</code> is a request header that tells the website you are visiting about yourself, namely your browser and OS. This is used to optimize the content for your set-up, but websites also use it to identify bots sending tons of requests — even if it changes IPS.</p>\n<p>Here’s what a <code>user-agent</code> header looks like:</p>\n<div>\n <pre><code>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36\n</code></pre>\n</div>\n\n<p>In the interest of not being detected and blocked, you should regularly change this header. Take extra care not to send an empty or outdated header since this should never happen for a run-fo-the-mill user, and you’ll stand out. </p>\n<h3>Rate Limiting</h3>\n<p>Web scrapers can gather content extremely fast, but you should avoid going at top speed. There are two reasons for this:</p>\n<ol>\n<li><strong>Too many requests</strong> in short order can slow down the website’s server or even bring it down, causing trouble for the owner and other visitors. It can essentially become a DoS attack.</li>\n<li>Without rotating proxies, it’s akin to loudly announcing that <strong>you’re using a bot</strong> since no human would send hundreds or thousands of requests per second.</li>\n</ol>\n<p>The solution is to introduce a delay between your requests, a practice called “rate limiting”. (<em>It’s pretty simple to implement, too!</em>)</p>\n<p>In the Puppeteer example provided above, before creating the <code>body</code> variable, we can use the <code>waitForTimeout</code> method provided by Puppeteer to wait a couple of seconds before making another request:</p>\n<pre><code>await page.waitForTimeout(3000);</code></pre>\n\n<p>Where <code>ms</code> is the number of seconds you would want to wait.</p>\n<p>Also, if we would want to do the same thig for the axios example, we can create a promise that calls the <code>setTimeout()</code> method, in order to help us wait for our desired number of miliseconds:</p>\n<pre><code>fetchShelves.then(result =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(result), 3000)))</code></pre>\n\n<p>In this way, you can avoid putting too much pressure on the targeted server and also, bring a more human approach to web scraping.</p>\nClosing Thoughts\n<p>And there you have it, a step-by-step guide to creating your own web scraper for Amazon product data! But remember, this was just one situation. If you’d like to scrape a different website, you’ll have to make a few tweaks to get any meaningful results.</p>\n<h3>Related Reading</h3>\n<p>If you’d still like to see more web scraping in action, here is some useful reading material for you:</p>\n<ul>\n<li>“<a href=\"https://www.webscrapingapi.com/the-ultimate-guide-to-web-scraping-with-javascript-and-node-js/\">The Ultimate Guide to Web Scraping with JavaScript and Node.Js</a>,” Robert Sfichi</li>\n<li>“<a href=\"https://www.webscrapingapi.com/web-scraping-with-a-headless-browser-using-puppeteer-and-node-js/\">Advanced Node.JS Web Scraping with Puppeteer</a>,” Gabriel Cioci</li>\n<li>“<a href=\"https://www.webscrapingapi.com/python-web-scraping/\">Python Web Scraping: The Ultimate Guide to Building Your Scraper</a>,” Raluca Penciuc</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"2cd4e64c7771f73b4aeb5b6539fd7edfe741be070be632f79d5fdccdfe7c72d5","category":"Tech"}