{"title":"How To Build An Expandable Accessible Gallery","link":"https://smashingmagazine.com/2021/10/build-expandable-accessible-gallery/","date":1633341600000,"content":"<p>One of the use cases for using CSS Grid is to display a gallery of images, but a gallery on its own may not be that exciting. We could, for example, add a click effect to enlarge the image without affecting the grid to make it a little bit more fun. And of course, as to not exclude anybody from enjoying this feature, we should make it accessible, too.</p>\n<p>In this article, I’ll explain how to build an accessible expandable gallery with a few tips and tricks along the way. Here’s how the final result looks like:</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/PojxvJr\">How to build accessible expandable gallery</a> by <a href=\"https://codepen.io/CiTA\">Silvestar Bistrović</a>.</p>\nThe HTML\n<p>First, we are going to set the HTML structure. Of course, we could always do it in various ways, but let us use a list of images wrapped in buttons.</p>\n<pre><code>&lt;ul class=\"js-favs\"&gt;\n  &lt;li&gt;\n    &lt;button&gt;\n      &lt;img src=\"/path/to/image\" alt=\"\" /&gt;\n    &lt;/button&gt;\n  &lt;/li&gt;\n  ...\n&lt;/ul&gt;</code></pre>\n\n<p>Now, to make the gallery accessible, we need to make some adjustments:</p>\n<ul>\n<li>Add the descriptive <code>alt</code> attribute to every image to help visually impaired people understand what is in the image;</li>\n<li>Use the <code>aria-expanded</code> attribute which informs assistive technologies if the image is expanded or not;</li>\n<li>Include <code>role=\"list\"</code> to make sure assistive technologies announce the list because some screen readers might remove the list announcement. </li>\n</ul>\n<blockquote>“It’s not just using <code>list-style: none</code>, but any CSS that would remove the bullet or number indicators of a list’s items will also remove the semantics.”<br /><br />— <a href=\"https://www.scottohara.me/blog/2019/01/12/lists-and-safari.html\">“Fixing” Lists</a>, Scott O’Hara</blockquote>\n\n<p>Finally, let’s add a paragraph with helpful text on how to use the gallery, and wrap the whole code in a landmark (in this case, the <code>main</code> element).</p>\n<pre><code>&lt;main&gt;\n  &lt;p&gt;Use ESC to close larger picture.&lt;/p&gt;\n  &lt;ul class=\"js-favs\" role=”list”&gt;\n    &lt;li&gt;\n      &lt;button aria-expanded=\"false\"&gt;\n        &lt;img src=\"/path/to/image\" alt=\"Description of the image.\" /&gt;\n      &lt;/button&gt;\n    &lt;/li&gt;\n    ...\n  &lt;/ul&gt;\n&lt;/main&gt;</code></pre>\n\n<p>For the simplicity of the demo, I decided to use images wrapped with the <code>aria-expanded</code> attribute. A better solution might be to add only image tags and then use JavaScript to wrap these images in a button with the <code>aria-expanded</code> attribute. This may be considered as progressive enhancement since the expanding effect wouldn’t work without JavaScript anyway.</p>\nThe CSS\n<p>To define the grid layout, we could use CSS Grid. We’ll use <code>auto-fit</code> so that items can fit into the available space, but restrict themselves from shrinking under a certain width. This means that we’ll see a different number of items on different viewports without writing too many media queries.</p>\n<pre><code>:root {\n  --gap: 4px;\n}\n\nul {\n  display: grid;\n  grid-template-columns: repeat(1, 1fr);\n  grid-gap: var(--gap);\n}\n\n@media screen and (min-width: 640px) {\n  ul {\n    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n  }\n}</code></pre>\n\n<p>To preserve the correct aspect ratio of the image, we could use the <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/aspect-ratio\"><code>aspect-ratio</code> property</a>. To reset the button style, we could add the <code>all: initial</code> declaration. We should also hide the overflow of the button. </p>\n<p>To make the image fit right into the button, we’ll use <code>object-fit: cover</code> declaration and set both <code>width</code> and <code>height</code> to <code>100%</code>:</p>\n<pre><code>button {\n  all: initial;\n  display: block;\n  width: 100%;\n  aspect-ratio: 2/1;\n  overflow: hidden;\n  cursor: pointer;\n}\n\nimg {\n  height: 100%;\n  width: 100%;\n  object-fit: cover;\n}</code></pre>\n\n<p>The expanding effect is done with the <code>scale</code> transformation. The transition is enabled by default, but if the user does not prefer transitions and animations, we can use the <code>prefers-reduced-motion</code> media query and set the <code>transition-duration</code> property to <code>0s</code>.</p>\n<pre><code>:root {\n  --duration-shrink: .5s;\n  --duration-expand: .25s;\n  --no-duration: 0s;\n}\n\nli {\n  transition-property: transform, opacity;\n  transition-timing-function: ease-in-out;\n  transition-duration: var(--duration-expand);\n}\n\nli.is-zoomed {\n  transition-duration: var(--duration-shrink);\n}\n\n@media (prefers-reduced-motion) {\n  li,\n  li.is-zoomed {    \n    transition-duration: var(--no-duration);\n  }\n}</code></pre>\n\n\n\nThe JavaScript\n<h3>Preparation</h3>\n<p>Before we make the element expandable, we need to prepare and calculate a few things.</p>\n<p>First, we’ll need to get the duration of the transition by reading the CSS Custom Property <code>--duration-on</code>.</p>\n<pre><code>let timeout = 0\n\n// Get the transition timeout from CSS\nconst getTimeouts = () =&gt; {\n  const durationOn = parseFloat(getComputedStyle(document.documentElement)\n    .getPropertyValue('--duration-on'));\n\n  timeout = parseFloat(durationOn) * 1000\n}</code></pre>\n\n<p>Next, we’ll <strong>set the data attributes</strong> for the later calculation:</p>\n<ul>\n<li>the gap of the grid elements;</li>\n<li>the width of a single element;</li>\n<li>the number of items per row.</li>\n</ul>\n<p>The first two are pretty straightforward. We could get the values from the computed CSS style.</p>\n<p>To find the number of columns, we should iterate through each tile and compare the top position of each element. Once the top position changes, the item is in the new row, which gets us the number of items.</p>\n<pre><code>// Set data attributes for calculations\nconst setDataAttrs = ($elems, $parent) =&gt; {\n  // Get the top offset of the first element\n  let top = getTop($elems[0])\n\n  // Set grid gap from CSS\n  const gridColumnGap = parseFloat(getComputedStyle(document.documentElement)\n    .getPropertyValue('--gap'))\n  $parent.setAttribute('data-gap', gridColumnGap)\n\n  // Set grid item width from CSS\n  const eStyle = getComputedStyle($elems[0])\n  $parent.setAttribute('data-width', eStyle.width)\n\n  // Iterate through grid items\n  for (let i = 0; i &lt; $elems.length; i++) {\n    const t = getTop($elems[i])\n\n    // Check when top offset changes\n    if (t != top) {\n      // Set the number of columns and break stop the loop\n      $parent.setAttribute('data-cols', i)\n      break;\n    }\n  }\n}</code></pre>\n\n<h3>Expanding Direction</h3>\n<p>To achieve the expandable effect, we should make some checks and calculations first. First, we should check if the item is in the last row and at the end of the row. If the item is in the last row, it should expand to the top. That means it should have the <code>transform-origin</code> property set to the <code>bottom</code> value.</p>\n<p><strong>Important</strong>: <em>If the element should expand to one direction, its <code>transform-origin</code> property should be set to an “opposite” value. Note that vertical and horizontal values should be combined.</em></p>\n<pre><code>// Set active item\nconst activateElem = ($elems, $parent, $elem, $button, lengthOfElems, i) =&gt; {\n  // Get data attributes from parent\n  const cols = parseInt($parent.getAttribute('data-cols'))\n  const width = parseFloat($parent.getAttribute('data-width'))\n  const gap = parseFloat($parent.getAttribute('data-gap'))\n\n  // Calculate the number of rows\n  const rows = Math.ceil(lengthOfElems / cols) - 1\n\n  // Calculate if the item is in the last row\n  const isLastRow = i + 1 &gt; rows * cols\n  // Set default transform direction to top (expand down) \n  let transformOrigin = 'top'\n\n  if (isLastRow) {\n    // If the item is in the last row, set transform direction to bottom (expand up) \n    transformOrigin = 'bottom'\n  }\n\n  // Calculate if the item is the most right\n  const isRight = (i + 1) % cols !== 0\n\n  if (isRight) {\n    // If the item is the most right, set transform direction to left (expand right) \n    transformOrigin += ' left'\n  } else {\n    // If the item is the most right, set transform direction to right (expand left) \n    transformOrigin += ' right'\n  }\n\n  $elem.style.transformOrigin = transformOrigin\n}</code></pre>\n\n<h3>Expanding Effect</h3>\n<p>To enlarge the image without affecting the grid, we could use CSS transforms. In particular, we should use the scale transformation. I decided to make the image double in size, i.e. the factor is the ratio of the double width of the element plus grid-gap.</p>\n<pre><code>// Calculate the scale coefficient\nconst scale = (width * 2 + gap) / width\n\n// Set item CSS transform\n$elem.style.transform = `scale(${scale})`</code></pre>\n\n\n\n<h3>Keyboard Support</h3>\n<p>Users who navigate sites by using a keyboard should be able to use the gallery. Going through the list works by default when using key Tab. Emulating the click works by default by pressing the Enter key while the item is focused. To enhance the default behavior, we should add support for Esc and the arrow keys.</p>\n<p>Once we expand the item, pressing Esc should revert it to its standard size. We could do it by checking the code of the pressed key. The same goes for arrow keys, but the action is different. When pressing arrow keys, we want to get the previous or next sibling and then emulate the click on that element.</p>\n<pre><code>// Set sibling as an active item\nconst activateSibling = ($sibling) =&gt; {\n  // Find anchor\n  const $siblingButton = $sibling.querySelector('button')\n\n  // Unset global active element\n  $activeElem = false\n\n  // Focus and click on current\n  $siblingButton.focus()\n  $siblingButton.click()\n}\n\n// Set keyboard events\nconst setKeyboardEvents = () =&gt; {\n  document.addEventListener('keydown', (e) =&gt; {\n    // Take action only if global active element exists\n    if ($activeElem) {\n      // If key is “escape”, emulate the click on the global active element\n      if (e.code === 'Escape') {\n        $activeElem.click()\n      }\n\n      // If key is “left arrow”, activate the previous sibling\n      if (e.code === 'ArrowLeft') {\n        const $previousSibling = $activeElem.parentNode.previousElementSibling\n\n        if($previousSibling) {\n          activateSibling($previousSibling)\n        }\n      }\n\n      // If key is “right arrow”, activate the next sibling\n      if (e.code === 'ArrowRight') {\n        const $nextSibling = $activeElem.parentNode.nextElementSibling\n\n        if($nextSibling) {\n          activateSibling($nextSibling)\n        }\n      }\n    }\n  })\n}</code></pre>\n\n<h3>Toggling</h3>\n<p>To make the gallery element expanded, we should deactivate all other elements first. Then, if we click on the expanded element, it should revert to the standard size.  </p>\n<pre><code>let $activeElem = false\n\n// Deactivate grid items\nconst deactiveElems = ($elems, $parent, $currentElem, $button) =&gt; {\n  // Unset parent class\n  $parent.classList.remove('is-zoomed')\n\n  for (let i = 0; i &lt; $elems.length; i++) {\n    // Unset item class\n    $elems[i].classList.remove('is-zoomed')\n    // Unset item CSS transform\n    $elems[i].style.transform = 'none'\n\n    // Skip the rest if the item is the current item\n    if ($elems[i] === $currentElem) {\n      continue\n    }\n\n    // Unset item aria expanded if element exists\n    if($button) {\n      $button.setAttribute('aria-expanded', false)\n    }\n  }\n}\n\n// Set active item\nconst activateElem = ($elems, $parent, $elem, $button, lengthOfElems, i) =&gt; {\n  ...\n\n  // Reset all elements\n  deactiveElems($elems, $parent, $elem, $button)\n\n  if ($activeElem) {\n    $activeElem = false\n    return\n  }\n\n  $activeElem = $button\n\n  ...\n}\n\n\n// Set click events on anchors\nconst setClicks = ($elems, $parent) =&gt; {\n  $elems.forEach(($elem, i) =&gt; {\n    // Find anchor\n    const $button = $elem.querySelector('button')\n\n    $button.addEventListener('click', (e) =&gt; {\n      // Set active item on click\n      activateElem($elems, $parent, $elem, $button, $elems.length, i)\n    })\n  })\n}</code></pre>\n\n<h3>Z-index Issues</h3>\n<p>To prevent issues with <code>z-index</code> and stacking context, we should use the timeout to delay the transform. That is the same timeout that we calculated in the preparation phase.</p>\n<pre><code>// Deactivate grid items\nconst deactiveElems = ($elems, $parent, $currentElem, $button) =&gt; {\n  for (let i = 0; i &lt; $elems.length; i++) {\n    ...\n\n    // After a half of the timeout, reset CSS z-index to avoid overlay issues\n    setTimeout(() =&gt; {\n      $elems[i].style.zIndex = 0\n    }, timeout)\n  }\n}\n\n// Set active item\nconst activateElem = ($elems, $parent, $elem, $button, lengthOfElems, i) =&gt; {\n  ...\n  setTimeout(() =&gt; {\n    // Set parent class\n    $parent.classList.add('is-zoomed')\n    // Set item class\n    $elem.classList.add('is-zoomed')\n    // Set item CSS transform\n    $elem.style.transform = `scale(${scale})`\n    // Set item aria expanded\n    $button.setAttribute('aria-expanded', true)\n    // Set global active item\n    $activeElem = $button\n  }, timeout)\n}</code></pre>\n\n\n\n<h3>Viewport Resizing</h3>\n<p>If the viewport changes the size, we need to recalculate defaults because we defined a fluid grid that allows items to fill the available space and move from row to row.</p>\n<pre><code>// Set resize events\nconst setResizeEvents = ($elems, $parent) =&gt; {\n  window.addEventListener('resize', () =&gt; {\n    // Set data attributes for calculations\n    setDataAttrs($elems, $parent)\n    // Deactivate grid items\n    deactiveElems($elems, $parent)\n  })\n}</code></pre>\n\n\n\nA Word About Accessibility And Credits\n<p>I had no problems building this demo except with the accessibility part. I was not sure what to do and which aria attributes to use at first. Even after figuring out which attributes to use, I could not be 100% sure it was right. So the first step was to <strong>test everything with a keyboard</strong>. That was the easy part. Then I used the VoiceOver application (since I am using a Mac) to test how it works for visually impaired persons. It sounded good enough to me.</p>\n<p>However, even after all that testing, I was still not 100% sure. So I decided to ask for help. I am a part of one Slack community for designers and developers (<a href=\"https://subscribe.boagworld.com/slack\">BoagWorld</a>), and I posted a question there. Fortunately, accessibility experts like <a href=\"https://www.smashingmagazine.com/author/todd-libby/\">Todd Libby</a> helped me test the demo on different devices and correct the code. I also asked <a href=\"https://www.smashingmagazine.com/author/manuelmatuzovic/\">Manuel Matuzović</a> for help and he helped me clean up the code.</p>\n<p>I’m grateful to have the Internet and developer communities where we can all ask for help, get answers from professionals, and <strong>solve problems together</strong>. That is especially true with sensitive issues like accessibility. Accessibility is hard, and it does not take much to make it wrong. Less is more — at least it was in my case.</p>\n<p>And finally, I wanted to share the greatest lesson:</p>\n<blockquote>“If you can use a native HTML element [<a href=\"https://www.w3.org/TR/using-aria/#bib-html51/\">HTML51</a>] or attribute with the semantics and behavior you require <strong>already built-in</strong>, instead of re-purposing an element and adding an ARIA role, state or property to make it accessible, <strong>then do so</strong>.”<br /><br />— <a href=\"https://www.w3.org/TR/using-aria/#firstrule/\">First Rule of ARIA Use</a>, W3C Working Draft 27 (Sept. 2018)</blockquote>\n\n<h3>Further Reading on Smashing Magazine</h3>\n<ul>\n<li><a href=\"https://www.smashingmagazine.com/2020/03/accessible-svgs-inclusiveness-beyond-patterns/\">Accessible SVGs: Inclusiveness Beyond Patterns</a>, Carie Fisher</li>\n<li><a href=\"https://www.smashingmagazine.com/2021/03/complete-guide-accessible-front-end-components/\">A Complete Guide To Accessible Front-End Components</a>, Vitaly Friedman</li>\n<li><a href=\"https://www.smashingmagazine.com/2021/07/accessible-dialog-from-scratch/\">Creating An Accessible Dialog From Scratch</a>, Kitty Giraudel</li>\n<li><a href=\"https://www.smashingmagazine.com/2021/06/css-javascript-requirements-accessible-components/\">When CSS Isn’t Enough: JavaScript Requirements For Accessible Components</a>, Stephanie Eckles</li>\n<li><a href=\"https://www.smashingmagazine.com/2021/05/accessible-svg-patterns-comparison/\">Accessible SVGs: Perfect Patterns For Screen Reader Users</a>, Carie Fisher</li>\n<li><a href=\"https://www.smashingmagazine.com/2020/07/accessible-front-end-application-chakra-ui-nuxtjs/\">How To Build An Accessible Front-End Application With Chakra UI And Nuxt.js</a>, Kelvin Omereshone</li>\n<li><a href=\"https://www.smashingmagazine.com/2020/07/design-wireframes-accessible-html-css/\">Translating Design Wireframes Into Accessible HTML/CSS</a>, Harris Schneiderman</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"975b180c614bb76bffe65a2ccc6ca633ac2a2323bb7e082f984139204e716064","category":"Tech"}