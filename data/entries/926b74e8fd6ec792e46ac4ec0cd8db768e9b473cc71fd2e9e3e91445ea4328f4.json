{"title":"Knip: An Automated Tool For Finding Unused Files, Exports, And Dependencies","link":"https://smashingmagazine.com/2023/08/knip-automated-tool-find-unused-files-exports-dependencies/","date":1692007200000,"content":"<p>Let’s face it. Most of us favor creating new features and user interfaces over maintenance tasks such as code cleanup, project configuration, and dependency management.</p>\n<p>Lots of the boring and repetitive things, like formatting and linting, are mostly solved problems with tools like Prettier, ESLint, and TypeScript.</p>\n<p>Yet there’s another area that often doesn’t receive much attention: <strong>handling unused files, exports, and dependencies</strong>. This is especially true as projects grow over time, negatively impacting maintainability as well as our enthusiasm for it. These unused artifacts often go unnoticed because they’re typically hard to find.</p>\n<p>Where do you start looking for unused things? I bet you’ve done a global search for a dependency to find out whether it’s still used. Did you know you can right-click a file and “Find File References” in VS Code? These are the things you shouldn’t have to do. They’re tedious tasks that can — and should — be automated.</p>\nThere’s Got to Be a Better Way\n<p>When I was in an expanding codebase, the number of unused files and exports in it kept growing. Tracking them became more and more difficult, so I started looking for automated solutions to help.</p>\n<p>I was happy I found some existing tools, such as <a href=\"https://github.com/nadeesha/ts-prune\">ts-prune</a>. After some initial runs, I\ndiscovered that our codebase required a lot of configuration and still produced many false positives. I researched how other codebases try to stay tidy and realized there’s a huge opportunity in this space.</p>\n<p>Along the road, I also found <a href=\"https://github.com/depcheck/depcheck\">depcheck</a>, which deals with a lot of complexity and customizations in JavaScript projects. And then there’s <a href=\"https://github.com/smeijer/unimported\">unimported</a>, which also does a notable job of finding dangling files and unused dependencies.</p>\n<p>But none of these tools handled my project very well. The fact that I would have to use a combination of them wouldn’t be a showstopper, but I couldn’t get the configurations right for handling the project’s customizations without reporting too many false positives or ignoring too much of the project and leaving a large blind spot.</p>\n<p>In the end, tools in this area are only used when they are fully automated and able to cover the whole project. It also didn’t help that none of the existing tools support monorepos, a structure for repositories that has recently gained widespread popularity. Last but not least, both ts-prune and depcheck are in maintenance mode, meaning they would likely never support monorepos.</p>\nWorking Towards A Solution\n<p>I’m motivated to automate things and keep projects in solid shape. </p>\n<p>Great developer experience (DX) keeps developers happy and productive.</p>\n<p>So I started developing an internal tool for my project to see if I could do better. It started as an internal script that handled only the specifics of that particular repository, and throughout the journey, I kept realizing what a blessing and a curse this is. Automating boring stuff is a winning concept, but getting it right is such a difficult challenge — but one that I was willing to try.</p>\n<p>Along the road, I also got more and more convinced that a single tool to find all categories of unused things was a good idea: each of them requires reading and parsing source files, and since this is a relatively expensive task, I think the efficient path is to track them in one go.</p>\nIntroducing Knip\n<p>So, what is Knip? I think it’s best categorized as a <strong>project linter</strong>. It picks up where ESLint ends. Where ESLint handles individual files, Knip lints the repository as a whole. It connects all the dots — in terms of files, imports, exports, and dependencies — and reports what is unused.</p>\n<p>Roughly speaking, there are two ways to look at Knip. In greenfield projects, it’s great to install Knip and let it grow with the project. Keep the repository tidy and run Knip manually or in an automated continuous integration (CI) environment.</p>\n<p>Another way to look at Knip is in larger projects. Knip is a great companion for housekeeping as far as identifying unused files, exports, and dependencies. There may be false positives initially, but it’s much easier to skip them compared to finding needles in a haystack on your own.</p>\n<p>Additionally, during or after large refactoring efforts, Knip can be a great assistant for cleaning things up. It’s only human to miss or forget things that are no longer used, even more so when the things are not close to the refactoring work.</p>\n<p>Knip works with traditional JavaScript and modern TypeScript, has built-in support for monorepos, works with <em>any</em> package manager, and has many features, small and large, that help you maintain your projects.</p>\nHow Knip Works\n<p>Knip starts with one or more entry files and calculates the dependency tree, helping it know all the files that are used while marking the remaining files as unused.</p>\n<p>Meanwhile, Knip keeps track of imported external dependencies and compares them against the dependencies in <code>package.json</code> to report both unused dependencies and dependencies that are used but not listed. It also keeps track of internal imports and exports to report unused exports.</p>\n<p>Let me give you a better look under the hood.</p>\n<h3>Production Mode</h3>\n<p>In its <strong>default mode</strong>, Knip analyzes the whole project, including both production and non-production files, such as tests, configurations, Storybook stories, <code>devDependencies</code>, and so on.</p>\n<p><img src=\"https://files.smashing.media/articles/knip-automated-tool-find-unused-files-exports-dependencies/knip-exports.png\" /></p>\n<p>But this mode might miss opportunities for trimming. For instance, files or exports imported only by tests are normally not reported as unused. However, when the export is not used anywhere else, you can delete both the export and its tests!</p>\n<p>This is why Knip has a <strong>production mode</strong>. This mode is more strict than the default mode, where Knip will use only production code as entry files and only consider <code>dependencies</code> (excluding <code>devDependencies</code>).</p>\n<h3>Scripts</h3>\n<p>Many projects use command line tools that come with dependencies. For instance, after installing ESLint, you can use <code>eslint</code>, and Angular makes <code>ng</code> available in <code>\"scripts\"</code> in <code>package.json</code>. Knip connects dependencies with binaries and tells you when they are unused or missing.</p>\n<p>But there’s more. CI environments, like Azure and GitHub Actions, are configured with YAML files that may also use the same command line tools.</p>\n<p>And finally, custom scripts may use command line tools by spawning child processes, either using native Node.js APIs or with libraries like <code>zx</code> or <code>execa</code>.</p>\n<p>Knip has a growing number of such detections to keep your projects neat and tidy, refactor after refactor. Yet what is so interesting about those scripts? They may be complicated to parse, making it difficult to extract their dependencies. Let’s look at an example:</p>\n<div>\n<pre><code>node -r @scope/package/register --experimental-loader ts-node/esm/transpile-only ./dir\n</code></pre>\n</div>\n\n<p>Here, we can find <code>@scope/package</code> and <code>ts-node</code> and <code>dir/index.ts</code> are dependencies of this script. Honestly, this is just the tip of the iceberg. I promise a few regular expressions won’t be enough!</p>\n<p>Now, if this script is updated or removed, Knip will tell you if any dependency or file is no longer used. On the other hand, Knip will also tell you if a dependency is used but not listed explicitly in <code>package.json</code>. (You shouldn’t be relying on transitive dependencies anyway, right?)</p>\n<h3>Plugins</h3>\n<p>There’s an abundance of tooling available in the JavaScript ecosystem. And each tool has its configurations. Some allow YAML or JSON, and some allow (or require) you to write configurations in JavaScript or even TypeScript.</p>\n<p>Since there’s no generic way to handle the myriad of variations, Knip supports <strong>plugins</strong>. Knip has plugins for tools that may reference dependencies that should be listed in <code>package.json</code>.</p>\n<p>What matters to plugins is how dependencies are referenced. They might be imported in JavaScript like any other source file, and Knip can also parse them as such. Yet, they’re often referenced as strings, much the same as what ESLint does with the <code>extends</code> and <code>plugins</code> options. Dependencies can be specified in implicit ways, such as <code>prettier</code>, which means the <code>eslint-config-prettier</code> dependency. Storybook has the <code>builder: \"webpack5\"</code> configuration that requires the <code>@storybook/builder-webpack5</code> and <code>@storybook/manager-webpack5</code> dependencies.</p>\n<h3>Compilers</h3>\n<p>Knip parses all sorts of JavaScript and TypeScript files, including ES modules and CommonJS modules.</p>\n<p>But some frameworks work with non-standard files, such as Vue, Svelte, MDX, and Astro. Knip allows you to configure compilers to include these types of files so they can also be included in the analysis.</p>\n<h3>Performance</h3>\n<p>Until version 2, Knip used <a href=\"https://ts-morph.com\">ts-morph</a> to calculate the dependency graph (and much more). This worked great initially because it abstracted away the TypeScript back end.</p>\n<p>But to support monorepos and compilers while maintaining good performance, I realized I had to work with the TypeScript back end directly. This required a lot of effort, but it does provide a lot more flexibility, as well as opportunities for more optimizations. For example, Knip can traverse the <strong>abstract syntax tree (AST)</strong> of any file only once to find everything it needs.</p>\n<h3>Configuration Hints</h3>\n<p>When Knip reports a false positive, you can configure it to ignore that dependency. Then, when Knip no longer reports the false positive, it will report that the configuration can be updated, and you can remove the ignored items.</p>\n<h3>Reporters</h3>\n<p>Knip comes with a default reporter and has a few additional reporters. There’s a compact reporter, a JSON reporter, and one that uses the <code>CODEOWNERS</code> file to show the code owner(s) with each reported issue.</p>\n<p>Knip also allows you to define a custom reporter. Knip will call your function with the results of the analysis. You can then do anything with it, like writing the results to a file or sending it to a service to track progress over time.</p>\nWhat’s Next For Knip?\n<p>Naturally, I’m not done working on Knip. These are a few of the things I have in mind.</p>\n<h3>More Plugins = Less Configuration</h3>\n<p>My hope with Knip is that as more and more people start to use Knip, they will report false positives: something is reported as unused but is in use.</p>\n<p>A false positive usually has one of the following three causes:</p>\n<ul>\n<li>A framework or tool is used that Knip does not yet have a plugin for,</li>\n<li>The configuration might need improvement; for instance, add an entry file that Knip didn’t know about or ignore something with a hard-to-find reference, or</li>\n<li>Knip has a bug.</li>\n</ul>\n<p>As Knip becomes better with bug fixes and plugins, more projects benefit because they need less configuration. Maintenance will become more enjoyable and easier for everyone!</p>\n<p>When you are using Knip and enjoying it, don’t let false positives scare you away, but report them instead. Please provide a reproducible test case, and I’m sure we can work it out. Additionally, <a href=\"https://github.com/webpro/knip/blob/main/docs/writing-a-plugin.md\">I’ve written a complete guide</a> detailing how to write a new plugin for Knip.</p>\n<h3>Auto-Fix</h3>\n<p>Much like ESLint, Knip will have a <code>--fix</code> option to automatically fix all sorts of issues. The idea is that this can automatically take care of things such as:</p>\n<ul>\n<li>Remove the <code>export</code> keyword for unused exports,</li>\n<li>Uninstall unused dependencies and install unlisted dependencies, and</li>\n<li>Delete unused files.</li>\n</ul>\n<p>Given enough interest from the community, I’m excited to start building this feature!</p>\n<h3>Integrations</h3>\n<p>Integrations such as a VS Code plugin or a GitHub Action sound like cool opportunities. I’m happy to collaborate and see where we can take it.</p>\nDemo Knip\n<p>I think the best way to understand Knip is to get your hands on it. So, I’ve created a CodeSandbox template that you can fork and spin up Knip in a new terminal with <code>npm run knip</code>.</p>\n<ul>\n<li><a href=\"https://codesandbox.io/p/sandbox/knip-playground-wphfrf\">Open Demo</a></li>\n</ul>\nConclusion\n<p>Knip aims to help you maintain your JavaScript or TypeScript repositories, and I’m very happy lots of projects are already cut by Knip daily.</p>\n<p>There is lots of room for improvement, bugs to fix, documentation to improve, and plugins to add! Your ideas and contributions are absolutely welcome — and encouraged — over at <a href=\"https://github.com/webpro/knip\">github.com/webpro/knip</a>.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"926b74e8fd6ec792e46ac4ec0cd8db768e9b473cc71fd2e9e3e91445ea4328f4","category":"Tech"}