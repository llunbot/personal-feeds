{"title":"ว่าด้วยเรื่องการติดต่อสื่อสารระหว่าง Module","link":"https://www.somkiat.cc/better-modular/","date":1721361952000,"content":"<p><img width=\"150\" height=\"150\" src=\"https://www.somkiat.cc/wp-content/uploads/2024/07/module-02-150x150.jpg\" loading=\"lazy\" srcset=\"https://www.somkiat.cc/wp-content/uploads/2024/07/module-02-150x150.jpg 150w, https://www.somkiat.cc/wp-content/uploads/2024/07/module-02-75x75.jpg 75w\" /></p>\n<figure><a href=\"https://www.somkiat.cc/wp-content/uploads/2024/07/module-02.jpg\"><img src=\"https://www.somkiat.cc/wp-content/uploads/2024/07/module-02.jpg\" width=\"566\" height=\"318\" /></a></figure>\n\n\n\n<p>ในการแบ่งปันเรื่อง Microservices design  และ develop นั้น<br />มักจะแนะนำเสมอว่า เริ่มจาก modular ให้มันดี ๆ ก่อน (process เดียวกัน)<br />เริ่มด้วยการแบ่งการทำงานต่าง ๆ เป็น module หรือกลุ่มการทำงานก่อน<br />จากนั้นดูการติดต่อสื่อสารระหว่าง module ว่าเป็นอย่างไร ?<br />มันทำให้แต่ละ module ผูกมัดกันมากไปหรือไม่ ? (Tight coupling)</p>\n\n\n\n<span></span>\n\n\n\n<p><strong>ดังนั้นในการทำ workshop จึงแนะนำหนึ่งแนวทางในการจัดการ module</strong></p>\n\n\n\n<p>และการติดต่อระหว่าง mnodule แบบไม่ผูกมัดกันมากนัก (Loose coupling)<br />เพื่อลดผลกระทบจากการแก้ไขใน module ต่าง ๆ ลง</p>\n\n\n\n<figure><a href=\"https://www.somkiat.cc/wp-content/uploads/2024/07/modular-03.jpg\"><img src=\"https://www.somkiat.cc/wp-content/uploads/2024/07/modular-03-1024x666.jpg\" width=\"492\" height=\"320\" /></a></figure>\n\n\n\n<p><strong>หนึ่งในวิธีการที่แนะนำคือ นำแนวคิดของ Event-based เข้ามาช่วยงาน</strong></p>\n\n\n\n<p>หรือ <a href=\"https://refactoring.guru/design-patterns/mediator\" target=\"_blank\">Mediator pattern</a> จาก design pattern นั่นเอง<br />แสดงดังรูป</p>\n\n\n\n<figure><a href=\"https://www.somkiat.cc/wp-content/uploads/2024/07/modular-01.jpg\"><img src=\"https://www.somkiat.cc/wp-content/uploads/2024/07/modular-01-1024x470.jpg\" width=\"735\" height=\"337\" /></a></figure>\n\n\n\n<p><strong>อธิบายการทำงานคร่าว ๆ เป็นดังนี้</strong></p>\n\n\n\n<ul>\n<li>เมื่อ module A ทำงานเรียบร้อยแล้ว ปกติจะต้องเป็นฝั่งที่เรียกใช้งาน module B เองต่อไป แต่ในแนวทางนี้ไม่ใช่</li>\n\n\n\n<li>module A ทำการสร้าง event ขึ้นมาจากนั้น publish ออกไป</li>\n\n\n\n<li>ทาง module B จะทำการสร้าง event handler สำหรับคอยรับ event type ที่ต้องการ </li>\n\n\n\n<li>เมื่อมี event ที่ต้องการเกิดขึ้นมา ทาง module B ก็จะทำงานต่อไปเองแบบอัตโนมัติ ทำให้ทั้งสอง module ไม่ผูกมัดกันมากนัก</li>\n\n\n\n<li>โดยทั้งสอง module ทำงานใน process เดียวกัน ดังนั้น event ก็จะอยู่ภายในนั่นเอง</li>\n\n\n\n<li>อีกอย่าง แนวคิดนี้มันก็เอื้อต่อการแยกในอนาคตอีกด้วย !!</li>\n</ul>\n\n\n\n<p><strong>ตัวอย่างของการพัฒนาจะมีดังนี้</strong></p>\n\n\n\n<ul>\n<li>ใน Spring Boot มี <a href=\"https://www.somkiat.cc/note-event-publisher-spring-boot-app/\" target=\"_blank\">EventPublisher</a></li>\n\n\n\n<li>ใน .Net มี <a href=\"https://github.com/jbogard/MediatR\" target=\"_blank\">MediatR</a></li>\n\n\n\n<li>ใน go มี <a href=\"https://github.com/mehdihadeli/Go-MediatR\" target=\"_blank\">Go-MediatR</a></li>\n</ul>\n\n\n\n<p>ลองนำไปเล่นกันดูครับ เป็นอีกหนึ่งแนวคิดที่น่าสนใจ</p>\n\n\n\n<p><strong>Reference websites</strong></p>\n\n\n\n<ul>\n<li><a href=\"https://levelup.gitconnected.com/architecture-style-modulith-vs-microservices-90c7c75713db\" target=\"_blank\">Architecture Style : Modulith (vs Microservices)</a></li>\n</ul>\n","author":"somkiat","siteTitle":"cc :: somkiat","siteHash":"3a23a5a4389e1e40c6fbb16520a8cc20df5b3591c25145ce72aaa18b19e48201","entryHash":"be7d605bbf36ac9e4f6796fc54b6db83a3d7a104bf0ae7ad236a6b4fb7268f66","category":"Thai"}