{"title":"SolidStart: A Different Breed Of Meta-Framework","link":"https://smashingmagazine.com/2024/01/solidstart-different-breed-meta-framework/","date":1704708000000,"content":"<p>The current landscape of web tooling is increasingly more complex than ever before. We have libraries such as Solid, Vue, Svelte, Angular, React, and others that handle UI (User Interface) updates in an ergonomic fashion. The ever more important topic weighing on developers is the balance and trade-off of performance and usability best practices.</p>\n<p>Developers are also blurring the lines between front-end and back-end code. The way we colocate logic and data is becoming more interesting as we integrate and mesh the way they work together to deliver a unified app experience.</p>\n<p>With these shifts in ideology in mind, meta-frameworks have evolved around the core libraries in unique ways. To encapsulate the paradigms in which the UI is rendered and create seamless interoperability between our server code and our browser code, <strong>new practices are emerging</strong>.</p>\n<p>While the initial idea of having a “meta” framework was to stitch together different sets of tools in order to build smooth experiences, it is tough to create integrations without making some level of opinionated decisions. So frameworks such as QwikCity, SvelteKit, Redwood, and Next.js went all the way into their own opinionated territory and provided a hard railway to ensure a defined set of conventions.</p>\n<p>Meanwhile, others like Nuxt, Remix, and Analog stayed with a more shallow abstraction of their integrations, allowing a mix of their toolings and more easily using resources from the community (Vite is a good example of a tool that is shallowly used by all of them).</p>\n<p>This not only produces a lower vendor lock-in to developers but also allows configuration to be re-used in some cases as such decisions are stripped out of opinions in favor of stronger abstractions. <strong>SolidStart takes a giant step beyond</strong> that into unbiased territory. Its own core is around 1500 lines of code, and the biggest pieces of functionality are provided with a meshing of well-integrated tools.</p>\nModules Over Monoliths\n<p>The impetus behind decoupling the architecture completely is to give power to the consuming developer to pick the framework and build it according to their desire. A developer may want to use Solid and SSR, but let’s imagine legacy code has a tight dependency on TanStack Router, while SolidStart and most Solid projects have Solid-Router instead. With a decoupled architecture, it becomes possible to either create an incremental adoption or integration layer so that everything will work tailored to the team’s best benefit.</p>\n<p>The decoupled architecture sustaining newer frameworks also empowers the developer for a <strong>better debugging experience</strong> within and beyond its community. If an issue is encountered on the server, you’re not restricted to the knowledge of a specific framework.</p>\n<p>For example, since both are based on Nitro, the Analog and SolidStart communities can now share knowledge with each other. Beyond that, because all of them are based in Nitro and Vite, Nuxt, Analog, and SolidStart can deploy to the same platforms and share implementation details to make each ecosystem grow together. The community wins with this approach, and the library/framework developers win as well. This is a radically <strong>new pattern and approach</strong> to jointly sharing the weight of meta-framework maintenance (one of the most feared responsibilities of maintainers).</p>\nWhat Is SolidStart Exactly?\n<p>SolidStart is built from five fundamental pillars:</p>\n<ol>\n<li><a href=\"https://solidjs.com\">Solid</a>: the view library that provides rendering abstractions.</li>\n<li><a href=\"https://vite.dev/\">Vite</a> (within Vinxi): the bundler to optimize code for execution in different runtimes.</li>\n<li><a href=\"https://nitro.unjs.io/\">Nitro</a> (within Vinxi): the agnostic web server created by the Nuxt team and based on h3 with Rollup.</li>\n<li><a href=\"https://github.com/nksaraf/vinxi\">Vinxi</a>: the orchestrator, what determines where the runtimes and the code each one has.</li>\n<li><a href=\"https://github.com/lxsmnsyc/seroval\">Seroval</a>: the data serializer that will bridge data from server to browser and back.</li>\n</ol>\n<p><img src=\"https://files.smashing.media/articles/solidstart-different-breed-meta-framework/anatomy-solidstart.png\" /></p>\n1. Solid\n<p>Solid as a rendering library has become increasingly popular because of its incredible rendering performance and thin abstraction layer. It’s built on top of Signals, a renewing and modern implementation of the classical Observer Pattern, and provides a series of helpers to empower the developer to create extremely <strong>high-performance and easy-to-read code</strong>.</p>\n<p>It uses JSX and has syntax that is very similar to React, but under the hood, it operates in a completely different manner. Bringing the developer closer to the DOM while still providing the needed ergonomics to be productive in the developer environment. At only 3Kb of bundle size, it’s often a choice even for mostly static sites. e.g., many people use Solid to bring interactivity to their content-based Astro websites when needed.</p>\n<p>Solid also brings first-class primitives, built-in Control Flow components, high-quality state management, and full TypeScript support. Solid packs a punch in a small efficient package.</p>\n2. Vite\n<p>Arguably the best bundler in the JavaScript ecosystem, Vite has the right balance between declarative and customizable configuration. It’s fully based on TypeScript, which makes it easy to extend by the consuming library or framework, and has a large enough user base that guarantees its versatility. Vite works with and has become the <strong>de-facto tool for many frameworks</strong>, such as Astro, Vue, Preact, Elm, Lit, Svelte, Nuxt, Analog, Remix, and many others.</p>\n<p>Aside from its popularity, it is particularly loved for its fast server start time, HMR support, optimized builds, ease of configuration, rich plug-in ecosystem, modern tooling, and high-quality overall developer experience.</p>\n3. Nitro\n<p>A framework in itself, Nitro is written in TypeScript and is completely agnostic and open for every <strong>meta-framework</strong> to use as a foundation. It provides a powerful set of tools and APIs to manage caching, routes, and tree-shaking. It is a fast base for any JavaScript-based project to build their server on. Nitro is highly scalable, integrating easily into DevOps and CI/CD pipelines, security-focused, robust, and boasts a rich set of adapters, making it deployable on most, if not all, major vendor platforms.</p>\n<p>Think of Nitro as a bolt-on extension that makes Vite easier to build on and more pliable. It solves a majority of run-time level concerns that would need to be solved in Vite.</p>\n4. Vinxi\n<p>Vinxi is an SDK (Software Development Kit) that brings <strong>a powerful set of configuration-based tools</strong> to create full-stack applications. It composes Nitro under the hood to establish a web server and leverages Vite for the bundling components. It is inspired by the Bun App API and works via a very declarative interface to instantiate an app by setting routers for each runtime.</p>\n<p>For example:</p>\n<div>\n <pre><code>import { createApp } from \"vinxi\";\nimport solid from \"vite-plugin-solid\";\n\nconst resources = {\n    name: \"public\",\n    mode: \"static\",\n    dir: \"./public\",\n};\n\nconst spa = {\n    name: \"client\",\n    mode: \"build\",\n    handler: \"./app/client.tsx\",\n    target: \"browser\",\n    plugins: () =&gt; [solid({ ssr: true })],\n    base: \"/_build\"\n}\n\nconst server = {\n    name: \"ssr\",\n    mode: \"handler\",\n    handler: \"./app/server.tsx\",\n    target: \"server\",\n    plugins: () =&gt; [solid({ ssr: true })],\n}\n\nexport default createApp({\n    routers: [resources, spa, server],\n});\n</code></pre>\n</div>\n\n<p>As resource routes work as a bucket, by defining <code>mode: \"static\"</code> there’s no need to define a handler. Your router can also be statically built (<code>mode: “build”</code>) and targeted towards the browser runtime, or it can be on the server and handle each request via its entry-point <code>handler: \"./app/server.tsx\"</code>.</p>\n<p>Vinxi will leverage the right set of APIs from Nitro and Vite so your resources aren’t exposed to the wrong runtimes and so that <strong>deployment works smoothly</strong> for defined platform providers.</p>\n5. Seroval\n<p>Once routers are set, and the app can handle navigation (hard navigation via the “ssr” handler and soft navigation via the “client” handler), it’s time to stitch them together. This is the part where SolidStart’s core comes into place. It supplies APIs that deliver the ergonomics to <strong>fetch and mutate requests</strong>.</p>\n<p>All these APIs are powered by yet another agnostic library called Seroval. In order to send data between server and client in a secure manner, it all needs to be serialized. Seroval defines itself in an over-simplistic way: “Stringify JS Values.” However, this definition doesn’t address the fact it does so in an extremely powerful and fast fashion.</p>\n<p>Thanks to Seroval, SolidStart is able to safely and efficiently cross the <strong>serialization boundary.</strong> Resource serialization is arguably the most important feature of a full-stack framework — without it, the back-end and front-end bridge simply won’t work in a smooth way.</p>\n<p>Besides resource serialization, SolidStart can also use <strong>server actions.</strong> Straight from the <a href=\"https://start.solidjs.com/core-concepts/actions\">documentation</a>, this is how server actions look for us (note the <code>\"use server\"</code> directive that allows Vinxi to put the code in the correct place.</p>\n<div>\n <pre><code>import { action, redirect } from \"@solidjs/router\";\n\nconst isAdmin = action(async (formData: FormData) =&gt; {\n  \"use server\";\n  await new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000));\n  const username = formData.get(\"username\");\n  if (username === \"admin\") throw redirect(\"/admin\");\n  return new Error(\"Invalid username\");\n});\n\nexport function MyComponent() {\n  return (\n    &lt;form action={isAdmin} method=\"post\"&gt;\n      &lt;label for=\"username\"&gt;Username:&lt;/label&gt;\n      &lt;input type=\"text\" name=\"username\" /&gt;\n      &lt;input type=\"submit\" value=\"submit\" /&gt;\n    &lt;/form&gt;\n  );\n}\n</code></pre>\n</div>\n\n\n\nEverything Comes Together\n<p>After this breakdown, things may still be a bit up in the air. So, let’s close the loop by assembling the parts:</p>\n<p><img src=\"https://files.smashing.media/articles/solidstart-different-breed-meta-framework/solidstart-explained.png\" /></p>\n<p>Hopefully, this little exercise of pulling the framework apart and putting the pieces back together was interesting and insightful. Let me know in the comments below or on <a href=\"https://atila.io/x\">X</a> if this has helped you better understand or even choose the tools for your next project.</p>\nFinal Considerations\n<p>This article would not have been possible without the technical help from my awesome folks at Solid’s team: <a href=\"https://x.com/davedbase\">Dave Di Biase</a>, <a href=\"https://x.com/lxsmnsyc\">Alexis Munsayac</a>, <a href=\"https://dev.to/lexlohr\">Alex Lohr</a>, <a href=\"https://x.com/danieljcafonso\">Daniel Afonso</a>, and <a href=\"https://x.com/nkSaraf98\">Nikhil Saraf</a>. Thank you for your reviews, insights, and overall making me sound cleverer!</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"fcc781ba6e5cba55720d40a88ad54aac5c4af23f73bef6a8a95b83fd4bb35ca0","category":"Tech"}