{"title":"Getting Internationalization (i18n) Right With Remix And Headless CMS","link":"https://smashingmagazine.com/2023/02/internationalization-i18n-right-remix-headless-cms-storyblok/","date":1676995200000,"content":"<p>This article is a sponsored by <a href=\"https://www.storyblok.com/?utm_source=smashmagazine&amp;utm_medium=article&amp;utm_campaign=i18n_remix_headless_cms\">Storyblok</a></p>\n<p>How much of a language barrier is there still in the 21st century? You, as the reader, are probably very familiar with English, but what about others?</p>\n<p>Nowadays, most of us have often heard the importance of accessibility, better performance, and better UX or DX. You might not hear or often see about i18n compared with these topics. But if you see facts and numbers from the statistics, you might find some surprising results about i18n and its impact. Let’s find out about that together.</p>\n<h3>i18n And l10n</h3>\n\n<p>Before we go through the impact of i18n, let’s learn the difference between the two terminologies.</p>\n<ul>\n<li><strong>i18n</strong><br />i18n stands for internationalization. Between the first character, “i,” and the last character, “n,” from this word, there are 18 characters. i18n describes implementing the structures and features for your applications to be ready to localize content.</li>\n<li><strong>l10n</strong><br />l10n stands for localization. Between the first character, “l,” and the last character, “n,” from this word, there are ten characters. l10n means translating content into the languages for users who are accessing from specific regions.</li>\n</ul>\n<p>As a follow-up, i18n contains a programmatic process to implement features for content editors and translators to be able to start the l10n process from the UI.</p>\nWhy Does i18n Matters That Much?\n\n<p>To see the importance of i18n, let’s look at the numbers and statistics for objective information. You will see the numbers of some facts below, and before reading further, let’s guess what those numbers stand for.</p>\n<ul>\n<li>5.07 billion</li>\n<li>25.9%</li>\n<li>74.1%</li>\n<li>China</li>\n<li>Asia</li>\n</ul>\n<p>The first fact shows a tremendous amount of the numbers. 5.07 billion is the number of users in this world in 2020. The world population in 2021 was 7.837 billion, nearly 8 billion. More than half of the world's population has access to content on the internet and apps.</p>\n<p>Based on the number of users in this world, there’s another research about the most common languages used on the internet. Looking at the chart, most of us pay attention to the highest number on this diagram: 25.9%, English.</p>\n<p><img src=\"https://files.smashing.media/articles/internationalization-i18n-right-remix-headless-cms-storyblok/1-common-languages-internet.png\" /></p>\n<p>The second highest is the rest of the languages, 23.1%. Also, suppose you gather the rest of the percentage except English. In that case, you may realize out of the over 5 billion users, 74.1% of the users are accessing the content in any other language.</p>\n<p>After going through these facts, we can now talk about why internationalizing and localizing your content for Asia and China, in particular, is crucial. China has the most internet users worldwide. As a result, more than half of all internet users globally are from Asia.</p>\n<p>Based on what we saw, probably, we can not ignore localizing content. It will improve UX if these huge amounts of users worldwide could have localized content. After knowing the potential impact of proper i18n, let’s look at the fundamental logic.</p>\nHow i18n Works At A Basic Level\n\n<p>Regardless of the technology to implement i18n, there are three ways to determine languages and regions. </p>\n<ol>\n<li>The location of the IP address</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language\">Accept-Language</a> header/<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Navigator/languages\">Navigator.languages</a></li>\n<li>Identifiers in URLs</li>\n</ol>\n<p>Using the IP address detects the region of the users and allows them to access content in their regional languages. However, the user’s IP address does not necessarily match their language preference. Moreover, <a href=\"https://developers.google.com/search/docs/specialty/international/managing-multi-regional-sites?visit_id=638090932378616963-37385648&amp;rd=1#geotargeting\">location analysis prevents the sites from being crawled by search engines.</a></p>\n<p>Using <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language\">Accept-Language</a> header or <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Navigator/languages\">Navigator.languages</a> is another possible approach to implement i18n. However, this approach provides language information but not regional information.</p>\n<p>i18n is not just about localizing content. It includes improving UX as well. For example, creating identifiers in URLs enhances UX. It also helps to divide localized content into the dedicated system. We will cover how it’s possible to implement such a system in the “<a href=\"#a-combination-of-remix-and-cms\">A Combination Of Remix And CMS</a>” section.</p>\n<p>Typically, identifiers in URLs exist in three different patterns:</p>\n<ol>\n<li>Differentiate by domains (i.e. <code>hello.es</code>, <code>hello.jp</code>)</li>\n<li>URL parameters (i.e. <code>hello.com?loc=de</code>)</li>\n<li>Localized sub-directories (i.e. <code>hello.com/es</code>, <code>hello.com/ja</code>)</li>\n</ol>\n<p>To follow the same-origin policy for better SEO, localized sub-directories can be used.</p>\n<p>Based on the interesting facts and the fundamental logic for implementing i18n, we’ll talk about frameworks and libraries, as some of them use i18n libraries.</p>\nLibraries\n<p>In order to not reinvent the wheel whenever we want to implement i18n into our projects, developers have different libraries, tools, and services that can be used to facilitate the work. If we are working with React or React-based frameworks, we have different options available. Let’s talk about some of them.</p>\n<h4>Format.js</h4>\n<p><a href=\"https://formatjs.io/\">Format.js</a> is a modular collection of JavaScript libraries that we can use to implement i18n logic in both the client and the server. This group of libraries is focused on formatting numbers, dates, and strings. It offers different functionalities and tooling and runs in the browser as well as in the Node.js runtime. It integrates with various frameworks, like Vue and React, so that we can use its functionalities on our Remix projects. You can read more about it on the <a href=\"https://formatjs.io/docs/react-intl/\">official React Intl's docs</a>.</p>\n<h4>i18next</h4>\n\n<p>Another alternative that we can evaluate for our project is <a href=\"https://www.i18next.com/\">i18next</a>. This JavaScript library goes beyond the standard i18n features, providing a whole suite to manage i18n in our projects. We can detect users’ language, cache translations, and even install plugins and extensions. As it was built in JavaScript, we can use this tool for websites as well as for mobile and desktop applications.</p>\nWhat About Remix?\n<p>When creating a website using Remix, we have different options to consider. As it is a React-based framework, we can use any of the previously mentioned libraries. However, we will go through two approaches that can fit better in your Remix projects. First, we will see how to localize content using remix-i18next, a Remix specific library for i18n. Second, we will use a headless content management system as the source of our content’s different languages/locales.</p>\n<h4>remix-i18next</h4>\n<p>Based on i18next, <a href=\"https://github.com/sergiodxa\">Sergio Xalambrí</a>, one of the main Remix contributors, created <a href=\"https://github.com/sergiodxa/remix-i18next\">remix-i18next</a>. This library offers similar features and modules as the JavaScript library but focuses on Remix concepts and approaches. Easy to set up and use, production-ready, and without any requirement or dependency. Let’s have a closer look at how to implement i18n into our Remix projects using remix-i18next.</p>\n<p>First of all, we need to install some npm packages:</p>\n<pre><code>npm install remix-i18next i18next react-i18next i18next-browser-languagedetector i18next-http-backend i18next-fs-backend\n</code></pre>\n\n<p>All of them will help us to manage i18n on both the server and the client side of our website. We will also use them to set up our backend and define the logic that will detect the language from the user.</p>\n<p>Now, we should add some configuration that will be used across the website from both the client and the server side. Let’s create a couple of JSON files with the translations of the different character strings that we’ll use on our website:</p>\n<pre><code>{\n  \"intro\": \"Hello everyone!\"\n}\n</code></pre>\n\n<pre><code>{\n  \"intro\": \"Hola a todos!\"\n}\n</code></pre>\n\n<p>By naming the files “common.json”, we’re defining the namespace for the strings that we’ll list in them.</p>\n<p>Now, let’s create a file called <code>i18n.js</code>. This file contains different configuration settings that we’ll use at the moment of initializing our i18n server.</p>\n<pre><code>export default {\n  supportedLngs: [\"en\", \"es\"],\n  fallbackLng: \"en\",\n  defaultNS: \"common\",\n  // Disabling suspense is recommended\n  react: { useSuspense: false },\n};\n</code></pre>\n\n<p>You can see more configuration options in the <a href=\"https://www.i18next.com/overview/configuration-options\">official i18next docs</a>.</p>\n<p>Now, create the file <code>i18next.server.js</code>, which contains logic that will be used in the <code>entry.server.jsx</code> file of our Remix project.</p>\n<div>\n <pre><code>import Backend from \"i18next-fs-backend\";\n    import { resolve } from \"node:path\";\n    import { RemixI18Next } from \"remix-i18next\";\n    import i18n from \"~/i18n\"; // The configuration file we created\n\n    let i18next = new RemixI18Next({\n      detection: {\n        supportedLanguages: i18n.supportedLngs,\n        fallbackLanguage: i18n.fallbackLng,\n      },\n      i18next: {\n        ...i18n,\n        backend: {\n          loadPath: resolve('./public/locales/{{lng}}/{{ns}}.json'),\n        },\n      },\n      backend: Backend,\n    });\n\n    export default i18next;\n</code></pre>\n\nWe’re basically initializing a new i18n server that will run with our Remix backend. We’re specifying the location of the JSON files containing the translations to be used.\n\nLet’s add these features to our main Remix config files. First, we add some logic to be able to translate content client side. To do that, let’s edit our <code>entry.client.jsx</code> file:\n\n<div>\n <pre><code>import i18next from \"i18next\";\nimport LanguageDetector from \"i18next-browser-languagedetector\";\nimport Backend from \"i18next-http-backend\";\nimport { I18nextProvider, initReactI18next } from \"react-i18next\";\nimport { getInitialNamespaces } from \"remix-i18next\";\nimport i18n from \"./i18n\"; // The configuration file we created\n\ni18next\n  .use(initReactI18next)\n  .use(LanguageDetector)\n  .use(Backend)\n  .init({\n    ...i18n, // The same config we created for the server\n    ns: getInitialNamespaces(),\n    backend: {\n      loadPath: \"/locales/{{lng}}/{{ns}}.json\",\n    },\n    detection: {\n      order: [\"htmlTag\"],\n      caches: [],\n    },\n  })\n  .then(() =&gt; {\n    // After i18next init, hydrate the app\n    hydrateRoot(\n      document,\n      // Wrap RemixBrowser in I18nextProvider\n      &lt;I18nextProvider i18n={i18next}&gt;\n        &lt;RemixBrowser /&gt;\n      &lt;/I18nextProvider&gt;\n    );\n  });\n</code></pre>\n</div>\n\n<p>We need to wait to ensure translations are loaded before the hydration in order to keep our web app interactive.</p>\n<p>Let’s add the logic to the <code>entry.server.jsx</code> file now:</p>\n<div>\n <pre><code>import { createInstance } from \"i18next\";\nimport Backend from \"i18next-fs-backend\";\nimport { resolve } from \"node:path\";\nimport { I18nextProvider, initReactI18next } from \"react-i18next\";\nimport i18next from \"./i18next.server\"; // The backend file we created\nimport i18n from \"./i18n\"; // The configuration file we created\n\n...\n\nexport default async function handleRequest(\n...\n) {\n  // We create a new instance of i18next\n  let instance = createInstance();\n\n  // We can detect the specific locale from each request\n  let lng = await i18next.getLocale(request);\n  // The namespaces the routes about to render wants to use\n  let ns = i18next.getRouteNamespaces(remixContext);\n\n  await instance\n    .use(initReactI18next)\n    .use(Backend)\n    .init({\n      ...i18n,// The config we created\n      lng, // The locale we detected from the request\n      ns,\n      backend: {\n        loadPath: resolve(\"./public/locales/{{lng}}/{{ns}}.json\"),\n      },\n    });\n\n  return new Promise((resolve, reject) =&gt; {\n    ...\n\n    let { pipe, abort } = renderToPipeableStream(\n      \n        {\" \"}\n      ,\n      ...\n    );\n    ...\n  });\n}\n</code></pre>\n</div>\n\n<p>Identifying users’ preferred language will allow us, among other things, to redirect them to certain routes.</p>\n<p>Now we can start using the functionalities provided by remix-i18next to detect the user’s locale and deliver translated content based on that. Let’s edit the <code>root.jsx</code> file:</p>\n<pre><code>...\n\nimport { json } from \"@remix-run/node\";\nimport { useChangeLanguage } from \"remix-i18next\";\nimport { useTranslation } from \"react-i18next\";\nimport i18next from \"~/i18next.server\";\n\n...\n\nexport let loader = async ({ request }) =&gt; {\n  let locale = await i18next.getLocale(request);\n  return json({ locale });\n};\n\nexport let handle = {\n  i18n: \"common\",\n};\n\nexport default function App() {\n  // Get the locale from the loader\n  let { locale } = useLoaderData();\n  let { i18n } = useTranslation();\n\n  useChangeLanguage(locale);\n\n  return (\n    &lt;html lang={locale} dir={i18n.dir()}&gt;\n      ...\n    &lt;/html&gt;\n  );\n}\n</code></pre>\n\n<p>The <code>useChangeLanguage</code> hook will change the language of the instance to the locale detected by the loader. Whenever we do something to change the language, this locale will change, and i18next will load the correct translations.</p>\n<p>Now, we are able to translate content in any route:</p>\n<pre><code>import { useTranslation } from \"react-i18next\";\n\nexport default function MyPage() {\n  let { t } = useTranslation();\n  return &lt;h1&gt;{t(\"intro\")}&lt;/h1&gt;;\n}\n</code></pre>\n\n<p>We use the <code>t()</code> function to show translated strings based on the list of messages that we defined in our JSON files. </p>\n<p>In this example, we use one default namespace, but we can set up multiple namespaces if we want. You can read more about the <code>t()</code> function in <a href=\"https://www.i18next.com/overview/api#t\">the official i18next docs</a>.</p>\n<p>In case we want to translate content server side, we can use the <code>getFixedT</code> method inside our loaders and actions:</p>\n<pre><code>import i18next from \"~/i18next.server\";\n\n...\n\nexport let loader = async ({ request }) =&gt; {\n  let t = await i18next.getFixedT(request);\n  let title = t(\"intro\");\n  return json({ title });\n};\n</code></pre>\n\nA Combination Of Remix And CMS\n<p>Together, we explored the available options to implement i18n with Remix. At the beginning of this article, we learned that i18n could result in hugely improved UX and SEOUX, and SEO. As part of UX, it’s also important to include better DX.</p>\n<p>The approach above creates translation files at the source code level. Also, we don’t have the logic to implement identifiers in URLs. To achieve this, let’s look at the approach of integrating a CMS. In this article, we’ll use Storyblok, which offers three different approaches to localizing content and handles to determine the languages and regions.</p>\n<p><strong>Note</strong>: <em>If you want to create the connection between your Remix app and Storyblok, there’s <a href=\"https://www.storyblok.com/tp/headless-cms-remix?utm_source=smashmagazine&amp;utm_medium=article&amp;utm_campaign=i18n_remix_headless_cms\">a 5-minute tutorial</a> that explains just how to do that.</em></p>\n<p>After that, you can quickly clone a starter space by using this magic link to have all the necessary components and field types. This example space covers an approach called folder-level translation. We’ll cover what it is about in the next section.</p>\n<h4>Choose Between Three Approaches</h4>\n<p>Storyblok has three ways to create the layout to store localized content and determine languages and regions.</p>\n<ol>\n<li><a href=\"https://www.storyblok.com/docs/guide/in-depth/internationalization#folder-level-translation?utm_source=smashmagazine&amp;utm_medium=article&amp;utm_campaign=i18n_remix_headless_cms\">Folder-level translation</a>: Divide localized content in folder-level.</li>\n<li><a href=\"https://youtu.be/I228iqqNz0E?t=138\">Field-level translation</a>: Translate in field-type level.</li>\n<li><a href=\"https://www.storyblok.com/docs/guide/in-depth/internationalization#space-level-translation?utm_source=smashmagazine&amp;utm_medium=article&amp;utm_campaign=i18n_remix_headless_cms\">Space-level translation</a>: Dedicate spaces (environments or repositories) into certain localized content.</li>\n</ol>\n<p>To cover the identifiers in URLs, folder-level translation works perfectly, as each folder will only contain relevant localized content.</p>\n<p><img src=\"https://files.smashing.media/articles/internationalization-i18n-right-remix-headless-cms-storyblok/2-storyblok-folder-level-translation.png\" /></p>\n<p>Also, identifiers can be modified from the folder settings via the slug.</p>\n<p><img src=\"https://files.smashing.media/articles/internationalization-i18n-right-remix-headless-cms-storyblok/3-storyblok-folder-settings.png\" /></p>\n<p>By modifying the slug from the folder settings screen, this localized identifier in the URL appears in all stories inside this Japanese folder. For example, the about page inside of the Japanese folder already has a localized identifier in the URL.</p>\n<p><img src=\"https://files.smashing.media/articles/internationalization-i18n-right-remix-headless-cms-storyblok/4-storyblok-page-teaser.png\" /></p>\n<p>To programmatically generate content pages, Remix has a feature called <a href=\"https://remix.run/docs/en/v1/guides/routing#splats\">Splats</a>, catching all slugs regardless of the nested levels. Naming a file <code>$.jsx</code> will enable the catch-all slug fundamental function.</p>\n<pre><code>app\n├── root.jsx\n└── routes\n    ├── files\n    │   └── $.jsx\n    └── files.jsx\n</code></pre>\n\n<p>The difference between <a href=\"https://remix.run/docs/en/v1/guides/routing#dynamic-segments\">dynamic segments</a> from Remix is that splats still match at the next <code>/</code>. Therefore, splats will capture everything in the path. If the URL path is <code>hello.com/ja/about/something</code>, the splat route has a special param to capture the trailing segments of the URL. </p>\n<pre><code>export async function loader({ params }) {\n  params[\"*\"]; // \"ja/about/something\"\n}\n</code></pre>\n\n<p>Using the splat route’s special param, let’s edit <code>$.jsx</code> file.</p>\n<div>\n <pre><code>export default function Page() {\n // useLoaderData returns JSON parsed data from loader func\n let story = useLoaderData();\n story = useStoryblokState(story, {\n   resolveRelations: [\"featured-posts.posts\", \"selected-posts.posts\"]\n });\n return &lt;StoryblokComponent blok={story.content} /&gt;\n};\n// loader is Backend API &amp; Wired up through useLoaderData\nexport const loader = async ({ params, preview = false }) =&gt; {\n let slug = params[\"*\"] ?? \"home\";\n slug = slug.endsWith(\"/\") ? slug.slice(0, -1) : slug;\n let sbParams = {\n   version: \"draft\",\n   resolve_relations: [\"featured-posts.posts\", \"selected-posts.posts\"],\n };\n // …\n let { data } = await getStoryblokApi().get(<code>cdn/stories/${slug}</code>,\n sbParams);\n return json(data?.story, preview);\n};\n</code></pre>\n</div>\n\n<p><strong>HINT</strong>: <em>In the section “Choose between 3 approaches”, we didn’t cover all three approaches, but if you’d like to know more, all approaches are documented below.</em></p>\nSummary\n<p>We learned together the facts and statistics to know the impacts and the importance of i18n and saw how Remix handles several options to implement advanced i18n. Interestingly, a better i18n experience provides better SEO and UX. Hopefully, this article provided you with new knowledge and insightful learnings.</p>\n<ul>\n<li>“<a href=\"https://www.storyblok.com/docs/guide/in-depth/internationalization?utm_source=smashmagazine&amp;utm_medium=article&amp;utm_campaign=i18n_remix_headless_cms\">Internationalization</a>,” Storyblok Docs</li>\n<li><a href=\"https://portal.gitnation.org/contents/lets-remix-to-localize-content-1072\">Video version of this article</a></li>\n<li><a href=\"https://remix.run/docs/en/v1\">Remix docs</a></li>\n<li><a href=\"https://github.com/sergiodxa/remix-i18next\">remix-i18next</a></li>\n<li><a href=\"https://www.storyblok.com/docs/guide/introduction?utm_source=smashmagazine&amp;utm_medium=article&amp;utm_campaign=i18n_remix_headless_cms\">Storyblok docs</a></li>\n</ul>\n</div>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"8a0865e6467556ca500c4737827ae1a70a31026a8f661714a8378602a06511eb","category":"Tech"}