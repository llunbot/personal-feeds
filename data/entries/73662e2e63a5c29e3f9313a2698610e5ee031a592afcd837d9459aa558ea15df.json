{"title":"Terraform apply as code: The multispace pattern","link":"https://www.hashicorp.com/blog/terraform-apply-as-code-the-multispace-pattern","date":1689004800000,"content":"<p>When working with Terraform, <a href=\"https://developer.hashicorp.com/terraform/cloud-docs/recommended-practices/part1\">HashiCorp recommends</a> keeping your workspaces small and focused on the resources that make up a single component of a larger infrastructure stack. Doing so has many benefits, but this best practice can introduce dependencies between workspaces, which in turn introduces a new challenge: how do you ensure that these interdependent component workspaces are automatically created (or destroyed) in the right order?</p>\n\n<p>I wrote this blog post to present a pattern to reduce operational overhead from managing multi-workspace deployments. When combined with <a href=\"https://www.hashicorp.com/blog/new-terraform-cloud-capabilities-to-import-view-and-manage-infrastructure\">ephemeral workspaces</a>, a feature coming soon to Terraform Cloud, this pattern can also help reduce costs by allowing you to destroy an entire stack of workspaces in a logical order. I’m a HashiCorp Solutions Engineer who uses this pattern frequently, and it's used by Terraform creator and HashiCorp Co-Founder Mitchell Hashimoto, and many others.</p>\n\n<p><strong>Notes:</strong> <em>This method is not an official HashiCorp-recommended best practice and is not intended to be the solution to all use cases. Rather, it’s just one example to explore and build upon. This blog post also includes a simpler solution to the challenge above, which should work for a large number of use cases. While this blog post was written with Terraform Cloud in mind, the same concepts and configuration will also work in Terraform Enterprise as well, depending on your version. Finally, the suggestions presented here all assume a basic understanding of Terraform Cloud, and you can try out the code examples yourself in this <a href=\"https://github.com/hashi-strawb/multispace-example\">GitHub repository</a>.</em></p>\n\n<h2>Workspaces, run triggers, and the Terraform Cloud/Enterprise provider</h2>\n\n<p>A <a href=\"https://developer.hashicorp.com/terraform/cloud-docs/workspaces\">workspace</a> in Terraform Cloud contains everything Terraform needs to manage a given collection of infrastructure, including variables, state, configuration, and credentials. For example, you may have one workspace that defines your virtual network and another for compute. These workspaces depend on each other; you cannot create your compute until you have a virtual network. The outputs from one workspace become the inputs to another.</p>\n\n<p>Terraform Cloud has a feature called <a href=\"https://developer.hashicorp.com/terraform/cloud-docs/workspaces/settings/run-triggers\">run triggers</a>. This allows you to kick off an <em>apply</em> on your compute workspace after your virtual network has been created. You can also define a one-to-many relationship here, where the successful apply on one upstream workspace triggers multiple downstream workspaces.</p>\n<img src=\"https://www.datocms-assets.com/2885/1688759076-multispace_blog-d1-1-up-many-down.png\" alt=\"1\" /><p>This alone solves some dependency challenges and is great for simple workflows. If it works for your use case, you should use it.</p>\n\n<p>However, it doesn’t address all situations, which is why Mitchell Hashimoto created the <a href=\"https://registry.terraform.io/providers/mitchellh/multispace/latest/docs\">multispace provider</a> to handle the kind of cascading creation/destruction workflows that can’t be done with simple run triggers. His example use case involves creating a Kubernetes stack: first you create the underlying virtual machines, then the core kubernetes services, DNS, and ingress. Each of these is its own separate workspace.</p>\n\n<p>This initial implementation has since been refined and incorporated into the official Terraform Cloud/Enterprise provider (also called the “TFE provider”) in the form of the <a href=\"https://registry.terraform.io/providers/hashicorp/tfe/latest/docs/resources/workspace_run\"><code>tfe_workspace_run</code></a> resource.</p>\n\n<p>For clarity, this post uses the following terminology when referring to the roles a workspace could have in multi-workspace deployments (an individual workspace may have one or more of these roles):</p>\n\n<ul>\n<li><strong>Upstream workspace:</strong> This is a workspace that must run first, and is depended upon in some way by a downstream workspace</li>\n<li><strong>Downstream workspace:</strong> This is a workspace that runs second, because it has some dependency on the upstream workspace</li>\n<li><strong>Workspace runner:</strong> This is a workspace responsible for triggering runs on other workspaces with the <code>tfe_workspace_run</code> resource.</li>\n<li><strong>Workspace creator:</strong> This is a workspace responsible for creating other workspaces with the <code>tfe_workspace</code> resource. This is usually also a workspace runner in my use cases, but it may not be a requirement for yours.</li>\n</ul>\n<img src=\"https://www.datocms-assets.com/2885/1688759071-multispace_blog-d2-terminology.png\" alt=\"Terminology\" /><h3>Applies</h3>\n\n<p>Here’s an example of how run triggers and <code>tfe_workspace_run</code> differ: run triggers will always kick off a plan on the downstream workspace once the upstream workspace has completed a successful apply. Sometimes this results in plans on the downstream workspace that are unnecessary (in the case of a do-nothing plan) or that fail (when a downstream workspace has a dependency on multiple upstream workspaces but some upstream workspaces haven’t yet completed their applies).</p>\n\n<p>With <code>tfe_workspace_run</code> you can specify when to apply and under what circumstance. For example, with <a href=\"https://developer.hashicorp.com/terraform/language/meta-arguments/depends_on\"><code>depends_on</code></a>, a workspace runner could wait until several upstream workspaces have applied before kicking off the downstream workspace. If that is the only benefit relevant to you, chances are that run triggers are probably good enough for your use case; you’re probably fine with a do-nothing or failed plan every now and then.</p>\n<img src=\"https://www.datocms-assets.com/2885/1688759066-multispace_blog-d3-many-up-1-down.png\" alt=\"Many\" /><p>You can use the <code>tfe_workspace_run</code> resource in two operational modes:</p>\n\n<p><strong>Fire-and-forget</strong>: The resource simply queues a run on the downstream workspace and considers it good enough if the run was successfully queued. This mode is very similar to how run triggers work.</p>\n<img src=\"https://www.datocms-assets.com/2885/1688759056-multispace_blog-d5-fire-forget.png\" alt=\"Fire\" /><p><strong>Wait</strong>: The resource queues a run on the downstream workspace and waits for it to successfully apply. After a successful plan, the resource can wait for a human approval on the apply or initiate the apply itself. Optionally, the resource can retry if the apply fails.</p>\n<img src=\"https://www.datocms-assets.com/2885/1688759061-multispace_blog-d4-wait.png\" alt=\"Wait\" /><h3>Destroys</h3>\n\n<p>Run triggers do one thing: they trigger applies on downstream workspaces, and they do it only after the upstream has completed successfully. They do not handle destruction use cases. For example, you should destroy your compute before destroying your virtual network, and run triggers do not give you a means to model that side of the dependency.</p>\n\n<p>This is where the real power of <code>tfe_workspace_run</code> comes in. The resource allows you to kick off a destroy on a downstream workspace and, if you’re using <code>depends_on</code>, you can ensure that nothing in the upstream workspace is destroyed until the downstream workspace has successfully finished its destroy.</p>\n\n<h3>Apply-only and destroy-only</h3>\n\n<p>While you can configure both the apply and destroy behavior for the downstream workspace, you don’t need to use both. There are cases where you only want to apply a downstream workspace. There are also times where you only want to destroy a downstream workspace, but you will trigger an apply yourself.</p>\n\n<h2>tfe<em>workspace</em>run in action</h2>\n\n<p>The <a href=\"https://registry.terraform.io/providers/hashicorp/tfe/latest/docs/resources/workspace_run\"><code>tfe_workspace_run resource</code></a> documentation on the Terraform Registry includes a few example code snippets to use as a starting point. At its most basic, the resource looks like this:</p>\n<pre><code>resource \"tfe_workspace_run\" \"ws_run_parent\" {\n  workspace_id = \"ws-fSX576JZGENVaeMi\"\n\n  apply {\n    # tfe_workspace_run is responsible for approving the apply part of the run\n    # this is the only required argument in the apply{} and destroy{} blocks\n    manual_confirm    = false\n\n    # if the run fails, try again, up to 3 times, waiting between 1 and 30 seconds\n    # this is the default behaviour, presented here for clarity\n    wait_for_run      = true\n    retry_attempts    = 3\n    retry_backoff_min = 1\n    retry_backoff_max = 30\n  }\n\n  destroy {\n    manual_confirm    = false\n  }\n}</code></pre><p>This example shows what’s meant by a <em>workspace runner</em>. For the specified workspace, our <code>tfe_workspace_run</code> resource will trigger an apply, wait for that to complete, then consider the <code>tfe_workspace_run</code> successfully created. On destroy, the <code>tfe_workspace_run</code> will trigger a destroy, wait for that to complete, then consider the <code>tfe_workspace_run</code> successfully destroyed.</p>\n\n<p>Because we are using the TFE provider, the workspace runner requires a <code>TFE_TOKEN</code> with sufficient permissions to kick off plan/apply/destroy runs on child workspaces. (You may wish to use the <a href=\"https://developer.hashicorp.com/vault/tutorials/secrets-management/terraform-secrets-engine\">Terraform Cloud secrets engine</a> in HashiCorp Vault to generate these, but that is out-of-scope for this blog post.)</p>\n\n<p>Beyond the basic examples, this post will present a few patterns with example configuration for how to use this resource.</p>\n\n<h2>Apply (fire and forget) and destroy (wait)</h2>\n\n<p>The <code>tfe_workspace_run</code> resource is most useful when creating new workspaces. This example uses the TFE provider to create a workspace, set up all the necessary permissions, and configure the <a href=\"https://developer.hashicorp.com/terraform/tutorials/cloud/dynamic-credentials\">dynamic credentials</a>. All of that must be done before the workspace can be applied. </p>\n\n<p>As a reminder, the term “workspace creator” refers to any workspace responsible for creating other workspaces and related resources. In most cases when using a workspace creator, it will also be a workspace runner for the workspaces it creates (i.e. it is responsible for triggering applies and/or destroys on those workspaces).</p>\n<pre><code>resource \"tfe_workspace_run\" \"downstream\" {\n  workspace_id = tfe_workspace.downstream.id\n\n  # depends_on = creds and other workspace dependencies go here\n\n  apply {\n    # Fire and Forget\n    wait_for_run = false\n    # auto-apply\n    manual_confirm = false\n  }\n\n  destroy {\n    # Wait for destroy before doing anything else\n    wait_for_run = true\n    # auto-apply\n    manual_confirm = false\n  }\n}</code></pre><p>From the perspective of the workspace runner, it doesn’t need to care if the downstream workspace was successfully applied, just that an apply was attempted. This functionality alone is achievable with run triggers (and in this fire-and-forget mode, the behavior is very similar), but as this example is already using <code>tfe_workspace_run</code> to handle the destroy, it makes sense to use it for the apply as well.</p>\n<img src=\"https://www.datocms-assets.com/2885/1688759848-multispace_blog-s1-apply.png\" alt=\"Apply\" /><p>By including the <code>destroy{}</code> block in combination with <code>depends_on</code>, you can ensure that the workspace and supporting resources remain untouched until the downstream workspace has successfully destroyed all the resources it manages.</p>\n\n<p>If you do not include a <code>destroy{}</code> block, then attempting to delete the downstream workspace will result in an error like this:</p>\n<pre><code>╷\n│ Error: error deleting workspace ws-BxxKPnyBVpxwVQB1: This workspace has 4 resources under management and must be force deleted by setting force_delete = true\n│\n│\n╵</code></pre><p>If you do not include the <code>depends_on</code>, then dependencies such as variables and credentials that the downstream workspace needs will end up getting deleted too early.</p>\n<img src=\"https://www.datocms-assets.com/2885/1688760010-multispace_blog-s2-destroy.png\" alt=\"Destroy\" /><p>The upcoming <a href=\"https://www.hashicorp.com/blog/new-terraform-cloud-capabilities-to-import-view-and-manage-infrastructure\">ephemeral workspaces</a> will ensure the entire stack of workspaces is safely destroyed in the correct order once the ephemeral workspace hits its time-to-live (TTL).</p>\n\n<h2>Destroy-only workflows</h2>\n\n<p>This is a pattern I use extensively in my workspace creator. As a reminder, this is a “workspace runner” (i.e. a workspace which triggers runs on other workspaces). In my case, when creating a new workspace, I don’t necessarily want it to try to apply immediately, so my configuration looks like this:</p>\n<pre><code>resource \"tfe_workspace_run\" \"downstream\" {\n  workspace_id = tfe_workspace.downstream.id\n\n  # depends_on = creds and other workspace dependencies go here\n\n  destroy {\n    wait_for_run = true\n    manual_confirm = false\n  }\n}</code></pre><p>The only difference between this and the previous example is the absence of the <code>apply{}</code> block. This means that when doing an apply on the workspace runner, Terraform will create a placeholder resource referencing a non-existent apply on the downstream workspace. This may seem pointless as nothing has actually been done yet, but the presence of this resource in Terraform state signals to Terraform that, when it comes time to destroy the workspace runner, it should first kick off a destroy on the downstream workspace.</p>\n\n<p>Similarly, you can also have an apply-only workflow by including an <code>apply{}</code> block but no <code>destroy{}</code>. For most use cases, an <code>apply{}</code> block with no <code>destroy{}</code> block is practically identical to just using run triggers.  If it is, then just use run triggers. But for some niche use-cases, you may want to conditionally apply, which run triggers does not allow you to do.</p>\n\n<h2>What if there are more than two workspaces?</h2>\n\n<p>This is the main reason for the concept of a workspace runner separate from the idea of an upstream workspace. The previous examples have a single upstream workspace for every downstream workspace. In cases like that, introducing an additional workspace runner just adds unnecessary complexity; the upstream can handle the runner functionality.</p>\n\n<p>Workspace runners become useful in cases where there are more than two workspaces. While upstream workspaces can handle the runner role functionally, if you have applies or destroys configured to wait for completion, then you’ll have more workspaces in your stack, which results in more concurrent runs. If you have too many, the queue will fill up, and you’ll end up in a deadlock, where downstream workspaces are queued but can never begin, and upstream workspaces are waiting on those downstream workspace runs.</p>\n\n<p>By introducing a separate workspace runner, you can ensure you need to consume only two concurrency slots: one for the runner, and one for whichever other workspace it is currently running.</p>\n\n<p>Some examples, first a simple one, then a complex one:</p>\n<img src=\"https://www.datocms-assets.com/2885/1688759049-multispace_blog-d6-chain.png\" alt=\"Chain\" /><pre><code>resource \"tfe_workspace_run\" \"A\" {\n  workspace_id = data.tfe_workspace.ws[\"A\"].id\n\n  apply {\n    wait_for_run   = true\n    manual_confirm = false\n  }\n\n  destroy {\n    wait_for_run   = true\n    manual_confirm = false\n  }\n}\n\nresource \"tfe_workspace_run\" \"B\" {\n  workspace_id = data.tfe_workspace.ws[\"B\"].id\n\n  depends_on = [tfe_workspace_run.A]\n\n  apply {\n    wait_for_run   = true\n    manual_confirm = false\n  }\n\n  destroy {\n    wait_for_run   = true\n    manual_confirm = false\n  }\n}\n\nresource \"tfe_workspace_run\" \"C\" {\n  workspace_id = data.tfe_workspace.ws[\"C\"].id\n\n  depends_on = [tfe_workspace_run.B]\n\n  apply {\n    wait_for_run   = true\n    manual_confirm = false\n  }\n\n  destroy {\n    wait_for_run   = true\n    manual_confirm = false\n  }\n}</code></pre><ul>\n<li>In this example, to apply, the workspace runner queues a run on A, waits for it to complete, queues a run on B, waits for it to complete, then queues a run on C.</li>\n<li>If you care only about applies, this is a perfect use case for run triggers.</li>\n<li>To destroy, the workspace runner queues a run on C first, then B, then A.</li>\n</ul>\n\n<p>Of course, there’s no reason you’re limited to each workspace having one upstream or one downstream. You may have a complex web of dependencies between your workspaces. Here’s as example (with the code in the repo linked at the end of the post):</p>\n<img src=\"https://www.datocms-assets.com/2885/1688759082-multispace_blog-d7-mesh.png\" alt=\"Mesh\" /><ul>\n<li>Whether or not there’s an actual real-world use case for this precise graph of workspace dependencies, it serves as a good example of the complexity you can end up with.</li>\n<li>In this example, the workspace runner queues runs on U1, U2, and U3.</li>\n<li>If there are spare concurrency slots, all three will run concurrently. If not, at least one will wait in the queue.</li>\n<li>Once all three have finished, then the workspace runner queues runs on D1, D2, and D3.</li>\n<li>Again, if you just care about applies, run triggers would work, but you would get a lot of failed plans because U1, U2, and U3 finish at different times.</li>\n<li>To destroy, the workspace runner queues a run on D1, D2, and D3 first, then U1, U2, and U3.</li>\n</ul>\n\n<h1>Summary</h1>\n\n<p>The resource required to power this workflow is now an official, supported part of the TFE provider. As more people make use of <code>tfe_workspace_run</code> and give feedback, HashiCorp can continue to improve the resource.</p>\n\n<p>If you aren’t already using Terraform Cloud, you’ll want to experiment with that first. Start for free by <a href=\"https://app.terraform.io/public/signup/account\">signing up for an account</a>.</p>\n\n<p>Please note that to avoid hitting concurrency limits on the Free tier of Terraform Cloud, you can:</p>\n\n<ul>\n<li>Use only run triggers or <code>tfe_workspace_run</code> in fire-and-forget mode.</li>\n<li>Ensure the workspace runner is running in local mode if you plan to use <code>tfe_workspace_run</code> in wait mode.</li>\n<li>Upgrade to a paid subscription to increase your concurrency limits.</li>\n</ul>\n\n<p>If you are an existing Terraform Cloud user, then experiment with these patterns. Regardless of whether you’re using run triggers or <code>tfe_workspace_run</code>, automating the dependencies between workspaces will save you time and effort.</p>\n\n<p>As mentioned at the beginning of the post, you can find these code examples in <a href=\"https://github.com/hashi-strawb/multispace-example\">this GitHub repository</a>.</p>\n","author":"Lucy Davinhart","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"73662e2e63a5c29e3f9313a2698610e5ee031a592afcd837d9459aa558ea15df","category":"Tech"}