{"title":"Recovering Deleted Files From Your Git Working Tree","link":"https://smashingmagazine.com/2023/12/recovering-deleted-files-git-working-tree/","date":1701424800000,"content":"<p>There are times when mistakes happen, and useful and important files are deleted by error or lost from your file system irrevocably (or seemingly, at least). Version control systems make it difficult to permanently lose files, provided they have been either added to staging or committed to a remote repository, because Git allows you to undo or revert changes and access previous versions of the saved files.</p>\n<p>It is also possible to erroneously erase files from both the working directory and the Git repository. I’ve certainly done that! I imagine you have, too, if you’re reading this, and if that’s the case, then you will need a way to recover those files.</p>\n<p>I have a few methods and strategies you can use to recover your deleted files. Some are more obvious than others, and some are designed for very specific situations. And while it is indeed possible to irrevocably lose a file, even then, you may have a path to at least recover a copy of it with third-party software if it comes to that.</p>\nHow Git Works With Files\n<p>Before we dive into all of that, let’s explore how your files journey from your local computer to your remote repository. </p>\n<p>Your files are initially only located on your computer’s storage, known as your <strong>working tree</strong> or <strong>working directory</strong>, and Git has no idea they exist yet. At this point, they are at their most vulnerable state since they are untracked.</p>\n<p>Adding files to the staging area — also known as the index — so that Git is aware of them is what the <code>git add &lt;filename&gt;</code> (or <code>git add -A</code> for all files) is for. What actually happens under the hood when pushing files to staging is that Git hashes the content and <a href=\"https://git-scm.com/book/en/v2/Git-Internals-Git-Objects\">creates a blob for each file</a> based on the file’s content and proceeds to store them in the <code>/objects</code> subdirectory located at <code>.git/objects</code>. Run <code>git status</code> to confirm that the files you want to commit have been added to your staging area.</p>\n<p><img src=\"https://files.smashing.media/articles/recovering-deleted-files-git-working-tree/1-git-hashing-storing-file-blob-git-objectsp-directory.jpg\" /></p>\n<p>Once the files are staged, Git is at least aware of them, and we can include them in commits. When including a file in a commit, Git creates a new tree object to represent the state of the repository at the time the commit happens. The tree object contains the following information:</p>\n<ul>\n<li>SHA-1 hash of the tree object that represents the state of the repository;</li>\n<li>SHA-1 hash of the commit’s parent commit object if it has a parent;</li>\n<li>Author and committer information;</li>\n<li>Commit message.</li>\n</ul>\n<p>It’s at this point that the files are <code>git push</code>-ed to the remote repo, wherever you happen to be hosting it, whether it’s GitHub, Beanstalk, Bitbucket, or whatever.</p>\n<p><img src=\"https://files.smashing.media/articles/recovering-deleted-files-git-working-tree/2-file-journey-local-computer-remote-repo.jpg\" /></p>\nHow Files Can Get Deleted From A Working Tree\n<p>So, the key pieces we’re talking about are your project’s <em>working tree</em>, <em>staging area</em> and <em>commit</em>. It is possible for files to be deleted at any one of these points, but it’s the working tree where it is most irreversible, or at least tough, to restore a lost file.</p>\n<p>There are some very specific Git commands or actions that tend to be the biggest culprits when a file is deleted from the working tree.</p>\n<h3><code>git rm</code></h3>\n<p>I’m sure you have seen this one before. It’s a command for <em>removing</em> (<code>rm</code>) files from the working tree. It might be the most commonly used command for deleting files. </p>\n<h3><code>git reset</code></h3>\n<p>Anytime a reset happens, it’s very possible to lose any files you’ve been working on. <a href=\"https://www.git-scm.com/docs/git-reset\">But there are two types of Git resets</a> that make this possible:</p>\n<ol>\n<li><strong><code>git reset --hard</code></strong><br />This command is sort of a nuclear path for resetting a working tree and the staging area. If you’ve made any changes to tracked files, those will be lost. That goes for commits, too, which are discarded altogether. In fact, <em>any</em> files or directories that are not in the HEAD commit are removed from the working tree.</li>\n<li><strong><code>git reset &lt;filename&gt;</code></strong><br />This is a lot less damaging than a hard reset, but it does indeed remove the specified file from the working tree. But it’s worth mentioning that <em>the file is not pulled out from the staging area</em>. So there’s a path back, which we’ll get to.</li>\n</ol>\n<h3><code>git clean</code></h3>\n<p>This <a href=\"https://www.git-scm.com/docs/git-clean\">removes untracked files</a> from the working tree. Untracked files are not in the Git staging area and are not really part of the repository. They’re typically temporary files or files that have not yet been added to the repository.</p>\n<p>One key distinction with a clean command is that it will not remove files that are included in a project’s <code>.gitignore</code> file, nor will it remove files that have been added to the staging area, nor ones that have already been committed. This can be useful for cleaning up your working tree after you have finished working on a project and you want to remove all of the temporary files that you created.</p>\n<p>Like <code>git reset</code>, there are different variations of <code>git clean</code> that remove files in different ways:</p>\n<ul>\n<li><strong><code>git clean &lt;filename&gt;</code></strong><br />Used to remove specific files from the working tree.</li>\n<li><strong><code>git clean -d</code></strong><br />Removes untracked files from a specific directory.</li>\n<li><strong><code>git clean -i</code></strong><br />This one interactively removes files from the working tree. And by that, I mean you will be prompted to confirm removal before it happens, which is a nice safeguard against accidents.</li>\n<li><strong><code>git clean -n</code></strong><br />This is a dry run option and will show you the files that would be removed if you were to run the original <code>git clean</code> command. In other words, it doesn’t actually remove anything but lets you know what would be removed if you were to run an actual clean.</li>\n<li><strong><code>git clean -f</code></strong><br />This one <em>forces</em> the <code>git clean</code> command to remove all untracked files from the working tree, even if they are ignored by the <code>.gitignore</code> file. It’s pretty heavy-handed.</li>\n<li><strong><code>git clean -f -d</code></strong><br />Running this command is a lot like <code>git clean --f</code> but wipes out directories as well.</li>\n<li><strong><code>git clean -x</code></strong><br />This removes all untracked files, including build products. It is best used when you want to wipe your working tree clean and test a fresh build.</li>\n<li><strong><code>git clean -X</code></strong><br />This only removes files ignored by git.</li>\n</ul>\n<p>Of course, I’m merely summarizing what you can already find in <a href=\"https://www.git-scm.com/docs/git-clean\">Git’s documentation</a>. That’s where you can get the best information about the specific details and nuances of <code>git clean</code> and its variants.</p>\nManually Removing Files\n<p>Yes, it’s possible! You can manually delete the files and directories from your working tree using your computer’s file manager. The good news, however, is that this will <em>not</em> remove the files from the staging area. Also, it’s quite possible you can undo that action with a simple CMD + Z/CTRL + Z if no other action has happened.</p>\n<p>It is important to note that <strong>manually removing files from the working tree is a destructive operation</strong>. Once you have removed a file from the working tree that has not been added to a commit, it is almost impossible to undo the operation completely from a Git perspective. As a result, it is crucial to make sure that you really want to remove a file before you go this route.</p>\n<p>But mistakes happen! So, let’s look at a variety of commands, strategies, and — if needed — apps that could reasonably recover deleted files from a working directory.</p>\nHow Files Can Be Recovered After Being Deleted\n<p>Git commands like <code>git checkout</code>, <code>git reset</code>, <code>git restore</code>, and <code>git reflog</code> can be helpful for restoring files that you have either previously added to the staging area or committed to your repository.</p>\n<h3><code>git checkout</code></h3>\n<p><strong>If you have not committed the changes that deleted the files and directories,</strong> then you can use the <code>git checkout</code> command to checkout a previous commit, branch, or tag. This will overwrite the working tree with the contents of the specific commit, branch, or tag, and any deleted files and directories will be restored.</p>\n<pre><code>git checkout HEAD~ &lt;filename&gt;\n</code></pre> \n\n<p>That will take things back to the last commit that was made. But let’s say you’ve made several commits since the file was deleted. If that’s the case, try checking out a specific commit by providing that commit’s hash:</p>\n<pre><code>git checkout &lt;commit-hash&gt; &lt;filename&gt;\n</code></pre>\n\n<p>Oh, you’re not sure which file it is, or there are more files than you want to type out? You can check out the entire working tree by committing the filename:</p>\n<pre><code>git checkout &lt;commit-hash&gt;\n</code></pre>\n\n<h3><code>git reset</code></h3>\n<p><strong>If you have committed the changes that deleted the files and directories,</strong> then you can use the <code>git reset</code> command to reset the HEAD pointer to a previous commit. This will also overwrite the working tree with the contents of the specific commit, and any deleted files and directories will be restored in the process.</p>\n<pre><code>git reset &lt;commit-hash&gt;\n</code></pre>\n\n<h3><code>git restore</code></h3>\n<p><strong>If you want to restore deleted files and directories without overwriting the working tree,</strong> then you can use the <code>git restore</code> command. This command restores files and directories deleted from the staging area or the working tree. Note that it only works for tracked files, meaning that any files that weren’t <code>git add</code>-ed to the working tree are excluded.</p>\n<pre><code>git restore --staged &lt;filename&gt;\n</code></pre>\n\n<p>To jump back one commit, you could go back to the <code>--worktree</code> instead of the staging area:</p>\n<pre><code>git restore --worktree &lt;filename&gt;\n</code></pre>\n\n<p>And, of course, leave out the filename if you want to restore all files in the working tree from the previous commit:</p>\n<pre><code>git restore --worktree\n</code></pre>\n\n<p>Another option is to restore all of the files in the current directory:</p>\n<pre><code>git restore .\n</code></pre>\n\n<h3><code>git reflog</code></h3>\n<p>There’s also the <code>git reflog</code> command, which shows a history of all recent HEAD movements. I like this as a way to identify the commit that you want to <code>checkout</code> or <code>reset</code> to.</p>\n<pre><code>git reflog\n</code></pre>\n\n\n\nLast Resorts\n<p>When files that are neither present in the staging area nor committed are deleted from the working tree, it is commonly accepted that those files are gone forever — or <em>oti lor</em> as we say in Yoruba — without any hope of recovery. So, if for any reason or by error, you delete important files from your project’s working tree without ensuring that they are either in the staging area or have been previously committed, then you may be thinking all hope of getting them back is lost.</p>\n<p>But I can assure you, based on my experiences in this situation, that it is usually possible to recover all or most of a project’s lost files. There are two approaches I normally take.</p>\n<h3>File Recovery Apps</h3>\n<p>File recovery tools can recover lost or deleted data from your storage devices. They work by running a deep scan of your device in an attempt to find every file and folder that has ever existed on your storage device, including deleted and lost files and folders. Once the files have all been found, you can then use the data recovery tool to restore/recover the files of your choice to a new location.</p>\n<p><strong>Note</strong>: <em>Some of the deleted and lost files found may be corrupted and damaged or not found at all, but I am certain from my experience using them that the majority will be found without any corruption or damage.</em></p>\n<p>There are a variety of file recovery tools available, and the “right” one is largely a subjective matter. I could spend an entire post exclusively on the various options, but I’ve selected a few that I have used and feel comfortable at least suggesting as options to look into.</p>\n<p><a href=\"https://recoverit.wondershare.com\"><strong>Wondershare Recoverit</strong></a> is capable of recovering more than 1,000 file formats. Its free tier option allows you to run a scan to find files on your computer’s storage, but to actually recover the files, you will have to do a paid upgrade to one of its paid plans starting at a $69.99 annual subscription or a one-time $119.99 license. There’s a premium plan for more enhanced recovery methods for things like videos and files, as well as fixing corrupted files that go well beyond the basic need of recovering a single lost file.</p>\n<ul>\n<li><strong>Pros:</strong> High success rate, free tech support, allows partition recovery.</li>\n<li><strong>Cons:</strong> Free tier is extremely limited.</li>\n</ul>\n<p><a href=\"https://www.easeus.com/data-recovery-software/\"><strong>EaseUS Data Recovery Wizard</strong></a> is perhaps one of the most popular tools out of what’s available. Its free tier option is quite robust, running a deep scan and recovering up to 2GB of data. The difference between that and its paid subscription (starting at $119.95 per year, $169.95 lifetime) is that the paid tier recovers an unlimited amount of data.</p>\n<ul>\n<li><strong>Pros:</strong> Fast deep scans, file preview before recovery, easy to use, generous free tier.</li>\n<li><strong>Cons:</strong> Paid plans are significantly more expensive than other tools, Windows and macOS versions are vastly different, and the macOS software is even more expensive.</li>\n</ul>\n<p><a href=\"https://dmde.com\"><strong>DM Disk Editor</strong></a> (DMDE) makes use of a special algorithm that reconstructs directory structures and recovers files by their <a href=\"https://dmde.com/manual/fullscan.html#raw\">file signature</a> when recovering solely by the file system proves impossible. DMDE also offers a free tier option, but it is quite limited as you can only recover files from the directory you have selected, and it only recovers up to 4,000 files at a time. Compare that to its paid versions that allow unlimited and unrestricted data recovery. Paid plans start at $20 per year but scale up to $133 per year for more advanced needs that are likely beyond the scope of what you need.</p>\n<ul>\n<li><strong>Pros:</strong> High recovery success rate, generous free tier, reasonable paid tiers if needed.</li>\n<li><strong>Cons:</strong> I personally find the UI to be more difficult to navigate than other apps.</li>\n</ul>\n<table>\n    <thead>\n        <tr>\n            <th>Software</th>\n            <th>Operating Systems supported</th>\n      <th>Starting price</th>\n      <th>File types and formats supported</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td><strong>Wondershare Recoverit</strong></td>\n            <td>Windows, Mac, Linux(Premium)</td>\n      <td>$69.99/year</td>\n      <td>1000+ file types and formats</td>\n        </tr>\n        <tr>\n            <td><strong>EaseUS</strong></td>\n            <td>Windows, Mac</td>\n      <td>$99.95/year (Windows), $119.95/year (Mac)</td>\n      <td>1000+ file types and formats</td>\n        </tr>\n        <tr>\n            <td><strong>DMDE</strong></td>\n            <td>Windows, Mac, Linux, DOS</td>\n      <td>$20/year</td>\n      <td>Supports basic file formats. Does not support raw photo files.</td>\n        </tr>\n    </tbody>\n</table>\n\n<p>As I said, there are many, many more options out there. If you’re reading this and have a favorite app that you use to recover lost files, then please share it in the comments. The more, the merrier!</p>\n<h3>Last Resort: <code>git fsck</code></h3>\n<p><strong>First off, the <code>git fsck</code> command can be dangerous if used incorrectly.</strong> It is essential to make sure that you understand how to use the command before using it to recover files from the working tree. If you are unsure how to proceed after reading this section, then it is a good idea to consult the <a href=\"https://git-scm.com/docs/git-fsck\">Git documentation</a> for additional details on how it is used and when it is best to use it.</p>\n<p>That said, <code>git fsck</code> can indeed recover files lost from the working tree in Git and maybe your absolute last resort. It works by scanning the Git repository for “dangling” objects, which are objects that are not referenced by any commit. The Git docs <a href=\"https://git-scm.com/docs/gitglossary/#Documentation/gitglossary.txt-aiddefdanglingobjectadanglingobject\">define it</a> like this:</p>\n<blockquote><strong><code>dangling object</code></strong>:<br /><br />“An <a href=\"https://git-scm.com/docs/gitglossary/#def_unreachable_object\">unreachable object</a> that is not <a href=\"https://git-scm.com/docs/gitglossary/#def_reachable\">reachable</a> even from other unreachable objects; a dangling object has no references to it from any reference or <a href=\"https://git-scm.com/docs/gitglossary/#def_object\">object</a> in the <a href=\"https://git-scm.com/docs/gitglossary/#def_repository\">repository</a>.”</blockquote>\n\n<p>This can happen if a file is deleted from the working tree but not committed or if a branch is deleted, but the files on the branch are not deleted.</p>\n<p>To recover files lost from the working tree using the <code>git fsck</code> command, follow these steps:</p>\n<ul>\n<li><strong>Run <code>git fsck –lost-found</code>, which is a special mode of the <code>git fsck</code> command.</strong><br />It creates a directory called <code>.git/lost-found</code> and moves all of the lost objects to that directory. The lost objects are organized into two subdirectories: commits and objects. The <code>/commits</code> subdirectory contains lost commits, and the <code>/objects</code> subdirectory contains lost blobs, trees, and tags. This command prints the dangling objects (blobs, commits, trees, and tags) if they exist.</li>\n</ul>\n<p><img src=\"https://files.smashing.media/articles/recovering-deleted-files-git-working-tree/3-output-git-fsck-lost-found-command.png\" /></p>\n<ul>\n<li><strong>Run the <code>git show &lt;dangling_object_hash&gt;</code> command for each dangling object that is printed.</strong><br />This will print the content of the object and enable you to see the original content of the hashed object so you can identify the dangling objects in the case of files dangling blobs that correspond to the files that you want to recover.</li>\n<li><strong>To recover a dangling object,</strong> you can manually copy the content of the printed in the console when you run the <code>git show &lt;dangling_object_hash&gt;</code> command or run <code>git show &lt;dangling_object_hash&gt; &gt; &lt;filename&gt;</code> command to save the content of the hashed object to the file you specified in the command. You can also use the <code>git checkout &lt;dangling_object_hash&gt;</code> command to restore the file to the working tree.</li>\n</ul>\n<p>Once you have recovered the files that you want to recover, you can commit the changes to the Git repository as if nothing ever happened. Phew! But again, I only advise this approach if you’ve tried everything else and are absolutely at your last resort.</p>\nConclusion\n<p>Now that you know how to recover files lost from your working tree, your mind should be relatively at ease whenever or if ever you find yourself in this unfortunate situation. Remember, there’s a good chance to recover a file that may have been accidentally deleted from a project.</p>\n<p>That said, a better plan is to prevent being in this situation in the first place. Here are some tips that will help you prevent ending up almost irrevocably losing files from your working tree:</p>\n<ul>\n<li><strong>Commit your files to your Git repository and remote servers as quickly and as often as you create or make changes to them.</strong><br />There is no such thing as a “too small” commit.</li>\n<li><strong>Routinely create backups of your project files.</strong><br />This will help you recover your files if you accidentally delete them or your computer crashes.</li>\n</ul>\n<h3>Further Reading On SmashingMag</h3>\n<ul>\n<li>“<a href=\"https://www.smashingmagazine.com/2021/05/undoing-mistakes-git-part1/\">A Guide To Undoing Mistakes With Git (Part 1)</a>,” Tobias Günther</li>\n<li>“<a href=\"https://www.smashingmagazine.com/make-life-easier-when-using-git/\">How To Make Life Easier When Using Git</a>,” Shane Hudson</li>\n<li>“<a href=\"https://www.smashingmagazine.com/2022/03/improving-ci-cd-flow-application/\">Improving The CI/CD Flow For Your Application</a>,” Tom Hastjarjanto</li>\n<li>“<a href=\"https://www.smashingmagazine.com/2021/02/getting-the-most-out-of-git/\">Getting The Most Out Of Git</a>,” Tobias Günther</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"966d8ac42c4af18959e0ff2e008b51d639eb0167c48762edadc41fda6812618a","category":"Tech"}