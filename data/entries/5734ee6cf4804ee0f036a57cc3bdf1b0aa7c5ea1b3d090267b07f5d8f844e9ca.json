{"title":"Terraform 1.5 brings config-driven import and checks","link":"https://www.hashicorp.com/blog/terraform-1-5-brings-config-driven-import-and-checks","date":1686585600000,"content":"<p>We’re excited to announce that HashiCorp Terraform 1.5 is now generally available, <a href=\"https://developer.hashicorp.com/terraform/downloads\">ready for download</a>, and available for use in <a href=\"https://www.hashicorp.com/products/terraform\">Terraform Cloud</a>. Terraform is the standard infrastructure as code tool for multi-cloud provisioning and automation at any scale. This release brings two significant new features: a config-driven import workflow and check blocks. Config-driven import is a new declarative workflow to add existing resources into Terraform state and solves the limitations of the existing import command. Checks are a new way to perform functional validation of provisioned infrastructure to ensure the real world matches expectations.</p>\n\n<h2>Config-driven import</h2>\n\n<p>Bringing existing infrastructure under management by Terraform is a common task when onboarding new teams and applications into a Terraform-based workflow. This often occurs as part of a standardization effort or during mergers and acquisitions. Until now, the only way to do this was with the <a href=\"https://developer.hashicorp.com/terraform/cli/commands/import\"><code>terraform import</code></a> command. But this command has limitations:</p>\n\n<ul>\n<li>Resources are imported one at a time.</li>\n<li>State is immediately modified, with no opportunity to preview the results. This can lead to accidental resource modifications or deletions if an <em>apply</em> operation is executed on the shared state by another team member before the corresponding configuration has been added.</li>\n<li>The matching resource code has to be manually written, which often means a multi-step process of running plans to identify the required attribute values to achieve a clean run.</li>\n</ul>\n\n<p>With Terraform 1.5, we have introduced a completely new config-driven import mechanism. A new top-level <code>import</code> block allows import operations to be defined in code. This means that import operations can be executed in bulk and are now part of the standard plan and apply cycle. Import is now a plannable operation, not a state operation, which eliminates the risk of unexpected state modification. </p>\n\n<p>Better yet, Terraform 1.5 also introduces automatic code generation for imported resources. This dramatically reduces the amount of time you need to spend writing code to match the imported resources. As one of our customers put it, “this is going to save us weeks and weeks of work.”</p>\n\n<p>The import block takes two parameters: the ID of the cloud resource to be imported and the HCL address for the new resource block. Here’s an example of an import block for an Amazon EC2 instance:</p>\n<pre><code>import {\n  # ID of the cloud resource\n  # Check provider documentation for importable resources and format\n  id = “i-abcd1234”\n\n  # Resource address\n  to = aws_instance.example\n}</code></pre><p>Once import blocks are added to your Terraform code, execute a plan with the new <code>-generate-config-out</code> parameter to automatically create the matching resource blocks in a file you specify (example: <code>terraform plan -generate-config-out=generated_resources.tf</code>). After reviewing the generated code, simply run a normal apply operation to complete the import to state.</p>\n\n<p>Follow the updated <a href=\"https://developer.hashicorp.com/terraform/tutorials/state/state-import\">Import Terraform Configuration</a> tutorial to get hands-on with the new import workflow and learn more in the <a href=\"https://developer.hashicorp.com/terraform/language/import\">documentation</a>.</p>\n\n<h2>Enhanced validation with checks</h2>\n\n<p>A common challenge for Terraform users and module authors is having confidence that the provisioned infrastructure is functioning as expected. Terraform 1.2 added <a href=\"https://developer.hashicorp.com/terraform/language/expressions/custom-conditions#preconditions-and-postconditions\">preconditions and postconditions</a> which allow you to codify custom validations with contextual error messages in Terraform configurations. These conditions exist at a data source or individual resource level, and they will stop a plan or apply operation if they fail.</p>\n\n<p>These custom conditions are great for validating assumptions and guarantees for individual data sources, resources, and outputs. But we’ve also heard from the community and our customers that there is a need for more holistic functional validation after infrastructure is provisioned.</p>\n\n<p>With Terraform 1.5 we are introducing a new validation mechanism to address these needs: the <code>check</code> block. Checks are a new top-level construct which gives Terraform practitioners and module authors additional flexibility to define assertions within Terraform code. While there is overlap between the use cases for postconditions and checks, the check block has several notable differences:</p>\n\n<ul>\n<li>Because they exist at the top level, checks can reference all resources, data sources, and module outputs in the configuration. Checks are best suited for overall functional validation of the infrastructure, while postconditions guarantee the configuration of a single resource.</li>\n<li>Checks occur as the last step in the plan or apply and do not halt execution. Failed checks emit a warning message instead of an error.</li>\n<li>Checks can contain more than one assertion. Combined with the ability to reference all objects in the configuration and the power of the Terraform language, this allows for more complex conditional evaluations that make up an overall result.</li>\n<li>A check block can optionally include one nested (“scoped”) data source. If a scoped data source fails to execute, the error is contained to the check block evaluation and does not halt overall execution of the Terraform run.</li>\n</ul>\n\n<p>In following example, a scoped data source is defined within the check block to validate the status of a provisioned web application:</p>\n<pre><code>check \"health_check\" {\n  data \"http\" \"example\" {\n    url = \"https://${aws_lb.example.dns_name}\"\n  }\n\n  assert {\n    condition     = data.http.example.status_code == 200\n    error_message = \"${data.http.example.url} returned an unhealthy status code\"\n  }\n}</code></pre><p>Learn more about <a href=\"https://developer.hashicorp.com/terraform/language/checks\">check blocks</a> and <a href=\"https://developer.hashicorp.com/terraform/language/expressions/custom-conditions#checks-with-assertions\">assertions</a> in the Terraform language documentation, and check out the new tutorial, <a href=\"https://developer.hashicorp.com/terraform/tutorials/configuration-language/checks\">Use checks to validate infrastructure</a> to try it yourself.</p>\n\n<h2>Getting started with Terraform 1.5</h2>\n\n<p>For more details and to learn about all of the enhancements in Terraform 1.5, please review the full HashiCorp Terraform 1.5 <a href=\"https://github.com/hashicorp/terraform/releases/tag/v1.5.0\">changelog</a>.</p>\n\n<ul>\n<li><a href=\"https://developer.hashicorp.com/terraform/downloads\">Download Terraform 1.5</a></li>\n<li><a href=\"https://hashi.co/tf-cloud-bc\">Sign up for a free Terraform Cloud account</a></li>\n<li>Read the <a href=\"https://developer.hashicorp.com/terraform/language/v1.5.x/upgrade-guides\">Terraform 1.5 upgrade guide</a></li>\n<li>Get hands-on with tutorials at <a href=\"https://developer.hashicorp.com/terraform/tutorials\">HashiCorp Developer</a></li>\n</ul>\n\n<p>As always, this release wouldn't have been possible without all of the great community feedback we've received via GitHub issues and from our customers. Thank you!</p>\n","author":"Dan Barr","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"5734ee6cf4804ee0f036a57cc3bdf1b0aa7c5ea1b3d090267b07f5d8f844e9ca","category":"Tech"}