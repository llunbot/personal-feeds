{"title":"The Forensics Of React Server Components (RSCs)","link":"https://smashingmagazine.com/2024/05/forensics-react-server-components/","date":1715259600000,"content":"<p>This article is a sponsored by <a href=\"https://sentry.io/welcome/\">Sentry.io</a></p>\n<p>In this article, we’re going to look deeply at React Server Components (RSCs). They are the latest innovation in React’s ecosystem, leveraging both server-side and client-side rendering as well as <a href=\"https://en.wikipedia.org/wiki/Chunked_transfer_encoding\">streaming HTML</a> to deliver content as fast as possible.</p>\n<p>We will get really nerdy to get a full understanding of how RFCs fit into the React picture, the level of control they offer over the rendering lifecycle of components, and what page loads look like with RFCs in place.</p>\n<p>But before we dive into all of that, I think it’s worth looking back at how React has rendered websites up until this point to set the context for why we need RFCs in the first place.</p>\nThe Early Days: React Client-Side Rendering\n<p>The first React apps were rendered on the client side, i.e., in the browser. As developers, we wrote apps with JavaScript classes as components and packaged everything up using bundlers, like Webpack, in a nicely compiled and tree-shaken heap of code ready to ship in a production environment.</p>\n<p>The HTML that returned from the server contained a few things, including:</p>\n<ul>\n<li>An HTML document with metadata in the <code>&lt;head&gt;</code> and a blank <code>&lt;div&gt;</code> in the <code>&lt;body&gt;</code> used as a hook to inject the app into the DOM;</li>\n<li>JavaScript resources containing React’s core code and the actual code for the web app, which would generate the user interface and populate the app inside of the empty <code>&lt;div&gt;</code>.</li>\n</ul>\n<p><img src=\"https://files.smashing.media/articles/forensics-react-server-components/1-client-side-rendering-process.jpg\" /></p>\n<p>A web app under this process is only fully interactive once JavaScript has fully completed its operations. You can probably already see the tension here that comes with an <strong>improved developer experience (DX) that negatively impacts the user experience (UX)</strong>.</p>\n<p>The truth is that there were (and are) pros and cons to CSR in React. Looking at the positives, web applications delivered <strong>smooth, quick transitions</strong> that reduced the overall time it took to load a page, thanks to reactive components that update with user interactions without triggering page refreshes. CSR lightens the server load and allows us to serve assets from speedy content delivery networks (CDNs) capable of delivering content to users from a server location geographically closer to the user for even more optimized page loads.</p>\n<p>There are also not-so-great consequences that come with CSR, most notably perhaps that components could fetch data independently, leading to <a href=\"https://blog.sentry.io/fetch-waterfall-in-react/\"><strong>waterfall network requests</strong></a> that dramatically slow things down. This may sound like a minor nuisance on the UX side of things, but the damage can actually be quite large on a human level. Eric Bailey’s “<a href=\"https://ericwbailey.design/published/modern-health-frameworks-performance-and-harm/\">Modern Health, frameworks, performance, and harm</a>” should be a cautionary tale for all CSR work.</p>\n<p>Other negative CSR consequences are not quite as severe but still lead to damage. For example, it used to be that an HTML document containing nothing but metadata and an empty <code>&lt;div&gt;</code> was illegible to search engine crawlers that never get the fully-rendered experience. While that’s solved today, the SEO hit at the time was an anchor on company sites that rely on search engine traffic to generate revenue.</p>\nThe Shift: Server-Side Rendering (SSR)\n<p>Something needed to change. CSR presented developers with a powerful new approach for constructing speedy, interactive interfaces, but users everywhere were inundated with blank screens and loading indicators to get there. The solution was to move the rendering experience from the <strong>client</strong> to the <strong>server</strong>. I know it sounds funny that we needed to improve something by going back to the way it was before.</p>\n<p>So, yes, React gained server-side rendering (SSR) capabilities. At one point, SSR was such a topic in the React community that <a href=\"https://sentry.io/resources/moving-to-server-side-rendering/\">it had a moment</a> in the spotlight. The move to SSR brought significant changes to app development, specifically in how it influenced React behavior and how content could be delivered by way of servers instead of browsers.</p>\n<p><img src=\"https://files.smashing.media/articles/forensics-react-server-components/2-diagram-server-side-rendering-process.jpg\" /></p>\n<h3>Addressing CSR Limitations</h3>\n<p>Instead of sending a blank HTML document with SSR, we rendered the initial HTML on the server and sent it to the browser. The browser was able to immediately start displaying the content without needing to show a loading indicator. This significantly improves the <a href=\"https://docs.sentry.io/product/performance/web-vitals/web-vitals-concepts/#first-contentful-paint-fcp\">First Contentful Paint (FCP) performance metric in Web Vitals</a>.</p>\n<p>Server-side rendering also fixed the SEO issues that came with CSR. Since the crawlers received the content of our websites directly, they were then able to index it right away. The data fetching that happens initially also takes place on the server, which is a plus because it’s closer to the data source and can eliminate fetch waterfalls <a href=\"https://blog.sentry.io/fetch-waterfall-in-react/#fetch-data-on-server-to-avoid-a-fetch-waterfall\"><em>if done properly</em></a>.</p>\n<h3>Hydration</h3>\n<p>SSR has its own complexities. For React to make the static HTML received from the server interactive, it needs to <strong>hydrate</strong> it. Hydration is the process that happens when React reconstructs its Virtual Document Object Model (DOM) on the client side based on what was in the DOM of the initial HTML.</p>\n<blockquote><strong>Note</strong>: React maintains its own <a href=\"https://legacy.reactjs.org/docs/faq-internals.html\">Virtual DOM</a> because it’s faster to figure out updates on it instead of the actual DOM. It synchronizes the actual DOM with the Virtual DOM when it needs to update the UI but performs the diffing algorithm on the Virtual DOM.</blockquote>\n\n<p>We now have two flavors of Reacts:</p>\n<ol>\n<li><strong>A server-side flavor</strong> that knows how to render static HTML from our component tree,</li>\n<li><strong>A client-side flavor</strong> that knows how to make the page interactive.</li>\n</ol>\n<p>We’re still shipping React and code for the app to the browser because — in order to hydrate the initial HTML — React needs the same components on the client side that were used on the server. During hydration, <a href=\"https://css-tricks.com/how-react-reconciliation-works/\">React performs a process called</a> <a href=\"https://css-tricks.com/how-react-reconciliation-works/\"><em>reconciliation</em></a> in which it compares the server-rendered DOM with the client-rendered DOM and tries to identify differences between the two. If there are differences between the two DOMs, React attempts to fix them by rehydrating the component tree and updating the component hierarchy to match the server-rendered structure. And if there are <em>still</em> inconsistencies that cannot be resolved, React will throw errors to indicate the problem. This problem is commonly known as a <em>hydration error</em>.</p>\n<h3>SSR Drawbacks</h3>\n<p>SSR is not a silver bullet solution that addresses CSR limitations. SSR comes with its own drawbacks. Since we moved the initial HTML rendering and data fetching to the server, those servers are now experiencing a much greater load than when we loaded everything on the client.</p>\n<p>Remember when I mentioned that SSR generally improves the FCP performance metric? That may be true, but the <a href=\"https://docs.sentry.io/product/performance/web-vitals/web-vitals-concepts/#time-to-first-byte-ttfb\">Time to First Byte (TTFB) performance metric</a> took a negative hit with SSR. The browser literally has to wait for the server to fetch the data it needs, generate the initial HTML, and send the first byte. And while TTFB is not a Core Web Vital metric in itself, it influences the metrics. A negative TTFB leads to negative Core Web Vitals metrics.</p>\n<p>Another drawback of SSR is that the entire page is unresponsive until client-side React has finished hydrating it. Interactive elements cannot listen and “react” to user interactions before React hydrates them, i.e., React attaches the intended event listeners to them. The hydration process is typically fast, but the internet connection and hardware capabilities of the device in use can slow down rendering by a noticeable amount.</p>\nThe Present: A Hybrid Approach\n<p>So far, we have covered two different flavors of React rendering: CSR and SSR. While the two were attempts to improve one another, we now get the best of both worlds, so to speak, as SSR has branched into three additional React flavors that offer a hybrid approach in hopes of reducing the limitations that come with CSR and SSR.</p>\n<p>We’ll look at the first two — <strong>static site generation</strong> and <strong>incremental static regeneration</strong> — before jumping into an entire discussion on React Server Components, the third flavor.</p>\n<h3>Static Site Generation (SSG)</h3>\n<p>Instead of regenerating the same HTML code on every request, we came up with SSG. This React flavor compiles and builds the entire app at build time, generating static (as in vanilla HTML and CSS) files that are, in turn, hosted on a speedy CDN.</p>\n<p>As you might suspect, this hybrid approach to rendering is a nice fit for smaller projects where the content doesn’t change much, like a marketing site or a personal blog, as opposed to larger projects where content may change with user interactions, like an e-commerce site.</p>\n<p>SSG reduces the burden on the server while improving performance metrics related to TTFB because the server no longer has to perform heavy, expensive tasks for re-rendering the page.</p>\n<h3>Incremental Static Regeneration (ISR)</h3>\n<p>One SSG drawback is having to rebuild all of the app’s code when a content change is needed. The content is set in stone — being static and all — and there’s no way to change just one part of it without rebuilding the whole thing.</p>\n<p>The Next.js team created the second hybrid flavor of React that addresses the drawback of complete SSG rebuilds: <strong>incremental static regeneration (ISR)</strong>. The name says a lot about the approach in that ISR only rebuilds what’s needed instead of the entire thing. We generate the “initial version” of the page statically during build time but are also able to rebuild any page containing stale data <em>after</em> a user lands on it (i.e., the server request triggers the data check).</p>\n<p>From that point on, the server will serve new versions of that page statically in increments when needed. That makes ISR a hybrid approach that is neatly positioned between SSG and traditional SSR.</p>\n<p>At the same time, ISR does not address the “stale content” symptom, where users may visit a page before it has finished being generated. Unlike SSG, ISR needs an actual server to regenerate individual pages in response to a user’s browser making a server request. That means we lose the valuable ability to deploy ISR-based apps on a CDN for optimized asset delivery.</p>\nThe Future: React Server Components\n<p>Up until this point, we’ve juggled between CSR, SSR, SSG, and ISR approaches, where all make some sort of trade-off, negatively affecting performance, development complexity, and user experience. Newly introduced <a href=\"https://nextjs.org/docs/app/building-your-application/rendering/server-components\">React Server Components</a> (RSC) aim to address most of these drawbacks by allowing us — the developer — to <strong>choose the right rendering strategy for each individual React component</strong>.</p>\n<p>RSCs can significantly reduce the amount of JavaScript shipped to the client since we can selectively decide which ones to serve statically on the server and which render on the client side. There’s a lot more control and flexibility for striking the right balance for your particular project.</p>\n<blockquote><strong>Note:</strong> It’s important to keep in mind that as we adopt more advanced architectures, like RSCs, monitoring solutions become invaluable. Sentry offers robust <a href=\"https://docs.sentry.io/product/performance/\">performance monitoring</a> and error-tracking capabilities that help you keep an eye on the real-world performance of your RSC-powered application. Sentry also helps you gain insights into how your releases are performing and how stable they are, which is yet another crucial feature to have while migrating your existing applications to RSCs. Implementing Sentry in an RSC-enabled framework like <a href=\"https://sentry.io/for/nextjs/\">Next.js</a> is as easy as running a single terminal command.</blockquote>\n\n<p>But what exactly <em>is</em> an RSC? Let’s pick one apart to see how it works under the hood.</p>\nThe Anatomy of React Server Components\n<p>This new approach introduces two types of rendering components: <strong>Server Components</strong> and <strong>Client Components</strong>. The differences between these two are not <em>how</em> they function but <em>where</em> they execute and the environments they’re designed for. At the time of this writing, the only way to use RSCs is through React frameworks. And at the moment, there are only three frameworks that support them: <a href=\"https://nextjs.org/docs/app/building-your-application/rendering/server-components\">Next.js</a>, <a href=\"https://www.gatsbyjs.com/docs/conceptual/partial-hydration/\">Gatsby</a>, and <a href=\"https://redwoodjs.com/blog/rsc-now-in-redwoodjs\">RedwoodJS</a>.</p>\n<p><img src=\"https://files.smashing.media/articles/forensics-react-server-components/3-wire-diagram-server-client-components.jpg\" /></p>\n<h3>Server Components</h3>\n<p>Server Components are designed to be executed on the server, and their code is never shipped to the browser. The HTML output and any props they might be accepting are the only pieces that are served. This approach has multiple performance benefits and user experience enhancements:</p>\n<ul>\n<li><strong>Server Components allow for large dependencies to remain on the server side.</strong><br />Imagine using a large library for a component. If you’re executing the component on the client side, it means that you’re also shipping the full library to the browser. With Server Components, you’re only taking the static HTML output and avoiding having to ship any JavaScript to the browser. Server Components are truly static, and they remove the whole hydration step.</li>\n<li><strong>Server Components are located much closer to the data sources — e.g., databases or file systems — they need to generate code.</strong><br />They also leverage the server’s computational power to speed up compute-intensive rendering tasks and send only the generated results back to the client. They are also generated in a single pass, which <a href=\"https://blog.sentry.io/fetch-waterfall-in-react/#fetch-data-on-server-to-avoid-a-fetch-waterfall\">avoids request waterfalls and HTTP round trips</a>.</li>\n<li><strong>Server Components safely keep sensitive data and logic away from the browser.</strong><br />That’s thanks to the fact that personal tokens and API keys are executed on a secure server rather than the client.</li>\n<li><strong>The rendering results can be cached and reused between subsequent requests and even across different sessions.</strong><br />This significantly reduces rendering time, as well as the overall amount of data that is fetched for each request.</li>\n</ul>\n<p>This architecture also makes use of <strong>HTML streaming</strong>, which means the server defers generating HTML for specific components and instead renders a fallback element in their place while it works on sending back the generated HTML. Streaming Server Components wrap components in <a href=\"https://react.dev/reference/react/Suspense\"><code>&lt;Suspense&gt;</code></a> tags that provide a fallback value. The implementing framework uses the fallback initially but streams the newly generated content when it‘s ready. We’ll talk more about streaming, but let’s first look at Client Components and compare them to Server Components.</p>\n<h3>Client Components</h3>\n<p>Client Components are the components we already know and love. They’re executed on the client side. Because of this, Client Components are capable of handling user interactions and have access to the browser APIs like <code>localStorage</code> and geolocation.</p>\n<p>The term “Client Component” doesn’t describe anything new; they merely are given the label to help distinguish the “old” CSR components from Server Components. Client Components are defined by a <a href=\"https://react.dev/reference/react/use-server\"><code>\"use client\"</code></a> directive at the top of their files.</p>\n<pre><code>\"use client\"\nexport default function LikeButton() {\n  const likePost = () =&gt; {\n    // ...\n  }\n  return (\n    &lt;button onClick={likePost}&gt;Like&lt;/button&gt;\n  )\n}\n</code></pre>\n\n<p>In Next.js, all components are Server Components by default. That’s why we need to explicitly define our Client Components with <code>\"use client\"</code>. There’s also a <code>\"use server\"</code> directive, but it’s used for Server Actions (which are RPC-like actions that invoked from the client, but executed on the server). You don’t use it to define your Server Components.</p>\n<p>You might (rightfully) assume that Client Components are only rendered on the client, but Next.js renders Client Components on the server to generate the initial HTML. As a result, browsers can immediately start rendering them and then perform hydration later.</p>\n<h3>The Relationship Between Server Components and Client Components</h3>\n<p>Client Components can only <em>explicitly</em> import other Client Components. In other words, we’re unable to import a Server Component into a Client Component because of re-rendering issues. But we can have Server Components in a Client Component’s subtree — only passed through the <code>children</code> prop. Since Client Components live in the browser and they handle user interactions or define their own state, they get to re-render often. When a Client Component re-renders, so will its subtree. But if its subtree contains Server Components, how would they re-render? They don’t live on the client side. That’s why the React team put that limitation in place.</p>\n<p>But hold on! We actually <em>can</em> import Server Components into Client Components. It’s just not a direct one-to-one relationship because the Server Component will be converted into a Client Component. If you’re using server APIs that you can’t use in the browser, you’ll get an error; if not — you’ll have a Server Component whose code gets “leaked” to the browser.</p>\n<p>This is an incredibly important nuance to keep in mind as you work with RSCs.</p>\nThe Rendering Lifecycle\n<p>Here’s the order of operations that Next.js takes to stream contents:</p>\n<ol>\n<li>The app router matches the page’s URL to a Server Component, builds the component tree, and instructs the server-side React to render that Server Component and all of its children components.</li>\n<li>During render, React generates an “RSC Payload”. The RSC Payload informs Next.js about the page and what to expect in return, as well as what to fall back to during a <code>&lt;Suspense&gt;</code>.</li>\n<li>If React encounters a suspended component, it pauses rendering that subtree and uses the suspended component’s fallback value.</li>\n<li>When React loops through the last static component, Next.js prepares the generated HTML and the RSC Payload before streaming it back to the client through one or multiple chunks.</li>\n<li>The client-side React then uses the instructions it has for the RSC Payload and client-side components to render the UI. It also hydrates each Client Component as they load.</li>\n<li>The server streams in the suspended Server Components as they become available as an RSC Payload. Children of Client Components are also hydrated at this time if the suspended component contains any.</li>\n</ol>\n<p>We will look at the RSC rendering lifecycle from the browser’s perspective momentarily. For now, the following figure illustrates the outlined steps we covered.</p>\n<p><img src=\"https://files.smashing.media/articles/forensics-react-server-components/4-wire-diagram-rsc-rendering-lifecycle.jpg\" /></p>\n<p>We’ll see this operation flow from the browser’s perspective in just a bit.</p>\nRSC Payload\n<p>The RSC payload is a special data format that the server generates as it renders the component tree, and it includes the following:</p>\n<ul>\n<li>The rendered HTML,</li>\n<li>Placeholders where the Client Components should be rendered,</li>\n<li>References to the Client Components’ JavaScript files,</li>\n<li>Instructions on which JavaScript files it should invoke,</li>\n<li>Any props passed from a Server Component to a Client Component.</li>\n</ul>\n<p>There’s no reason to worry much about the RSC payload, but it’s worth understanding what exactly the RSC payload contains. Let’s examine an example (truncated for brevity) from a <a href=\"https://github.com/nikolovlazar/rsc-forensics\">demo app I created</a>:</p>\n<div>\n<pre><code>1:HL[\"/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/app/layout.css?v=1711137019097\",\"style\"]\n0:\"$L3\"\n4:HL[\"/_next/static/css/app/page.css?v=1711137019097\",\"style\"]\n5:I[\"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\",[\"app-pages-internals\",\"static/chunks/app-pages-internals.js\"],\"\"]\n8:\"$Sreact.suspense\"\na:I[\"(app-pages-browser)/./node_modules/next/dist/client/components/layout-router.js\",[\"app-pages-internals\",\"static/chunks/app-pages-internals.js\"],\"\"]\nb:I[\"(app-pages-browser)/./node_modules/next/dist/client/components/render-from-template-context.js\",[\"app-pages-internals\",\"static/chunks/app-pages-internals.js\"],\"\"]\nd:I[\"(app-pages-browser)/./src/app/global-error.jsx\",[\"app/global-error\",\"static/chunks/app/global-error.js\"],\"\"]\nf:I[\"(app-pages-browser)/./src/components/clearCart.js\",[\"app/page\",\"static/chunks/app/page.js\"],\"ClearCart\"]\n7:[\"$\",\"main\",null,{\"className\":\"page_main__GlU4n\",\"children\":[[\"$\",\"$Lf\",null,{}],[\"$\",\"$8\",null,{\"fallback\":[\"$\",\"p\",null,{\"children\":\"🌀 loading products...\"}],\"children\":\"$L10\"}]]}]\nc:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]...\n9:[\"$\",\"p\",null,{\"children\":[\"🛍️ \",3]}]\n11:I[\"(app-pages-browser)/./src/components/addToCart.js\",[\"app/page\",\"static/chunks/app/page.js\"],\"AddToCart\"]\n10:[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",\"1\",{\"children\":[\"Gloves\",\" - $\",20,[\"$...\n</code></pre>\n</div>\n\n<p>To find this code in the demo app, open your browser’s developer tools at the Elements tab and look at the <code>&lt;script&gt;</code> tags at the bottom of the page. They’ll contain lines like:</p>\n<pre><code>self.__next_f.push([1,\"PAYLOAD_STRING_HERE\"]).\n</code></pre>\n\n<p>Every line from the snippet above is an individual RSC payload. You can see that each line starts with a number or a letter, followed by a colon, and then an array that’s sometimes prefixed with letters. We won’t get into too deep in detail as to what they mean, but in general:</p>\n<ul>\n<li><strong><code>HL</code> payloads</strong> are called “hints” and link to specific resources like CSS and fonts.</li>\n<li><strong><code>I</code> payloads</strong> are called “modules,” and they invoke specific scripts. This is how Client Components are being loaded as well. If the Client Component is part of the main bundle, it’ll execute. If it’s not (meaning it’s lazy-loaded), a fetcher script is added to the main bundle that fetches the component’s CSS and JavaScript files when it needs to be rendered. There’s going to be an <code>I</code> payload sent from the server that invokes the fetcher script when needed.</li>\n<li><strong><code>\"$\"</code> payloads</strong> are DOM definitions generated for a certain Server Component. They are usually accompanied by actual static HTML streamed from the server. That’s what happens when a suspended component becomes ready to be rendered: the server generates its static HTML and RSC Payload and then streams both to the browser.</li>\n</ul>\nStreaming\n<p>Streaming allows us to progressively render the UI from the server. With RSCs, each component is capable of fetching its own data. Some components are fully static and ready to be sent immediately to the client, while others require more work before loading. Based on this, Next.js splits that work into multiple chunks and streams them to the browser as they become ready. So, when a user visits a page, the server invokes all Server Components, generates the initial HTML for the page (i.e., the page shell), replaces the “suspended” components’ contents with their fallbacks, and streams all of that through one or multiple chunks back to the client.</p>\n<p>The server returns a <code>Transfer-Encoding: chunked</code> header that lets the browser know to expect streaming HTML. This prepares the browser for receiving multiple chunks of the document, rendering them as it receives them. We can actually see the header when opening Developer Tools at the Network tab. Trigger a refresh and click on the document request.</p>\n<p><img src=\"https://files.smashing.media/articles/forensics-react-server-components/5-streaming-header.jpeg\" /></p>\n<p>We can also debug the way Next.js sends the chunks in a terminal with the <code>curl</code> command:</p>\n<pre><code>curl -D - --raw localhost:3000 &gt; chunked-response.txt\n</code></pre>\n\n<p><img src=\"https://files.smashing.media/articles/forensics-react-server-components/6-chunked-response.jpeg\" /></p>\n<p>You probably see the pattern. For each chunk, the server responds with the chunk’s size before sending the chunk’s contents. Looking at the output, we can see that the server streamed the entire page in 16 different chunks. At the end, the server sends back a zero-sized chunk, indicating the end of the stream.</p>\n<p>The first chunk starts with the <code>&lt;!DOCTYPE html&gt;</code> declaration. The second-to-last chunk, meanwhile, contains the closing <code>&lt;/body&gt;</code> and <code>&lt;/html&gt;</code> tags. So, we can see that the server streams the entire document from top to bottom, then pauses to wait for the suspended components, and finally, at the end, closes the body and HTML before it stops streaming.</p>\n<p>Even though the server hasn’t completely finished streaming the document, the browser’s fault tolerance features allow it to draw and invoke whatever it has at the moment without waiting for the closing <code>&lt;/body&gt;</code> and <code>&lt;/html&gt;</code> tags.</p>\n<h3>Suspending Components</h3>\n<p>We learned from the render lifecycle that when a page is visited, Next.js matches the RSC component for that page and asks React to render its subtree in HTML. When React stumbles upon a suspended component (i.e., async function component), it grabs its fallback value from the <code>&lt;Suspense&gt;</code> component (or the <code>loading.js</code> file if it’s a Next.js route), renders that instead, then continues loading the other components. Meanwhile, the RSC invokes the async component in the background, which is streamed later as it finishes loading.</p>\n<p>At this point, Next.js has returned a full page of static HTML that includes either the components themselves (rendered in static HTML) or their fallback values (if they’re suspended). It takes the static HTML and RSC payload and streams them back to the browser through one or multiple chunks.</p>\n<p><img src=\"https://files.smashing.media/articles/forensics-react-server-components/7-fallbacks-suspended-components.jpeg\" /></p>\n<p>As the suspended components finish loading, React generates HTML recursively while looking for other nested <code>&lt;Suspense&gt;</code> boundaries, generates their RSC payloads and then lets Next.js stream the HTML and RSC Payload back to the browser as new chunks. When the browser receives the new chunks, it has the HTML and RSC payload it needs and is ready to replace the fallback element from the DOM with the newly-streamed HTML. And so on.</p>\n<p><img src=\"https://files.smashing.media/articles/forensics-react-server-components/8-suspended-components-html.jpeg\" /></p>\n<p>In Figures 7 and 8, notice how the fallback elements have a unique ID in the form of <code>B:0</code>, <code>B:1</code>, and so on, while the actual components have a similar ID in a similar form: <code>S:0</code> and <code>S:1</code>, and so on.</p>\n<p>Along with the first chunk that contains a suspended component’s HTML, the server also ships an <code>$RC</code> function (i.e., <code>completeBoundary</code> from <a href=\"https://github.com/facebook/react/blob/main/packages/react-dom-bindings/src/server/fizz-instruction-set/ReactDOMFizzInstructionSetShared.js#L46\">React’s source code</a>) that knows how to find the <code>B:0</code> fallback element in the DOM and replace it with the <code>S:0</code> template it received from the server. That’s the “replacer” function that lets us see the component contents when they arrive in the browser.</p>\n<p>The entire page eventually finishes loading, chunk by chunk.</p>\n<h3>Lazy-Loading Components</h3>\n<p>If a suspended Server Component contains a lazy-loaded Client Component, Next.js will also send an RSC payload chunk containing instructions on how to fetch and load the lazy-loaded component’s code. This represents a <em>significant performance improvement</em> because the page load isn’t dragged out by JavaScript, which might not even be loaded during that session.</p>\n<p><img src=\"https://files.smashing.media/articles/forensics-react-server-components/9-fetching-lazy-loaded-scripts.jpeg\" /></p>\n<p>At the time I’m writing this, the dynamic method to lazy-load a Client Component in a Server Component in Next.js does not work as you might expect. To effectively lazy-load a Client Component, put it in a <a href=\"https://github.com/nikolovlazar/rsc-forensics/blob/main/src/components/addToCartWrapper.js\">“wrapper” Client Component</a> that uses the <code>dynamic</code> method itself to lazy-load the actual Client Component. The wrapper will be turned into a script that fetches and loads the Client Component’s JavaScript and CSS files at the time they’re needed.</p>\n<h3>TL;DR</h3>\n<p>I know that’s a lot of plates spinning and pieces moving around at various times. What it boils down to, however, is that a page visit triggers Next.js to render as much HTML as it can, using the fallback values for any suspended components, and then sends that to the browser. Meanwhile, Next.js triggers the suspended async components and gets them formatted in HTML and contained in RSC Payloads that are streamed to the browser, one by one, along with an <code>$RC</code> script that knows how to swap things out.</p>\nThe Page Load Timeline\n<p>By now, we should have a solid understanding of how RSCs work, how Next.js handles their rendering, and how all the pieces fit together. In this section, we’ll zoom in on what exactly happens when we visit an RSC page in the browser.</p>\n<h3>The Initial Load</h3>\n<p>As we mentioned in the TL;DR section above, when visiting a page, Next.js will render the initial HTML minus the suspended component and stream it to the browser as part of the first streaming chunks.</p>\n<p>To see everything that happens during the page load, we’ll visit the “Performance” tab in Chrome DevTools and click on the “reload” button to reload the page and capture a profile. Here’s what that looks like:</p>\n<p><img src=\"https://files.smashing.media/articles/forensics-react-server-components/10-first-chunks-being-streamed.jpeg\" /></p>\n<p>When we zoom in at the very beginning, we can see the first “Parse HTML” span. That’s the server streaming the first chunks of the document to the browser. The browser has just received the initial HTML, which contains the page shell and a few links to resources like fonts, CSS files, and JavaScript. The browser starts to invoke the scripts.</p>\n<p><img src=\"https://files.smashing.media/articles/forensics-react-server-components/11-first-frames.jpeg\" /></p>\n<p>After some time, we start to see the page’s first frames appear, along with the initial JavaScript scripts being loaded and hydration taking place. If you look at the frame closely, you’ll see that the whole page shell is rendered, and “loading” components are used in the place where there are suspended Server Components. You might notice that this takes place around 800ms, while the browser started to get the first HTML at  100ms. During those 700ms, the browser is continuously receiving chunks from the server.</p>\n<p>Bear in mind that this is a Next.js demo app running locally in development mode, so it’s going to be slower than when it’s running in production mode.</p>\n<h3>The Suspended Component</h3>\n<p>Fast forward few seconds and we see another “Parse HTML” span in the page load timeline, but this one it indicates that a suspended Server Component finished loading and is being streamed to the browser.</p>\n<p><img src=\"https://files.smashing.media/articles/forensics-react-server-components/12-suspended-component.jpeg\" /></p>\n<p>We can also see that a lazy-loaded Client Component is discovered at the same time, and it contains CSS and JavaScript files that need to be fetched. These files weren’t part of the initial bundle because the component isn’t needed until later on; the code is split into their own files.</p>\n<p>This way of code-splitting certainly improves the performance of the initial page load. It also makes sure that the Client Component’s code is shipped only if it’s needed. If the Server Component (which acts as the Client Component’s parent component) throws an error, then the Client Component does not load. It doesn’t make sense to load all of its code before we know whether it will load or not.</p>\n<p>Figure 12 shows the <code>DOMContentLoaded</code> event is reported at the end of the page load timeline. And, just before that, we can see that the <code>localhost</code> HTTP request comes to an end. That means the server has likely sent the last zero-sized chunk, indicating to the client that the data is fully transferred and that the streaming communication can be closed.</p>\n<h3>The End Result</h3>\n<p>The main <code>localhost</code> HTTP request took around five seconds, but thanks to streaming, we began seeing page contents load much earlier than that. If this was a traditional SSR setup, we would likely be staring at a blank screen for those five seconds before anything arrives. On the other hand, if this was a traditional CSR setup, we would likely have shipped <em>a lot</em> more of JavaScript and put a heavy burden on both the browser and network.</p>\n<p>This way, however, the app was fully interactive in those five seconds. We were able to navigate between pages and interact with Client Components that have loaded as part of the initial main bundle. This is a pure win from a user experience standpoint.</p>\nConclusion\n<p>RSCs mark a significant evolution in the React ecosystem. They leverage the strengths of server-side and client-side rendering while embracing HTML streaming to speed up content delivery. This approach not only addresses the SEO and loading time issues we experience with CSR but also improves SSR by reducing server load, thus enhancing performance.</p>\n<p>I’ve refactored the same RSC app I shared earlier so that it uses the Next.js Page router with SSR. The improvements in RSCs are significant:</p>\n<p><img src=\"https://files.smashing.media/articles/forensics-react-server-components/13-ssr-vs-rscs.jpeg\" /></p>\n<p>Looking at these two reports I pulled from Sentry, we can see that streaming allows the page to start loading its resources before the actual request finishes. This significantly improves the Web Vitals metrics, which we see when comparing the two reports.</p>\n<p>The conclusion: <strong>Users enjoy faster, more reactive interfaces with an architecture that relies on RSCs.</strong></p>\n<p>The RSC architecture introduces two new component types: Server Components and Client Components. This division helps React and the frameworks that rely on it — like Next.js — streamline content delivery while maintaining interactivity.</p>\n<p>However, this setup also introduces new challenges in areas like state management, authentication, and component architecture. Exploring those challenges is a great topic for another blog post!</p>\n<p>Despite these challenges, the benefits of RSCs present a compelling case for their adoption. We definitely will see guides published on how to address RSC’s challenges as they mature, but, in my opinion, they already look like the future of rendering practices in modern web development.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"bfbbf3318ac08319b595e776b017ab81f3537d1c356f2cfe812dfd3b53beff5b","category":"Tech"}