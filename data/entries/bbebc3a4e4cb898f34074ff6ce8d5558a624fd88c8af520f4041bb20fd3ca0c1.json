{"title":"A Deep Dive Into Serverless UI With TypeScript","link":"https://smashingmagazine.com/2021/11/deep-dive-into-serverless-ui-typescript/","date":1635939000000,"content":"<p>If you’ve been looking for a clear explanation of how applications can be developed and deployed to AWS with less configuration as possible, then I’ve prepared just the article for you. We’ll be breaking it all down into two parts: deploying a static web application (in this case a Notes application), and then a serverless web application to CloudFront using the Serverless UI library.</p>\n<p><strong>Note</strong>: <em>To follow along, you’ll need a basic understanding of AWS and web development in order to understand how the TypeScript project is built and used to deploy to AWS.</em></p>\nRequirements\n<p>Before starting to build our project, the following requirements need to be met:</p>\n<ul>\n<li>Basic knowledge of React, React Hooks, and Material UI;</li>\n<li>Good knowledge of TypeScript;</li>\n<li>Node.js version &gt;= <code>12.x.x</code> installed on your local machine;</li>\n<li>Have an AWS verified account;</li>\n<li>Configured your AWS CLI with local credentials;</li>\n<li>Ensure that <code>npm</code> or <code>yarn</code> is also installed as the package manager.</li>\n</ul>\nIntroduction\n<p>We’ll start with a few introductions on Serverless UI, but at the end of this tutorial, you should be able to comfortably use Serverless UI in your applications — from installing to understanding the concepts and implementing it in your very own projects. According to the <a href=\"https://github.com/JakePartusch/serverlessui\">docs</a> on GitHub:</p>\n<blockquote>“Serverless UI is simply a free, open-source command-line utility for quickly building and deploying serverless applications on the AWS platform.”</blockquote>\n\n<p>As stated, it’s a lightweight library that’s quickly installed over the terminal, and can be used to set up configure-domain, deploy static or serverless websites — all done on the terminal. This permits you to easily couple any choice of front-end framework with Serverless UI to deploy existing and new applications to AWS stress-free.</p>\n<p>Serverless UI also works great with any static website, and websites that use serverless functions to handle requests to some sort of API. This makes it great for building serverless back-end applications. The deploy process through Serverless UI gives you the control to automatically deploy each part or in better words, iteration of your application with a different and separate URL. Though, this means you get to monitor the continuous integration and testing of your application with confidence in real-time. </p>\n<p>Using Serverless UI in production, you can choose to have your project or serverless functions written in native JavaScript or TypeScript. Either way, they’ll be bundled down extremely quickly and your functions deployed as Node.js 14 Lambda functions. Your functions within the <code>./functions</code> folder are deployed automatically as serverless functions on AWS. This approach means that we’ll be writing our code in the form of functions that will handle different tasks or requests within the application. So when we deploy our functions, we’ll invoke them in the format of an event. </p>\n<p>Then the need for a fast and very small application file size makes the Serverless UI be of good essence within our application. Being a command-line tool, it doesn’t need to be bundled inside the application — it can be installed globally, <code>npm install -g @serverlessui/cli</code> or as a <code>devDependency</code> within our application. This means no file size was added to our application, giving us the benefit of having only the code needed for our application to function. No extra added bundle size to our application. As with any migration, we developers know that migrating existing applications can be tough and troubling without downtime for our users, but it is doable depending on the use case.</p>\nPros And Cons Of Using Serverless UI\n<p>Using Serverless UI within our projects, whether existing or new project has some <strong>benefits</strong> that it gives us:</p>\n<ul>\n<li>There are no middleman services unlike others; Serverless UI gives you out-of-the-box benefits of a pre-configured infrastructure without having to go through a middleman.</li>\n<li>It supports and works in almost any CI (<strong>Continuous Integration</strong>) environment owing that it’s a command-line tool readily available via npm. This is a plus for the backend and infrastructure setup.</li>\n<li>For already existing serverless applications or those that may have additional CloudFormation and/or CDK infrastructure, there is a full provision of CDK constructs for each of the CLI actions.</li>\n<li>Serverless UI provides almost any option during deploying your application — deploy your static website, Lambda functions or production code.</li>\n<li>Almost all configurations (such as <code>configure-domain</code> and deploying applications) are all done on the command line.</li>\n<li>Front-end frameworks like React, Svelte, Vue, or JQuery are all supported, as long as it compiles down to static code.</li>\n<li>Gives serverless applications the ability to scale dynamically per request, and won’t require any capacity planning or provisioning for the application.</li>\n</ul>\n<p>These are some <strong>downsides of Serverless UI</strong> that we should consider before deciding to use it within our projects:</p>\n<ul>\n<li>There is only support for projects built using TypeScript or JavaScript within the project.</li>\n<li>Within recent time, the library core infrastructure is written with <code>aws-cdk</code>, which means the only platform our applications could be deployed to is AWS.</li>\n</ul>\n<p><strong>Recommended Reading</strong>: <a href=\"https://www.smashingmagazine.com/2021/10/local-testing-serverless-api-gateway-lambda/\"><em>Local Testing A Serverless API (API Gateway And Lambda)</em></a></p>\nSetting Up The Notes Application\n<p>Nowadays, several tools are available for developers to efficiently manage infrastructures, for example, the <strong>Serverless UI</strong>, the console, or one of the frameworks available online. As explained above, our goal is to set up a simple demo of a Notes application in TypeScript, which will quickly help us to demonstrate how Serverless UI could be used in hosting it, so you can quickly grasp and implement it within your own projects.</p>\n<p>For this tutorial, we’ll quickly explore and explain the different parts of a Notes application, then install <strong>Serverless UI</strong> library to host the application on AWS. </p>\n<p>We proceed to clone the remote repository on our local machine and run the command that will install all the dependencies.</p>\n<pre><code>git clone https://github.com/smashingmagazine/serverless-UI-typescript.git\n\nyarn install</code></pre>\n\n<p>The above command clones a Note application that has the functional components built already, and then goes ahead to install the dependencies that are needed for the components to function. Here’s the list of the dependencies that are required for this Notes application to function:</p>\n<pre><code>{\n  ...\n  \"dependencies\": {\n    \"@testing-library/jest-dom\": \"^5.11.4\",\n    \"@testing-library/react\": \"^11.1.0\",\n    \"@testing-library/user-event\": \"^12.1.10\",\n    \"@types/jest\": \"^26.0.15\",\n    \"@types/node\": \"^12.0.0\",\n    \"@types/react\": \"^17.0.0\",\n    \"@types/react-dom\": \"^17.0.0\",\n    \"react\": \"^17.0.1\",\n    \"react-dom\": \"^17.0.1\",\n    \"react-scripts\": \"4.0.3\",\n    \"typescript\": \"^4.1.2\",\n    \"web-vitals\": \"^1.0.1\"\n  },\n  ...\n}\n</code></pre>\n\n<p>The above list contains dependencies and their type definitions to work optimally with TypeScript. We proceed to explain the working parts of the application. But let’s first define interfaces for the Note data and the Props argument that will be passed down into our functions. Create a <code>/src/interfaces.ts</code> file and include the following:</p>\n<pre><code>export interface INote {\n  note: string;\n}\nexport interface Props {\n  content: INote;\n  delContent(noteToDelete: string): void;\n}</code></pre>\n\n<p>Here we’re defining the type structure that acts as a syntax contract between our components and the props passed within them. Also defines the unit data of our application state, <code>INote</code>.</p>\n<p>For this application, we’ll focus mainly on the <code>/src/components</code> folder and the <code>/src/App.tsx</code> file. We’ll start from the <code>components</code> folder then gradually explain the rest of the application.</p>\n<p><strong>Note:</strong> <em>The styles defined and used throughout this Notes application can be found in the <code>/src/App.css</code> file.</em></p>\n<p>The <code>components</code> folder contains one file, the <code>Note.tsx</code> file; which will define the UI structure of each Note data we create. </p>\n<pre><code>import { INote } from \"../Interfaces\";\n\ninterface Props {\n  content: INote;\n  delContent(noteToDelete: number): void;\n}\n\nconst Note = ({ content, delContent }: Props) =&gt; {\n  return (\n    &lt;div className=\"note\"&gt;\n      &lt;div className=\"content\"&gt;\n        &lt;span&gt;{content.note}&lt;/span&gt;\n      &lt;/div&gt;\n      &lt;button\n        onClick={() =&gt; {\n          delContent(content.id);\n        }}\n      &gt;\n        X\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\nexport default Note;\n</code></pre>\n\n<p>Within the <code>Note</code> function, we’re destructuring a props parameter that has the data type definition of <code>Props</code>, and contains the <code>content</code> and <code>delContent</code> fields. The <code>content</code> field further contains the <code>note</code> field whose value will be the input value of our users. While the <code>delContent</code> field is a function to delete <code>content</code> from the application. </p>\n<p>We’ll proceed to build the general UI of the application, defining its two sections; one for creating the notes and the other to contain the list of notes already created:</p>\n<pre><code>const App: FC = () =&gt; {\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;div className=\"header\"&gt;\n      &lt;/div&gt;\n\n      &lt;div className=\"noteList\"&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\nexport default App;</code></pre>\n\n<p>The <code>div</code> tag with the <strong>header</strong> class contains the input and the button elements for creating and adding notes to the application:</p>\n<pre><code>const App: FC = () =&gt; {\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;div className=\"header\"&gt;\n        &lt;div className=\"inputContainer\"&gt;\n          &lt;input\n            type=\"text\"\n            placeholder=\"Add Note...\"\n            name=\"note\"\n            value={noteContent}\n            onChange={handleChange}\n          /&gt;\n        &lt;/div&gt;\n        &lt;button onClick={addNote}&gt;Add Note&lt;/button&gt;\n      &lt;/div&gt;\n\n      ...\n    &lt;/div&gt;\n  );\n};\nexport default App;</code></pre>\n\n<p>In the above code we recorded a new state, <code>noteContent</code>, for the <code>input</code> element’s value. Also an <code>onChange</code> event to update the <strong>input</strong> value. The <code>button</code> element has <code>onClick</code> event that will handle generating new content from the input’s value and adding it to the application. The above UI markup coupled with the already defined styles will look like:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/37b7b12a-581c-49ef-8ca3-00b55baaa71e/2-deep-dive-into-severless-ui-typescript.png\" /></p>\n<p>Now let’s define the new states, <code>noteContent</code> and <code>noteList</code>, then the two events, <code>handleChange</code> and <code>addNote</code> functions to update our application functionalities:</p>\n<pre><code>import { FC, ChangeEvent, useState } from \"react\";\nimport \"./App.css\";\nimport { INote } from \"./Interfaces\";\n\nconst App: FC = () =&gt; {\n  const [noteContent, setNoteContent] = useState&lt;string&gt;(\"\");\n  const [noteList, setNoteList] = useState&lt;INote[]&gt;([]);\n\n  const handleChange = (event: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {\n      setNoteContent(event.target.value.trim());\n  };\n\n  const addNote = (): void =&gt; {\n    const newContent = { Date.now(), note: noteContent };\n    setNoteList([...noteList, newContent]);\n    setNoteContent(\"\");\n  };\n\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;div className=\"header\"&gt;\n        &lt;div className=\"inputContainer\"&gt;\n          &lt;input\n            type=\"text\"\n            placeholder=\"Add Note...\"\n            name=\"note\"\n            value={noteContent}\n            onChange={handleChange}\n          /&gt;\n        &lt;/div&gt;\n        &lt;button onClick={addNote}&gt;Add Note&lt;/button&gt;\n      &lt;/div&gt;\n\n      ...\n    &lt;/div&gt;\n  );\n};\nexport default App;\n</code></pre>\n\n<p>The <code>noteList</code> state contains all the notes created within the application. We add and remove from it to update the UI with more notes created. Within the <code>handleChange</code> function, we’re regularly updating <code>noteContent</code> with the changes made to the input field using the <code>setNoteContent</code> function. The <code>addNote</code> function creates a <code>newContent</code> object with a <code>note</code> field whose value is gotten from <code>noteContent</code>. It then calls the <code>setNoteList</code> functions and creates a new <code>noteList</code> array from its previous state and <code>newContent</code>.</p>\n<p>Next is to update the second section of the <code>App</code> function with the JSX code to contain the list of notes created:</p>\n<div>\n<pre><code>...\n\nimport Note from \"./Components/Note\";\n\nconst App: FC = () =&gt; {\n  ...\n\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;div className=\"header\"&gt;\n        ...\n      &lt;/div&gt;\n\n      &lt;div className=\"noteList\"&gt;\n        {noteList.map((content: INote) =&gt; {\n          return &lt;Note key={content.id} content={content} delContent={delContent} /&gt;;\n        })}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre>\n</div>\n\n<p>We’re looping through the <code>noteList</code> using the <code>Array.prototype.map</code> method to create the dump of notes within our application. Then we imported the <code>Note</code> component which defines the UI of our note, passing the <code>key</code>, <code>content</code> and <code>delContent</code> props into it. The <code>delContent</code> function as discussed earlier deletes <code>content</code> from the application:</p>\n<div>\n<pre><code>...\nimport Note from \"./Components/Note\";\n\nconst App: FC = () =&gt; {\n  ...\n  const [noteList, setNoteList] = useState&lt;INote[]&gt;([]);\n\n  ...\n\n  const delContent = (noteID: number) =&gt; {\n    setNoteList(\n      noteList.filter((content) =&gt; {\n        return content.id !== noteID;\n      })\n    );\n  };\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;div className=\"header\"&gt;\n        ...\n      &lt;/div&gt;\n\n      &lt;div className=\"noteList\"&gt;\n        {noteList.map((content: INote) =&gt; {\n          return &lt;Note key={content.id} content={content} delContent={delContent} /&gt;;\n        })}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\nexport default App;</code></pre>\n</div>\n\n<p>The <code>delContent</code> function filters out of <code>noteList</code> the <code>content</code>s that are not in any way equivalent to the <code>noteToDelete</code> argument. The <code>noteToDelete</code> is equivalent to <code>content.note</code> but gets passed down to <code>delContent</code> whenever a note is created by calling the <code>Note</code> component.</p>\n<p>Coupling the two sections of the <code>App</code> component together, your code should look like the below:</p>\n<div>\n<pre><code>import { FC, ChangeEvent, useState } from \"react\";\nimport \"./App.css\";\nimport Note from \"./Components/Note\";\nimport { INote } from \"./Interfaces\";\n\nconst App: FC = () =&gt; {\n  const [noteContent, setNoteContent] = useState&lt;string&gt;(\"\");\n  const [noteList, setNoteList] = useState&lt;INote[]&gt;([]);\n\n  const handleChange = (event: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {\n      setNoteContent(event.target.value.trim());\n  };\n\n  const addNote = (): void =&gt; {\n    const newContent = { id: Date.now(), note: noteContent };\n    setNoteList([...noteList, newContent]);\n    setNoteContent(\"\");\n  };\n\n  const delContent = (noteID: number): void =&gt; {\n    setNoteList(\n      noteList.filter((content) =&gt; {\n        return content.id !== noteID;\n      })\n    );\n  };\n\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;div className=\"header\"&gt;\n        &lt;div className=\"inputContainer\"&gt;\n          &lt;input\n            type=\"text\"\n            placeholder=\"Add Note...\"\n            name=\"note\"\n            value={noteContent}\n            onChange={handleChange}\n          /&gt;\n        &lt;/div&gt;\n        &lt;button onClick={addNote}&gt;Add Note&lt;/button&gt;\n      &lt;/div&gt;\n\n      &lt;div className=\"noteList\"&gt;\n        {noteList.map((content: INote) =&gt; {\n          return &lt;Note key={content.id} content={content} delContent={delContent} /&gt;;\n        })}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\nexport default App;\n</code></pre>\n</div>\n\n<p>And if we go ahead and add a few notes to our application, then our final UI will look like this:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b09655bb-b586-4a73-8e69-069a57b90ebb/3-deep-dive-into-severless-ui-typescript.png\" /></p>\n<p>Now we have created a simple Notes application that we can add and delete Notes, let’s move on to using Serverless UI to deploy this application to AWS and as well deploy a serverless back-end application (serverless functions).</p>\n<h3>Deploying Notes Application With Serverless UI</h3>\n<p>Now we’re done explaining the components that make up our Notes application, it’s time to deploy our application using <strong>Serverless UI</strong> on the terminal. The first step in deploying our application to AWS is to configure the AWS CLI on our machine. Check <a href=\"https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html\">here</a> for comprehensive steps to take.</p>\n<p>Next is to install the <strong>Serverless UI library</strong> globally on our local machine:</p>\n<pre><code>npm install -g @serverlessui/cli</code></pre>\n\n<p>This installs the package globally, meaning no extra file size was added within the build code.</p>\n<p>Next is to make a <code>build</code> folder of the project, this is the folder we’ll reference within our terminal:</p>\n<pre><code>sui deploy --dir=\"build\"\n...\n❯ Website Url: https://xxxxx.cloudfront.net</code></pre>\n\n<p>But for our project, we’ll run the <code>yarn</code> command that builds our application into a static website within the <code>build</code> folder, after which we run the <strong>Serverless UI</strong> command to deploy the application:</p>\n<div>\n<pre><code>yarn build \n...\nDone in 80.63s.\n\nsui deploy --dir=\"build\"\n...\n\n✅  ServerlessUIAppPreview1c9ec9f1\n\nOutputs:\nServerlessUIAppPreview1c9ec9f1.ServerlessUIBaseUrlCA2DC891 = <a href=\"https://dal254gl37fow.cloudfront.net\">https://dal254gl37fow.cloudfront.net</a>\n\nStack ARN:\narn:aws:cloudformation:us-west-2:261955174750:stack/ServerlessUIAppPreview1c9ec9f1/e4dc82e0-fe44-11eb-b959-064619847e85\n</code></pre>\n</div>\n\n<p>Our application was successfully deployed, and the total time it took to deploy was less than five minutes. The application was deployed to Cloudfront <a href=\"https://dal254gl37fow.cloudfront.net\">here</a>.</p>\nDeploying Serverless Functions With Serverless UI\n<p>Here, we’ll focus on deploying Lambda functions written in our local environment, other than on the IDE provided on the AWS web platform. With Serverless UI, we’ll remove the hassle of doing a lot of configuration and set up before deploying it on AWS.</p>\n<p>You’ll also want to ensure your local environment is as close to the production environment as possible. This includes the runtime, Node.js version. As a reminder, you need to install a version of Node.js supported by AWS Lambda.</p>\n<p>The code or the <code>/serverless</code> folder used within this part of the article can be found <a href=\"https://github.com/smashingmagazine/serverless-UI-typescript/tree/main/serverless\">here</a>. This folder contains the source file, that makes a request to an API to get a random note; a joke.</p>\n<pre><code>const nodefetch = require(\"node-fetch\");\n\nexports.handler = async (event, context) =&gt; {\n  const url = \"https://icanhazdadjoke.com/\";\n  try {\n    const jokeStream = await nodefetch(url, {\n      headers: {\n        Accept: \"application/json\"\n      }\n    });\n    const jsonJoke = await jokeStream.json();\n    return {\n      statusCode: 200,\n      body: JSON.stringify(jsonJoke)\n    };\n  } catch (err) {\n    return { statusCode: 422, body: err.stack };\n  }\n};</code></pre>\n\n<p>Before we deploy the <code>serverless</code> folder, we’ll need to install <code>esbuild</code> library. This will help make bundling of the application files more fast and accessible.</p>\n<pre><code>npm install esbuild --save-dev</code></pre>\n\n<p>The next step to deploy the serverless function on AWS is by specifying the folder location with the <code>--functions</code> flag as we previously did with the <code>--dist</code> flag when deploying our static website.</p>\n<pre><code>sui deploy --functions=\"serverless\"</code></pre>\n\n<p>While the above command helps us build our application, the serverless function successfully deploys it:</p>\n<div>\n<pre><code>...\n\n✅  ServerlessUIAppPreview560dbd41\n\nOutputs:\nServerlessUIAppPreview560dbd41.ServerlessUIFunctionPathjokesD9F032B9 = <a href=\"https://dwh6k64yrlqcn.cloudfront.net/api/jokes\">https://dwh6k64yrlqcn.cloudfront.net/api/jokes</a>\n\nStack ARN:\narn:aws:cloudformation:us-west-2:261955174750:stack/ServerlessUIAppPreview560dbd41/21de6780-fb93-11eb-a0fb-061a2a83f0b9</code></pre>\n</div>\n\n<ul>\n<li><em>The serverless function is now deployed to Cloudfront <a href=\"https://dwh6k64yrlqcn.cloudfront.net/api/jokes\">here</a>.</em></li>\n</ul>\n<p>As a side note, we should be able to reference our API URL by relative path in our UI code like <code>/api/jokes</code> instead of the full URL if deployed at the same time with the <code>/dist</code> or <code>/build</code> folder. This should always work — even with CORS — since the UI and API are on the same domain.</p>\n<p>But by default, Serverless Ui will create a new stack for every preview deployed, which means each URL will be different and unique. In order to deploy to the same URL multiple times, the <code>--prod</code> flag needs to be passed. </p>\n<pre><code>sui deploy --prod --dir=\"dist\" --functions=\"serverless\"</code></pre>\n\n<p>Let’s create a <code>/src/components/Quote</code> folder and inside it create an <code>index.tsx</code> file. This contains the JSX code to house the quotes.</p>\n<pre><code>import { useState } from \"react\";\n\nconst Quote = () =&gt; {\n  const [joke, setJoke] = useState&lt;string&gt;();\n  return (\n    &lt;div className=\"container\"&gt;\n      &lt;p className=\"fade-in\"&gt;{joke}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n};\nexport default Quote;</code></pre>\n\n<p>Next, we will make a request to the deployed serverless functions to retrieve a joke from it within a set interval of time. This way the note, i.e the joke, within the <code>&lt;p className=\"fade-in\"&gt;{joke}&lt;/p&gt;</code> JSX markup gets updated every 2000 milliseconds.</p>\n<div>\n<pre><code>import { useEffect, useState } from \"react\";\n\nconst Quote = () =&gt; {\n  const [joke, setJoke] = useState&lt;string&gt;();\n\n  useEffect(() =&gt; {\n    const getRandomJokeEveryTwoSeconds = setInterval(async () =&gt; {\n      const url = process.env.API_LINK || \"<a href=\"https://dwh6k64yrlqcn.cloudfront.net/api/jokes&quot;\">https://dwh6k64yrlqcn.cloudfront.net/api/jokes\"</a>;\n      const jokeStream = await fetch(url);\n      const res = await jokeStream.json();\n      const joke = res.joke;\n      setJoke(joke);\n    }, 2000);\n    return () =&gt; {\n      clearInterval(getRandomJokeEveryTwoSeconds);\n    };\n  }, []);\n\n  return (\n    &lt;div className=\"container\"&gt;\n      &lt;p className=\"fade-in\"&gt;{joke}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n};\nexport default Quote;</code></pre>\n</div>\n\n<p>The code snippet added to the above source code will use <code>useEffect</code> hook to make API calls to the serverless functions, updating the UI with the jokes returned from the request by using the <code>setJoke</code> function provided from the <code>useState</code> hook.</p>\n<p>Let’s restart our local development server to see the new changes added to our UI:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/606e8d06-6c97-4e3f-9caf-60d771648df1/1-deep-dive-into-severless-ui-typescript.png\" /></p>\n<p>Before deploying the updates to your existing application, you can set up a custom domain, and using Serverless UI deploy and push subsequent code updates to this custom domain.</p>\nConfigure Domain With Serverless UI\n<p>We can deploy our serverless application to our custom domain rather than the default one provided by CloudFront. Configuring and deploying to our custom domain may take 20 – 48 hours to fully propagate but only needs to be completed once. Navigate into your project directory and run the command:</p>\n<pre><code>sui configure-domain --domain=\"&lt;custom-domain.com&gt;\"</code></pre>\n\n<p>Replace the above value of the <code>--domain</code> flag with your own custom URL. Then you can continuously update the already deployed project by adding the <code>--prod</code> flag when using the <code>sui deploy</code> command again.</p>\n<p><strong>Recommended Reading</strong>: <a href=\"https://www.smashingmagazine.com/2018/05/building-serverless-contact-form-static-website/\"><em>Building A Serverless Contact Form For Your Static Site</em></a></p>\nConclusion\n<p>In this article, we introduced Serverless UI by discussing different merits that make it a good fit for deploying your application with it. Also, we created a demo of a simple Notes application and deployed it with the library. You can further build back-end serverless functions that are triggered by events happening with the application, and deploy them to your AWS lambda.</p>\n<p>For the advanced use case of Serverless UI, we configured the default domain provided by CloudFront with our own custom domain name using <strong>Serverless UI.</strong> And for existing serverless projects or those that may have additional CloudFormation and/or CDK infrastructure, Serverless UI provides CDK constructs for each of the CLI actions. And with Serverless UI, we can easily configure a private S3 bucket — an extra desired feature for enhanced security on our serverless applications. Click <a href=\"https://github.com/JakePartusch/serverlessui#configure-domain\">here</a> to read up more on it.</p>\n<ul>\n<li><em>The code used within this article can be found on <a href=\"https://github.com/smashingmagazine/serverless-UI-typescript\">Github</a>.</em></li>\n</ul>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://github.com/JakePartusch/serverlessui\">Serverless UI Official documentation</a></li>\n<li><a href=\"https://github.com/JakePartusch/serverlessui\">Setting up AWS CLI</a></li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"bbebc3a4e4cb898f34074ff6ce8d5558a624fd88c8af520f4041bb20fd3ca0c1","category":"Tech"}